(window.webpackJsonp = window.webpackJsonp || []).push([
    [1], {
        "+0xr": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return bt
            }), i.d(e, "b", function() {
                return ct
            }), i.d(e, "c", function() {
                return pt
            }), i.d(e, "d", function() {
                return gt
            }), i.d(e, "e", function() {
                return ut
            }), i.d(e, "f", function() {
                return Ct
            }), i.d(e, "g", function() {
                return vt
            }), i.d(e, "h", function() {
                return St
            }), i.d(e, "i", function() {
                return _t
            }), i.d(e, "j", function() {
                return ot
            }), i.d(e, "k", function() {
                return Pt
            }), i.d(e, "l", function() {
                return Ot
            });
            var n = i("8LU1"),
                s = i("0EQZ"),
                r = i("fXoL"),
                a = i("cH1L"),
                o = i("nLfN"),
                l = i("vxfF"),
                c = i("ofXK"),
                h = i("oXA7"),
                u = i("g/MW"),
                d = i("X/DG"),
                p = i("BBcS"),
                f = i("4krO"),
                g = i("bk9D"),
                m = i("nnEh");
            const b = [
                    [
                        ["caption"]
                    ],
                    [
                        ["colgroup"],
                        ["col"]
                    ]
                ],
                y = ["caption", "colgroup, col"];

            function v(t) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this._sticky = !1, this._hasStickyChanged = !1
                    }
                    get sticky() {
                        return this._sticky
                    }
                    set sticky(t) {
                        const e = this._sticky;
                        this._sticky = Object(n.c)(t), this._hasStickyChanged = e !== this._sticky
                    }
                    hasStickyChanged() {
                        const t = this._hasStickyChanged;
                        return this._hasStickyChanged = !1, t
                    }
                    resetStickyChanged() {
                        this._hasStickyChanged = !1
                    }
                }
            }
            const x = new r.s("CDK_TABLE");
            let _ = (() => {
                    class t {
                        constructor(t) {
                            this.template = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkCellDef", ""]
                        ]
                    }), t
                })(),
                w = (() => {
                    class t {
                        constructor(t) {
                            this.template = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkHeaderCellDef", ""]
                        ]
                    }), t
                })(),
                C = (() => {
                    class t {
                        constructor(t) {
                            this.template = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkFooterCellDef", ""]
                        ]
                    }), t
                })();
            class k {}
            const S = v(k);
            let A = (() => {
                class t extends S {
                    constructor(t) {
                        super(), this._table = t, this._stickyEnd = !1
                    }
                    get name() {
                        return this._name
                    }
                    set name(t) {
                        this._setNameInput(t)
                    }
                    get stickyEnd() {
                        return this._stickyEnd
                    }
                    set stickyEnd(t) {
                        const e = this._stickyEnd;
                        this._stickyEnd = Object(n.c)(t), this._hasStickyChanged = e !== this._stickyEnd
                    }
                    _updateColumnCssClassName() {
                        this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`]
                    }
                    _setNameInput(t) {
                        t && (this._name = t, this.cssClassFriendlyName = t.replace(/[^a-z0-9_-]/gi, "-"), this._updateColumnCssClassName())
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(r.Pb(x, 8))
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "cdkColumnDef", ""]
                    ],
                    contentQueries: function(t, e, i) {
                        if (1 & t && (r.Ib(i, _, 1), r.Ib(i, w, 1), r.Ib(i, C, 1)), 2 & t) {
                            let t;
                            r.rc(t = r.dc()) && (e.cell = t.first), r.rc(t = r.dc()) && (e.headerCell = t.first), r.rc(t = r.dc()) && (e.footerCell = t.first)
                        }
                    },
                    inputs: {
                        sticky: "sticky",
                        name: ["cdkColumnDef", "name"],
                        stickyEnd: "stickyEnd"
                    },
                    features: [r.Cb([{
                        provide: "MAT_SORT_HEADER_COLUMN_DEF",
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            class O {
                constructor(t, e) {
                    const i = e.nativeElement.classList;
                    for (const n of t._columnCssClassName) i.add(n)
                }
            }
            let E = (() => {
                    class t extends O {
                        constructor(t, e) {
                            super(t, e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(A), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["cdk-header-cell"],
                            ["th", "cdk-header-cell", ""]
                        ],
                        hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
                        features: [r.Ab]
                    }), t
                })(),
                P = (() => {
                    class t extends O {
                        constructor(t, e) {
                            super(t, e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(A), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["cdk-cell"],
                            ["td", "cdk-cell", ""]
                        ],
                        hostAttrs: ["role", "gridcell", 1, "cdk-cell"],
                        features: [r.Ab]
                    }), t
                })();
            class T {
                constructor() {
                    this.tasks = [], this.endTasks = []
                }
            }
            const D = new r.s("_COALESCED_STYLE_SCHEDULER");
            let I = (() => {
                    class t {
                        constructor(t) {
                            this._ngZone = t, this._currentSchedule = null, this._destroyed = new h.a
                        }
                        schedule(t) {
                            this._createScheduleIfNeeded(), this._currentSchedule.tasks.push(t)
                        }
                        scheduleEnd(t) {
                            this._createScheduleIfNeeded(), this._currentSchedule.endTasks.push(t)
                        }
                        ngOnDestroy() {
                            this._destroyed.next(), this._destroyed.complete()
                        }
                        _createScheduleIfNeeded() {
                            this._currentSchedule || (this._currentSchedule = new T, this._getScheduleObservable().pipe(Object(g.a)(this._destroyed)).subscribe(() => {
                                for (; this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length;) {
                                    const t = this._currentSchedule;
                                    this._currentSchedule = new T;
                                    for (const e of t.tasks) e();
                                    for (const e of t.endTasks) e()
                                }
                                this._currentSchedule = null
                            }))
                        }
                        _getScheduleObservable() {
                            return this._ngZone.isStable ? Object(u.a)(Promise.resolve(void 0)) : this._ngZone.onStable.pipe(Object(m.a)(1))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Zb(r.B))
                    }, t.\u0275prov = r.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                M = (() => {
                    class t {
                        constructor(t, e) {
                            this.template = t, this._differs = e
                        }
                        ngOnChanges(t) {
                            if (!this._columnsDiffer) {
                                const e = t.columns && t.columns.currentValue || [];
                                this._columnsDiffer = this._differs.find(e).create(), this._columnsDiffer.diff(e)
                            }
                        }
                        getColumnsDiff() {
                            return this._columnsDiffer.diff(this.columns)
                        }
                        extractCellTemplate(t) {
                            return this instanceof j ? t.headerCell.template : this instanceof z ? t.footerCell.template : t.cell.template
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O), r.Pb(r.u))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        features: [r.Bb]
                    }), t
                })();
            class L extends M {}
            const R = v(L);
            let j = (() => {
                class t extends R {
                    constructor(t, e, i) {
                        super(t, e), this._table = i
                    }
                    ngOnChanges(t) {
                        super.ngOnChanges(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(r.Pb(r.O), r.Pb(r.u), r.Pb(x, 8))
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "cdkHeaderRowDef", ""]
                    ],
                    inputs: {
                        columns: ["cdkHeaderRowDef", "columns"],
                        sticky: ["cdkHeaderRowDefSticky", "sticky"]
                    },
                    features: [r.Ab, r.Bb]
                }), t
            })();
            class F extends M {}
            const N = v(F);
            let z = (() => {
                    class t extends N {
                        constructor(t, e, i) {
                            super(t, e), this._table = i
                        }
                        ngOnChanges(t) {
                            super.ngOnChanges(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O), r.Pb(r.u), r.Pb(x, 8))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkFooterRowDef", ""]
                        ],
                        inputs: {
                            columns: ["cdkFooterRowDef", "columns"],
                            sticky: ["cdkFooterRowDefSticky", "sticky"]
                        },
                        features: [r.Ab, r.Bb]
                    }), t
                })(),
                V = (() => {
                    class t extends M {
                        constructor(t, e, i) {
                            super(t, e), this._table = i
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O), r.Pb(r.u), r.Pb(x, 8))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkRowDef", ""]
                        ],
                        inputs: {
                            columns: ["cdkRowDefColumns", "columns"],
                            when: ["cdkRowDefWhen", "when"]
                        },
                        features: [r.Ab]
                    }), t
                })(),
                B = (() => {
                    class t {
                        constructor(e) {
                            this._viewContainer = e, t.mostRecentCellOutlet = this
                        }
                        ngOnDestroy() {
                            t.mostRecentCellOutlet === this && (t.mostRecentCellOutlet = null)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.S))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkCellOutlet", ""]
                        ]
                    }), t.mostRecentCellOutlet = null, t
                })(),
                H = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["cdk-header-row"],
                            ["tr", "cdk-header-row", ""]
                        ],
                        hostAttrs: ["role", "row", 1, "cdk-header-row"],
                        decls: 1,
                        vars: 0,
                        consts: [
                            ["cdkCellOutlet", ""]
                        ],
                        template: function(t, e) {
                            1 & t && r.Rb(0, 0)
                        },
                        directives: [B],
                        encapsulation: 2
                    }), t
                })(),
                U = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["cdk-row"],
                            ["tr", "cdk-row", ""]
                        ],
                        hostAttrs: ["role", "row", 1, "cdk-row"],
                        decls: 1,
                        vars: 0,
                        consts: [
                            ["cdkCellOutlet", ""]
                        ],
                        template: function(t, e) {
                            1 & t && r.Rb(0, 0)
                        },
                        directives: [B],
                        encapsulation: 2
                    }), t
                })(),
                X = (() => {
                    class t {
                        constructor(t) {
                            this.templateRef = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.O))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["ng-template", "cdkNoDataRow", ""]
                        ]
                    }), t
                })();
            const W = ["top", "bottom", "left", "right"];
            class Y {
                constructor(t, e, i, n, s = !0, r = !0, a) {
                    this._isNativeHtmlTable = t, this._stickCellCss = e, this.direction = i, this._coalescedStyleScheduler = n, this._isBrowser = s, this._needsPositionStickyOnElement = r, this._positionListener = a, this._cachedCellWidths = [], this._borderCellCss = {
                        top: `${e}-border-elem-top`,
                        bottom: `${e}-border-elem-bottom`,
                        left: `${e}-border-elem-left`,
                        right: `${e}-border-elem-right`
                    }
                }
                clearStickyPositioning(t, e) {
                    const i = [];
                    for (const n of t)
                        if (n.nodeType === n.ELEMENT_NODE) {
                            i.push(n);
                            for (let t = 0; t < n.children.length; t++) i.push(n.children[t])
                        } this._scheduleStyleChanges(() => {
                        for (const t of i) this._removeStickyStyle(t, e)
                    })
                }
                updateStickyColumns(t, e, i, n = !0) {
                    if (!t.length || !this._isBrowser || !e.some(t => t) && !i.some(t => t)) return void(this._positionListener && (this._positionListener.stickyColumnsUpdated({
                        sizes: []
                    }), this._positionListener.stickyEndColumnsUpdated({
                        sizes: []
                    })));
                    const s = t[0],
                        r = s.children.length,
                        a = this._getCellWidths(s, n),
                        o = this._getStickyStartColumnPositions(a, e),
                        l = this._getStickyEndColumnPositions(a, i),
                        c = e.lastIndexOf(!0),
                        h = i.indexOf(!0);
                    this._scheduleStyleChanges(() => {
                        const n = "rtl" === this.direction,
                            s = n ? "right" : "left",
                            u = n ? "left" : "right";
                        for (const a of t)
                            for (let t = 0; t < r; t++) {
                                const n = a.children[t];
                                e[t] && this._addStickyStyle(n, s, o[t], t === c), i[t] && this._addStickyStyle(n, u, l[t], t === h)
                            }
                        this._positionListener && (this._positionListener.stickyColumnsUpdated({
                            sizes: -1 === c ? [] : a.slice(0, c + 1).map((t, i) => e[i] ? t : null)
                        }), this._positionListener.stickyEndColumnsUpdated({
                            sizes: -1 === h ? [] : a.slice(h).map((t, e) => i[e + h] ? t : null).reverse()
                        }))
                    })
                }
                stickRows(t, e, i) {
                    if (!this._isBrowser) return;
                    const n = "bottom" === i ? t.slice().reverse() : t,
                        s = "bottom" === i ? e.slice().reverse() : e,
                        r = [],
                        a = [],
                        o = [];
                    for (let c = 0, h = 0; c < n.length; c++) {
                        if (r[c] = h, !s[c]) continue;
                        const t = n[c];
                        o[c] = this._isNativeHtmlTable ? Array.from(t.children) : [t];
                        const e = t.getBoundingClientRect().height;
                        h += e, a[c] = e
                    }
                    const l = s.lastIndexOf(!0);
                    this._scheduleStyleChanges(() => {
                        var t, e;
                        for (let a = 0; a < n.length; a++) {
                            if (!s[a]) continue;
                            const t = r[a],
                                e = a === l;
                            for (const n of o[a]) this._addStickyStyle(n, i, t, e)
                        }
                        "top" === i ? null === (t = this._positionListener) || void 0 === t || t.stickyHeaderRowsUpdated({
                            sizes: a,
                            elements: o
                        }) : null === (e = this._positionListener) || void 0 === e || e.stickyFooterRowsUpdated({
                            sizes: a,
                            elements: o
                        })
                    })
                }
                updateStickyFooterContainer(t, e) {
                    if (!this._isNativeHtmlTable) return;
                    const i = t.querySelector("tfoot");
                    this._scheduleStyleChanges(() => {
                        e.some(t => !t) ? this._removeStickyStyle(i, ["bottom"]) : this._addStickyStyle(i, "bottom", 0, !1)
                    })
                }
                _removeStickyStyle(t, e) {
                    for (const i of e) t.style[i] = "", t.classList.remove(this._borderCellCss[i]);
                    W.some(i => -1 === e.indexOf(i) && t.style[i]) ? t.style.zIndex = this._getCalculatedZIndex(t) : (t.style.zIndex = "", this._needsPositionStickyOnElement && (t.style.position = ""), t.classList.remove(this._stickCellCss))
                }
                _addStickyStyle(t, e, i, n) {
                    t.classList.add(this._stickCellCss), n && t.classList.add(this._borderCellCss[e]), t.style[e] = `${i}px`, t.style.zIndex = this._getCalculatedZIndex(t), this._needsPositionStickyOnElement && (t.style.cssText += "position: -webkit-sticky; position: sticky; ")
                }
                _getCalculatedZIndex(t) {
                    const e = {
                        top: 100,
                        bottom: 10,
                        left: 1,
                        right: 1
                    };
                    let i = 0;
                    for (const n of W) t.style[n] && (i += e[n]);
                    return i ? `${i}` : ""
                }
                _getCellWidths(t, e = !0) {
                    if (!e && this._cachedCellWidths.length) return this._cachedCellWidths;
                    const i = [],
                        n = t.children;
                    for (let s = 0; s < n.length; s++) i.push(n[s].getBoundingClientRect().width);
                    return this._cachedCellWidths = i, i
                }
                _getStickyStartColumnPositions(t, e) {
                    const i = [];
                    let n = 0;
                    for (let s = 0; s < t.length; s++) e[s] && (i[s] = n, n += t[s]);
                    return i
                }
                _getStickyEndColumnPositions(t, e) {
                    const i = [];
                    let n = 0;
                    for (let s = t.length; s > 0; s--) e[s] && (i[s] = n, n += t[s]);
                    return i
                }
                _scheduleStyleChanges(t) {
                    this._coalescedStyleScheduler ? this._coalescedStyleScheduler.schedule(t) : t()
                }
            }
            const G = new r.s("CDK_SPL");
            let q = (() => {
                    class t {
                        constructor(t, e) {
                            this.viewContainer = t, this.elementRef = e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.S), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "rowOutlet", ""]
                        ]
                    }), t
                })(),
                Z = (() => {
                    class t {
                        constructor(t, e) {
                            this.viewContainer = t, this.elementRef = e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.S), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "headerRowOutlet", ""]
                        ]
                    }), t
                })(),
                $ = (() => {
                    class t {
                        constructor(t, e) {
                            this.viewContainer = t, this.elementRef = e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.S), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "footerRowOutlet", ""]
                        ]
                    }), t
                })(),
                Q = (() => {
                    class t {
                        constructor(t, e) {
                            this.viewContainer = t, this.elementRef = e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.S), r.Pb(r.l))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["", "noDataRowOutlet", ""]
                        ]
                    }), t
                })(),
                K = (() => {
                    class t {
                        constructor(t, e, i, n, s, r, a, o, l, c, u) {
                            this._differs = t, this._changeDetectorRef = e, this._elementRef = i, this._dir = s, this._platform = a, this._viewRepeater = o, this._coalescedStyleScheduler = l, this._stickyPositioningListener = c, this._viewportRuler = u, this._onDestroy = new h.a, this._columnDefsByName = new Map, this._customColumnDefs = new Set, this._customRowDefs = new Set, this._customHeaderRowDefs = new Set, this._customFooterRowDefs = new Set, this._headerRowDefChanged = !0, this._footerRowDefChanged = !0, this._stickyColumnStylesNeedReset = !0, this._forceRecalculateCellWidths = !0, this._cachedRenderRowsMap = new Map, this.stickyCssClass = "cdk-table-sticky", this.needsPositionStickyOnElement = !0, this._isShowingNoDataRow = !1, this._multiTemplateDataRows = !1, this._fixedLayout = !1, this.viewChange = new d.a({
                                start: 0,
                                end: Number.MAX_VALUE
                            }), n || this._elementRef.nativeElement.setAttribute("role", "grid"), this._document = r, this._isNativeHtmlTable = "TABLE" === this._elementRef.nativeElement.nodeName
                        }
                        get trackBy() {
                            return this._trackByFn
                        }
                        set trackBy(t) {
                            this._trackByFn = t
                        }
                        get dataSource() {
                            return this._dataSource
                        }
                        set dataSource(t) {
                            this._dataSource !== t && this._switchDataSource(t)
                        }
                        get multiTemplateDataRows() {
                            return this._multiTemplateDataRows
                        }
                        set multiTemplateDataRows(t) {
                            this._multiTemplateDataRows = Object(n.c)(t), this._rowOutlet && this._rowOutlet.viewContainer.length && (this._forceRenderDataRows(), this.updateStickyColumnStyles())
                        }
                        get fixedLayout() {
                            return this._fixedLayout
                        }
                        set fixedLayout(t) {
                            this._fixedLayout = Object(n.c)(t), this._forceRecalculateCellWidths = !0, this._stickyColumnStylesNeedReset = !0
                        }
                        ngOnInit() {
                            this._setupStickyStyler(), this._isNativeHtmlTable && this._applyNativeTableSections(), this._dataDiffer = this._differs.find([]).create((t, e) => this.trackBy ? this.trackBy(e.dataIndex, e.data) : e), this._viewportRuler && this._viewportRuler.change().pipe(Object(g.a)(this._onDestroy)).subscribe(() => {
                                this._forceRecalculateCellWidths = !0
                            })
                        }
                        ngAfterContentChecked() {
                            this._cacheRowDefs(), this._cacheColumnDefs();
                            const t = this._renderUpdatedColumns() || this._headerRowDefChanged || this._footerRowDefChanged;
                            this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || t, this._forceRecalculateCellWidths = t, this._headerRowDefChanged && (this._forceRenderHeaderRows(), this._headerRowDefChanged = !1), this._footerRowDefChanged && (this._forceRenderFooterRows(), this._footerRowDefChanged = !1), this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription ? this._observeRenderChanges() : this._stickyColumnStylesNeedReset && this.updateStickyColumnStyles(), this._checkStickyStates()
                        }
                        ngOnDestroy() {
                            this._rowOutlet.viewContainer.clear(), this._noDataRowOutlet.viewContainer.clear(), this._headerRowOutlet.viewContainer.clear(), this._footerRowOutlet.viewContainer.clear(), this._cachedRenderRowsMap.clear(), this._onDestroy.next(), this._onDestroy.complete(), Object(s.g)(this.dataSource) && this.dataSource.disconnect(this)
                        }
                        renderRows() {
                            this._renderRows = this._getAllRenderRows();
                            const t = this._dataDiffer.diff(this._renderRows);
                            if (!t) return void this._updateNoDataRow();
                            const e = this._rowOutlet.viewContainer;
                            this._viewRepeater ? this._viewRepeater.applyChanges(t, e, (t, e, i) => this._getEmbeddedViewArgs(t.item, i), t => t.item.data, t => {
                                1 === t.operation && t.context && this._renderCellTemplateForItem(t.record.item.rowDef, t.context)
                            }) : t.forEachOperation((t, i, n) => {
                                if (null == t.previousIndex) {
                                    const e = t.item;
                                    this._renderRow(this._rowOutlet, e.rowDef, n, {
                                        $implicit: e.data
                                    })
                                } else if (null == n) e.remove(i);
                                else {
                                    const t = e.get(i);
                                    e.move(t, n)
                                }
                            }), this._updateRowIndexContext(), t.forEachIdentityChange(t => {
                                e.get(t.currentIndex).context.$implicit = t.item.data
                            }), this._updateNoDataRow(), this.updateStickyColumnStyles()
                        }
                        addColumnDef(t) {
                            this._customColumnDefs.add(t)
                        }
                        removeColumnDef(t) {
                            this._customColumnDefs.delete(t)
                        }
                        addRowDef(t) {
                            this._customRowDefs.add(t)
                        }
                        removeRowDef(t) {
                            this._customRowDefs.delete(t)
                        }
                        addHeaderRowDef(t) {
                            this._customHeaderRowDefs.add(t), this._headerRowDefChanged = !0
                        }
                        removeHeaderRowDef(t) {
                            this._customHeaderRowDefs.delete(t), this._headerRowDefChanged = !0
                        }
                        addFooterRowDef(t) {
                            this._customFooterRowDefs.add(t), this._footerRowDefChanged = !0
                        }
                        removeFooterRowDef(t) {
                            this._customFooterRowDefs.delete(t), this._footerRowDefChanged = !0
                        }
                        setNoDataRow(t) {
                            this._customNoDataRow = t
                        }
                        updateStickyHeaderRowStyles() {
                            const t = this._getRenderedRows(this._headerRowOutlet),
                                e = this._elementRef.nativeElement.querySelector("thead");
                            e && (e.style.display = t.length ? "" : "none");
                            const i = this._headerRowDefs.map(t => t.sticky);
                            this._stickyStyler.clearStickyPositioning(t, ["top"]), this._stickyStyler.stickRows(t, i, "top"), this._headerRowDefs.forEach(t => t.resetStickyChanged())
                        }
                        updateStickyFooterRowStyles() {
                            const t = this._getRenderedRows(this._footerRowOutlet),
                                e = this._elementRef.nativeElement.querySelector("tfoot");
                            e && (e.style.display = t.length ? "" : "none");
                            const i = this._footerRowDefs.map(t => t.sticky);
                            this._stickyStyler.clearStickyPositioning(t, ["bottom"]), this._stickyStyler.stickRows(t, i, "bottom"), this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, i), this._footerRowDefs.forEach(t => t.resetStickyChanged())
                        }
                        updateStickyColumnStyles() {
                            const t = this._getRenderedRows(this._headerRowOutlet),
                                e = this._getRenderedRows(this._rowOutlet),
                                i = this._getRenderedRows(this._footerRowOutlet);
                            (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) && (this._stickyStyler.clearStickyPositioning([...t, ...e, ...i], ["left", "right"]), this._stickyColumnStylesNeedReset = !1), t.forEach((t, e) => {
                                this._addStickyColumnStyles([t], this._headerRowDefs[e])
                            }), this._rowDefs.forEach(t => {
                                const i = [];
                                for (let n = 0; n < e.length; n++) this._renderRows[n].rowDef === t && i.push(e[n]);
                                this._addStickyColumnStyles(i, t)
                            }), i.forEach((t, e) => {
                                this._addStickyColumnStyles([t], this._footerRowDefs[e])
                            }), Array.from(this._columnDefsByName.values()).forEach(t => t.resetStickyChanged())
                        }
                        _getAllRenderRows() {
                            const t = [],
                                e = this._cachedRenderRowsMap;
                            this._cachedRenderRowsMap = new Map;
                            for (let i = 0; i < this._data.length; i++) {
                                let n = this._data[i];
                                const s = this._getRenderRowsForData(n, i, e.get(n));
                                this._cachedRenderRowsMap.has(n) || this._cachedRenderRowsMap.set(n, new WeakMap);
                                for (let e = 0; e < s.length; e++) {
                                    let i = s[e];
                                    const n = this._cachedRenderRowsMap.get(i.data);
                                    n.has(i.rowDef) ? n.get(i.rowDef).push(i) : n.set(i.rowDef, [i]), t.push(i)
                                }
                            }
                            return t
                        }
                        _getRenderRowsForData(t, e, i) {
                            return this._getRowDefs(t, e).map(n => {
                                const s = i && i.has(n) ? i.get(n) : [];
                                if (s.length) {
                                    const t = s.shift();
                                    return t.dataIndex = e, t
                                }
                                return {
                                    data: t,
                                    rowDef: n,
                                    dataIndex: e
                                }
                            })
                        }
                        _cacheColumnDefs() {
                            this._columnDefsByName.clear(), J(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs).forEach(t => {
                                this._columnDefsByName.has(t.name), this._columnDefsByName.set(t.name, t)
                            })
                        }
                        _cacheRowDefs() {
                            this._headerRowDefs = J(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs), this._footerRowDefs = J(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs), this._rowDefs = J(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
                            const t = this._rowDefs.filter(t => !t.when);
                            this._defaultRowDef = t[0]
                        }
                        _renderUpdatedColumns() {
                            const t = (t, e) => t || !!e.getColumnsDiff(),
                                e = this._rowDefs.reduce(t, !1);
                            e && this._forceRenderDataRows();
                            const i = this._headerRowDefs.reduce(t, !1);
                            i && this._forceRenderHeaderRows();
                            const n = this._footerRowDefs.reduce(t, !1);
                            return n && this._forceRenderFooterRows(), e || i || n
                        }
                        _switchDataSource(t) {
                            this._data = [], Object(s.g)(this.dataSource) && this.dataSource.disconnect(this), this._renderChangeSubscription && (this._renderChangeSubscription.unsubscribe(), this._renderChangeSubscription = null), t || (this._dataDiffer && this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear()), this._dataSource = t
                        }
                        _observeRenderChanges() {
                            if (!this.dataSource) return;
                            let t;
                            Object(s.g)(this.dataSource) ? t = this.dataSource.connect(this) : Object(p.a)(this.dataSource) ? t = this.dataSource : Array.isArray(this.dataSource) && (t = Object(f.a)(this.dataSource)), this._renderChangeSubscription = t.pipe(Object(g.a)(this._onDestroy)).subscribe(t => {
                                this._data = t || [], this.renderRows()
                            })
                        }
                        _forceRenderHeaderRows() {
                            this._headerRowOutlet.viewContainer.length > 0 && this._headerRowOutlet.viewContainer.clear(), this._headerRowDefs.forEach((t, e) => this._renderRow(this._headerRowOutlet, t, e)), this.updateStickyHeaderRowStyles()
                        }
                        _forceRenderFooterRows() {
                            this._footerRowOutlet.viewContainer.length > 0 && this._footerRowOutlet.viewContainer.clear(), this._footerRowDefs.forEach((t, e) => this._renderRow(this._footerRowOutlet, t, e)), this.updateStickyFooterRowStyles()
                        }
                        _addStickyColumnStyles(t, e) {
                            const i = Array.from(e.columns || []).map(t => this._columnDefsByName.get(t)),
                                n = i.map(t => t.sticky),
                                s = i.map(t => t.stickyEnd);
                            this._stickyStyler.updateStickyColumns(t, n, s, !this._fixedLayout || this._forceRecalculateCellWidths)
                        }
                        _getRenderedRows(t) {
                            const e = [];
                            for (let i = 0; i < t.viewContainer.length; i++) {
                                const n = t.viewContainer.get(i);
                                e.push(n.rootNodes[0])
                            }
                            return e
                        }
                        _getRowDefs(t, e) {
                            if (1 == this._rowDefs.length) return [this._rowDefs[0]];
                            let i = [];
                            if (this.multiTemplateDataRows) i = this._rowDefs.filter(i => !i.when || i.when(e, t));
                            else {
                                let n = this._rowDefs.find(i => i.when && i.when(e, t)) || this._defaultRowDef;
                                n && i.push(n)
                            }
                            return i
                        }
                        _getEmbeddedViewArgs(t, e) {
                            return {
                                templateRef: t.rowDef.template,
                                context: {
                                    $implicit: t.data
                                },
                                index: e
                            }
                        }
                        _renderRow(t, e, i, n = {}) {
                            const s = t.viewContainer.createEmbeddedView(e.template, n, i);
                            return this._renderCellTemplateForItem(e, n), s
                        }
                        _renderCellTemplateForItem(t, e) {
                            for (let i of this._getCellTemplates(t)) B.mostRecentCellOutlet && B.mostRecentCellOutlet._viewContainer.createEmbeddedView(i, e);
                            this._changeDetectorRef.markForCheck()
                        }
                        _updateRowIndexContext() {
                            const t = this._rowOutlet.viewContainer;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const n = t.get(e).context;
                                n.count = i, n.first = 0 === e, n.last = e === i - 1, n.even = e % 2 == 0, n.odd = !n.even, this.multiTemplateDataRows ? (n.dataIndex = this._renderRows[e].dataIndex, n.renderIndex = e) : n.index = this._renderRows[e].dataIndex
                            }
                        }
                        _getCellTemplates(t) {
                            return t && t.columns ? Array.from(t.columns, e => {
                                const i = this._columnDefsByName.get(e);
                                return t.extractCellTemplate(i)
                            }) : []
                        }
                        _applyNativeTableSections() {
                            const t = this._document.createDocumentFragment(),
                                e = [{
                                    tag: "thead",
                                    outlets: [this._headerRowOutlet]
                                }, {
                                    tag: "tbody",
                                    outlets: [this._rowOutlet, this._noDataRowOutlet]
                                }, {
                                    tag: "tfoot",
                                    outlets: [this._footerRowOutlet]
                                }];
                            for (const i of e) {
                                const e = this._document.createElement(i.tag);
                                e.setAttribute("role", "rowgroup");
                                for (const t of i.outlets) e.appendChild(t.elementRef.nativeElement);
                                t.appendChild(e)
                            }
                            this._elementRef.nativeElement.appendChild(t)
                        }
                        _forceRenderDataRows() {
                            this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear(), this.renderRows()
                        }
                        _checkStickyStates() {
                            const t = (t, e) => t || e.hasStickyChanged();
                            this._headerRowDefs.reduce(t, !1) && this.updateStickyHeaderRowStyles(), this._footerRowDefs.reduce(t, !1) && this.updateStickyFooterRowStyles(), Array.from(this._columnDefsByName.values()).reduce(t, !1) && (this._stickyColumnStylesNeedReset = !0, this.updateStickyColumnStyles())
                        }
                        _setupStickyStyler() {
                            this._stickyStyler = new Y(this._isNativeHtmlTable, this.stickyCssClass, this._dir ? this._dir.value : "ltr", this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener), (this._dir ? this._dir.change : Object(f.a)()).pipe(Object(g.a)(this._onDestroy)).subscribe(t => {
                                this._stickyStyler.direction = t, this.updateStickyColumnStyles()
                            })
                        }
                        _getOwnDefs(t) {
                            return t.filter(t => !t._table || t._table === this)
                        }
                        _updateNoDataRow() {
                            const t = this._customNoDataRow || this._noDataRow;
                            if (t) {
                                const e = 0 === this._rowOutlet.viewContainer.length;
                                if (e !== this._isShowingNoDataRow) {
                                    const i = this._noDataRowOutlet.viewContainer;
                                    e ? i.createEmbeddedView(t.templateRef) : i.clear(), this._isShowingNoDataRow = e
                                }
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.u), r.Pb(r.h), r.Pb(r.l), r.ac("role"), r.Pb(a.b, 8), r.Pb(c.d), r.Pb(o.a), r.Pb(s.f, 8), r.Pb(D, 8), r.Pb(G, 12), r.Pb(l.e, 8))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["cdk-table"],
                            ["table", "cdk-table", ""]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (r.Ib(i, X, 1), r.Ib(i, A, 1), r.Ib(i, V, 1), r.Ib(i, j, 1), r.Ib(i, z, 1)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e._noDataRow = t.first), r.rc(t = r.dc()) && (e._contentColumnDefs = t), r.rc(t = r.dc()) && (e._contentRowDefs = t), r.rc(t = r.dc()) && (e._contentHeaderRowDefs = t), r.rc(t = r.dc()) && (e._contentFooterRowDefs = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && (r.Hc(q, 3), r.Hc(Z, 3), r.Hc($, 3), r.Hc(Q, 3)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e._rowOutlet = t.first), r.rc(t = r.dc()) && (e._headerRowOutlet = t.first), r.rc(t = r.dc()) && (e._footerRowOutlet = t.first), r.rc(t = r.dc()) && (e._noDataRowOutlet = t.first)
                            }
                        },
                        hostAttrs: [1, "cdk-table"],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            2 & t && r.Hb("cdk-table-fixed-layout", e.fixedLayout)
                        },
                        inputs: {
                            trackBy: "trackBy",
                            dataSource: "dataSource",
                            multiTemplateDataRows: "multiTemplateDataRows",
                            fixedLayout: "fixedLayout"
                        },
                        exportAs: ["cdkTable"],
                        features: [r.Cb([{
                            provide: x,
                            useExisting: t
                        }, {
                            provide: s.f,
                            useClass: s.d
                        }, {
                            provide: D,
                            useClass: I
                        }, {
                            provide: G,
                            useValue: null
                        }])],
                        ngContentSelectors: y,
                        decls: 6,
                        vars: 0,
                        consts: [
                            ["headerRowOutlet", ""],
                            ["rowOutlet", ""],
                            ["noDataRowOutlet", ""],
                            ["footerRowOutlet", ""]
                        ],
                        template: function(t, e) {
                            1 & t && (r.kc(b), r.jc(0), r.jc(1, 1), r.Rb(2, 0), r.Rb(3, 1), r.Rb(4, 2), r.Rb(5, 3))
                        },
                        directives: [Z, q, Q, $],
                        styles: [".cdk-table-fixed-layout{table-layout:fixed}\n"],
                        encapsulation: 2
                    }), t
                })();

            function J(t, e) {
                return t.concat(Array.from(e))
            }
            let tt = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = r.Nb({
                    type: t
                }), t.\u0275inj = r.Mb({
                    imports: [
                        [l.d]
                    ]
                }), t
            })();
            var et = i("FKr1"),
                it = i("2btn"),
                nt = i("mASl"),
                st = i("rdQv");
            const rt = [
                    [
                        ["caption"]
                    ],
                    [
                        ["colgroup"],
                        ["col"]
                    ]
                ],
                at = ["caption", "colgroup, col"];
            let ot = (() => {
                class t extends K {
                    constructor() {
                        super(...arguments), this.stickyCssClass = "mat-table-sticky", this.needsPositionStickyOnElement = !1
                    }
                }
                return t.\u0275fac = function(e) {
                    return lt(e || t)
                }, t.\u0275cmp = r.Jb({
                    type: t,
                    selectors: [
                        ["mat-table"],
                        ["table", "mat-table", ""]
                    ],
                    hostAttrs: [1, "mat-table"],
                    hostVars: 2,
                    hostBindings: function(t, e) {
                        2 & t && r.Hb("mat-table-fixed-layout", e.fixedLayout)
                    },
                    exportAs: ["matTable"],
                    features: [r.Cb([{
                        provide: s.f,
                        useClass: s.d
                    }, {
                        provide: K,
                        useExisting: t
                    }, {
                        provide: x,
                        useExisting: t
                    }, {
                        provide: D,
                        useClass: I
                    }]), r.Ab],
                    ngContentSelectors: at,
                    decls: 6,
                    vars: 0,
                    consts: [
                        ["headerRowOutlet", ""],
                        ["rowOutlet", ""],
                        ["noDataRowOutlet", ""],
                        ["footerRowOutlet", ""]
                    ],
                    template: function(t, e) {
                        1 & t && (r.kc(rt), r.jc(0), r.jc(1, 1), r.Rb(2, 0), r.Rb(3, 1), r.Rb(4, 2), r.Rb(5, 3))
                    },
                    directives: [Z, q, Q, $],
                    styles: ['mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:""}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}.mat-table-sticky{position:-webkit-sticky !important;position:sticky !important}.mat-table-fixed-layout{table-layout:fixed}\n'],
                    encapsulation: 2
                }), t
            })();
            const lt = r.Xb(ot);
            let ct = (() => {
                class t extends _ {}
                return t.\u0275fac = function(e) {
                    return ht(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "matCellDef", ""]
                    ],
                    features: [r.Cb([{
                        provide: _,
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            const ht = r.Xb(ct);
            let ut = (() => {
                class t extends w {}
                return t.\u0275fac = function(e) {
                    return dt(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "matHeaderCellDef", ""]
                    ],
                    features: [r.Cb([{
                        provide: w,
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            const dt = r.Xb(ut);
            let pt = (() => {
                class t extends A {
                    get name() {
                        return this._name
                    }
                    set name(t) {
                        this._setNameInput(t)
                    }
                    _updateColumnCssClassName() {
                        super._updateColumnCssClassName(), this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`)
                    }
                }
                return t.\u0275fac = function(e) {
                    return ft(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "matColumnDef", ""]
                    ],
                    inputs: {
                        sticky: "sticky",
                        name: ["matColumnDef", "name"]
                    },
                    features: [r.Cb([{
                        provide: A,
                        useExisting: t
                    }, {
                        provide: "MAT_SORT_HEADER_COLUMN_DEF",
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            const ft = r.Xb(pt);
            let gt = (() => {
                class t extends E {}
                return t.\u0275fac = function(e) {
                    return mt(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["mat-header-cell"],
                        ["th", "mat-header-cell", ""]
                    ],
                    hostAttrs: ["role", "columnheader", 1, "mat-header-cell"],
                    features: [r.Ab]
                }), t
            })();
            const mt = r.Xb(gt);
            let bt = (() => {
                class t extends P {}
                return t.\u0275fac = function(e) {
                    return yt(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["mat-cell"],
                        ["td", "mat-cell", ""]
                    ],
                    hostAttrs: ["role", "gridcell", 1, "mat-cell"],
                    features: [r.Ab]
                }), t
            })();
            const yt = r.Xb(bt);
            let vt = (() => {
                class t extends j {}
                return t.\u0275fac = function(e) {
                    return xt(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "matHeaderRowDef", ""]
                    ],
                    inputs: {
                        columns: ["matHeaderRowDef", "columns"],
                        sticky: ["matHeaderRowDefSticky", "sticky"]
                    },
                    features: [r.Cb([{
                        provide: j,
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            const xt = r.Xb(vt);
            let _t = (() => {
                class t extends V {}
                return t.\u0275fac = function(e) {
                    return wt(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t,
                    selectors: [
                        ["", "matRowDef", ""]
                    ],
                    inputs: {
                        columns: ["matRowDefColumns", "columns"],
                        when: ["matRowDefWhen", "when"]
                    },
                    features: [r.Cb([{
                        provide: V,
                        useExisting: t
                    }]), r.Ab]
                }), t
            })();
            const wt = r.Xb(_t);
            let Ct = (() => {
                class t extends H {}
                return t.\u0275fac = function(e) {
                    return kt(e || t)
                }, t.\u0275cmp = r.Jb({
                    type: t,
                    selectors: [
                        ["mat-header-row"],
                        ["tr", "mat-header-row", ""]
                    ],
                    hostAttrs: ["role", "row", 1, "mat-header-row"],
                    exportAs: ["matHeaderRow"],
                    features: [r.Cb([{
                        provide: H,
                        useExisting: t
                    }]), r.Ab],
                    decls: 1,
                    vars: 0,
                    consts: [
                        ["cdkCellOutlet", ""]
                    ],
                    template: function(t, e) {
                        1 & t && r.Rb(0, 0)
                    },
                    directives: [B],
                    encapsulation: 2
                }), t
            })();
            const kt = r.Xb(Ct);
            let St = (() => {
                class t extends U {}
                return t.\u0275fac = function(e) {
                    return At(e || t)
                }, t.\u0275cmp = r.Jb({
                    type: t,
                    selectors: [
                        ["mat-row"],
                        ["tr", "mat-row", ""]
                    ],
                    hostAttrs: ["role", "row", 1, "mat-row"],
                    exportAs: ["matRow"],
                    features: [r.Cb([{
                        provide: U,
                        useExisting: t
                    }]), r.Ab],
                    decls: 1,
                    vars: 0,
                    consts: [
                        ["cdkCellOutlet", ""]
                    ],
                    template: function(t, e) {
                        1 & t && r.Rb(0, 0)
                    },
                    directives: [B],
                    encapsulation: 2
                }), t
            })();
            const At = r.Xb(St);
            let Ot = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = r.Nb({
                    type: t
                }), t.\u0275inj = r.Mb({
                    imports: [
                        [tt, et.e], et.e
                    ]
                }), t
            })();
            class Et extends s.b {
                constructor(t = []) {
                    super(), this._renderData = new d.a([]), this._filter = new d.a(""), this._internalPageChanges = new h.a, this._renderChangesSubscription = null, this.sortingDataAccessor = (t, e) => {
                        const i = t[e];
                        if (Object(n.a)(i)) {
                            const t = Number(i);
                            return t < 9007199254740991 ? t : i
                        }
                        return i
                    }, this.sortData = (t, e) => {
                        const i = e.active,
                            n = e.direction;
                        return i && "" != n ? t.sort((t, e) => {
                            let s = this.sortingDataAccessor(t, i),
                                r = this.sortingDataAccessor(e, i);
                            const a = typeof s,
                                o = typeof r;
                            a !== o && ("number" === a && (s += ""), "number" === o && (r += ""));
                            let l = 0;
                            return null != s && null != r ? s > r ? l = 1 : s < r && (l = -1) : null != s ? l = 1 : null != r && (l = -1), l * ("asc" == n ? 1 : -1)
                        }) : t
                    }, this.filterPredicate = (t, e) => {
                        const i = Object.keys(t).reduce((e, i) => e + t[i] + "\u25ec", "").toLowerCase(),
                            n = e.trim().toLowerCase();
                        return -1 != i.indexOf(n)
                    }, this._data = new d.a(t), this._updateChangeSubscription()
                }
                get data() {
                    return this._data.value
                }
                set data(t) {
                    this._data.next(t), this._renderChangesSubscription || this._filterData(t)
                }
                get filter() {
                    return this._filter.value
                }
                set filter(t) {
                    this._filter.next(t), this._renderChangesSubscription || this._filterData(this.data)
                }
                get sort() {
                    return this._sort
                }
                set sort(t) {
                    this._sort = t, this._updateChangeSubscription()
                }
                get paginator() {
                    return this._paginator
                }
                set paginator(t) {
                    this._paginator = t, this._updateChangeSubscription()
                }
                _updateChangeSubscription() {
                    var t;
                    const e = this._sort ? Object(it.a)(this._sort.sortChange, this._sort.initialized) : Object(f.a)(null),
                        i = this._paginator ? Object(it.a)(this._paginator.page, this._internalPageChanges, this._paginator.initialized) : Object(f.a)(null),
                        n = this._data,
                        s = Object(nt.a)([n, this._filter]).pipe(Object(st.a)(([t]) => this._filterData(t))),
                        r = Object(nt.a)([s, e]).pipe(Object(st.a)(([t]) => this._orderData(t))),
                        a = Object(nt.a)([r, i]).pipe(Object(st.a)(([t]) => this._pageData(t)));
                    null === (t = this._renderChangesSubscription) || void 0 === t || t.unsubscribe(), this._renderChangesSubscription = a.subscribe(t => this._renderData.next(t))
                }
                _filterData(t) {
                    return this.filteredData = null == this.filter || "" === this.filter ? t : t.filter(t => this.filterPredicate(t, this.filter)), this.paginator && this._updatePaginator(this.filteredData.length), this.filteredData
                }
                _orderData(t) {
                    return this.sort ? this.sortData(t.slice(), this.sort) : t
                }
                _pageData(t) {
                    if (!this.paginator) return t;
                    const e = this.paginator.pageIndex * this.paginator.pageSize;
                    return t.slice(e, e + this.paginator.pageSize)
                }
                _updatePaginator(t) {
                    Promise.resolve().then(() => {
                        const e = this.paginator;
                        if (e && (e.length = t, e.pageIndex > 0)) {
                            const t = Math.ceil(e.length / e.pageSize) - 1 || 0,
                                i = Math.min(e.pageIndex, t);
                            i !== e.pageIndex && (e.pageIndex = i, this._internalPageChanges.next())
                        }
                    })
                }
                connect() {
                    return this._renderChangesSubscription || this._updateChangeSubscription(), this._renderData
                }
                disconnect() {
                    var t;
                    null === (t = this._renderChangesSubscription) || void 0 === t || t.unsubscribe(), this._renderChangesSubscription = null
                }
            }
            class Pt extends Et {}
        },
        "+qId": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("WGFi"),
                s = i("ZjGG");

            function r(t) {
                s.a.setTimeout(() => {
                    const {
                        onUnhandledError: e
                    } = n.a;
                    if (!e) throw t;
                    e(t)
                })
            }
        },
        "+rOU": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return u
            }), i.d(e, "b", function() {
                return d
            }), i.d(e, "c", function() {
                return a
            }), i.d(e, "d", function() {
                return h
            }), i.d(e, "e", function() {
                return p
            }), i.d(e, "f", function() {
                return o
            });
            var n = i("fXoL"),
                s = i("ofXK");
            class r {
                attach(t) {
                    return this._attachedHost = t, t.attach(this)
                }
                detach() {
                    let t = this._attachedHost;
                    null != t && (this._attachedHost = null, t.detach())
                }
                get isAttached() {
                    return null != this._attachedHost
                }
                setAttachedHost(t) {
                    this._attachedHost = t
                }
            }
            class a extends r {
                constructor(t, e, i, n) {
                    super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = n
                }
            }
            class o extends r {
                constructor(t, e, i) {
                    super(), this.templateRef = t, this.viewContainerRef = e, this.context = i
                }
                get origin() {
                    return this.templateRef.elementRef
                }
                attach(t, e = this.context) {
                    return this.context = e, super.attach(t)
                }
                detach() {
                    return this.context = void 0, super.detach()
                }
            }
            class l extends r {
                constructor(t) {
                    super(), this.element = t instanceof n.l ? t.nativeElement : t
                }
            }
            class c {
                constructor() {
                    this._isDisposed = !1, this.attachDomPortal = null
                }
                hasAttached() {
                    return !!this._attachedPortal
                }
                attach(t) {
                    return t instanceof a ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof o ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof l ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0
                }
                detach() {
                    this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn()
                }
                dispose() {
                    this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0
                }
                setDisposeFn(t) {
                    this._disposeFn = t
                }
                _invokeDisposeFn() {
                    this._disposeFn && (this._disposeFn(), this._disposeFn = null)
                }
            }
            class h extends c {
                constructor(t, e, i, n, s) {
                    super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = n, this.attachDomPortal = t => {
                        const e = t.element,
                            i = this._document.createComment("dom-portal");
                        e.parentNode.insertBefore(i, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => {
                            i.parentNode && i.parentNode.replaceChild(e, i)
                        })
                    }, this._document = s
                }
                attachComponentPortal(t) {
                    const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component);
                    let i;
                    return t.viewContainerRef ? (i = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => i.destroy())) : (i = e.create(t.injector || this._defaultInjector), this._appRef.attachView(i.hostView), this.setDisposeFn(() => {
                        this._appRef.detachView(i.hostView), i.destroy()
                    })), this.outletElement.appendChild(this._getComponentRootNode(i)), this._attachedPortal = t, i
                }
                attachTemplatePortal(t) {
                    let e = t.viewContainerRef,
                        i = e.createEmbeddedView(t.templateRef, t.context);
                    return i.rootNodes.forEach(t => this.outletElement.appendChild(t)), i.detectChanges(), this.setDisposeFn(() => {
                        let t = e.indexOf(i); - 1 !== t && e.remove(t)
                    }), this._attachedPortal = t, i
                }
                dispose() {
                    super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement)
                }
                _getComponentRootNode(t) {
                    return t.hostView.rootNodes[0]
                }
            }
            let u = (() => {
                    class t extends o {
                        constructor(t, e) {
                            super(t, e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.O), n.Pb(n.S))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkPortal", ""]
                        ],
                        exportAs: ["cdkPortal"],
                        features: [n.Ab]
                    }), t
                })(),
                d = (() => {
                    class t extends c {
                        constructor(t, e, i) {
                            super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new n.o, this.attachDomPortal = t => {
                                const e = t.element,
                                    i = this._document.createComment("dom-portal");
                                t.setAttachedHost(this), e.parentNode.insertBefore(i, e), this._getRootNode().appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => {
                                    i.parentNode && i.parentNode.replaceChild(e, i)
                                })
                            }, this._document = i
                        }
                        get portal() {
                            return this._attachedPortal
                        }
                        set portal(t) {
                            (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t)
                        }
                        get attachedRef() {
                            return this._attachedRef
                        }
                        ngOnInit() {
                            this._isInitialized = !0
                        }
                        ngOnDestroy() {
                            super.dispose(), this._attachedPortal = null, this._attachedRef = null
                        }
                        attachComponentPortal(t) {
                            t.setAttachedHost(this);
                            const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef,
                                i = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component),
                                n = e.createComponent(i, e.length, t.injector || e.injector);
                            return e !== this._viewContainerRef && this._getRootNode().appendChild(n.hostView.rootNodes[0]), super.setDisposeFn(() => n.destroy()), this._attachedPortal = t, this._attachedRef = n, this.attached.emit(n), n
                        }
                        attachTemplatePortal(t) {
                            t.setAttachedHost(this);
                            const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context);
                            return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e
                        }
                        _getRootNode() {
                            const t = this._viewContainerRef.element.nativeElement;
                            return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.j), n.Pb(n.S), n.Pb(s.d))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkPortalOutlet", ""]
                        ],
                        inputs: {
                            portal: ["cdkPortalOutlet", "portal"]
                        },
                        outputs: {
                            attached: "attached"
                        },
                        exportAs: ["cdkPortalOutlet"],
                        features: [n.Ab]
                    }), t
                })(),
                p = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({}), t
                })()
        },
        "/2RN": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return w
            });
            var n = i("ofXK"),
                s = i("+0xr"),
                r = i("DKVz"),
                a = i("LNGT"),
                o = i("Wp6s"),
                l = i("NFeN"),
                c = i("STbY"),
                h = i("bTqV"),
                u = i("bv9b"),
                d = i("/t3+"),
                p = i("fXoL"),
                f = i("FKr1");
            i("8LU1"), i("cH1L");
            let g = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = p.Nb({
                    type: t
                }), t.\u0275inj = p.Mb({
                    imports: [
                        [f.g, f.e], f.g, f.e
                    ]
                }), t
            })();
            var m = i("d3UM"),
                b = i("qFsG"),
                y = i("CV0D"),
                v = i("3Pt+"),
                x = i("PCNd"),
                _ = i("AGcZ");
            let w = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = p.Nb({
                    type: t
                }), t.\u0275inj = p.Mb({
                    providers: [_.a],
                    imports: [
                        [n.c, s.l, r.b, a.b, o.c, l.b, c.c, h.c, u.b, d.b, g, m.b, b.b, y.b, v.g, x.a]
                    ]
                }), t
            })()
        },
        "/t3+": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return d
            }), i.d(e, "b", function() {
                return p
            });
            var n = i("FKr1"),
                s = i("ofXK"),
                r = i("fXoL"),
                a = i("nLfN");
            const o = ["*", [
                    ["mat-toolbar-row"]
                ]],
                l = ["*", "mat-toolbar-row"];
            class c {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const h = Object(n.q)(c);
            let u = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-toolbar-row"]
                        ],
                        hostAttrs: [1, "mat-toolbar-row"],
                        exportAs: ["matToolbarRow"]
                    }), t
                })(),
                d = (() => {
                    class t extends h {
                        constructor(t, e, i) {
                            super(t), this._platform = e, this._document = i
                        }
                        ngAfterViewInit() {
                            this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes()))
                        }
                        _checkToolbarMixedModes() {}
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.l), r.Pb(a.a), r.Pb(s.d))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["mat-toolbar"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && r.Ib(i, u, 1), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e._toolbarRows = t)
                            }
                        },
                        hostAttrs: [1, "mat-toolbar"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && r.Hb("mat-toolbar-multiple-rows", e._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === e._toolbarRows.length)
                        },
                        inputs: {
                            color: "color"
                        },
                        exportAs: ["matToolbar"],
                        features: [r.Ab],
                        ngContentSelectors: l,
                        decls: 2,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (r.kc(o), r.jc(0), r.jc(1, 1))
                        },
                        styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                p = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = r.Nb({
                        type: t
                    }), t.\u0275inj = r.Mb({
                        imports: [
                            [n.e], n.e
                        ]
                    }), t
                })()
        },
        0: function(t, e, i) {
            t.exports = i("zUnb")
        },
        "0EQZ": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return c
            }), i.d(e, "b", function() {
                return o
            }), i.d(e, "c", function() {
                return d
            }), i.d(e, "d", function() {
                return h
            }), i.d(e, "e", function() {
                return u
            }), i.d(e, "f", function() {
                return p
            }), i.d(e, "g", function() {
                return l
            });
            var n = i("BBcS"),
                s = i("4krO"),
                r = i("oXA7"),
                a = i("fXoL");
            class o {}

            function l(t) {
                return t && "function" == typeof t.connect
            }
            class c extends o {
                constructor(t) {
                    super(), this._data = t
                }
                connect() {
                    return Object(n.a)(this._data) ? this._data : Object(s.a)(this._data)
                }
                disconnect() {}
            }
            class h {
                applyChanges(t, e, i, n, s) {
                    t.forEachOperation((t, n, r) => {
                        let a, o;
                        if (null == t.previousIndex) {
                            const s = i(t, n, r);
                            a = e.createEmbeddedView(s.templateRef, s.context, s.index), o = 1
                        } else null == r ? (e.remove(n), o = 3) : (a = e.get(n), e.move(a, r), o = 2);
                        s && s({
                            context: null == a ? void 0 : a.context,
                            operation: o,
                            record: t
                        })
                    })
                }
                detach() {}
            }
            class u {
                constructor() {
                    this.viewCacheSize = 20, this._viewCache = []
                }
                applyChanges(t, e, i, n, s) {
                    t.forEachOperation((t, r, a) => {
                        let o, l;
                        null == t.previousIndex ? (o = this._insertView(() => i(t, r, a), a, e, n(t)), l = o ? 1 : 0) : null == a ? (this._detachAndCacheView(r, e), l = 3) : (o = this._moveView(r, a, e, n(t)), l = 2), s && s({
                            context: null == o ? void 0 : o.context,
                            operation: l,
                            record: t
                        })
                    })
                }
                detach() {
                    for (const t of this._viewCache) t.destroy();
                    this._viewCache = []
                }
                _insertView(t, e, i, n) {
                    const s = this._insertViewFromCache(e, i);
                    if (s) return void(s.context.$implicit = n);
                    const r = t();
                    return i.createEmbeddedView(r.templateRef, r.context, r.index)
                }
                _detachAndCacheView(t, e) {
                    const i = e.detach(t);
                    this._maybeCacheView(i, e)
                }
                _moveView(t, e, i, n) {
                    const s = i.get(t);
                    return i.move(s, e), s.context.$implicit = n, s
                }
                _maybeCacheView(t, e) {
                    if (this._viewCache.length < this.viewCacheSize) this._viewCache.push(t);
                    else {
                        const i = e.indexOf(t); - 1 === i ? t.destroy() : e.remove(i)
                    }
                }
                _insertViewFromCache(t, e) {
                    const i = this._viewCache.pop();
                    return i && e.insert(i, t), i || null
                }
            }
            class d {
                constructor(t = !1, e, i = !0) {
                    this._multiple = t, this._emitChanges = i, this._selection = new Set, this._deselectedToEmit = [], this._selectedToEmit = [], this.changed = new r.a, e && e.length && (t ? e.forEach(t => this._markSelected(t)) : this._markSelected(e[0]), this._selectedToEmit.length = 0)
                }
                get selected() {
                    return this._selected || (this._selected = Array.from(this._selection.values())), this._selected
                }
                select(...t) {
                    this._verifyValueAssignment(t), t.forEach(t => this._markSelected(t)), this._emitChangeEvent()
                }
                deselect(...t) {
                    this._verifyValueAssignment(t), t.forEach(t => this._unmarkSelected(t)), this._emitChangeEvent()
                }
                toggle(t) {
                    this.isSelected(t) ? this.deselect(t) : this.select(t)
                }
                clear() {
                    this._unmarkAll(), this._emitChangeEvent()
                }
                isSelected(t) {
                    return this._selection.has(t)
                }
                isEmpty() {
                    return 0 === this._selection.size
                }
                hasValue() {
                    return !this.isEmpty()
                }
                sort(t) {
                    this._multiple && this.selected && this._selected.sort(t)
                }
                isMultipleSelection() {
                    return this._multiple
                }
                _emitChangeEvent() {
                    this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({
                        source: this,
                        added: this._selectedToEmit,
                        removed: this._deselectedToEmit
                    }), this._deselectedToEmit = [], this._selectedToEmit = [])
                }
                _markSelected(t) {
                    this.isSelected(t) || (this._multiple || this._unmarkAll(), this._selection.add(t), this._emitChanges && this._selectedToEmit.push(t))
                }
                _unmarkSelected(t) {
                    this.isSelected(t) && (this._selection.delete(t), this._emitChanges && this._deselectedToEmit.push(t))
                }
                _unmarkAll() {
                    this.isEmpty() || this._selection.forEach(t => this._unmarkSelected(t))
                }
                _verifyValueAssignment(t) {}
            }
            const p = new a.s("_ViewRepeater")
        },
        "0MCZ": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return I
            });
            var n = i("fXoL"),
                s = i("0MNC"),
                r = i("v/4h"),
                a = i("foWl"),
                o = i("tyNb"),
                l = i("/t3+"),
                c = i("bTqV"),
                h = i("ofXK"),
                u = i("NFeN");

            function d(t, e) {
                1 & t && n.Qb(0, "input", 3)
            }
            const p = function(t) {
                    return {
                        "show-search-input": t
                    }
                },
                f = function(t) {
                    return {
                        "open-search": t
                    }
                };
            let g = (() => {
                class t {
                    constructor() {
                        this.isShowInput = !1
                    }
                    showInput() {
                        this.isShowInput = !0
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-search"]
                    ],
                    decls: 4,
                    vars: 7,
                    consts: [
                        [1, "search", 3, "ngClass", "click"],
                        [1, "search-icon", 3, "ngClass"],
                        ["class", "search-input", "placeholder", "Search...", 4, "ngIf"],
                        ["placeholder", "Search...", 1, "search-input"]
                    ],
                    template: function(t, e) {
                        1 & t && (n.Vb(0, "div", 0), n.cc("click", function() {
                            return e.showInput()
                        }), n.Vb(1, "mat-icon", 1), n.Cc(2, "search"), n.Ub(), n.Bc(3, d, 1, 0, "input", 2), n.Ub()), 2 & t && (n.lc("ngClass", n.oc(3, p, e.isShowInput)), n.Db(1), n.lc("ngClass", n.oc(5, f, e.isShowInput)), n.Db(2), n.lc("ngIf", e.isShowInput))
                    },
                    directives: [h.j, u.a, h.l],
                    styles: [".search[_ngcontent-%COMP%]{display:flex;height:36px;border-radius:32px;box-sizing:border-box;align-items:center;width:36px;padding-left:4px;cursor:pointer;flex-direction:row-reverse}.search[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}@media (max-width:576px){.search[_ngcontent-%COMP%]{display:none}}.show-search-input[_ngcontent-%COMP%]{-webkit-animation:open_search .3s;animation:open_search .3s;width:250px;padding-left:22.4px;background-color:rgba(0,0,0,.08)}.search-input[_ngcontent-%COMP%]{color:#fff;font-family:Roboto,Helvetica,Arial,sans-serif;line-height:19px;font-size:14px;background-color:transparent;border:none;outline:none;height:36px;width:100%}.search-input[_ngcontent-%COMP%]::-webkit-input-placeholder{color:hsla(0,0%,100%,.35)}.search-icon[_ngcontent-%COMP%]{padding:0 7px 3px 0;color:hsla(0,0%,100%,.35)}.open-search[_ngcontent-%COMP%]{-webkit-animation:move_search-icon .3s;animation:move_search-icon .3s;padding-right:16px;padding-left:4px}@-webkit-keyframes open_search{0%{width:36px}to{width:250px}}@keyframes open_search{0%{width:36px}to{width:250px}}@-webkit-keyframes open_search_large{0%{width:36px}to{width:150px}}@keyframes open_search_large{0%{width:36px}to{width:150px}}@-webkit-keyframes move_search-icon{0%{padding:0 7px 3px 0}to{padding-right:16px}}@keyframes move_search-icon{0%{padding:0 7px 3px 0}to{padding-right:16px}}"]
                }), t
            })();
            var m = i("STbY"),
                b = i("TU8p");
            let y = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["app-notifications"]
                        ],
                        decls: 21,
                        vars: 1,
                        consts: [
                            ["mat-mini-fab", "", 1, "notification-button", 3, "matMenuTriggerFor"],
                            ["matBadge", "4", "matBadgeColor", "warn", 1, "notification-button__icon"],
                            ["xPosition", "before", 1, "notification-menu"],
                            ["bell", "matMenu"],
                            ["mat-menu-item", "", 1, "notification-menu__button"],
                            [1, "notification-menu__icon_yellow"],
                            [1, "notification-menu__icon_green"],
                            [1, "notification-menu__icon_pink"],
                            [1, "notification-menu__icon_blue"]
                        ],
                        template: function(t, e) {
                            if (1 & t && (n.Vb(0, "button", 0), n.Vb(1, "mat-icon", 1), n.Cc(2, "notifications_none"), n.Ub(), n.Ub(), n.Vb(3, "mat-menu", 2, 3), n.Vb(5, "button", 4), n.Vb(6, "mat-icon", 5), n.Cc(7, "local_offer"), n.Ub(), n.Cc(8, "Check out this awesome ticket "), n.Ub(), n.Vb(9, "button", 4), n.Vb(10, "mat-icon", 6), n.Cc(11, "thumb_up"), n.Ub(), n.Cc(12, "What is the best way to get ... "), n.Ub(), n.Vb(13, "button", 4), n.Vb(14, "mat-icon", 7), n.Cc(15, "notifications_none"), n.Ub(), n.Cc(16, "This is just a simple notification "), n.Ub(), n.Vb(17, "button", 4), n.Vb(18, "mat-icon", 8), n.Cc(19, "local_grocery_store"), n.Ub(), n.Cc(20, "12 new orders has arrived today "), n.Ub(), n.Ub()), 2 & t) {
                                const t = n.sc(4);
                                n.lc("matMenuTriggerFor", t)
                            }
                        },
                        directives: [c.b, m.d, u.a, b.a, m.a, m.b],
                        styles: [".notification-button[_ngcontent-%COMP%]{background-color:#536dfe;box-shadow:none;margin-left:16px}.notification-button__icon[_ngcontent-%COMP%]{color:hsla(0,0%,100%,.35)}.notification-button[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}@media (max-width:576px){.notification-button[_ngcontent-%COMP%]{margin-top:0}}.notification-menu__button[_ngcontent-%COMP%]:hover{background-color:#f3f5ff}.notification-menu__icon_yellow[_ngcontent-%COMP%]{color:#ffc260}.notification-menu__icon_green[_ngcontent-%COMP%]{color:#3cd4a0}.notification-menu__icon_pink[_ngcontent-%COMP%]{color:#ff4081}.notification-menu__icon_blue[_ngcontent-%COMP%]{color:#536dfe}"]
                    }), t
                })(),
                v = (() => {
                    class t {
                        transform(t) {
                            const e = t.search("\\s");
                            return "" + t[0].toUpperCase() + t[e + 1].toUpperCase()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275pipe = n.Ob({
                        name: "shortName",
                        type: t,
                        pure: !0
                    }), t
                })();

            function x(t, e) {
                if (1 & t && (n.Vb(0, "div", 11), n.Vb(1, "div", 12), n.Vb(2, "button", 13), n.Cc(3), n.hc(4, "shortName"), n.Ub(), n.Vb(5, "span", 14), n.Cc(6), n.Ub(), n.Ub(), n.Vb(7, "div", 15), n.Vb(8, "span", 16), n.Cc(9), n.Ub(), n.Vb(10, "span", 17), n.Cc(11), n.Ub(), n.Ub(), n.Ub()), 2 & t) {
                    const t = e.$implicit,
                        i = e.index,
                        s = n.gc();
                    n.Db(2), n.lc("ngClass", s.colors[i]), n.Db(1), n.Dc(n.ic(4, 5, t.name)), n.Db(3), n.Dc(t.time), n.Db(3), n.Dc(t.name), n.Db(2), n.Dc(t.message)
                }
            }
            let _ = (() => {
                    class t {
                        constructor() {
                            this.colors = ["yellow", "green", "blue", "ping"]
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["app-email"]
                        ],
                        inputs: {
                            emails: "emails"
                        },
                        decls: 16,
                        vars: 3,
                        consts: [
                            ["mat-mini-fab", "", 1, "email-button", 3, "matMenuTriggerFor"],
                            ["matBadge", "4", "matBadgeColor", "accent", 1, "email-button__icon"],
                            ["xPosition", "before"],
                            ["email", "matMenu"],
                            [1, "email-menu-header"],
                            [1, "email-menu-header__title"],
                            [1, "email-menu-header__subtitle"],
                            ["class", "mail-wrapper", 4, "ngFor", "ngForOf"],
                            [1, "send-message-button-wrapper"],
                            ["mat-fab", "", 1, "send-message-button"],
                            [1, "send-message-button__icon"],
                            [1, "mail-wrapper"],
                            [1, "mail-wrapper__icon-wrapper"],
                            ["mat-mini-fab", "", 1, "mail-wrapper__icon", 3, "ngClass"],
                            [1, "mail-wrapper__time"],
                            [1, "mail-content"],
                            [1, "mail-content__user"],
                            [1, "mail-content__message"]
                        ],
                        template: function(t, e) {
                            if (1 & t && (n.Vb(0, "button", 0), n.Vb(1, "mat-icon", 1), n.Cc(2, "mail_outline"), n.Ub(), n.Ub(), n.Vb(3, "mat-menu", 2, 3), n.Vb(5, "div", 4), n.Vb(6, "h4", 5), n.Cc(7, "New Messages"), n.Ub(), n.Vb(8, "p", 6), n.Cc(9), n.Ub(), n.Ub(), n.Bc(10, x, 12, 7, "div", 7), n.Vb(11, "div", 8), n.Vb(12, "button", 9), n.Cc(13, " Send New Message "), n.Vb(14, "mat-icon", 10), n.Cc(15, "send"), n.Ub(), n.Ub(), n.Ub(), n.Ub()), 2 & t) {
                                const t = n.sc(4);
                                n.lc("matMenuTriggerFor", t), n.Db(9), n.Ec("", e.emails.length, " New Messages"), n.Db(1), n.lc("ngForOf", e.emails)
                            }
                        },
                        directives: [c.b, m.d, u.a, b.a, m.a, h.k, h.j],
                        pipes: [v],
                        styles: [".email-button[_ngcontent-%COMP%]{background-color:#536dfe;box-shadow:none;margin-left:16px}.email-button__icon[_ngcontent-%COMP%]{color:hsla(0,0%,100%,.35)}.email-button[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}@media (max-width:576px){.email-button[_ngcontent-%COMP%]{margin-top:0}}.email-menu-header[_ngcontent-%COMP%]{padding:16px 16px 0}.email-menu-header__title[_ngcontent-%COMP%]{margin:0;font-weight:400;font-size:24px;color:#4a4a4a}.email-menu-header__subtitle[_ngcontent-%COMP%]{color:#ff4081;font-weight:400;font-size:14px;margin:4px 0 16px}.mail-wrapper[_ngcontent-%COMP%]{cursor:pointer;display:flex;padding:6px 16px}.mail-wrapper[_ngcontent-%COMP%]:hover{background-color:#f3f5ff}.mail-wrapper__icon-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column}.mail-wrapper__icon[_ngcontent-%COMP%]{font-weight:400;font-size:14px;color:#fff;display:flex;align-items:center;justify-content:center;box-shadow:none;width:30px;height:30px}.mail-wrapper__time[_ngcontent-%COMP%]{text-align:center;color:#6e6e6e;font-weight:400;font-size:11.2px}.mail-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;overflow:hidden;padding-left:16px;justify-content:space-between}.mail-content__user[_ngcontent-%COMP%]{margin-top:3px;font-weight:500;font-size:14px;color:#4a4a4a}.mail-content__message[_ngcontent-%COMP%]{color:#6e6e6e;font-weight:14px;font-size:14px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.send-message-button-wrapper[_ngcontent-%COMP%]{margin:16px 0;text-align:center;padding:0 16px}.send-message-button[_ngcontent-%COMP%]{width:224px;height:48px;padding:0 16px;border-radius:32px;color:#fff;background-color:#536dfe}.send-message-button[_ngcontent-%COMP%]   .mat-button-wrapper[_ngcontent-%COMP%]{padding:0}.send-message-button__icon[_ngcontent-%COMP%]{color:#fff;margin-left:16px}.yellow[_ngcontent-%COMP%]{background-color:#ffc260}.green[_ngcontent-%COMP%]{background-color:#3cd4a0}.blue[_ngcontent-%COMP%]{background-color:#536dfe}.ping[_ngcontent-%COMP%]{background-color:#ff4081}"]
                    }), t
                })(),
                w = (() => {
                    class t {
                        constructor() {
                            this.signOut = new n.o, this.routes = r.b, this.flatlogicEmail = "https://flatlogic.com"
                        }
                        signOutEmit() {
                            this.signOut.emit()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["app-user"]
                        ],
                        inputs: {
                            user: "user"
                        },
                        outputs: {
                            signOut: "signOut"
                        },
                        decls: 25,
                        vars: 4,
                        consts: [
                            ["mat-mini-fab", "", 1, "user-button", 3, "matMenuTriggerFor"],
                            [1, "user-button__icon"],
                            ["xPosition", "before"],
                            ["userMenu", "matMenu"],
                            [1, "user-menu-title"],
                            [1, "user-menu-title__name"],
                            [1, "user-menu-title__link", 3, "href"],
                            ["mat-menu-item", "", 1, "user-menu__item-title"],
                            [1, "user-menu-icon"],
                            [1, "sign-button-wrapper"],
                            ["mat-flat-button", "", 1, "sign-button", 3, "click"]
                        ],
                        template: function(t, e) {
                            if (1 & t && (n.Vb(0, "button", 0), n.Vb(1, "mat-icon", 1), n.Cc(2, "person"), n.Ub(), n.Ub(), n.Vb(3, "mat-menu", 2, 3), n.Vb(5, "div", 4), n.Vb(6, "h4", 5), n.Cc(7), n.Ub(), n.Vb(8, "a", 6), n.Cc(9, "Flatlogic.com"), n.Ub(), n.Ub(), n.Vb(10, "button", 7), n.Vb(11, "mat-icon", 8), n.Cc(12, "person"), n.Ub(), n.Cc(13, "Profile "), n.Ub(), n.Vb(14, "button", 7), n.Vb(15, "mat-icon", 8), n.Cc(16, "description"), n.Ub(), n.Cc(17, "Tasks "), n.Ub(), n.Vb(18, "button", 7), n.Vb(19, "mat-icon", 8), n.Cc(20, "email"), n.Ub(), n.Cc(21, "Messages "), n.Ub(), n.Vb(22, "div", 9), n.Vb(23, "button", 10), n.cc("click", function() {
                                    return e.signOutEmit()
                                }), n.Cc(24, "Sign out"), n.Ub(), n.Ub(), n.Ub()), 2 & t) {
                                const t = n.sc(4);
                                n.lc("matMenuTriggerFor", t), n.Db(7), n.Fc("", e.user.name, " ", e.user.lastName, ""), n.Db(1), n.lc("href", e.flatlogicEmail, n.wc)
                            }
                        },
                        directives: [c.b, m.d, u.a, m.a, m.b],
                        styles: [".user-button[_ngcontent-%COMP%]{background-color:#536dfe;box-shadow:none;margin-left:16px}.user-button__icon[_ngcontent-%COMP%]{color:hsla(0,0%,100%,.35)}.user-button[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}@media (max-width:576px){.user-button[_ngcontent-%COMP%]{margin-top:0}}.user-menu-title[_ngcontent-%COMP%]{padding:16px 48px 0 16px;margin-bottom:4px}.user-menu-title__name[_ngcontent-%COMP%]{margin-bottom:4px;font-weight:400;font-size:24px;color:#4a4a4a}.user-menu-title__link[_ngcontent-%COMP%]{color:#536dfe;font-weight:400;font-size:14px;text-decoration:none}.user-menu-icon[_ngcontent-%COMP%]{color:#b9b9b9;margin-right:16px;opacity:.8}.sign-button-wrapper[_ngcontent-%COMP%]{text-align:center;padding:8px 0 16px;width:100%}.sign-button[_ngcontent-%COMP%]{border:1px solid;color:#536dfe;width:80%}.user-menu__item-title[_ngcontent-%COMP%]{color:#b9b9b9}.user-menu__item-title[_ngcontent-%COMP%]:hover{color:#4a4a4a;background-color:#f3f5ff}.user-menu__item-title[_ngcontent-%COMP%]:hover   .user-menu-icon[_ngcontent-%COMP%]{color:#536dfe}"]
                    }), t
                })();

            function C(t, e) {
                1 & t && (n.Vb(0, "mat-icon", 9), n.Cc(1, "menu"), n.Ub())
            }

            function k(t, e) {
                1 & t && (n.Vb(0, "mat-icon", 9), n.Cc(1, "arrow_back"), n.Ub())
            }
            let S = (() => {
                class t {
                    constructor(t, e, i) {
                        this.userService = t, this.emailService = e, this.router = i, this.isShowSidebar = new n.o, this.routers = r.b, this.user$ = this.userService.getUser(), this.emails$ = this.emailService.loadEmails()
                    }
                    openMenu() {
                        this.isMenuOpened = !this.isMenuOpened, this.isShowSidebar.emit(this.isMenuOpened)
                    }
                    signOut() {
                        this.userService.signOut(), this.router.navigate([this.routers.LOGIN])
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(a.a), n.Pb(a.b), n.Pb(o.b))
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-header"]
                    ],
                    inputs: {
                        isMenuOpened: "isMenuOpened"
                    },
                    outputs: {
                        isShowSidebar: "isShowSidebar"
                    },
                    decls: 16,
                    vars: 8,
                    consts: [
                        [1, "header"],
                        [1, "header__title"],
                        ["mat-mini-fab", "", 1, "header__title-button", 3, "click"],
                        ["class", "header__title-button-icon", 4, "ngIf"],
                        [1, "header__title-text"],
                        [1, "header-toolbar"],
                        ["mat-flat-button", "", "href", "https://flatlogic.com/templates/angular-material-admin-full/demo", "target", "_blank", 1, "unlock-button"],
                        [3, "emails"],
                        [3, "user", "signOut"],
                        [1, "header__title-button-icon"]
                    ],
                    template: function(t, e) {
                        1 & t && (n.Vb(0, "mat-toolbar", 0), n.Vb(1, "div", 1), n.Vb(2, "button", 2), n.cc("click", function() {
                            return e.openMenu()
                        }), n.Bc(3, C, 2, 0, "mat-icon", 3), n.Bc(4, k, 2, 0, "mat-icon", 3), n.Ub(), n.Vb(5, "h6", 4), n.Cc(6, "Angular Material Admin"), n.Ub(), n.Ub(), n.Vb(7, "div", 5), n.Vb(8, "a", 6), n.Cc(9, "Unlock Full Version"), n.Ub(), n.Qb(10, "app-search"), n.Qb(11, "app-notifications"), n.Qb(12, "app-email", 7), n.hc(13, "async"), n.Vb(14, "app-user", 8), n.cc("signOut", function() {
                            return e.signOut()
                        }), n.hc(15, "async"), n.Ub(), n.Ub(), n.Ub()), 2 & t && (n.Db(3), n.lc("ngIf", !e.isMenuOpened), n.Db(1), n.lc("ngIf", e.isMenuOpened), n.Db(8), n.lc("emails", n.ic(13, 4, e.emails$)), n.Db(2), n.lc("user", n.ic(15, 6, e.user$)))
                    },
                    directives: [l.a, c.b, h.l, c.a, g, y, _, w, u.a],
                    pipes: [h.b],
                    styles: [".header[_ngcontent-%COMP%]{background-color:#536dfe;display:flex;justify-content:space-between;position:fixed;z-index:2;height:64px}.header__title[_ngcontent-%COMP%]{display:flex;align-items:center}.header__title-button[_ngcontent-%COMP%]{background-color:#536dfe;box-shadow:none}.header__title-button[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}@media (max-width:576px){.header__title-button[_ngcontent-%COMP%]{margin-top:0}}.header__title-button-icon[_ngcontent-%COMP%]{color:#fff}.header__title-text[_ngcontent-%COMP%]{color:#fff;margin-left:32px;font-weight:400}@media (max-width:576px){.header__title-text[_ngcontent-%COMP%]{display:none}}.header-toolbar[_ngcontent-%COMP%]{display:flex;align-items:center}.header-toolbar[_ngcontent-%COMP%]   .unlock-button[_ngcontent-%COMP%]{border-color:#3cd4a0;margin-right:16px;text-transform:uppercase;background-color:#3cd4a0;color:#fff;letter-spacing:.0892857143em}@media (max-width:576px){.header-toolbar[_ngcontent-%COMP%]   .unlock-button[_ngcontent-%COMP%]{display:none}}"]
                }), t
            })();
            var A = i("XhcP"),
                O = i("UtzL"),
                E = i("MutI");
            let P = (() => {
                class t {
                    constructor() {
                        this.routes = O.a, this.isOpenUiElements = !1
                    }
                    openUiElements() {
                        this.isOpenUiElements = !this.isOpenUiElements
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-sidebar"]
                    ],
                    decls: 61,
                    vars: 7,
                    consts: [
                        ["routerLinkActive", "active", 3, "routerLink"],
                        [3, "click"],
                        ["routerLinkActive", "active", 1, "ui-element", 3, "routerLink"],
                        [1, "circle"],
                        [1, "sidebar-title"],
                        ["href", "https://flatlogic.com/templates", "target", "_blank", 2, "text-decoration", "none"],
                        ["href", "https://flatlogic.com/forum/", "target", "_blank", 2, "text-decoration", "none"],
                        ["href", "https://flatlogic.com/forum", "target", "_blank", 2, "text-decoration", "none"],
                        [1, "project-circle", "project-circle_yellow"],
                        [1, "project-circle", "project-circle_blue"],
                        [1, "project-circle", "project-circle_pink"]
                    ],
                    template: function(t, e) {
                        1 & t && (n.Vb(0, "mat-list"), n.Vb(1, "mat-list-item", 0), n.Vb(2, "mat-icon"), n.Cc(3, "home"), n.Ub(), n.Cc(4, " Dashboard "), n.Ub(), n.Vb(5, "mat-list-item", 0), n.Vb(6, "mat-icon"), n.Cc(7, "text_fields"), n.Ub(), n.Cc(8, " Typography "), n.Ub(), n.Vb(9, "mat-list-item", 0), n.Vb(10, "mat-icon"), n.Cc(11, "border_all"), n.Ub(), n.Cc(12, " Tables "), n.Ub(), n.Vb(13, "mat-list-item", 0), n.Vb(14, "mat-icon"), n.Cc(15, "notifications_none"), n.Ub(), n.Cc(16, " Notification "), n.Ub(), n.Vb(17, "mat-list-item", 1), n.cc("click", function() {
                            return e.openUiElements()
                        }), n.Vb(18, "mat-icon"), n.Cc(19, "filter_none"), n.Ub(), n.Cc(20, " UI Elements "), n.Ub(), n.Vb(21, "div"), n.Vb(22, "mat-list-item", 2), n.Qb(23, "div", 3), n.Cc(24, "Icons "), n.Ub(), n.Vb(25, "mat-list-item", 2), n.Qb(26, "div", 3), n.Cc(27, "Charts "), n.Ub(), n.Vb(28, "mat-list-item", 2), n.Qb(29, "div", 3), n.Cc(30, "Map "), n.Ub(), n.Ub(), n.Ub(), n.Vb(31, "p", 4), n.Cc(32, "Help"), n.Ub(), n.Vb(33, "mat-list"), n.Vb(34, "a", 5), n.Vb(35, "mat-list-item"), n.Vb(36, "mat-icon"), n.Cc(37, "library_books"), n.Ub(), n.Cc(38, " Library "), n.Ub(), n.Ub(), n.Vb(39, "a", 6), n.Vb(40, "mat-list-item"), n.Vb(41, "mat-icon"), n.Cc(42, "question_answer"), n.Ub(), n.Cc(43, " Support "), n.Ub(), n.Ub(), n.Vb(44, "a", 7), n.Vb(45, "mat-list-item"), n.Vb(46, "mat-icon"), n.Cc(47, "help_outline"), n.Ub(), n.Cc(48, " FAQ "), n.Ub(), n.Ub(), n.Ub(), n.Vb(49, "p", 4), n.Cc(50, "Projects"), n.Ub(), n.Vb(51, "mat-list"), n.Vb(52, "mat-list-item"), n.Qb(53, "div", 8), n.Cc(54, " My resend "), n.Ub(), n.Vb(55, "mat-list-item"), n.Qb(56, "div", 9), n.Cc(57, " Starred"), n.Ub(), n.Vb(58, "mat-list-item"), n.Qb(59, "div", 10), n.Cc(60, " Background "), n.Ub(), n.Ub()), 2 & t && (n.Db(1), n.mc("routerLink", e.routes.DASHBOARD), n.Db(4), n.mc("routerLink", e.routes.TYPOGRAPHY), n.Db(4), n.mc("routerLink", e.routes.TABLES), n.Db(4), n.mc("routerLink", e.routes.NOTIFICATION), n.Db(9), n.mc("routerLink", e.routes.UI_ELEMENTS_ICONS), n.Db(3), n.mc("routerLink", e.routes.UI_ELEMENTS_CHARTS), n.Db(3), n.mc("routerLink", e.routes.UI_ELEMENTS_MAP))
                    },
                    directives: [E.a, E.b, o.d, o.c, u.a],
                    styles: [".mat-list-base[_ngcontent-%COMP%]{border-bottom:1px solid hsla(0,0%,84.7%,.5019607843137255);width:210px;padding-bottom:16px}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item[_ngcontent-%COMP%]{display:flex;cursor:pointer;color:hsla(0,0%,43.1%,.8);width:auto;padding-left:4px}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item.active[_ngcontent-%COMP%]{color:#4a4a4a;background-color:#f3f5ff;outline:none}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item.active[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{color:#536dfe}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item.active[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]{background-color:#536dfe}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item[_ngcontent-%COMP%]:hover{background-color:#f3f5ff}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item[_ngcontent-%COMP%]:focus{outline:none}.mat-icon[_ngcontent-%COMP%]{margin-right:15px;color:hsla(0,0%,43.1%,.6)}.sidebar-title[_ngcontent-%COMP%]{color:hsla(0,0%,43.1%,.8);font-size:16px;text-transform:uppercase;margin-top:32px;margin-left:24px;margin-bottom:16px}.mat-list-base[_ngcontent-%COMP%]   .mat-list-item.ui-element[_ngcontent-%COMP%]{padding-left:40px}.circle[_ngcontent-%COMP%]{width:5px;height:5px;border-radius:50%;background-color:#b9b9b9;margin-right:30px}.project-circle[_ngcontent-%COMP%]{width:8px;height:8px;border-radius:50%;margin-right:15px;margin-left:8px}.project-circle_yellow[_ngcontent-%COMP%]{background-color:#ffc260}.project-circle_blue[_ngcontent-%COMP%]{background-color:#536dfe}.project-circle_pink[_ngcontent-%COMP%]{background-color:#ff4081}"]
                }), t
            })();
            const T = ["sidenav"],
                D = ["*"];
            let I = (() => {
                class t {
                    constructor(t, e) {
                        this.mobileQuery = e.matchMedia("(max-width: 1024px)"), this.mobileQueryListener = () => t.detectChanges(), this.mobileQuery.addListener(this.mobileQueryListener), this.isShowSidebar = !this.mobileQuery.matches
                    }
                    ngOnDestroy() {
                        this.mobileQuery.removeListener(this.mobileQueryListener), this.sidenav.close()
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(n.h), n.Pb(s.c))
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-layout"]
                    ],
                    viewQuery: function(t, e) {
                        if (1 & t && n.Hc(T, 1), 2 & t) {
                            let t;
                            n.rc(t = n.dc()) && (e.sidenav = t.first)
                        }
                    },
                    ngContentSelectors: D,
                    decls: 7,
                    vars: 4,
                    consts: [
                        [3, "isMenuOpened", "isShowSidebar"],
                        [1, "layout"],
                        ["mode", "side", 1, "layout-sidebar", 3, "opened", "mode", "fixedInViewport", "openedChange"],
                        ["sidenav", ""],
                        [1, "layout-content"]
                    ],
                    template: function(t, e) {
                        if (1 & t) {
                            const t = n.Wb();
                            n.kc(), n.Vb(0, "app-header", 0), n.cc("isShowSidebar", function(e) {
                                return n.uc(t), n.sc(3).toggle(e)
                            }), n.Ub(), n.Vb(1, "mat-sidenav-container", 1), n.Vb(2, "mat-sidenav", 2, 3), n.cc("openedChange", function(t) {
                                return e.isShowSidebar = t
                            }), n.Qb(4, "app-sidebar"), n.Ub(), n.Vb(5, "mat-sidenav-content", 4), n.jc(6), n.Ub(), n.Ub()
                        }
                        2 & t && (n.lc("isMenuOpened", e.isShowSidebar), n.Db(2), n.lc("opened", e.isShowSidebar)("mode", e.mobileQuery.matches ? "over" : "side")("fixedInViewport", e.mobileQuery.matches))
                    },
                    directives: [S, A.b, A.a, P, A.c],
                    styles: [".layout[_ngcontent-%COMP%]{width:100%}.layout-sidebar[_ngcontent-%COMP%]{height:calc(100vh - 64px);margin-top:64px}@media (max-width:576px){.layout-sidebar[_ngcontent-%COMP%]{width:218px}}.layout-content[_ngcontent-%COMP%]{background-color:#f6f7ff;height:calc(100vh - 64px);margin-top:64px}@media (max-width:576px){.layout-content[_ngcontent-%COMP%]{width:100%}}"]
                }), t
            })()
        },
        "0MNC": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return x
            }), i.d(e, "b", function() {
                return w
            }), i.d(e, "c", function() {
                return y
            });
            var n = i("fXoL"),
                s = i("8LU1"),
                r = i("oXA7"),
                a = i("mASl"),
                o = i("g+Sw"),
                l = i("SIQg"),
                c = i("nnEh"),
                h = i("r9Bt"),
                u = i("sj3c"),
                d = i("rdQv"),
                p = i("zzs5"),
                f = i("bk9D"),
                g = i("nLfN");
            const m = new Set;
            let b, y = (() => {
                class t {
                    constructor(t) {
                        this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : v
                    }
                    matchMedia(t) {
                        return this._platform.WEBKIT && function(t) {
                            if (!m.has(t)) try {
                                b || (b = document.createElement("style"), b.setAttribute("type", "text/css"), document.head.appendChild(b)), b.sheet && (b.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), m.add(t))
                            } catch (e) {
                                console.error(e)
                            }
                        }(t), this._matchMedia(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(g.a))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: function() {
                        return new t(Object(n.Zb)(g.a))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function v(t) {
                return {
                    matches: "all" === t || "" === t,
                    media: t,
                    addListener: () => {},
                    removeListener: () => {}
                }
            }
            let x = (() => {
                class t {
                    constructor(t, e) {
                        this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new r.a
                    }
                    ngOnDestroy() {
                        this._destroySubject.next(), this._destroySubject.complete()
                    }
                    isMatched(t) {
                        return _(Object(s.b)(t)).some(t => this._registerQuery(t).mql.matches)
                    }
                    observe(t) {
                        const e = _(Object(s.b)(t)).map(t => this._registerQuery(t).observable);
                        let i = Object(a.a)(e);
                        return i = Object(o.a)(i.pipe(Object(c.a)(1)), i.pipe(Object(h.a)(1), Object(u.a)(0))), i.pipe(Object(d.a)(t => {
                            const e = {
                                matches: !1,
                                breakpoints: {}
                            };
                            return t.forEach(({
                                matches: t,
                                query: i
                            }) => {
                                e.matches = e.matches || t, e.breakpoints[i] = t
                            }), e
                        }))
                    }
                    _registerQuery(t) {
                        if (this._queries.has(t)) return this._queries.get(t);
                        const e = this._mediaMatcher.matchMedia(t),
                            i = {
                                observable: new l.a(t => {
                                    const i = e => this._zone.run(() => t.next(e));
                                    return e.addListener(i), () => {
                                        e.removeListener(i)
                                    }
                                }).pipe(Object(p.a)(e), Object(d.a)(({
                                    matches: e
                                }) => ({
                                    query: t,
                                    matches: e
                                })), Object(f.a)(this._destroySubject)),
                                mql: e
                            };
                        return this._queries.set(t, i), i
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(y), n.Zb(n.B))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: function() {
                        return new t(Object(n.Zb)(y), Object(n.Zb)(n.B))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function _(t) {
                return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim())
            }
            const w = {
                XSmall: "(max-width: 599.98px)",
                Small: "(min-width: 600px) and (max-width: 959.98px)",
                Medium: "(min-width: 960px) and (max-width: 1279.98px)",
                Large: "(min-width: 1280px) and (max-width: 1919.98px)",
                XLarge: "(min-width: 1920px)",
                Handset: "(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)",
                Tablet: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
                Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)",
                HandsetPortrait: "(max-width: 599.98px) and (orientation: portrait)",
                TabletPortrait: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)",
                WebPortrait: "(min-width: 840px) and (orientation: portrait)",
                HandsetLandscape: "(max-width: 959.98px) and (orientation: landscape)",
                TabletLandscape: "(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
                WebLandscape: "(min-width: 1280px) and (orientation: landscape)"
            }
        },
        "0fNd": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("v/4h"),
                s = i("fXoL"),
                r = i("tyNb");
            let a = (() => {
                class t {
                    constructor(t) {
                        this.router = t, this.routers = n.b
                    }
                    canActivate(t, e) {
                        if (localStorage.getItem("token")) return !0;
                        this.router.navigate([this.routers.LOGIN])
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(r.b))
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })()
        },
        "1M4b": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            });
            var n = i("rdQv"),
                s = i("g/MW"),
                r = i("EPzc"),
                a = i("xt23"),
                o = i("2QHy");

            function l(t, e, i = 1 / 0) {
                return Object(o.a)(e) ? l((i, r) => Object(n.a)((t, n) => e(i, t, r, n))(Object(s.c)(t(i, r))), i) : ("number" == typeof e && (i = e), Object(r.b)((e, n) => function(t, e, i, n, r, o, l, c) {
                    const h = [];
                    let u = 0,
                        d = 0,
                        p = !1;
                    const f = () => {
                            !p || h.length || u || e.complete()
                        },
                        g = t => {
                            u++;
                            let r = !1;
                            Object(s.c)(i(t, d++)).subscribe(new a.a(e, t => {
                                e.next(t)
                            }, () => {
                                r = !0
                            }, void 0, () => {
                                if (r) try {
                                    for (u--; h.length && u < n;) {
                                        const t = h.shift();
                                        g(t)
                                    }
                                    f()
                                } catch (t) {
                                    e.error(t)
                                }
                            }))
                        };
                    return t.subscribe(new a.a(e, t => u < n ? g(t) : h.push(t), () => {
                        p = !0, f()
                    })), () => {}
                }(e, n, t, i)))
            }
        },
        "1lu8": function(t, e, i) {
            "use strict";
            i.d(e, "b", function() {
                return a
            }), i.d(e, "c", function() {
                return o
            }), i.d(e, "a", function() {
                return l
            });
            var n = i("2QHy"),
                s = i("XwfS");

            function r(t) {
                return t[t.length - 1]
            }

            function a(t) {
                return Object(n.a)(r(t)) ? t.pop() : void 0
            }

            function o(t) {
                return Object(s.a)(r(t)) ? t.pop() : void 0
            }

            function l(t, e) {
                return "number" == typeof r(t) ? t.pop() : e
            }
        },
        "1q39": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("g/MW"),
                s = i("EPzc"),
                r = i("xt23");

            function a(t, e) {
                return Object(s.b)((i, s) => {
                    let a = null,
                        o = 0,
                        l = !1;
                    const c = () => l && !a && s.complete();
                    i.subscribe(new r.a(s, i => {
                        null == a || a.unsubscribe();
                        let l = 0;
                        const h = o++;
                        Object(n.c)(t(i, h)).subscribe(a = new r.a(s, t => s.next(e ? e(i, t, h, l++) : t), () => {
                            a = null, c()
                        }))
                    }, () => {
                        l = !0, c()
                    }))
                })
            }
        },
        "2QHy": function(t, e, i) {
            "use strict";

            function n(t) {
                return "function" == typeof t
            }
            i.d(e, "a", function() {
                return n
            })
        },
        "2btn": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            });
            var n = i("tmVS"),
                s = i("vfWG"),
                r = i("g/MW"),
                a = i("eX4W"),
                o = i("1lu8");

            function l(...t) {
                const e = Object(o.c)(t),
                    i = Object(o.a)(t, 1 / 0),
                    l = t;
                return l.length ? 1 === l.length ? Object(r.c)(l[0]) : Object(n.a)(i)(Object(s.a)(l, e)) : a.a
            }
        },
        "2nZi": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return p
            });
            var n = i("Tk8M");
            let s, r = 1;
            const a = {};

            function o(t) {
                return t in a && (delete a[t], !0)
            }
            const l = {
                    setImmediate(t) {
                        const e = r++;
                        return a[e] = !0, s || (s = Promise.resolve()), s.then(() => o(e) && t()), e
                    },
                    clearImmediate(t) {
                        o(t)
                    }
                },
                {
                    setImmediate: c,
                    clearImmediate: h
                } = l,
                u = {
                    setImmediate(...t) {
                        const {
                            delegate: e
                        } = u;
                        return ((null == e ? void 0 : e.setImmediate) || c)(...t)
                    },
                    clearImmediate(t) {
                        const {
                            delegate: e
                        } = u;
                        return ((null == e ? void 0 : e.clearImmediate) || h)(t)
                    },
                    delegate: void 0
                };
            var d = i("3x7h");
            const p = new class extends d.a {
                flush(t) {
                    this._active = !0, this._scheduled = void 0;
                    const {
                        actions: e
                    } = this;
                    let i, n = -1;
                    t = t || e.shift();
                    const s = e.length;
                    do {
                        if (i = t.execute(t.state, t.delay)) break
                    } while (++n < s && (t = e.shift()));
                    if (this._active = !1, i) {
                        for (; ++n < s && (t = e.shift());) t.unsubscribe();
                        throw i
                    }
                }
            }(class extends n.a {
                constructor(t, e) {
                    super(t, e), this.scheduler = t, this.work = e
                }
                requestAsyncId(t, e, i = 0) {
                    return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = u.setImmediate(t.flush.bind(t, void 0))))
                }
                recycleAsyncId(t, e, i = 0) {
                    if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i);
                    0 === t.actions.length && (u.clearImmediate(e), t._scheduled = void 0)
                }
            })
        },
        "3Pt+": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return Ct
            }), i.d(e, "b", function() {
                return u
            }), i.d(e, "c", function() {
                return st
            }), i.d(e, "d", function() {
                return vt
            }), i.d(e, "e", function() {
                return rt
            }), i.d(e, "f", function() {
                return bt
            }), i.d(e, "g", function() {
                return At
            }), i.d(e, "h", function() {
                return f
            }), i.d(e, "i", function() {
                return l
            }), i.d(e, "j", function() {
                return j
            }), i.d(e, "k", function() {
                return N
            }), i.d(e, "l", function() {
                return z
            }), i.d(e, "m", function() {
                return ct
            }), i.d(e, "n", function() {
                return dt
            }), i.d(e, "o", function() {
                return Ot
            }), i.d(e, "p", function() {
                return b
            }), i.d(e, "q", function() {
                return pt
            });
            var n = i("fXoL"),
                s = i("ofXK"),
                r = i("g/MW"),
                a = i("zPkR"),
                o = i("rdQv");
            const l = new n.s("NgValueAccessor"),
                c = {
                    provide: l,
                    useExisting: Object(n.W)(() => u),
                    multi: !0
                },
                h = new n.s("CompositionEventMode");
            let u = (() => {
                class t {
                    constructor(t, e, i) {
                        this._renderer = t, this._elementRef = e, this._compositionMode = i, this.onChange = t => {}, this.onTouched = () => {}, this._composing = !1, null == this._compositionMode && (this._compositionMode = ! function() {
                            const t = Object(s.x)() ? Object(s.x)().getUserAgent() : "";
                            return /android (\d+)/.test(t.toLowerCase())
                        }())
                    }
                    writeValue(t) {
                        this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t)
                    }
                    registerOnChange(t) {
                        this.onChange = t
                    }
                    registerOnTouched(t) {
                        this.onTouched = t
                    }
                    setDisabledState(t) {
                        this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t)
                    }
                    _handleInput(t) {
                        (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t)
                    }
                    _compositionStart() {
                        this._composing = !0
                    }
                    _compositionEnd(t) {
                        this._composing = !1, this._compositionMode && this.onChange(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(n.G), n.Pb(n.l), n.Pb(h, 8))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["input", "formControlName", "", 3, "type", "checkbox"],
                        ["textarea", "formControlName", ""],
                        ["input", "formControl", "", 3, "type", "checkbox"],
                        ["textarea", "formControl", ""],
                        ["input", "ngModel", "", 3, "type", "checkbox"],
                        ["textarea", "ngModel", ""],
                        ["", "ngDefaultControl", ""]
                    ],
                    hostBindings: function(t, e) {
                        1 & t && n.cc("input", function(t) {
                            return e._handleInput(t.target.value)
                        })("blur", function() {
                            return e.onTouched()
                        })("compositionstart", function() {
                            return e._compositionStart()
                        })("compositionend", function(t) {
                            return e._compositionEnd(t.target.value)
                        })
                    },
                    features: [n.Cb([c])]
                }), t
            })();

            function d(t) {
                return null == t || 0 === t.length
            }

            function p(t) {
                return null != t && "number" == typeof t.length
            }
            const f = new n.s("NgValidators"),
                g = new n.s("NgAsyncValidators"),
                m = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
            class b {
                static min(t) {
                    return function(t) {
                        return e => {
                            if (d(e.value) || d(t)) return null;
                            const i = parseFloat(e.value);
                            return !isNaN(i) && i < t ? {
                                min: {
                                    min: t,
                                    actual: e.value
                                }
                            } : null
                        }
                    }(t)
                }
                static max(t) {
                    return function(t) {
                        return e => {
                            if (d(e.value) || d(t)) return null;
                            const i = parseFloat(e.value);
                            return !isNaN(i) && i > t ? {
                                max: {
                                    max: t,
                                    actual: e.value
                                }
                            } : null
                        }
                    }(t)
                }
                static required(t) {
                    return y(t)
                }
                static requiredTrue(t) {
                    return v(t)
                }
                static email(t) {
                    return function(t) {
                        return d(t.value) || m.test(t.value) ? null : {
                            email: !0
                        }
                    }(t)
                }
                static minLength(t) {
                    return function(t) {
                        return e => d(e.value) || !p(e.value) ? null : e.value.length < t ? {
                            minlength: {
                                requiredLength: t,
                                actualLength: e.value.length
                            }
                        } : null
                    }(t)
                }
                static maxLength(t) {
                    return function(t) {
                        return e => p(e.value) && e.value.length > t ? {
                            maxlength: {
                                requiredLength: t,
                                actualLength: e.value.length
                            }
                        } : null
                    }(t)
                }
                static pattern(t) {
                    return function(t) {
                        if (!t) return x;
                        let e, i;
                        return "string" == typeof t ? (i = "", "^" !== t.charAt(0) && (i += "^"), i += t, "$" !== t.charAt(t.length - 1) && (i += "$"), e = new RegExp(i)) : (i = t.toString(), e = t), t => {
                            if (d(t.value)) return null;
                            const n = t.value;
                            return e.test(n) ? null : {
                                pattern: {
                                    requiredPattern: i,
                                    actualValue: n
                                }
                            }
                        }
                    }(t)
                }
                static nullValidator(t) {
                    return null
                }
                static compose(t) {
                    return A(t)
                }
                static composeAsync(t) {
                    return E(t)
                }
            }

            function y(t) {
                return d(t.value) ? {
                    required: !0
                } : null
            }

            function v(t) {
                return !0 === t.value ? null : {
                    required: !0
                }
            }

            function x(t) {
                return null
            }

            function _(t) {
                return null != t
            }

            function w(t) {
                const e = Object(n.ub)(t) ? Object(r.a)(t) : t;
                return Object(n.tb)(e), e
            }

            function C(t) {
                let e = {};
                return t.forEach(t => {
                    e = null != t ? Object.assign(Object.assign({}, e), t) : e
                }), 0 === Object.keys(e).length ? null : e
            }

            function k(t, e) {
                return e.map(e => e(t))
            }

            function S(t) {
                return t.map(t => function(t) {
                    return !t.validate
                }(t) ? t : e => t.validate(e))
            }

            function A(t) {
                if (!t) return null;
                const e = t.filter(_);
                return 0 == e.length ? null : function(t) {
                    return C(k(t, e))
                }
            }

            function O(t) {
                return null != t ? A(S(t)) : null
            }

            function E(t) {
                if (!t) return null;
                const e = t.filter(_);
                return 0 == e.length ? null : function(t) {
                    const i = k(t, e).map(w);
                    return Object(a.a)(i).pipe(Object(o.a)(C))
                }
            }

            function P(t) {
                return null != t ? E(S(t)) : null
            }

            function T(t, e) {
                return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e]
            }

            function D(t) {
                return t._rawValidators
            }

            function I(t) {
                return t._rawAsyncValidators
            }
            let M = (() => {
                    class t {
                        constructor() {
                            this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = []
                        }
                        get value() {
                            return this.control ? this.control.value : null
                        }
                        get valid() {
                            return this.control ? this.control.valid : null
                        }
                        get invalid() {
                            return this.control ? this.control.invalid : null
                        }
                        get pending() {
                            return this.control ? this.control.pending : null
                        }
                        get disabled() {
                            return this.control ? this.control.disabled : null
                        }
                        get enabled() {
                            return this.control ? this.control.enabled : null
                        }
                        get errors() {
                            return this.control ? this.control.errors : null
                        }
                        get pristine() {
                            return this.control ? this.control.pristine : null
                        }
                        get dirty() {
                            return this.control ? this.control.dirty : null
                        }
                        get touched() {
                            return this.control ? this.control.touched : null
                        }
                        get status() {
                            return this.control ? this.control.status : null
                        }
                        get untouched() {
                            return this.control ? this.control.untouched : null
                        }
                        get statusChanges() {
                            return this.control ? this.control.statusChanges : null
                        }
                        get valueChanges() {
                            return this.control ? this.control.valueChanges : null
                        }
                        get path() {
                            return null
                        }
                        _setValidators(t) {
                            this._rawValidators = t || [], this._composedValidatorFn = O(this._rawValidators)
                        }
                        _setAsyncValidators(t) {
                            this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = P(this._rawAsyncValidators)
                        }
                        get validator() {
                            return this._composedValidatorFn || null
                        }
                        get asyncValidator() {
                            return this._composedAsyncValidatorFn || null
                        }
                        _registerOnDestroy(t) {
                            this._onDestroyCallbacks.push(t)
                        }
                        _invokeOnDestroyCallbacks() {
                            this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = []
                        }
                        reset(t) {
                            this.control && this.control.reset(t)
                        }
                        hasError(t, e) {
                            return !!this.control && this.control.hasError(t, e)
                        }
                        getError(t, e) {
                            return this.control ? this.control.getError(t, e) : null
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t
                    }), t
                })(),
                L = (() => {
                    class t extends M {
                        get formDirective() {
                            return null
                        }
                        get path() {
                            return null
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return R(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        features: [n.Ab]
                    }), t
                })();
            const R = n.Xb(L);
            class j extends M {
                constructor() {
                    super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null
                }
            }
            class F {
                constructor(t) {
                    this._cd = t
                }
                is(t) {
                    var e, i;
                    return !!(null === (i = null === (e = this._cd) || void 0 === e ? void 0 : e.control) || void 0 === i ? void 0 : i[t])
                }
            }
            let N = (() => {
                    class t extends F {
                        constructor(t) {
                            super(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(j, 2))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "formControlName", ""],
                            ["", "ngModel", ""],
                            ["", "formControl", ""]
                        ],
                        hostVars: 14,
                        hostBindings: function(t, e) {
                            2 & t && n.Hb("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending"))
                        },
                        features: [n.Ab]
                    }), t
                })(),
                z = (() => {
                    class t extends F {
                        constructor(t) {
                            super(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(L, 10))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "formGroupName", ""],
                            ["", "formArrayName", ""],
                            ["", "ngModelGroup", ""],
                            ["", "formGroup", ""],
                            ["form", 3, "ngNoForm", ""],
                            ["", "ngForm", ""]
                        ],
                        hostVars: 14,
                        hostBindings: function(t, e) {
                            2 & t && n.Hb("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending"))
                        },
                        features: [n.Ab]
                    }), t
                })();

            function V(t, e) {
                return [...e.path, t]
            }

            function B(t, e) {
                X(t, e, !0), e.valueAccessor.writeValue(t.value),
                    function(t, e) {
                        e.valueAccessor.registerOnChange(i => {
                            t._pendingValue = i, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && Y(t, e)
                        })
                    }(t, e),
                    function(t, e) {
                        const i = (t, i) => {
                            e.valueAccessor.writeValue(t), i && e.viewToModelUpdate(t)
                        };
                        t.registerOnChange(i), e._registerOnDestroy(() => {
                            t._unregisterOnChange(i)
                        })
                    }(t, e),
                    function(t, e) {
                        e.valueAccessor.registerOnTouched(() => {
                            t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && Y(t, e), "submit" !== t.updateOn && t.markAsTouched()
                        })
                    }(t, e),
                    function(t, e) {
                        if (e.valueAccessor.setDisabledState) {
                            const i = t => {
                                e.valueAccessor.setDisabledState(t)
                            };
                            t.registerOnDisabledChange(i), e._registerOnDestroy(() => {
                                t._unregisterOnDisabledChange(i)
                            })
                        }
                    }(t, e)
            }

            function H(t, e, i = !0) {
                const n = () => {};
                e.valueAccessor && (e.valueAccessor.registerOnChange(n), e.valueAccessor.registerOnTouched(n)), W(t, e, !0), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => {}))
            }

            function U(t, e) {
                t.forEach(t => {
                    t.registerOnValidatorChange && t.registerOnValidatorChange(e)
                })
            }

            function X(t, e, i) {
                const n = D(t);
                null !== e.validator ? t.setValidators(T(n, e.validator)) : "function" == typeof n && t.setValidators([n]);
                const s = I(t);
                if (null !== e.asyncValidator ? t.setAsyncValidators(T(s, e.asyncValidator)) : "function" == typeof s && t.setAsyncValidators([s]), i) {
                    const i = () => t.updateValueAndValidity();
                    U(e._rawValidators, i), U(e._rawAsyncValidators, i)
                }
            }

            function W(t, e, i) {
                let n = !1;
                if (null !== t) {
                    if (null !== e.validator) {
                        const i = D(t);
                        if (Array.isArray(i) && i.length > 0) {
                            const s = i.filter(t => t !== e.validator);
                            s.length !== i.length && (n = !0, t.setValidators(s))
                        }
                    }
                    if (null !== e.asyncValidator) {
                        const i = I(t);
                        if (Array.isArray(i) && i.length > 0) {
                            const s = i.filter(t => t !== e.asyncValidator);
                            s.length !== i.length && (n = !0, t.setAsyncValidators(s))
                        }
                    }
                }
                if (i) {
                    const t = () => {};
                    U(e._rawValidators, t), U(e._rawAsyncValidators, t)
                }
                return n
            }

            function Y(t, e) {
                t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, {
                    emitModelToViewChange: !1
                }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1
            }

            function G(t, e) {
                X(t, e, !1)
            }

            function q(t, e) {
                if (!t.hasOwnProperty("model")) return !1;
                const i = t.model;
                return !!i.isFirstChange() || !Object.is(e, i.currentValue)
            }

            function Z(t, e) {
                t._syncPendingControls(), e.forEach(t => {
                    const e = t.control;
                    "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1)
                })
            }

            function $(t, e) {
                if (!e) return null;
                let i, n, s;
                return Array.isArray(e), e.forEach(t => {
                    t.constructor === u ? i = t : Object.getPrototypeOf(t.constructor) === class {} ? n = t : s = t
                }), s || n || i || null
            }

            function Q(t, e) {
                const i = t.indexOf(e);
                i > -1 && t.splice(i, 1)
            }

            function K(t) {
                return (it(t) ? t.validators : t) || null
            }

            function J(t) {
                return Array.isArray(t) ? O(t) : t || null
            }

            function tt(t, e) {
                return (it(e) ? e.asyncValidators : t) || null
            }

            function et(t) {
                return Array.isArray(t) ? P(t) : t || null
            }

            function it(t) {
                return null != t && !Array.isArray(t) && "object" == typeof t
            }
            class nt {
                constructor(t, e) {
                    this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => {}, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = J(this._rawValidators), this._composedAsyncValidatorFn = et(this._rawAsyncValidators)
                }
                get validator() {
                    return this._composedValidatorFn
                }
                set validator(t) {
                    this._rawValidators = this._composedValidatorFn = t
                }
                get asyncValidator() {
                    return this._composedAsyncValidatorFn
                }
                set asyncValidator(t) {
                    this._rawAsyncValidators = this._composedAsyncValidatorFn = t
                }
                get parent() {
                    return this._parent
                }
                get valid() {
                    return "VALID" === this.status
                }
                get invalid() {
                    return "INVALID" === this.status
                }
                get pending() {
                    return "PENDING" == this.status
                }
                get disabled() {
                    return "DISABLED" === this.status
                }
                get enabled() {
                    return "DISABLED" !== this.status
                }
                get dirty() {
                    return !this.pristine
                }
                get untouched() {
                    return !this.touched
                }
                get updateOn() {
                    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
                }
                setValidators(t) {
                    this._rawValidators = t, this._composedValidatorFn = J(t)
                }
                setAsyncValidators(t) {
                    this._rawAsyncValidators = t, this._composedAsyncValidatorFn = et(t)
                }
                clearValidators() {
                    this.validator = null
                }
                clearAsyncValidators() {
                    this.asyncValidator = null
                }
                markAsTouched(t = {}) {
                    this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t)
                }
                markAllAsTouched() {
                    this.markAsTouched({
                        onlySelf: !0
                    }), this._forEachChild(t => t.markAllAsTouched())
                }
                markAsUntouched(t = {}) {
                    this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => {
                        t.markAsUntouched({
                            onlySelf: !0
                        })
                    }), this._parent && !t.onlySelf && this._parent._updateTouched(t)
                }
                markAsDirty(t = {}) {
                    this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t)
                }
                markAsPristine(t = {}) {
                    this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => {
                        t.markAsPristine({
                            onlySelf: !0
                        })
                    }), this._parent && !t.onlySelf && this._parent._updatePristine(t)
                }
                markAsPending(t = {}) {
                    this.status = "PENDING", !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t)
                }
                disable(t = {}) {
                    const e = this._parentMarkedDirty(t.onlySelf);
                    this.status = "DISABLED", this.errors = null, this._forEachChild(e => {
                        e.disable(Object.assign(Object.assign({}, t), {
                            onlySelf: !0
                        }))
                    }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), {
                        skipPristineCheck: e
                    })), this._onDisabledChange.forEach(t => t(!0))
                }
                enable(t = {}) {
                    const e = this._parentMarkedDirty(t.onlySelf);
                    this.status = "VALID", this._forEachChild(e => {
                        e.enable(Object.assign(Object.assign({}, t), {
                            onlySelf: !0
                        }))
                    }), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: t.emitEvent
                    }), this._updateAncestors(Object.assign(Object.assign({}, t), {
                        skipPristineCheck: e
                    })), this._onDisabledChange.forEach(t => t(!1))
                }
                _updateAncestors(t) {
                    this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched())
                }
                setParent(t) {
                    this._parent = t
                }
                updateValueAndValidity(t = {}) {
                    this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), "VALID" !== this.status && "PENDING" !== this.status || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t)
                }
                _updateTreeValidity(t = {
                    emitEvent: !0
                }) {
                    this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: t.emitEvent
                    })
                }
                _setInitialStatus() {
                    this.status = this._allControlsDisabled() ? "DISABLED" : "VALID"
                }
                _runValidator() {
                    return this.validator ? this.validator(this) : null
                }
                _runAsyncValidator(t) {
                    if (this.asyncValidator) {
                        this.status = "PENDING", this._hasOwnPendingAsyncValidator = !0;
                        const e = w(this.asyncValidator(this));
                        this._asyncValidationSubscription = e.subscribe(e => {
                            this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, {
                                emitEvent: t
                            })
                        })
                    }
                }
                _cancelExistingSubscription() {
                    this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1)
                }
                setErrors(t, e = {}) {
                    this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent)
                }
                get(t) {
                    return function(t, e, i) {
                        if (null == e) return null;
                        if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null;
                        let n = t;
                        return e.forEach(t => {
                            n = n instanceof rt ? n.controls.hasOwnProperty(t) ? n.controls[t] : null : n instanceof at && n.at(t) || null
                        }), n
                    }(this, t)
                }
                getError(t, e) {
                    const i = e ? this.get(e) : this;
                    return i && i.errors ? i.errors[t] : null
                }
                hasError(t, e) {
                    return !!this.getError(t, e)
                }
                get root() {
                    let t = this;
                    for (; t._parent;) t = t._parent;
                    return t
                }
                _updateControlsErrors(t) {
                    this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t)
                }
                _initObservables() {
                    this.valueChanges = new n.o, this.statusChanges = new n.o
                }
                _calculateStatus() {
                    return this._allControlsDisabled() ? "DISABLED" : this.errors ? "INVALID" : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus("PENDING") ? "PENDING" : this._anyControlsHaveStatus("INVALID") ? "INVALID" : "VALID"
                }
                _anyControlsHaveStatus(t) {
                    return this._anyControls(e => e.status === t)
                }
                _anyControlsDirty() {
                    return this._anyControls(t => t.dirty)
                }
                _anyControlsTouched() {
                    return this._anyControls(t => t.touched)
                }
                _updatePristine(t = {}) {
                    this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t)
                }
                _updateTouched(t = {}) {
                    this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t)
                }
                _isBoxedValue(t) {
                    return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t
                }
                _registerOnCollectionChange(t) {
                    this._onCollectionChange = t
                }
                _setUpdateStrategy(t) {
                    it(t) && null != t.updateOn && (this._updateOn = t.updateOn)
                }
                _parentMarkedDirty(t) {
                    return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty()
                }
            }
            class st extends nt {
                constructor(t = null, e, i) {
                    super(K(e), tt(i, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!i
                    })
                }
                setValue(t, e = {}) {
                    this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e)
                }
                patchValue(t, e = {}) {
                    this.setValue(t, e)
                }
                reset(t = null, e = {}) {
                    this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1
                }
                _updateValue() {}
                _anyControls(t) {
                    return !1
                }
                _allControlsDisabled() {
                    return this.disabled
                }
                registerOnChange(t) {
                    this._onChange.push(t)
                }
                _unregisterOnChange(t) {
                    Q(this._onChange, t)
                }
                registerOnDisabledChange(t) {
                    this._onDisabledChange.push(t)
                }
                _unregisterOnDisabledChange(t) {
                    Q(this._onDisabledChange, t)
                }
                _forEachChild(t) {}
                _syncPendingControls() {
                    return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, {
                        onlySelf: !0,
                        emitModelToViewChange: !1
                    }), 0))
                }
                _applyFormState(t) {
                    this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({
                        onlySelf: !0,
                        emitEvent: !1
                    }) : this.enable({
                        onlySelf: !0,
                        emitEvent: !1
                    })) : this.value = this._pendingValue = t
                }
            }
            class rt extends nt {
                constructor(t, e, i) {
                    super(K(e), tt(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!i
                    })
                }
                registerControl(t, e) {
                    return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e)
                }
                addControl(t, e) {
                    this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange()
                }
                removeControl(t) {
                    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange()
                }
                setControl(t, e) {
                    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange()
                }
                contains(t) {
                    return this.controls.hasOwnProperty(t) && this.controls[t].enabled
                }
                setValue(t, e = {}) {
                    this._checkAllValuesPresent(t), Object.keys(t).forEach(i => {
                        this._throwIfControlMissing(i), this.controls[i].setValue(t[i], {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this.updateValueAndValidity(e)
                }
                patchValue(t, e = {}) {
                    null != t && (Object.keys(t).forEach(i => {
                        this.controls[i] && this.controls[i].patchValue(t[i], {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this.updateValueAndValidity(e))
                }
                reset(t = {}, e = {}) {
                    this._forEachChild((i, n) => {
                        i.reset(t[n], {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e)
                }
                getRawValue() {
                    return this._reduceChildren({}, (t, e, i) => (t[i] = e instanceof st ? e.value : e.getRawValue(), t))
                }
                _syncPendingControls() {
                    let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t);
                    return t && this.updateValueAndValidity({
                        onlySelf: !0
                    }), t
                }
                _throwIfControlMissing(t) {
                    if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
                    if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`)
                }
                _forEachChild(t) {
                    Object.keys(this.controls).forEach(e => {
                        const i = this.controls[e];
                        i && t(i, e)
                    })
                }
                _setUpControls() {
                    this._forEachChild(t => {
                        t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange)
                    })
                }
                _updateValue() {
                    this.value = this._reduceValue()
                }
                _anyControls(t) {
                    for (const e of Object.keys(this.controls)) {
                        const i = this.controls[e];
                        if (this.contains(e) && t(i)) return !0
                    }
                    return !1
                }
                _reduceValue() {
                    return this._reduceChildren({}, (t, e, i) => ((e.enabled || this.disabled) && (t[i] = e.value), t))
                }
                _reduceChildren(t, e) {
                    let i = t;
                    return this._forEachChild((t, n) => {
                        i = e(i, t, n)
                    }), i
                }
                _allControlsDisabled() {
                    for (const t of Object.keys(this.controls))
                        if (this.controls[t].enabled) return !1;
                    return Object.keys(this.controls).length > 0 || this.disabled
                }
                _checkAllValuesPresent(t) {
                    this._forEachChild((e, i) => {
                        if (void 0 === t[i]) throw new Error(`Must supply a value for form control with name: '${i}'.`)
                    })
                }
            }
            class at extends nt {
                constructor(t, e, i) {
                    super(K(e), tt(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!i
                    })
                }
                at(t) {
                    return this.controls[t]
                }
                push(t) {
                    this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange()
                }
                insert(t, e) {
                    this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity()
                }
                removeAt(t) {
                    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), this.controls.splice(t, 1), this.updateValueAndValidity()
                }
                setControl(t, e) {
                    this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange()
                }
                get length() {
                    return this.controls.length
                }
                setValue(t, e = {}) {
                    this._checkAllValuesPresent(t), t.forEach((t, i) => {
                        this._throwIfControlMissing(i), this.at(i).setValue(t, {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this.updateValueAndValidity(e)
                }
                patchValue(t, e = {}) {
                    null != t && (t.forEach((t, i) => {
                        this.at(i) && this.at(i).patchValue(t, {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this.updateValueAndValidity(e))
                }
                reset(t = [], e = {}) {
                    this._forEachChild((i, n) => {
                        i.reset(t[n], {
                            onlySelf: !0,
                            emitEvent: e.emitEvent
                        })
                    }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e)
                }
                getRawValue() {
                    return this.controls.map(t => t instanceof st ? t.value : t.getRawValue())
                }
                clear() {
                    this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => {})), this.controls.splice(0), this.updateValueAndValidity())
                }
                _syncPendingControls() {
                    let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1);
                    return t && this.updateValueAndValidity({
                        onlySelf: !0
                    }), t
                }
                _throwIfControlMissing(t) {
                    if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
                    if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`)
                }
                _forEachChild(t) {
                    this.controls.forEach((e, i) => {
                        t(e, i)
                    })
                }
                _updateValue() {
                    this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value)
                }
                _anyControls(t) {
                    return this.controls.some(e => e.enabled && t(e))
                }
                _setUpControls() {
                    this._forEachChild(t => this._registerControl(t))
                }
                _checkAllValuesPresent(t) {
                    this._forEachChild((e, i) => {
                        if (void 0 === t[i]) throw new Error(`Must supply a value for form control at index: ${i}.`)
                    })
                }
                _allControlsDisabled() {
                    for (const t of this.controls)
                        if (t.enabled) return !1;
                    return this.controls.length > 0 || this.disabled
                }
                _registerControl(t) {
                    t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange)
                }
            }
            const ot = {
                    provide: L,
                    useExisting: Object(n.W)(() => ct)
                },
                lt = (() => Promise.resolve(null))();
            let ct = (() => {
                class t extends L {
                    constructor(t, e) {
                        super(), this.submitted = !1, this._directives = [], this.ngSubmit = new n.o, this.form = new rt({}, O(t), P(e))
                    }
                    ngAfterViewInit() {
                        this._setUpdateStrategy()
                    }
                    get formDirective() {
                        return this
                    }
                    get control() {
                        return this.form
                    }
                    get path() {
                        return []
                    }
                    get controls() {
                        return this.form.controls
                    }
                    addControl(t) {
                        lt.then(() => {
                            const e = this._findContainer(t.path);
                            t.control = e.registerControl(t.name, t.control), B(t.control, t), t.control.updateValueAndValidity({
                                emitEvent: !1
                            }), this._directives.push(t)
                        })
                    }
                    getControl(t) {
                        return this.form.get(t.path)
                    }
                    removeControl(t) {
                        lt.then(() => {
                            const e = this._findContainer(t.path);
                            e && e.removeControl(t.name), Q(this._directives, t)
                        })
                    }
                    addFormGroup(t) {
                        lt.then(() => {
                            const e = this._findContainer(t.path),
                                i = new rt({});
                            G(i, t), e.registerControl(t.name, i), i.updateValueAndValidity({
                                emitEvent: !1
                            })
                        })
                    }
                    removeFormGroup(t) {
                        lt.then(() => {
                            const e = this._findContainer(t.path);
                            e && e.removeControl(t.name)
                        })
                    }
                    getFormGroup(t) {
                        return this.form.get(t.path)
                    }
                    updateModel(t, e) {
                        lt.then(() => {
                            this.form.get(t.path).setValue(e)
                        })
                    }
                    setValue(t) {
                        this.control.setValue(t)
                    }
                    onSubmit(t) {
                        return this.submitted = !0, Z(this.form, this._directives), this.ngSubmit.emit(t), !1
                    }
                    onReset() {
                        this.resetForm()
                    }
                    resetForm(t) {
                        this.form.reset(t), this.submitted = !1
                    }
                    _setUpdateStrategy() {
                        this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn)
                    }
                    _findContainer(t) {
                        return t.pop(), t.length ? this.form.get(t) : this.form
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(f, 10), n.Pb(g, 10))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["form", 3, "ngNoForm", "", 3, "formGroup", ""],
                        ["ng-form"],
                        ["", "ngForm", ""]
                    ],
                    hostBindings: function(t, e) {
                        1 & t && n.cc("submit", function(t) {
                            return e.onSubmit(t)
                        })("reset", function() {
                            return e.onReset()
                        })
                    },
                    inputs: {
                        options: ["ngFormOptions", "options"]
                    },
                    outputs: {
                        ngSubmit: "ngSubmit"
                    },
                    exportAs: ["ngForm"],
                    features: [n.Cb([ot]), n.Ab]
                }), t
            })();
            const ht = {
                    provide: j,
                    useExisting: Object(n.W)(() => dt)
                },
                ut = (() => Promise.resolve(null))();
            let dt = (() => {
                    class t extends j {
                        constructor(t, e, i, s) {
                            super(), this.control = new st, this._registered = !1, this.update = new n.o, this._parent = t, this._setValidators(e), this._setAsyncValidators(i), this.valueAccessor = $(0, s)
                        }
                        ngOnChanges(t) {
                            this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), q(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model)
                        }
                        ngOnDestroy() {
                            this.formDirective && this.formDirective.removeControl(this)
                        }
                        get path() {
                            return this._parent ? V(this.name, this._parent) : [this.name]
                        }
                        get formDirective() {
                            return this._parent ? this._parent.formDirective : null
                        }
                        viewToModelUpdate(t) {
                            this.viewModel = t, this.update.emit(t)
                        }
                        _setUpControl() {
                            this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0
                        }
                        _setUpdateStrategy() {
                            this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn)
                        }
                        _isStandalone() {
                            return !this._parent || !(!this.options || !this.options.standalone)
                        }
                        _setUpStandalone() {
                            B(this.control, this), this.control.updateValueAndValidity({
                                emitEvent: !1
                            })
                        }
                        _checkForErrors() {
                            this._isStandalone() || this._checkParentType(), this._checkName()
                        }
                        _checkParentType() {}
                        _checkName() {
                            this.options && this.options.name && (this.name = this.options.name), this._isStandalone()
                        }
                        _updateValue(t) {
                            ut.then(() => {
                                this.control.setValue(t, {
                                    emitViewToModelChange: !1
                                })
                            })
                        }
                        _updateDisabled(t) {
                            const e = t.isDisabled.currentValue,
                                i = "" === e || e && "false" !== e;
                            ut.then(() => {
                                i && !this.control.disabled ? this.control.disable() : !i && this.control.disabled && this.control.enable()
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(L, 9), n.Pb(f, 10), n.Pb(g, 10), n.Pb(l, 10))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]
                        ],
                        inputs: {
                            name: "name",
                            isDisabled: ["disabled", "isDisabled"],
                            model: ["ngModel", "model"],
                            options: ["ngModelOptions", "options"]
                        },
                        outputs: {
                            update: "ngModelChange"
                        },
                        exportAs: ["ngModel"],
                        features: [n.Cb([ht]), n.Ab, n.Bb]
                    }), t
                })(),
                pt = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]
                        ],
                        hostAttrs: ["novalidate", ""]
                    }), t
                })(),
                ft = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({}), t
                })();
            const gt = new n.s("NgModelWithFormControlWarning"),
                mt = {
                    provide: L,
                    useExisting: Object(n.W)(() => bt)
                };
            let bt = (() => {
                class t extends L {
                    constructor(t, e) {
                        super(), this.validators = t, this.asyncValidators = e, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new n.o, this._setValidators(t), this._setAsyncValidators(e)
                    }
                    ngOnChanges(t) {
                        this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form)
                    }
                    ngOnDestroy() {
                        this.form && (W(this.form, this, !1), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => {}))
                    }
                    get formDirective() {
                        return this
                    }
                    get control() {
                        return this.form
                    }
                    get path() {
                        return []
                    }
                    addControl(t) {
                        const e = this.form.get(t.path);
                        return B(e, t), e.updateValueAndValidity({
                            emitEvent: !1
                        }), this.directives.push(t), e
                    }
                    getControl(t) {
                        return this.form.get(t.path)
                    }
                    removeControl(t) {
                        H(t.control || null, t, !1), Q(this.directives, t)
                    }
                    addFormGroup(t) {
                        this._setUpFormContainer(t)
                    }
                    removeFormGroup(t) {
                        this._cleanUpFormContainer(t)
                    }
                    getFormGroup(t) {
                        return this.form.get(t.path)
                    }
                    addFormArray(t) {
                        this._setUpFormContainer(t)
                    }
                    removeFormArray(t) {
                        this._cleanUpFormContainer(t)
                    }
                    getFormArray(t) {
                        return this.form.get(t.path)
                    }
                    updateModel(t, e) {
                        this.form.get(t.path).setValue(e)
                    }
                    onSubmit(t) {
                        return this.submitted = !0, Z(this.form, this.directives), this.ngSubmit.emit(t), !1
                    }
                    onReset() {
                        this.resetForm()
                    }
                    resetForm(t) {
                        this.form.reset(t), this.submitted = !1
                    }
                    _updateDomValue() {
                        this.directives.forEach(t => {
                            const e = t.control,
                                i = this.form.get(t.path);
                            e !== i && (H(e || null, t), i instanceof st && (B(i, t), t.control = i))
                        }), this.form._updateTreeValidity({
                            emitEvent: !1
                        })
                    }
                    _setUpFormContainer(t) {
                        const e = this.form.get(t.path);
                        G(e, t), e.updateValueAndValidity({
                            emitEvent: !1
                        })
                    }
                    _cleanUpFormContainer(t) {
                        if (this.form) {
                            const e = this.form.get(t.path);
                            e && function(t, e) {
                                return W(t, e, !1)
                            }(e, t) && e.updateValueAndValidity({
                                emitEvent: !1
                            })
                        }
                    }
                    _updateRegistrations() {
                        this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => {})
                    }
                    _updateValidators() {
                        X(this.form, this, !1), this._oldForm && W(this._oldForm, this, !1)
                    }
                    _checkFormPresent() {}
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(f, 10), n.Pb(g, 10))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["", "formGroup", ""]
                    ],
                    hostBindings: function(t, e) {
                        1 & t && n.cc("submit", function(t) {
                            return e.onSubmit(t)
                        })("reset", function() {
                            return e.onReset()
                        })
                    },
                    inputs: {
                        form: ["formGroup", "form"]
                    },
                    outputs: {
                        ngSubmit: "ngSubmit"
                    },
                    exportAs: ["ngForm"],
                    features: [n.Cb([mt]), n.Ab, n.Bb]
                }), t
            })();
            const yt = {
                provide: j,
                useExisting: Object(n.W)(() => vt)
            };
            let vt = (() => {
                class t extends j {
                    constructor(t, e, i, s, r) {
                        super(), this._ngModelWarningConfig = r, this._added = !1, this.update = new n.o, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(e), this._setAsyncValidators(i), this.valueAccessor = $(0, s)
                    }
                    set isDisabled(t) {}
                    ngOnChanges(t) {
                        this._added || this._setUpControl(), q(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model))
                    }
                    ngOnDestroy() {
                        this.formDirective && this.formDirective.removeControl(this)
                    }
                    viewToModelUpdate(t) {
                        this.viewModel = t, this.update.emit(t)
                    }
                    get path() {
                        return V(null == this.name ? this.name : this.name.toString(), this._parent)
                    }
                    get formDirective() {
                        return this._parent ? this._parent.formDirective : null
                    }
                    _checkParentType() {}
                    _setUpControl() {
                        this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(L, 13), n.Pb(f, 10), n.Pb(g, 10), n.Pb(l, 10), n.Pb(gt, 8))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["", "formControlName", ""]
                    ],
                    inputs: {
                        isDisabled: ["disabled", "isDisabled"],
                        name: ["formControlName", "name"],
                        model: ["ngModel", "model"]
                    },
                    outputs: {
                        update: "ngModelChange"
                    },
                    features: [n.Cb([yt]), n.Ab, n.Bb]
                }), t._ngModelWarningSentOnce = !1, t
            })();
            const xt = {
                    provide: f,
                    useExisting: Object(n.W)(() => wt),
                    multi: !0
                },
                _t = {
                    provide: f,
                    useExisting: Object(n.W)(() => Ct),
                    multi: !0
                };
            let wt = (() => {
                    class t {
                        constructor() {
                            this._required = !1
                        }
                        get required() {
                            return this._required
                        }
                        set required(t) {
                            this._required = null != t && !1 !== t && "false" != `${t}`, this._onChange && this._onChange()
                        }
                        validate(t) {
                            return this.required ? y(t) : null
                        }
                        registerOnValidatorChange(t) {
                            this._onChange = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "required", "", "formControlName", "", 3, "type", "checkbox"],
                            ["", "required", "", "formControl", "", 3, "type", "checkbox"],
                            ["", "required", "", "ngModel", "", 3, "type", "checkbox"]
                        ],
                        hostVars: 1,
                        hostBindings: function(t, e) {
                            2 & t && n.Eb("required", e.required ? "" : null)
                        },
                        inputs: {
                            required: "required"
                        },
                        features: [n.Cb([xt])]
                    }), t
                })(),
                Ct = (() => {
                    class t extends wt {
                        validate(t) {
                            return this.required ? v(t) : null
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return kt(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["input", "type", "checkbox", "required", "", "formControlName", ""],
                            ["input", "type", "checkbox", "required", "", "formControl", ""],
                            ["input", "type", "checkbox", "required", "", "ngModel", ""]
                        ],
                        hostVars: 1,
                        hostBindings: function(t, e) {
                            2 & t && n.Eb("required", e.required ? "" : null)
                        },
                        features: [n.Cb([_t]), n.Ab]
                    }), t
                })();
            const kt = n.Xb(Ct);
            let St = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            [ft]
                        ]
                    }), t
                })(),
                At = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [St]
                    }), t
                })(),
                Ot = (() => {
                    class t {
                        static withConfig(e) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: gt,
                                    useValue: e.warnOnNgModelWithFormControl
                                }]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [St]
                    }), t
                })()
        },
        "3x7h": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("iu6b");
            class s {
                constructor(t, e = s.now) {
                    this.schedulerActionCtor = t, this.now = e
                }
                schedule(t, e = 0, i) {
                    return new this.schedulerActionCtor(this, t).schedule(i, e)
                }
            }
            s.now = n.a.now;
            class r extends s {
                constructor(t, e = s.now) {
                    super(t, e), this.actions = [], this._active = !1, this._scheduled = void 0
                }
                flush(t) {
                    const {
                        actions: e
                    } = this;
                    if (this._active) return void e.push(t);
                    let i;
                    this._active = !0;
                    do {
                        if (i = t.execute(t.state, t.delay)) break
                    } while (t = e.shift());
                    if (this._active = !1, i) {
                        for (; t = e.shift();) t.unsubscribe();
                        throw i
                    }
                }
            }
        },
        "42oE": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("EPzc"),
                s = i("xt23");

            function r() {
                return Object(n.b)((t, e) => {
                    let i = null;
                    t._refCount++;
                    const n = new s.a(e, void 0, void 0, void 0, () => {
                        if (!t || t._refCount <= 0 || 0 < --t._refCount) return void(i = null);
                        const n = t._connection,
                            s = i;
                        i = null, !n || s && n !== s || n.unsubscribe(), e.unsubscribe()
                    });
                    t.subscribe(n), n.closed || (i = t.connect())
                })
            }
        },
        "4krO": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("vfWG"),
                s = i("v1EJ"),
                r = i("1lu8");

            function a(...t) {
                const e = Object(r.c)(t);
                return e ? Object(s.a)(t, e) : Object(n.a)(t)
            }
        },
        "5CXX": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = "function" == typeof Symbol && Symbol.observable || "@@observable"
        },
        "5eHb": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return I
            }), i.d(e, "b", function() {
                return _
            }), i.d(e, "c", function() {
                return L
            }), i.d(e, "d", function() {
                return D
            });
            var n = i("fXoL"),
                s = i("R0Ic"),
                r = i("oXA7"),
                a = i("jhN1"),
                o = i("ofXK");
            const l = ["toast-component", ""];

            function c(t, e) {
                if (1 & t) {
                    const t = n.Wb();
                    n.Vb(0, "button", 5), n.cc("click", function() {
                        return n.uc(t), n.gc().remove()
                    }), n.Vb(1, "span", 6), n.Cc(2, "\xd7"), n.Ub(), n.Ub()
                }
            }

            function h(t, e) {
                if (1 & t && (n.Tb(0), n.Cc(1), n.Sb()), 2 & t) {
                    const t = n.gc(2);
                    n.Db(1), n.Ec("[", t.duplicatesCount + 1, "]")
                }
            }

            function u(t, e) {
                if (1 & t && (n.Vb(0, "div"), n.Cc(1), n.Bc(2, h, 2, 1, "ng-container", 4), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.titleClass), n.Eb("aria-label", t.title), n.Db(1), n.Ec(" ", t.title, " "), n.Db(1), n.lc("ngIf", t.duplicatesCount)
                }
            }

            function d(t, e) {
                if (1 & t && n.Qb(0, "div", 7), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.messageClass), n.lc("innerHTML", t.message, n.vc)
                }
            }

            function p(t, e) {
                if (1 & t && (n.Vb(0, "div", 8), n.Cc(1), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.messageClass), n.Eb("aria-label", t.message), n.Db(1), n.Ec(" ", t.message, " ")
                }
            }

            function f(t, e) {
                if (1 & t && (n.Vb(0, "div"), n.Qb(1, "div", 9), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Db(1), n.yc("width", t.width + "%")
                }
            }

            function g(t, e) {
                if (1 & t) {
                    const t = n.Wb();
                    n.Vb(0, "button", 5), n.cc("click", function() {
                        return n.uc(t), n.gc().remove()
                    }), n.Vb(1, "span", 6), n.Cc(2, "\xd7"), n.Ub(), n.Ub()
                }
            }

            function m(t, e) {
                if (1 & t && (n.Tb(0), n.Cc(1), n.Sb()), 2 & t) {
                    const t = n.gc(2);
                    n.Db(1), n.Ec("[", t.duplicatesCount + 1, "]")
                }
            }

            function b(t, e) {
                if (1 & t && (n.Vb(0, "div"), n.Cc(1), n.Bc(2, m, 2, 1, "ng-container", 4), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.titleClass), n.Eb("aria-label", t.title), n.Db(1), n.Ec(" ", t.title, " "), n.Db(1), n.lc("ngIf", t.duplicatesCount)
                }
            }

            function y(t, e) {
                if (1 & t && n.Qb(0, "div", 7), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.messageClass), n.lc("innerHTML", t.message, n.vc)
                }
            }

            function v(t, e) {
                if (1 & t && (n.Vb(0, "div", 8), n.Cc(1), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Fb(t.options.messageClass), n.Eb("aria-label", t.message), n.Db(1), n.Ec(" ", t.message, " ")
                }
            }

            function x(t, e) {
                if (1 & t && (n.Vb(0, "div"), n.Qb(1, "div", 9), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Db(1), n.yc("width", t.width + "%")
                }
            }
            class _ {
                constructor(t, e, i, n, s, a) {
                    this.toastId = t, this.config = e, this.message = i, this.title = n, this.toastType = s, this.toastRef = a, this._onTap = new r.a, this._onAction = new r.a, this.toastRef.afterClosed().subscribe(() => {
                        this._onAction.complete(), this._onTap.complete()
                    })
                }
                triggerTap() {
                    this._onTap.next(), this.config.tapToDismiss && this._onTap.complete()
                }
                onTap() {
                    return this._onTap.asObservable()
                }
                triggerAction(t) {
                    this._onAction.next(t)
                }
                onAction() {
                    return this._onAction.asObservable()
                }
            }
            const w = {
                    maxOpened: 0,
                    autoDismiss: !1,
                    newestOnTop: !0,
                    preventDuplicates: !1,
                    countDuplicates: !1,
                    resetTimeoutOnDuplicate: !1,
                    includeTitleDuplicates: !1,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    closeButton: !1,
                    disableTimeOut: !1,
                    timeOut: 5e3,
                    extendedTimeOut: 1e3,
                    enableHtml: !1,
                    progressBar: !1,
                    toastClass: "ngx-toastr",
                    positionClass: "toast-top-right",
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    easing: "ease-in",
                    easeTime: 300,
                    tapToDismiss: !0,
                    onActivateTick: !1,
                    progressAnimation: "decreasing"
                },
                C = new n.s("ToastConfig");
            class k {
                constructor(t, e) {
                    this.component = t, this.injector = e
                }
                attach(t, e) {
                    return this._attachedHost = t, t.attach(this, e)
                }
                detach() {
                    const t = this._attachedHost;
                    if (t) return this._attachedHost = void 0, t.detach()
                }
                get isAttached() {
                    return null != this._attachedHost
                }
                setAttachedHost(t) {
                    this._attachedHost = t
                }
            }
            class S extends class {
                attach(t, e) {
                    return this._attachedPortal = t, this.attachComponentPortal(t, e)
                }
                detach() {
                    this._attachedPortal && this._attachedPortal.setAttachedHost(), this._attachedPortal = void 0, this._disposeFn && (this._disposeFn(), this._disposeFn = void 0)
                }
                setDisposeFn(t) {
                    this._disposeFn = t
                }
            } {
                constructor(t, e, i) {
                    super(), this._hostDomElement = t, this._componentFactoryResolver = e, this._appRef = i
                }
                attachComponentPortal(t, e) {
                    const i = this._componentFactoryResolver.resolveComponentFactory(t.component);
                    let n;
                    return n = i.create(t.injector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => {
                        this._appRef.detachView(n.hostView), n.destroy()
                    }), e ? this._hostDomElement.insertBefore(this._getComponentRootNode(n), this._hostDomElement.firstChild) : this._hostDomElement.appendChild(this._getComponentRootNode(n)), n
                }
                _getComponentRootNode(t) {
                    return t.hostView.rootNodes[0]
                }
            }
            let A = (() => {
                class t {
                    constructor(t) {
                        this._document = t
                    }
                    ngOnDestroy() {
                        this._containerElement && this._containerElement.parentNode && this._containerElement.parentNode.removeChild(this._containerElement)
                    }
                    getContainerElement() {
                        return this._containerElement || this._createContainer(), this._containerElement
                    }
                    _createContainer() {
                        const t = this._document.createElement("div");
                        t.classList.add("overlay-container"), this._document.body.appendChild(t), this._containerElement = t
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(o.d))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: function() {
                        return new t(Object(n.Zb)(o.d))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            class O {
                constructor(t) {
                    this._portalHost = t
                }
                attach(t, e = !0) {
                    return this._portalHost.attach(t, e)
                }
                detach() {
                    return this._portalHost.detach()
                }
            }
            let E = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._overlayContainer = t, this._componentFactoryResolver = e, this._appRef = i, this._document = n, this._paneElements = new Map
                    }
                    create(t, e) {
                        return this._createOverlayRef(this.getPaneElement(t, e))
                    }
                    getPaneElement(t = "", e) {
                        return this._paneElements.get(e) || this._paneElements.set(e, {}), this._paneElements.get(e)[t] || (this._paneElements.get(e)[t] = this._createPaneElement(t, e)), this._paneElements.get(e)[t]
                    }
                    _createPaneElement(t, e) {
                        const i = this._document.createElement("div");
                        return i.id = "toast-container", i.classList.add(t), i.classList.add("toast-container"), e ? e.getContainerElement().appendChild(i) : this._overlayContainer.getContainerElement().appendChild(i), i
                    }
                    _createPortalHost(t) {
                        return new S(t, this._componentFactoryResolver, this._appRef)
                    }
                    _createOverlayRef(t) {
                        return new O(this._createPortalHost(t))
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(A), n.Zb(n.j), n.Zb(n.g), n.Zb(o.d))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: function() {
                        return new t(Object(n.Zb)(A), Object(n.Zb)(n.j), Object(n.Zb)(n.g), Object(n.Zb)(o.d))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            class P {
                constructor(t) {
                    this._overlayRef = t, this.duplicatesCount = 0, this._afterClosed = new r.a, this._activate = new r.a, this._manualClose = new r.a, this._resetTimeout = new r.a, this._countDuplicate = new r.a
                }
                manualClose() {
                    this._manualClose.next(), this._manualClose.complete()
                }
                manualClosed() {
                    return this._manualClose.asObservable()
                }
                timeoutReset() {
                    return this._resetTimeout.asObservable()
                }
                countDuplicate() {
                    return this._countDuplicate.asObservable()
                }
                close() {
                    this._overlayRef.detach(), this._afterClosed.next(), this._manualClose.next(), this._afterClosed.complete(), this._manualClose.complete(), this._activate.complete(), this._resetTimeout.complete(), this._countDuplicate.complete()
                }
                afterClosed() {
                    return this._afterClosed.asObservable()
                }
                isInactive() {
                    return this._activate.isStopped
                }
                activate() {
                    this._activate.next(), this._activate.complete()
                }
                afterActivate() {
                    return this._activate.asObservable()
                }
                onDuplicate(t, e) {
                    t && this._resetTimeout.next(), e && this._countDuplicate.next(++this.duplicatesCount)
                }
            }
            class T {
                constructor(t, e) {
                    this._toastPackage = t, this._parentInjector = e
                }
                get(t, e, i) {
                    return t === _ ? this._toastPackage : this._parentInjector.get(t, e, i)
                }
            }
            let D = (() => {
                    class t {
                        constructor(t, e, i, n, s) {
                            this.overlay = e, this._injector = i, this.sanitizer = n, this.ngZone = s, this.currentlyActive = 0, this.toasts = [], this.index = 0, this.toastrConfig = Object.assign(Object.assign({}, t.default), t.config), t.config.iconClasses && (this.toastrConfig.iconClasses = Object.assign(Object.assign({}, t.default.iconClasses), t.config.iconClasses))
                        }
                        show(t, e, i = {}, n = "") {
                            return this._preBuildNotification(n, t, e, this.applyConfig(i))
                        }
                        success(t, e, i = {}) {
                            return this._preBuildNotification(this.toastrConfig.iconClasses.success || "", t, e, this.applyConfig(i))
                        }
                        error(t, e, i = {}) {
                            return this._preBuildNotification(this.toastrConfig.iconClasses.error || "", t, e, this.applyConfig(i))
                        }
                        info(t, e, i = {}) {
                            return this._preBuildNotification(this.toastrConfig.iconClasses.info || "", t, e, this.applyConfig(i))
                        }
                        warning(t, e, i = {}) {
                            return this._preBuildNotification(this.toastrConfig.iconClasses.warning || "", t, e, this.applyConfig(i))
                        }
                        clear(t) {
                            for (const e of this.toasts)
                                if (void 0 !== t) {
                                    if (e.toastId === t) return void e.toastRef.manualClose()
                                } else e.toastRef.manualClose()
                        }
                        remove(t) {
                            const e = this._findToast(t);
                            if (!e) return !1;
                            if (e.activeToast.toastRef.close(), this.toasts.splice(e.index, 1), this.currentlyActive = this.currentlyActive - 1, !this.toastrConfig.maxOpened || !this.toasts.length) return !1;
                            if (this.currentlyActive < this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {
                                const t = this.toasts[this.currentlyActive].toastRef;
                                t.isInactive() || (this.currentlyActive = this.currentlyActive + 1, t.activate())
                            }
                            return !0
                        }
                        findDuplicate(t = "", e = "", i, n) {
                            const {
                                includeTitleDuplicates: s
                            } = this.toastrConfig;
                            for (const r of this.toasts) {
                                const a = s && r.title === t;
                                if ((!s || a) && r.message === e) return r.toastRef.onDuplicate(i, n), r
                            }
                            return null
                        }
                        applyConfig(t = {}) {
                            return Object.assign(Object.assign({}, this.toastrConfig), t)
                        }
                        _findToast(t) {
                            for (let e = 0; e < this.toasts.length; e++)
                                if (this.toasts[e].toastId === t) return {
                                    index: e,
                                    activeToast: this.toasts[e]
                                };
                            return null
                        }
                        _preBuildNotification(t, e, i, n) {
                            return n.onActivateTick ? this.ngZone.run(() => this._buildNotification(t, e, i, n)) : this._buildNotification(t, e, i, n)
                        }
                        _buildNotification(t, e, i, s) {
                            if (!s.toastComponent) throw new Error("toastComponent required");
                            const r = this.findDuplicate(i, e, this.toastrConfig.resetTimeoutOnDuplicate && s.timeOut > 0, this.toastrConfig.countDuplicates);
                            if ((this.toastrConfig.includeTitleDuplicates && i || e) && this.toastrConfig.preventDuplicates && null !== r) return r;
                            this.previousToastMessage = e;
                            let a = !1;
                            this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened && (a = !0, this.toastrConfig.autoDismiss && this.clear(this.toasts[0].toastId));
                            const o = this.overlay.create(s.positionClass, this.overlayContainer);
                            this.index = this.index + 1;
                            let l = e;
                            e && s.enableHtml && (l = this.sanitizer.sanitize(n.K.HTML, e));
                            const c = new P(o),
                                h = new _(this.index, s, l, i, t, c),
                                u = new T(h, this._injector),
                                d = new k(s.toastComponent, u),
                                p = o.attach(d, this.toastrConfig.newestOnTop);
                            c.componentInstance = p.instance;
                            const f = {
                                toastId: this.index,
                                title: i || "",
                                message: e || "",
                                toastRef: c,
                                onShown: c.afterActivate(),
                                onHidden: c.afterClosed(),
                                onTap: h.onTap(),
                                onAction: h.onAction(),
                                portal: p
                            };
                            return a || (this.currentlyActive = this.currentlyActive + 1, setTimeout(() => {
                                f.toastRef.activate()
                            })), this.toasts.push(f), f
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(C), n.Zb(E), n.Zb(n.t), n.Zb(a.b), n.Zb(n.B))
                    }, t.\u0275prov = Object(n.Lb)({
                        factory: function() {
                            return new t(Object(n.Zb)(C), Object(n.Zb)(E), Object(n.Zb)(n.p), Object(n.Zb)(a.b), Object(n.Zb)(n.B))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                I = (() => {
                    class t {
                        constructor(t, e, i) {
                            this.toastrService = t, this.toastPackage = e, this.ngZone = i, this.width = -1, this.toastClasses = "", this.state = {
                                value: "inactive",
                                params: {
                                    easeTime: this.toastPackage.config.easeTime,
                                    easing: "ease-in"
                                }
                            }, this.message = e.message, this.title = e.title, this.options = e.config, this.originalTimeout = e.config.timeOut, this.toastClasses = `${e.toastType} ${e.config.toastClass}`, this.sub = e.toastRef.afterActivate().subscribe(() => {
                                this.activateToast()
                            }), this.sub1 = e.toastRef.manualClosed().subscribe(() => {
                                this.remove()
                            }), this.sub2 = e.toastRef.timeoutReset().subscribe(() => {
                                this.resetTimeout()
                            }), this.sub3 = e.toastRef.countDuplicate().subscribe(t => {
                                this.duplicatesCount = t
                            })
                        }
                        get displayStyle() {
                            if ("inactive" === this.state.value) return "none"
                        }
                        ngOnDestroy() {
                            this.sub.unsubscribe(), this.sub1.unsubscribe(), this.sub2.unsubscribe(), this.sub3.unsubscribe(), clearInterval(this.intervalId), clearTimeout(this.timeout)
                        }
                        activateToast() {
                            this.state = Object.assign(Object.assign({}, this.state), {
                                value: "active"
                            }), !0 !== this.options.disableTimeOut && "timeOut" !== this.options.disableTimeOut && this.options.timeOut && (this.outsideTimeout(() => this.remove(), this.options.timeOut), this.hideTime = (new Date).getTime() + this.options.timeOut, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10))
                        }
                        updateProgress() {
                            if (0 === this.width || 100 === this.width || !this.options.timeOut) return;
                            const t = (new Date).getTime();
                            this.width = (this.hideTime - t) / this.options.timeOut * 100, "increasing" === this.options.progressAnimation && (this.width = 100 - this.width), this.width <= 0 && (this.width = 0), this.width >= 100 && (this.width = 100)
                        }
                        resetTimeout() {
                            clearTimeout(this.timeout), clearInterval(this.intervalId), this.state = Object.assign(Object.assign({}, this.state), {
                                value: "active"
                            }), this.outsideTimeout(() => this.remove(), this.originalTimeout), this.options.timeOut = this.originalTimeout, this.hideTime = (new Date).getTime() + (this.options.timeOut || 0), this.width = -1, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10)
                        }
                        remove() {
                            "removed" !== this.state.value && (clearTimeout(this.timeout), this.state = Object.assign(Object.assign({}, this.state), {
                                value: "removed"
                            }), this.outsideTimeout(() => this.toastrService.remove(this.toastPackage.toastId), +this.toastPackage.config.easeTime))
                        }
                        tapToast() {
                            "removed" !== this.state.value && (this.toastPackage.triggerTap(), this.options.tapToDismiss && this.remove())
                        }
                        stickAround() {
                            "removed" !== this.state.value && (clearTimeout(this.timeout), this.options.timeOut = 0, this.hideTime = 0, clearInterval(this.intervalId), this.width = 0)
                        }
                        delayedHideToast() {
                            !0 !== this.options.disableTimeOut && "extendedTimeOut" !== this.options.disableTimeOut && 0 !== this.options.extendedTimeOut && "removed" !== this.state.value && (this.outsideTimeout(() => this.remove(), this.options.extendedTimeOut), this.options.timeOut = this.options.extendedTimeOut, this.hideTime = (new Date).getTime() + (this.options.timeOut || 0), this.width = -1, this.options.progressBar && this.outsideInterval(() => this.updateProgress(), 10))
                        }
                        outsideTimeout(t, e) {
                            this.ngZone ? this.ngZone.runOutsideAngular(() => this.timeout = setTimeout(() => this.runInsideAngular(t), e)) : this.timeout = setTimeout(() => t(), e)
                        }
                        outsideInterval(t, e) {
                            this.ngZone ? this.ngZone.runOutsideAngular(() => this.intervalId = setInterval(() => this.runInsideAngular(t), e)) : this.intervalId = setInterval(() => t(), e)
                        }
                        runInsideAngular(t) {
                            this.ngZone ? this.ngZone.run(() => t()) : t()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(D), n.Pb(_), n.Pb(n.B))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["", "toast-component", ""]
                        ],
                        hostVars: 5,
                        hostBindings: function(t, e) {
                            1 & t && n.cc("click", function() {
                                return e.tapToast()
                            })("mouseenter", function() {
                                return e.stickAround()
                            })("mouseleave", function() {
                                return e.delayedHideToast()
                            }), 2 & t && (n.Ac("@flyInOut", e.state), n.Fb(e.toastClasses), n.yc("display", e.displayStyle))
                        },
                        attrs: l,
                        decls: 5,
                        vars: 5,
                        consts: [
                            ["class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"],
                            [3, "class", 4, "ngIf"],
                            ["role", "alertdialog", "aria-live", "polite", 3, "class", "innerHTML", 4, "ngIf"],
                            ["role", "alertdialog", "aria-live", "polite", 3, "class", 4, "ngIf"],
                            [4, "ngIf"],
                            ["aria-label", "Close", 1, "toast-close-button", 3, "click"],
                            ["aria-hidden", "true"],
                            ["role", "alertdialog", "aria-live", "polite", 3, "innerHTML"],
                            ["role", "alertdialog", "aria-live", "polite"],
                            [1, "toast-progress"]
                        ],
                        template: function(t, e) {
                            1 & t && (n.Bc(0, c, 3, 0, "button", 0), n.Bc(1, u, 3, 5, "div", 1), n.Bc(2, d, 1, 3, "div", 2), n.Bc(3, p, 2, 4, "div", 3), n.Bc(4, f, 2, 2, "div", 4)), 2 & t && (n.lc("ngIf", e.options.closeButton), n.Db(1), n.lc("ngIf", e.title), n.Db(1), n.lc("ngIf", e.message && e.options.enableHtml), n.Db(1), n.lc("ngIf", e.message && !e.options.enableHtml), n.Db(1), n.lc("ngIf", e.options.progressBar))
                        },
                        directives: [o.l],
                        encapsulation: 2,
                        data: {
                            animation: [Object(s.m)("flyInOut", [Object(s.j)("inactive", Object(s.k)({
                                opacity: 0
                            })), Object(s.j)("active", Object(s.k)({
                                opacity: 1
                            })), Object(s.j)("removed", Object(s.k)({
                                opacity: 0
                            })), Object(s.l)("inactive => active", Object(s.e)("{{ easeTime }}ms {{ easing }}")), Object(s.l)("active => removed", Object(s.e)("{{ easeTime }}ms {{ easing }}"))])]
                        }
                    }), t
                })();
            const M = Object.assign(Object.assign({}, w), {
                toastComponent: I
            });
            let L = (() => {
                    class t {
                        static forRoot(e = {}) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: C,
                                    useValue: {
                                        default: M,
                                        config: e
                                    }
                                }]
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            [o.c]
                        ]
                    }), t
                })(),
                R = (() => {
                    class t {
                        constructor(t, e, i) {
                            this.toastrService = t, this.toastPackage = e, this.appRef = i, this.width = -1, this.toastClasses = "", this.state = "inactive", this.message = e.message, this.title = e.title, this.options = e.config, this.originalTimeout = e.config.timeOut, this.toastClasses = `${e.toastType} ${e.config.toastClass}`, this.sub = e.toastRef.afterActivate().subscribe(() => {
                                this.activateToast()
                            }), this.sub1 = e.toastRef.manualClosed().subscribe(() => {
                                this.remove()
                            }), this.sub2 = e.toastRef.timeoutReset().subscribe(() => {
                                this.resetTimeout()
                            }), this.sub3 = e.toastRef.countDuplicate().subscribe(t => {
                                this.duplicatesCount = t
                            })
                        }
                        get displayStyle() {
                            if ("inactive" === this.state) return "none"
                        }
                        ngOnDestroy() {
                            this.sub.unsubscribe(), this.sub1.unsubscribe(), this.sub2.unsubscribe(), this.sub3.unsubscribe(), clearInterval(this.intervalId), clearTimeout(this.timeout)
                        }
                        activateToast() {
                            this.state = "active", !0 !== this.options.disableTimeOut && "timeOut" !== this.options.disableTimeOut && this.options.timeOut && (this.timeout = setTimeout(() => {
                                this.remove()
                            }, this.options.timeOut), this.hideTime = (new Date).getTime() + this.options.timeOut, this.options.progressBar && (this.intervalId = setInterval(() => this.updateProgress(), 10))), this.options.onActivateTick && this.appRef.tick()
                        }
                        updateProgress() {
                            if (0 === this.width || 100 === this.width || !this.options.timeOut) return;
                            const t = (new Date).getTime();
                            this.width = (this.hideTime - t) / this.options.timeOut * 100, "increasing" === this.options.progressAnimation && (this.width = 100 - this.width), this.width <= 0 && (this.width = 0), this.width >= 100 && (this.width = 100)
                        }
                        resetTimeout() {
                            clearTimeout(this.timeout), clearInterval(this.intervalId), this.state = "active", this.options.timeOut = this.originalTimeout, this.timeout = setTimeout(() => this.remove(), this.originalTimeout), this.hideTime = (new Date).getTime() + (this.originalTimeout || 0), this.width = -1, this.options.progressBar && (this.intervalId = setInterval(() => this.updateProgress(), 10))
                        }
                        remove() {
                            "removed" !== this.state && (clearTimeout(this.timeout), this.state = "removed", this.timeout = setTimeout(() => this.toastrService.remove(this.toastPackage.toastId)))
                        }
                        tapToast() {
                            "removed" !== this.state && (this.toastPackage.triggerTap(), this.options.tapToDismiss && this.remove())
                        }
                        stickAround() {
                            "removed" !== this.state && (clearTimeout(this.timeout), this.options.timeOut = 0, this.hideTime = 0, clearInterval(this.intervalId), this.width = 0)
                        }
                        delayedHideToast() {
                            !0 !== this.options.disableTimeOut && "extendedTimeOut" !== this.options.disableTimeOut && 0 !== this.options.extendedTimeOut && "removed" !== this.state && (this.timeout = setTimeout(() => this.remove(), this.options.extendedTimeOut), this.options.timeOut = this.options.extendedTimeOut, this.hideTime = (new Date).getTime() + (this.options.timeOut || 0), this.width = -1, this.options.progressBar && (this.intervalId = setInterval(() => this.updateProgress(), 10)))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(D), n.Pb(_), n.Pb(n.g))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["", "toast-component", ""]
                        ],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            1 & t && n.cc("click", function() {
                                return e.tapToast()
                            })("mouseenter", function() {
                                return e.stickAround()
                            })("mouseleave", function() {
                                return e.delayedHideToast()
                            }), 2 & t && (n.Fb(e.toastClasses), n.yc("display", e.displayStyle))
                        },
                        attrs: l,
                        decls: 5,
                        vars: 5,
                        consts: [
                            ["class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"],
                            [3, "class", 4, "ngIf"],
                            ["role", "alert", "aria-live", "polite", 3, "class", "innerHTML", 4, "ngIf"],
                            ["role", "alert", "aria-live", "polite", 3, "class", 4, "ngIf"],
                            [4, "ngIf"],
                            ["aria-label", "Close", 1, "toast-close-button", 3, "click"],
                            ["aria-hidden", "true"],
                            ["role", "alert", "aria-live", "polite", 3, "innerHTML"],
                            ["role", "alert", "aria-live", "polite"],
                            [1, "toast-progress"]
                        ],
                        template: function(t, e) {
                            1 & t && (n.Bc(0, g, 3, 0, "button", 0), n.Bc(1, b, 3, 5, "div", 1), n.Bc(2, y, 1, 3, "div", 2), n.Bc(3, v, 2, 4, "div", 3), n.Bc(4, x, 2, 2, "div", 4)), 2 & t && (n.lc("ngIf", e.options.closeButton), n.Db(1), n.lc("ngIf", e.title), n.Db(1), n.lc("ngIf", e.message && e.options.enableHtml), n.Db(1), n.lc("ngIf", e.message && !e.options.enableHtml), n.Db(1), n.lc("ngIf", e.options.progressBar))
                        },
                        directives: [o.l],
                        encapsulation: 2
                    }), t
                })();
            Object.assign(Object.assign({}, w), {
                toastComponent: R
            })
        },
        "8LU1": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            }), i.d(e, "b", function() {
                return o
            }), i.d(e, "c", function() {
                return s
            }), i.d(e, "d", function() {
                return l
            }), i.d(e, "e", function() {
                return c
            }), i.d(e, "f", function() {
                return r
            });
            var n = i("fXoL");

            function s(t) {
                return null != t && "false" != `${t}`
            }

            function r(t, e = 0) {
                return a(t) ? Number(t) : e
            }

            function a(t) {
                return !isNaN(parseFloat(t)) && !isNaN(Number(t))
            }

            function o(t) {
                return Array.isArray(t) ? t : [t]
            }

            function l(t) {
                return null == t ? "" : "string" == typeof t ? t : `${t}px`
            }

            function c(t) {
                return t instanceof n.l ? t.nativeElement : t
            }
        },
        "8iEs": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            });
            var n = i("Jlqm"),
                s = i("EPzc"),
                r = i("g/MW"),
                a = i("xt23"),
                o = i("QoT1");

            function l(t, e = n.a) {
                return i = () => Object(o.a)(t, e), Object(s.b)((t, e) => {
                    let n = !1,
                        s = null,
                        o = null,
                        l = !1;
                    const c = () => {
                            if (null == o || o.unsubscribe(), o = null, n) {
                                n = !1;
                                const t = s;
                                s = null, e.next(t)
                            }
                            l && e.complete()
                        },
                        h = () => {
                            o = null, l && e.complete()
                        };
                    t.subscribe(new a.a(e, t => {
                        n = !0, s = t, o || Object(r.c)(i()).subscribe(o = new a.a(e, c, h))
                    }, () => {
                        l = !0, (!n || !o || o.closed) && e.complete()
                    }))
                });
                var i
            }
        },
        AGcZ: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("4krO"),
                s = i("fXoL");
            let r = (() => {
                class t {
                    loadDailyLineChartData() {
                        return Object(n.a)({
                            dailyData: {
                                mobile: [16, 46, 45, 12, 37, 16, 41, 13, 25, 22, 30],
                                desktop: [42, 60, 49, 50, 13, 15, 16, 57, 56, 27, 43],
                                tablet: [35, 25, 36, 30, 67, 35, 64, 12, 25, 36, 39]
                            },
                            weeklyData: {
                                mobile: [23, 31, 45, 10, 37, 67, 43, 63, 15, 22, 30],
                                desktop: [67, 60, 49, 50, 25, 15, 16, 57, 13, 27, 43],
                                tablet: [56, 48, 23, 48, 13, 35, 64, 12, 45, 36, 39]
                            },
                            monthlyData: {
                                mobile: [23, 11, 22, 27, 13, 22, 37, 21, 44, 22, 30],
                                desktop: [44, 55, 41, 67, 22, 43, 21, 41, 56, 27, 43],
                                tablet: [30, 25, 36, 30, 45, 35, 64, 52, 59, 36, 39]
                            },
                            labels: ["01/01/2003", "02/01/2003", "03/01/2003", "04/01/2003", "05/01/2003", "06/01/2003", "07/01/2003", "08/01/2003", "09/01/2003", "10/01/2003", "11/01/2003"]
                        })
                    }
                    loadPerformanceChartData() {
                        return Object(n.a)({
                            integration: 40,
                            sdk: 75
                        })
                    }
                    loadRevenueChartData() {
                        return Object(n.a)({
                            groupA: Math.round(100 * Math.random()),
                            groupB: Math.round(100 * Math.random()),
                            groupC: Math.round(100 * Math.random()),
                            groupD: Math.round(100 * Math.random())
                        })
                    }
                    loadServerChartData() {
                        return Object(n.a)({
                            firstServerChartData: [18107.85, 49128, 38122.9, 28965.5, 49340.7],
                            firstDataTitle: "45% / 78\xb0\u0421 / 78 Ghz",
                            secondServerChartData: [18423.7, 48423.5, 28514.3, 48481.85, 18487.7],
                            secondDataTitle: "57% / 45\xb0\u0421 / 54 Ghz",
                            thirdServerChartData: [17114.25, 27126.6, 47116.95, 37203.7, 17233.75],
                            thirdDataTitle: "87% / 55\xb0\u0421 / 76 Ghz",
                            dates: ["13 Nov 2017", "14 Nov 2017", "15 Nov 2017", "16 Nov 2017", "17 Nov 2017"]
                        })
                    }
                    loadSupportRequestData() {
                        return Object(n.a)([{
                            name: "Mark Otto",
                            email: "ottoto@wxample.com",
                            product: "ON the Road",
                            price: "$25 224.2",
                            date: "11 May 2017",
                            city: "Otsego",
                            status: "send"
                        }, {
                            name: "Jacob Thornton",
                            email: "thornton@wxample.com",
                            product: "HP Core i7",
                            price: "$1 254.2",
                            date: "4 Jun 2017",
                            city: "Fivepointville",
                            status: "send"
                        }, {
                            name: "Larry the Bird",
                            email: "bird@wxample.com",
                            product: "Air Pro",
                            price: "$1 570.0",
                            date: "27 Aug 2017",
                            city: "Leadville North",
                            status: "pending"
                        }, {
                            name: "Joseph May",
                            email: "josephmay@wxample.com",
                            product: "Version Control",
                            price: "$5 224.5",
                            date: "19 Feb 2018",
                            city: "Seaforth",
                            status: "declined"
                        }, {
                            name: "Peter Horadnia",
                            email: "horadnia@wxample.com",
                            product: "Let's Dance",
                            price: "$43 594.7",
                            date: "1 Mar 2018",
                            city: "Hanoverton",
                            status: "send"
                        }])
                    }
                    loadVisitsChartData() {
                        return Object(n.a)({
                            data: [7, 6, 3, 8, 10, 6, 7, 8, 3, 0, 7, 6, 2, 7, 4, 7, 3, 6, 2, 3, 8, 1, 0, 4, 9],
                            registration: "860",
                            signOut: "32",
                            rate: "3.25",
                            all: "12.678"
                        })
                    }
                    loadProjectsStatsData() {
                        return Object(n.a)({
                            lightBlue: {
                                daily: {
                                    name: "Light Blue",
                                    users: "199",
                                    percent: -3.7,
                                    registrations: "33",
                                    bounce: "3.25%",
                                    views: "330",
                                    series: [{
                                        name: "Net Profit",
                                        data: [210, 95, 155, 200, 61, 135, 63]
                                    }]
                                },
                                week: {
                                    name: "Light Blue",
                                    users: "1293",
                                    percent: 3.1,
                                    registrations: "233",
                                    bounce: "3.1%",
                                    views: "2310",
                                    series: [{
                                        name: "Net Profit",
                                        data: [65, 195, 135, 95, 72, 155, 200]
                                    }]
                                },
                                monthly: {
                                    name: "Light Blue",
                                    users: "9991",
                                    percent: -3.1,
                                    registrations: "725",
                                    bounce: "3.3%",
                                    views: "12301",
                                    series: [{
                                        name: "Net Profit",
                                        data: [152, 61, 142, 183, 74, 195, 210]
                                    }]
                                }
                            },
                            singApp: {
                                daily: {
                                    name: "Sing App",
                                    users: "121",
                                    percent: -3.2,
                                    registrations: "15",
                                    bounce: "3.01%",
                                    views: "302",
                                    series: [{
                                        name: "Net Profit",
                                        data: [135, 65, 192, 215, 85, 154, 75]
                                    }]
                                },
                                week: {
                                    name: "Sing App",
                                    users: "956",
                                    percent: 2.9,
                                    registrations: "295",
                                    bounce: "3.15%",
                                    views: "2401",
                                    series: [{
                                        name: "Net Profit",
                                        data: [78, 145, 186, 64, 78, 135, 224]
                                    }]
                                },
                                monthly: {
                                    name: "Sing App",
                                    users: "9982",
                                    percent: -3.23,
                                    registrations: "712",
                                    bounce: "3.2%",
                                    views: "12256",
                                    series: [{
                                        name: "Net Profit",
                                        data: [59, 75, 153, 194, 87, 205, 215]
                                    }]
                                }
                            },
                            rns: {
                                daily: {
                                    name: "RNS",
                                    users: "175",
                                    percent: -3.1,
                                    registrations: "31",
                                    bounce: "3.23%",
                                    views: "301",
                                    series: [{
                                        name: "Net Profit",
                                        data: [205, 81, 175, 192, 52, 199, 206]
                                    }]
                                },
                                week: {
                                    name: "RNS",
                                    users: "1395",
                                    percent: 3.21,
                                    registrations: "235",
                                    bounce: "3.23%",
                                    views: "2215",
                                    series: [{
                                        name: "Net Profit",
                                        data: [51, 186, 159, 201, 72, 86, 212]
                                    }]
                                },
                                monthly: {
                                    name: "RNS",
                                    users: "9125",
                                    percent: -3.3,
                                    registrations: "756",
                                    bounce: "3.1%",
                                    views: "12025",
                                    series: [{
                                        name: "Net Profit",
                                        data: [161, 84, 151, 201, 45, 196, 57]
                                    }]
                                }
                            }
                        })
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac,
                    providedIn: "root"
                }), t
            })()
        },
        BBcS: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("SIQg"),
                s = i("2QHy");

            function r(t) {
                return !!t && (t instanceof n.a || Object(s.a)(t.lift) && Object(s.a)(t.subscribe))
            }
        },
        BWBv: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("1M4b"),
                s = i("2QHy");

            function r(t, e) {
                return Object(s.a)(e) ? Object(n.a)(t, e, 1) : Object(n.a)(t, 1)
            }
        },
        BjsQ: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("EPzc");

            function s(t) {
                return Object(n.b)((e, i) => {
                    try {
                        e.subscribe(i)
                    } finally {
                        i.add(t)
                    }
                })
            }
        },
        CLjF: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("rdQv");
            const {
                isArray: s
            } = Array;

            function r(t) {
                return Object(n.a)(e => function(t, e) {
                    return s(e) ? t(...e) : t(e)
                }(t, e))
            }
        },
        CV0D: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            }), i.d(e, "b", function() {
                return c
            });
            var n = i("2nZi"),
                s = i("ujAs"),
                r = i.n(s),
                a = i("fXoL");
            const o = ["chart"];
            let l = (() => {
                class t {
                    constructor() {
                        this.autoUpdateSeries = !0
                    }
                    ngOnInit() {
                        n.a.schedule(() => {
                            this.createElement()
                        })
                    }
                    ngOnChanges(t) {
                        n.a.schedule(() => {
                            this.autoUpdateSeries && 0 === Object.keys(t).filter(t => "series" !== t).length ? this.updateSeries(this.series, !0) : this.createElement()
                        })
                    }
                    ngOnDestroy() {
                        this.chartObj && this.chartObj.destroy()
                    }
                    createElement() {
                        const t = {};
                        this.annotations && (t.annotations = this.annotations), this.chart && (t.chart = this.chart), this.colors && (t.colors = this.colors), this.dataLabels && (t.dataLabels = this.dataLabels), this.series && (t.series = this.series), this.stroke && (t.stroke = this.stroke), this.labels && (t.labels = this.labels), this.legend && (t.legend = this.legend), this.fill && (t.fill = this.fill), this.tooltip && (t.tooltip = this.tooltip), this.plotOptions && (t.plotOptions = this.plotOptions), this.responsive && (t.responsive = this.responsive), this.markers && (t.markers = this.markers), this.noData && (t.noData = this.noData), this.xaxis && (t.xaxis = this.xaxis), this.yaxis && (t.yaxis = this.yaxis), this.grid && (t.grid = this.grid), this.states && (t.states = this.states), this.title && (t.title = this.title), this.subtitle && (t.subtitle = this.subtitle), this.theme && (t.theme = this.theme), this.chartObj && this.chartObj.destroy(), this.chartObj = new r.a(this.chartElement.nativeElement, t), this.render()
                    }
                    render() {
                        return this.chartObj.render()
                    }
                    updateOptions(t, e, i, n) {
                        return this.chartObj.updateOptions(t, e, i, n)
                    }
                    updateSeries(t, e) {
                        this.chartObj.updateSeries(t, e)
                    }
                    appendSeries(t, e) {
                        this.chartObj.appendSeries(t, e)
                    }
                    appendData(t) {
                        this.chartObj.appendData(t)
                    }
                    toggleSeries(t) {
                        return this.chartObj.toggleSeries(t)
                    }
                    showSeries(t) {
                        this.chartObj.showSeries(t)
                    }
                    hideSeries(t) {
                        this.chartObj.hideSeries(t)
                    }
                    resetSeries() {
                        this.chartObj.resetSeries()
                    }
                    zoomX(t, e) {
                        this.chartObj.zoomX(t, e)
                    }
                    toggleDataPointSelection(t, e) {
                        this.chartObj.toggleDataPointSelection(t, e)
                    }
                    destroy() {
                        this.chartObj.destroy()
                    }
                    setLocale(t) {
                        this.chartObj.setLocale(t)
                    }
                    paper() {
                        this.chartObj.paper()
                    }
                    addXaxisAnnotation(t, e, i) {
                        this.chartObj.addXaxisAnnotation(t, e, i)
                    }
                    addYaxisAnnotation(t, e, i) {
                        this.chartObj.addYaxisAnnotation(t, e, i)
                    }
                    addPointAnnotation(t, e, i) {
                        this.chartObj.addPointAnnotation(t, e, i)
                    }
                    removeAnnotation(t, e) {
                        this.chartObj.removeAnnotation(t, e)
                    }
                    clearAnnotations(t) {
                        this.chartObj.clearAnnotations(t)
                    }
                    dataURI() {
                        return this.chartObj.dataURI()
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = a.Jb({
                    type: t,
                    selectors: [
                        ["apx-chart"]
                    ],
                    viewQuery: function(t, e) {
                        if (1 & t && a.Hc(o, 3), 2 & t) {
                            let t;
                            a.rc(t = a.dc()) && (e.chartElement = t.first)
                        }
                    },
                    inputs: {
                        autoUpdateSeries: "autoUpdateSeries",
                        chart: "chart",
                        annotations: "annotations",
                        colors: "colors",
                        dataLabels: "dataLabels",
                        series: "series",
                        stroke: "stroke",
                        labels: "labels",
                        legend: "legend",
                        markers: "markers",
                        noData: "noData",
                        fill: "fill",
                        tooltip: "tooltip",
                        plotOptions: "plotOptions",
                        responsive: "responsive",
                        xaxis: "xaxis",
                        yaxis: "yaxis",
                        grid: "grid",
                        states: "states",
                        title: "title",
                        subtitle: "subtitle",
                        theme: "theme"
                    },
                    features: [a.Bb],
                    decls: 2,
                    vars: 0,
                    consts: [
                        ["chart", ""]
                    ],
                    template: function(t, e) {
                        1 & t && a.Qb(0, "div", null, 0)
                    },
                    styles: [""]
                }), t
            })();
            window.ApexCharts = r.a;
            let c = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = a.Nb({
                    type: t
                }), t.\u0275inj = a.Mb({
                    imports: [
                        []
                    ]
                }), t
            })()
        },
        CZFc: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("oXA7"),
                s = i("iu6b");
            class r extends n.a {
                constructor(t = 1 / 0, e = 1 / 0, i = s.a) {
                    super(), this._bufferSize = t, this._windowTime = e, this._timestampProvider = i, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = e === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, e)
                }
                next(t) {
                    const {
                        isStopped: e,
                        _buffer: i,
                        _infiniteTimeWindow: n,
                        _timestampProvider: s,
                        _windowTime: r
                    } = this;
                    e || (i.push(t), !n && i.push(s.now() + r)), this._trimBuffer(), super.next(t)
                }
                _subscribe(t) {
                    this._throwIfClosed(), this._trimBuffer();
                    const e = this._innerSubscribe(t),
                        {
                            _infiniteTimeWindow: i,
                            _buffer: n
                        } = this,
                        s = n.slice();
                    for (let r = 0; r < s.length && !t.closed; r += i ? 1 : 2) t.next(s[r]);
                    return this._checkFinalizedStatuses(t), e
                }
                _trimBuffer() {
                    const {
                        _bufferSize: t,
                        _timestampProvider: e,
                        _buffer: i,
                        _infiniteTimeWindow: n
                    } = this, s = (n ? 1 : 2) * t;
                    if (t < 1 / 0 && s < i.length && i.splice(0, i.length - s), !n) {
                        const t = e.now();
                        let n = 0;
                        for (let e = 1; e < i.length && i[e] <= t; e += 2) n = e;
                        n && i.splice(0, n + 1)
                    }
                }
            }
        },
        DKVz: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return D
            }), i.d(e, "b", function() {
                return I
            });
            var n = i("fXoL");

            function s(t, e, i, n) {
                return new(i || (i = Promise))(function(s, r) {
                    function a(t) {
                        try {
                            l(n.next(t))
                        } catch (e) {
                            r(e)
                        }
                    }

                    function o(t) {
                        try {
                            l(n.throw(t))
                        } catch (e) {
                            r(e)
                        }
                    }

                    function l(t) {
                        var e;
                        t.done ? s(t.value) : (e = t.value, e instanceof i ? e : new i(function(t) {
                            t(e)
                        })).then(a, o)
                    }
                    l((n = n.apply(t, e || [])).next())
                })
            }
            var r = function() {
                    if ("undefined" != typeof Map) return Map;

                    function t(t, e) {
                        var i = -1;
                        return t.some(function(t, n) {
                            return t[0] === e && (i = n, !0)
                        }), i
                    }
                    return function() {
                        function e() {
                            this.__entries__ = []
                        }
                        return Object.defineProperty(e.prototype, "size", {
                            get: function() {
                                return this.__entries__.length
                            },
                            enumerable: !0,
                            configurable: !0
                        }), e.prototype.get = function(e) {
                            var i = t(this.__entries__, e),
                                n = this.__entries__[i];
                            return n && n[1]
                        }, e.prototype.set = function(e, i) {
                            var n = t(this.__entries__, e);
                            ~n ? this.__entries__[n][1] = i : this.__entries__.push([e, i])
                        }, e.prototype.delete = function(e) {
                            var i = this.__entries__,
                                n = t(i, e);
                            ~n && i.splice(n, 1)
                        }, e.prototype.has = function(e) {
                            return !!~t(this.__entries__, e)
                        }, e.prototype.clear = function() {
                            this.__entries__.splice(0)
                        }, e.prototype.forEach = function(t, e) {
                            void 0 === e && (e = null);
                            for (var i = 0, n = this.__entries__; i < n.length; i++) {
                                var s = n[i];
                                t.call(e, s[1], s[0])
                            }
                        }, e
                    }()
                }(),
                a = "undefined" != typeof window && "undefined" != typeof document && window.document === document,
                o = "undefined" != typeof global && global.Math === Math ? global : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(),
                l = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(o) : function(t) {
                    return setTimeout(function() {
                        return t(Date.now())
                    }, 1e3 / 60)
                },
                c = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
                h = "undefined" != typeof MutationObserver,
                u = function() {
                    function t() {
                        this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = function(t, e) {
                            var i = !1,
                                n = !1,
                                s = 0;

                            function r() {
                                i && (i = !1, t()), n && o()
                            }

                            function a() {
                                l(r)
                            }

                            function o() {
                                var t = Date.now();
                                if (i) {
                                    if (t - s < 2) return;
                                    n = !0
                                } else i = !0, n = !1, setTimeout(a, 20);
                                s = t
                            }
                            return o
                        }(this.refresh.bind(this))
                    }
                    return t.prototype.addObserver = function(t) {
                        ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_()
                    }, t.prototype.removeObserver = function(t) {
                        var e = this.observers_,
                            i = e.indexOf(t);
                        ~i && e.splice(i, 1), !e.length && this.connected_ && this.disconnect_()
                    }, t.prototype.refresh = function() {
                        this.updateObservers_() && this.refresh()
                    }, t.prototype.updateObservers_ = function() {
                        var t = this.observers_.filter(function(t) {
                            return t.gatherActive(), t.hasActive()
                        });
                        return t.forEach(function(t) {
                            return t.broadcastActive()
                        }), t.length > 0
                    }, t.prototype.connect_ = function() {
                        a && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), h ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
                            attributes: !0,
                            childList: !0,
                            characterData: !0,
                            subtree: !0
                        })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0)
                    }, t.prototype.disconnect_ = function() {
                        a && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1)
                    }, t.prototype.onTransitionEnd_ = function(t) {
                        var e = t.propertyName,
                            i = void 0 === e ? "" : e;
                        c.some(function(t) {
                            return !!~i.indexOf(t)
                        }) && this.refresh()
                    }, t.getInstance = function() {
                        return this.instance_ || (this.instance_ = new t), this.instance_
                    }, t.instance_ = null, t
                }(),
                d = function(t, e) {
                    for (var i = 0, n = Object.keys(e); i < n.length; i++) {
                        var s = n[i];
                        Object.defineProperty(t, s, {
                            value: e[s],
                            enumerable: !1,
                            writable: !1,
                            configurable: !0
                        })
                    }
                    return t
                },
                p = function(t) {
                    return t && t.ownerDocument && t.ownerDocument.defaultView || o
                },
                f = y(0, 0, 0, 0);

            function g(t) {
                return parseFloat(t) || 0
            }

            function m(t) {
                for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
                return e.reduce(function(e, i) {
                    return e + g(t["border-" + i + "-width"])
                }, 0)
            }
            var b = "undefined" != typeof SVGGraphicsElement ? function(t) {
                return t instanceof p(t).SVGGraphicsElement
            } : function(t) {
                return t instanceof p(t).SVGElement && "function" == typeof t.getBBox
            };

            function y(t, e, i, n) {
                return {
                    x: t,
                    y: e,
                    width: i,
                    height: n
                }
            }
            var v = function() {
                    function t(t) {
                        this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = y(0, 0, 0, 0), this.target = t
                    }
                    return t.prototype.isActive = function() {
                        var t, e = (t = this.target, a ? b(t) ? function(t) {
                            var e = t.getBBox();
                            return y(0, 0, e.width, e.height)
                        }(t) : function(t) {
                            var e = t.clientWidth,
                                i = t.clientHeight;
                            if (!e && !i) return f;
                            var n = p(t).getComputedStyle(t),
                                s = function(t) {
                                    for (var e = {}, i = 0, n = ["top", "right", "bottom", "left"]; i < n.length; i++) {
                                        var s = n[i];
                                        e[s] = g(t["padding-" + s])
                                    }
                                    return e
                                }(n),
                                r = s.left + s.right,
                                a = s.top + s.bottom,
                                o = g(n.width),
                                l = g(n.height);
                            if ("border-box" === n.boxSizing && (Math.round(o + r) !== e && (o -= m(n, "left", "right") + r), Math.round(l + a) !== i && (l -= m(n, "top", "bottom") + a)), ! function(t) {
                                    return t === p(t).document.documentElement
                                }(t)) {
                                var c = Math.round(o + r) - e,
                                    h = Math.round(l + a) - i;
                                1 !== Math.abs(c) && (o -= c), 1 !== Math.abs(h) && (l -= h)
                            }
                            return y(s.left, s.top, o, l)
                        }(t) : f);
                        return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
                    }, t.prototype.broadcastRect = function() {
                        var t = this.contentRect_;
                        return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t
                    }, t
                }(),
                x = function(t, e) {
                    var i, n, s, r, a, o, l, c = (n = (i = e).x, s = i.y, r = i.width, a = i.height, o = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, l = Object.create(o.prototype), d(l, {
                        x: n,
                        y: s,
                        width: r,
                        height: a,
                        top: s,
                        right: n + r,
                        bottom: a + s,
                        left: n
                    }), l);
                    d(this, {
                        target: t,
                        contentRect: c
                    })
                },
                _ = function() {
                    function t(t, e, i) {
                        if (this.activeObservations_ = [], this.observations_ = new r, "function" != typeof t) throw new TypeError("The callback provided as parameter 1 is not a function.");
                        this.callback_ = t, this.controller_ = e, this.callbackCtx_ = i
                    }
                    return t.prototype.observe = function(t) {
                        if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                        if ("undefined" != typeof Element && Element instanceof Object) {
                            if (!(t instanceof p(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                            var e = this.observations_;
                            e.has(t) || (e.set(t, new v(t)), this.controller_.addObserver(this), this.controller_.refresh())
                        }
                    }, t.prototype.unobserve = function(t) {
                        if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                        if ("undefined" != typeof Element && Element instanceof Object) {
                            if (!(t instanceof p(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                            var e = this.observations_;
                            e.has(t) && (e.delete(t), e.size || this.controller_.removeObserver(this))
                        }
                    }, t.prototype.disconnect = function() {
                        this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
                    }, t.prototype.gatherActive = function() {
                        var t = this;
                        this.clearActive(), this.observations_.forEach(function(e) {
                            e.isActive() && t.activeObservations_.push(e)
                        })
                    }, t.prototype.broadcastActive = function() {
                        if (this.hasActive()) {
                            var t = this.callbackCtx_,
                                e = this.activeObservations_.map(function(t) {
                                    return new x(t.target, t.broadcastRect())
                                });
                            this.callback_.call(t, e, t), this.clearActive()
                        }
                    }, t.prototype.clearActive = function() {
                        this.activeObservations_.splice(0)
                    }, t.prototype.hasActive = function() {
                        return this.activeObservations_.length > 0
                    }, t
                }(),
                w = "undefined" != typeof WeakMap ? new WeakMap : new r,
                C = function t(e) {
                    if (!(this instanceof t)) throw new TypeError("Cannot call a class as a function.");
                    if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                    var i = u.getInstance(),
                        n = new _(e, i, this);
                    w.set(this, n)
                };
            ["observe", "unobserve", "disconnect"].forEach(function(t) {
                C.prototype[t] = function() {
                    var e;
                    return (e = w.get(this))[t].apply(e, arguments)
                }
            });
            var k = void 0 !== o.ResizeObserver ? o.ResizeObserver : C,
                S = i("4krO"),
                A = i("eX4W"),
                O = i("SIQg"),
                E = i("1q39");
            class P {
                constructor(t) {
                    this.changes = t
                }
                static of (t) {
                    return new P(t)
                }
                notEmpty(t) {
                    if (this.changes[t]) {
                        const e = this.changes[t].currentValue;
                        if (null != e) return Object(S.a)(e)
                    }
                    return A.a
                }
                has(t) {
                    if (this.changes[t]) {
                        const e = this.changes[t].currentValue;
                        return Object(S.a)(e)
                    }
                    return A.a
                }
                notFirst(t) {
                    if (this.changes[t] && !this.changes[t].isFirstChange()) {
                        const e = this.changes[t].currentValue;
                        return Object(S.a)(e)
                    }
                    return A.a
                }
                notFirstAndEmpty(t) {
                    if (this.changes[t] && !this.changes[t].isFirstChange()) {
                        const e = this.changes[t].currentValue;
                        if (null != e) return Object(S.a)(e)
                    }
                    return A.a
                }
            }
            const T = new n.s("NGX_ECHARTS_CONFIG");
            let D = (() => {
                    class t {
                        constructor(t, e, i) {
                            this.el = e, this.ngZone = i, this.autoResize = !0, this.loadingType = "default", this.chartInit = new n.o, this.optionsError = new n.o, this.chartClick = this.createLazyEvent("click"), this.chartDblClick = this.createLazyEvent("dblclick"), this.chartMouseDown = this.createLazyEvent("mousedown"), this.chartMouseMove = this.createLazyEvent("mousemove"), this.chartMouseUp = this.createLazyEvent("mouseup"), this.chartMouseOver = this.createLazyEvent("mouseover"), this.chartMouseOut = this.createLazyEvent("mouseout"), this.chartGlobalOut = this.createLazyEvent("globalout"), this.chartContextMenu = this.createLazyEvent("contextmenu"), this.chartLegendSelectChanged = this.createLazyEvent("legendselectchanged"), this.chartLegendSelected = this.createLazyEvent("legendselected"), this.chartLegendUnselected = this.createLazyEvent("legendunselected"), this.chartLegendScroll = this.createLazyEvent("legendscroll"), this.chartDataZoom = this.createLazyEvent("datazoom"), this.chartDataRangeSelected = this.createLazyEvent("datarangeselected"), this.chartTimelineChanged = this.createLazyEvent("timelinechanged"), this.chartTimelinePlayChanged = this.createLazyEvent("timelineplaychanged"), this.chartRestore = this.createLazyEvent("restore"), this.chartDataViewChanged = this.createLazyEvent("dataviewchanged"), this.chartMagicTypeChanged = this.createLazyEvent("magictypechanged"), this.chartPieSelectChanged = this.createLazyEvent("pieselectchanged"), this.chartPieSelected = this.createLazyEvent("pieselected"), this.chartPieUnselected = this.createLazyEvent("pieunselected"), this.chartMapSelectChanged = this.createLazyEvent("mapselectchanged"), this.chartMapSelected = this.createLazyEvent("mapselected"), this.chartMapUnselected = this.createLazyEvent("mapunselected"), this.chartAxisAreaSelected = this.createLazyEvent("axisareaselected"), this.chartFocusNodeAdjacency = this.createLazyEvent("focusnodeadjacency"), this.chartUnfocusNodeAdjacency = this.createLazyEvent("unfocusnodeadjacency"), this.chartBrush = this.createLazyEvent("brush"), this.chartBrushEnd = this.createLazyEvent("brushend"), this.chartBrushSelected = this.createLazyEvent("brushselected"), this.chartRendered = this.createLazyEvent("rendered"), this.chartFinished = this.createLazyEvent("finished"), this.animationFrameID = null, this.echarts = t.echarts
                        }
                        ngOnChanges(t) {
                            const e = P.of(t);
                            e.notFirstAndEmpty("options").subscribe(t => this.onOptionsChange(t)), e.notFirstAndEmpty("merge").subscribe(t => this.setOption(t)), e.has("loading").subscribe(t => this.toggleLoading(!!t)), e.notFirst("theme").subscribe(() => this.refreshChart())
                        }
                        ngOnInit() {
                            this.autoResize && (this.resizeSub = new k(() => {
                                this.animationFrameID = window.requestAnimationFrame(() => this.resize())
                            }), this.resizeSub.observe(this.el.nativeElement))
                        }
                        ngOnDestroy() {
                            this.resizeSub && (this.resizeSub.unobserve(this.el.nativeElement), window.cancelAnimationFrame(this.animationFrameID)), this.dispose()
                        }
                        ngAfterViewInit() {
                            setTimeout(() => this.initChart())
                        }
                        dispose() {
                            this.chart && (this.chart.isDisposed() || this.chart.dispose(), this.chart = null)
                        }
                        resize() {
                            this.chart && this.chart.resize()
                        }
                        toggleLoading(t) {
                            this.chart && (t ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading())
                        }
                        setOption(t, e) {
                            if (this.chart) try {
                                this.chart.setOption(t, e)
                            } catch (i) {
                                console.error(i), this.optionsError.emit(i)
                            }
                        }
                        refreshChart() {
                            return s(this, void 0, void 0, function*() {
                                this.dispose(), yield this.initChart()
                            })
                        }
                        createChart() {
                            const t = this.el.nativeElement;
                            if (window && window.getComputedStyle) {
                                const e = window.getComputedStyle(t, null).getPropertyValue("height");
                                e && "0px" !== e || t.style.height && "0px" !== t.style.height || (t.style.height = "400px")
                            }
                            return this.ngZone.runOutsideAngular(() => ("function" == typeof this.echarts ? this.echarts : () => Promise.resolve(this.echarts))().then(({
                                init: e
                            }) => e(t, this.theme, this.initOpts)))
                        }
                        initChart() {
                            return s(this, void 0, void 0, function*() {
                                yield this.onOptionsChange(this.options), this.merge && this.chart && this.setOption(this.merge)
                            })
                        }
                        onOptionsChange(t) {
                            return s(this, void 0, void 0, function*() {
                                t && (this.chart || (this.chart = yield this.createChart(), this.chartInit.emit(this.chart)), this.setOption(this.options, !0))
                            })
                        }
                        createLazyEvent(t) {
                            return this.chartInit.pipe(Object(E.a)(e => new O.a(i => (e.on(t, t => this.ngZone.run(() => i.next(t))), () => {
                                this.chart && (this.chart.isDisposed() || e.off(t))
                            }))))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(T), n.Pb(n.l), n.Pb(n.B))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["echarts"],
                            ["", "echarts", ""]
                        ],
                        inputs: {
                            autoResize: "autoResize",
                            loadingType: "loadingType",
                            options: "options",
                            theme: "theme",
                            loading: "loading",
                            initOpts: "initOpts",
                            merge: "merge",
                            loadingOpts: "loadingOpts"
                        },
                        outputs: {
                            chartInit: "chartInit",
                            optionsError: "optionsError",
                            chartClick: "chartClick",
                            chartDblClick: "chartDblClick",
                            chartMouseDown: "chartMouseDown",
                            chartMouseMove: "chartMouseMove",
                            chartMouseUp: "chartMouseUp",
                            chartMouseOver: "chartMouseOver",
                            chartMouseOut: "chartMouseOut",
                            chartGlobalOut: "chartGlobalOut",
                            chartContextMenu: "chartContextMenu",
                            chartLegendSelectChanged: "chartLegendSelectChanged",
                            chartLegendSelected: "chartLegendSelected",
                            chartLegendUnselected: "chartLegendUnselected",
                            chartLegendScroll: "chartLegendScroll",
                            chartDataZoom: "chartDataZoom",
                            chartDataRangeSelected: "chartDataRangeSelected",
                            chartTimelineChanged: "chartTimelineChanged",
                            chartTimelinePlayChanged: "chartTimelinePlayChanged",
                            chartRestore: "chartRestore",
                            chartDataViewChanged: "chartDataViewChanged",
                            chartMagicTypeChanged: "chartMagicTypeChanged",
                            chartPieSelectChanged: "chartPieSelectChanged",
                            chartPieSelected: "chartPieSelected",
                            chartPieUnselected: "chartPieUnselected",
                            chartMapSelectChanged: "chartMapSelectChanged",
                            chartMapSelected: "chartMapSelected",
                            chartMapUnselected: "chartMapUnselected",
                            chartAxisAreaSelected: "chartAxisAreaSelected",
                            chartFocusNodeAdjacency: "chartFocusNodeAdjacency",
                            chartUnfocusNodeAdjacency: "chartUnfocusNodeAdjacency",
                            chartBrush: "chartBrush",
                            chartBrushEnd: "chartBrushEnd",
                            chartBrushSelected: "chartBrushSelected",
                            chartRendered: "chartRendered",
                            chartFinished: "chartFinished"
                        },
                        exportAs: ["echarts"],
                        features: [n.Bb]
                    }), t
                })(),
                I = (() => {
                    class t {
                        static forRoot(e) {
                            return {
                                ngModule: t,
                                providers: [{
                                    provide: T,
                                    useValue: e
                                }]
                            }
                        }
                        static forChild() {
                            return {
                                ngModule: t
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            []
                        ]
                    }), t
                })()
        },
        EPzc: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            }), i.d(e, "b", function() {
                return r
            });
            var n = i("2QHy");

            function s(t) {
                return Object(n.a)(null == t ? void 0 : t.lift)
            }

            function r(t) {
                return e => {
                    if (s(e)) return e.lift(function(e) {
                        try {
                            return t(e, this)
                        } catch (i) {
                            this.error(i)
                        }
                    });
                    throw new TypeError("Unable to lift unknown Observable type")
                }
            }
        },
        FKr1: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return E
            }), i.d(e, "b", function() {
                return Z
            }), i.d(e, "c", function() {
                return X
            }), i.d(e, "d", function() {
                return z
            }), i.d(e, "e", function() {
                return _
            }), i.d(e, "f", function() {
                return P
            }), i.d(e, "g", function() {
                return I
            }), i.d(e, "h", function() {
                return J
            }), i.d(e, "i", function() {
                return it
            }), i.d(e, "j", function() {
                return H
            }), i.d(e, "k", function() {
                return U
            }), i.d(e, "l", function() {
                return V
            }), i.d(e, "m", function() {
                return B
            }), i.d(e, "n", function() {
                return N
            }), i.d(e, "o", function() {
                return tt
            }), i.d(e, "p", function() {
                return et
            }), i.d(e, "q", function() {
                return C
            }), i.d(e, "r", function() {
                return k
            }), i.d(e, "s", function() {
                return w
            }), i.d(e, "t", function() {
                return A
            }), i.d(e, "u", function() {
                return O
            }), i.d(e, "v", function() {
                return S
            }), i.d(e, "w", function() {
                return T
            });
            var n = i("fXoL"),
                s = i("u47x"),
                r = i("cH1L");
            const a = new n.R("11.2.12");
            var o = i("ofXK"),
                l = i("8LU1"),
                c = i("oXA7"),
                h = i("SIQg"),
                u = i("nLfN"),
                d = i("zzs5"),
                p = i("R1ws"),
                f = i("FtGj");

            function g(t, e) {
                if (1 & t && n.Qb(0, "mat-pseudo-checkbox", 4), 2 & t) {
                    const t = n.gc();
                    n.lc("state", t.selected ? "checked" : "unchecked")("disabled", t.disabled)
                }
            }

            function m(t, e) {
                if (1 & t && (n.Vb(0, "span", 5), n.Cc(1), n.Ub()), 2 & t) {
                    const t = n.gc();
                    n.Db(1), n.Ec("(", t.group.label, ")")
                }
            }
            const b = ["*"],
                y = new n.R("11.2.12"),
                v = new n.s("mat-sanity-checks", {
                    providedIn: "root",
                    factory: function() {
                        return !0
                    }
                });
            let x, _ = (() => {
                class t {
                    constructor(t, e, i) {
                        this._hasDoneGlobalChecks = !1, this._document = i, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0)
                    }
                    _getWindow() {
                        const t = this._document.defaultView || window;
                        return "object" == typeof t && t ? t : null
                    }
                    _checksAreEnabled() {
                        return Object(n.Y)() && !this._isTestEnv()
                    }
                    _isTestEnv() {
                        const t = this._getWindow();
                        return t && (t.__karma__ || t.jasmine)
                    }
                    _checkDoctypeIsDefined() {
                        this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype) && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")
                    }
                    _checkThemeIsPresent() {
                        if (!this._checksAreEnabled() || !1 === this._sanityChecks || !this._sanityChecks.theme || !this._document.body || "function" != typeof getComputedStyle) return;
                        const t = this._document.createElement("div");
                        t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t);
                        const e = getComputedStyle(t);
                        e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t)
                    }
                    _checkCdkVersionMatch() {
                        this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && y.full !== a.full && console.warn("The Angular Material version (" + y.full + ") does not match the Angular CDK version (" + a.full + ").\nPlease ensure the versions of these two packages exactly match.")
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(s.h), n.Zb(v, 8), n.Zb(o.d))
                }, t.\u0275mod = n.Nb({
                    type: t
                }), t.\u0275inj = n.Mb({
                    imports: [
                        [r.a], r.a
                    ]
                }), t
            })();

            function w(t) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this._disabled = !1
                    }
                    get disabled() {
                        return this._disabled
                    }
                    set disabled(t) {
                        this._disabled = Object(l.c)(t)
                    }
                }
            }

            function C(t, e) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this.defaultColor = e, this.color = e
                    }
                    get color() {
                        return this._color
                    }
                    set color(t) {
                        const e = t || this.defaultColor;
                        e !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), e && this._elementRef.nativeElement.classList.add(`mat-${e}`), this._color = e)
                    }
                }
            }

            function k(t) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this._disableRipple = !1
                    }
                    get disableRipple() {
                        return this._disableRipple
                    }
                    set disableRipple(t) {
                        this._disableRipple = Object(l.c)(t)
                    }
                }
            }

            function S(t, e = 0) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this._tabIndex = e, this.defaultTabIndex = e
                    }
                    get tabIndex() {
                        return this.disabled ? -1 : this._tabIndex
                    }
                    set tabIndex(t) {
                        this._tabIndex = null != t ? Object(l.f)(t) : this.defaultTabIndex
                    }
                }
            }

            function A(t) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this.errorState = !1, this.stateChanges = new c.a
                    }
                    updateErrorState() {
                        const t = this.errorState,
                            e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm);
                        e !== t && (this.errorState = e, this.stateChanges.next())
                    }
                }
            }

            function O(t) {
                return class extends t {
                    constructor(...t) {
                        super(...t), this._isInitialized = !1, this._pendingSubscribers = [], this.initialized = new h.a(t => {
                            this._isInitialized ? this._notifySubscriber(t) : this._pendingSubscribers.push(t)
                        })
                    }
                    _markInitialized() {
                        this._isInitialized = !0, this._pendingSubscribers.forEach(this._notifySubscriber), this._pendingSubscribers = null
                    }
                    _notifySubscriber(t) {
                        t.next(), t.complete()
                    }
                }
            }
            try {
                x = "undefined" != typeof Intl
            } catch (nt) {
                x = !1
            }
            let E = (() => {
                    class t {
                        isErrorState(t, e) {
                            return !!(t && t.invalid && (t.touched || e && e.submitted))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Object(n.Lb)({
                        factory: function() {
                            return new t
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                P = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "mat-line", ""],
                            ["", "matLine", ""]
                        ],
                        hostAttrs: [1, "mat-line"]
                    }), t
                })();

            function T(t, e, i = "mat") {
                t.changes.pipe(Object(d.a)(t)).subscribe(({
                    length: t
                }) => {
                    D(e, `${i}-2-line`, !1), D(e, `${i}-3-line`, !1), D(e, `${i}-multi-line`, !1), 2 === t || 3 === t ? D(e, `${i}-${t}-line`, !0) : t > 3 && D(e, `${i}-multi-line`, !0)
                })
            }

            function D(t, e, i) {
                const n = t.nativeElement.classList;
                i ? n.add(e) : n.remove(e)
            }
            let I = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = n.Nb({
                    type: t
                }), t.\u0275inj = n.Mb({
                    imports: [
                        [_], _
                    ]
                }), t
            })();
            class M {
                constructor(t, e, i) {
                    this._renderer = t, this.element = e, this.config = i, this.state = 3
                }
                fadeOut() {
                    this._renderer.fadeOutRipple(this)
                }
            }
            const L = {
                    enterDuration: 450,
                    exitDuration: 400
                },
                R = Object(u.f)({
                    passive: !0
                }),
                j = ["mousedown", "touchstart"],
                F = ["mouseup", "mouseleave", "touchend", "touchcancel"];
            class N {
                constructor(t, e, i, n) {
                    this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, n.isBrowser && (this._containerElement = Object(l.e)(i))
                }
                fadeInRipple(t, e, i = {}) {
                    const n = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(),
                        s = Object.assign(Object.assign({}, L), i.animation);
                    i.centered && (t = n.left + n.width / 2, e = n.top + n.height / 2);
                    const r = i.radius || function(t, e, i) {
                            const n = Math.max(Math.abs(t - i.left), Math.abs(t - i.right)),
                                s = Math.max(Math.abs(e - i.top), Math.abs(e - i.bottom));
                            return Math.sqrt(n * n + s * s)
                        }(t, e, n),
                        a = t - n.left,
                        o = e - n.top,
                        l = s.enterDuration,
                        c = document.createElement("div");
                    c.classList.add("mat-ripple-element"), c.style.left = a - r + "px", c.style.top = o - r + "px", c.style.height = 2 * r + "px", c.style.width = 2 * r + "px", null != i.color && (c.style.backgroundColor = i.color), c.style.transitionDuration = `${l}ms`, this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)";
                    const h = new M(this, c, i);
                    return h.state = 0, this._activeRipples.add(h), i.persistent || (this._mostRecentTransientRipple = h), this._runTimeoutOutsideZone(() => {
                        const t = h === this._mostRecentTransientRipple;
                        h.state = 1, i.persistent || t && this._isPointerDown || h.fadeOut()
                    }, l), h
                }
                fadeOutRipple(t) {
                    const e = this._activeRipples.delete(t);
                    if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return;
                    const i = t.element,
                        n = Object.assign(Object.assign({}, L), t.config.animation);
                    i.style.transitionDuration = `${n.exitDuration}ms`, i.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => {
                        t.state = 3, i.parentNode.removeChild(i)
                    }, n.exitDuration)
                }
                fadeOutAll() {
                    this._activeRipples.forEach(t => t.fadeOut())
                }
                fadeOutAllNonPersistent() {
                    this._activeRipples.forEach(t => {
                        t.config.persistent || t.fadeOut()
                    })
                }
                setupTriggerEvents(t) {
                    const e = Object(l.e)(t);
                    e && e !== this._triggerElement && (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(j))
                }
                handleEvent(t) {
                    "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(F), this._pointerUpEventsRegistered = !0)
                }
                _onMousedown(t) {
                    const e = Object(s.j)(t),
                        i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800;
                    this._target.rippleDisabled || e || i || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig))
                }
                _onTouchStart(t) {
                    if (!this._target.rippleDisabled && !Object(s.k)(t)) {
                        this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0;
                        const e = t.changedTouches;
                        for (let t = 0; t < e.length; t++) this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig)
                    }
                }
                _onPointerUp() {
                    this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => {
                        !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut()
                    }))
                }
                _runTimeoutOutsideZone(t, e = 0) {
                    this._ngZone.runOutsideAngular(() => setTimeout(t, e))
                }
                _registerEvents(t) {
                    this._ngZone.runOutsideAngular(() => {
                        t.forEach(t => {
                            this._triggerElement.addEventListener(t, this, R)
                        })
                    })
                }
                _removeTriggerEvents() {
                    this._triggerElement && (j.forEach(t => {
                        this._triggerElement.removeEventListener(t, this, R)
                    }), this._pointerUpEventsRegistered && F.forEach(t => {
                        this._triggerElement.removeEventListener(t, this, R)
                    }))
                }
            }
            const z = new n.s("mat-ripple-global-options");
            let V = (() => {
                    class t {
                        constructor(t, e, i, n, s) {
                            this._elementRef = t, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = n || {}, this._rippleRenderer = new N(this, e, t, i)
                        }
                        get disabled() {
                            return this._disabled
                        }
                        set disabled(t) {
                            t && this.fadeOutAllNonPersistent(), this._disabled = t, this._setupTriggerEventsIfEnabled()
                        }
                        get trigger() {
                            return this._trigger || this._elementRef.nativeElement
                        }
                        set trigger(t) {
                            this._trigger = t, this._setupTriggerEventsIfEnabled()
                        }
                        ngOnInit() {
                            this._isInitialized = !0, this._setupTriggerEventsIfEnabled()
                        }
                        ngOnDestroy() {
                            this._rippleRenderer._removeTriggerEvents()
                        }
                        fadeOutAll() {
                            this._rippleRenderer.fadeOutAll()
                        }
                        fadeOutAllNonPersistent() {
                            this._rippleRenderer.fadeOutAllNonPersistent()
                        }
                        get rippleConfig() {
                            return {
                                centered: this.centered,
                                radius: this.radius,
                                color: this.color,
                                animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? {
                                    enterDuration: 0,
                                    exitDuration: 0
                                } : {}), this.animation),
                                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
                            }
                        }
                        get rippleDisabled() {
                            return this.disabled || !!this._globalOptions.disabled
                        }
                        _setupTriggerEventsIfEnabled() {
                            !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger)
                        }
                        launch(t, e = 0, i) {
                            return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign(Object.assign({}, this.rippleConfig), i)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), t))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(n.B), n.Pb(u.a), n.Pb(z, 8), n.Pb(p.a, 8))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "mat-ripple", ""],
                            ["", "matRipple", ""]
                        ],
                        hostAttrs: [1, "mat-ripple"],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            2 & t && n.Hb("mat-ripple-unbounded", e.unbounded)
                        },
                        inputs: {
                            radius: ["matRippleRadius", "radius"],
                            disabled: ["matRippleDisabled", "disabled"],
                            trigger: ["matRippleTrigger", "trigger"],
                            color: ["matRippleColor", "color"],
                            unbounded: ["matRippleUnbounded", "unbounded"],
                            centered: ["matRippleCentered", "centered"],
                            animation: ["matRippleAnimation", "animation"]
                        },
                        exportAs: ["matRipple"]
                    }), t
                })(),
                B = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            [_, u.b], _
                        ]
                    }), t
                })(),
                H = (() => {
                    class t {
                        constructor(t) {
                            this._animationMode = t, this.state = "unchecked", this.disabled = !1
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(p.a, 8))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["mat-pseudo-checkbox"]
                        ],
                        hostAttrs: [1, "mat-pseudo-checkbox"],
                        hostVars: 8,
                        hostBindings: function(t, e) {
                            2 & t && n.Hb("mat-pseudo-checkbox-indeterminate", "indeterminate" === e.state)("mat-pseudo-checkbox-checked", "checked" === e.state)("mat-pseudo-checkbox-disabled", e.disabled)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)
                        },
                        inputs: {
                            state: "state",
                            disabled: "disabled"
                        },
                        decls: 0,
                        vars: 0,
                        template: function(t, e) {},
                        styles: ['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                U = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            [_]
                        ]
                    }), t
                })();
            const X = new n.s("MAT_OPTION_PARENT_COMPONENT");
            class W {}
            const Y = w(W);
            let G = 0,
                q = (() => {
                    class t extends Y {
                        constructor(t) {
                            var e;
                            super(), this._labelId = "mat-optgroup-label-" + G++, this._inert = null !== (e = null == t ? void 0 : t.inertGroups) && void 0 !== e && e
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(X, 8))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        inputs: {
                            label: "label"
                        },
                        features: [n.Ab]
                    }), t
                })();
            const Z = new n.s("MatOptgroup");
            let $ = 0;
            class Q {
                constructor(t, e = !1) {
                    this.source = t, this.isUserInput = e
                }
            }
            let K = (() => {
                    class t {
                        constructor(t, e, i, s) {
                            this._element = t, this._changeDetectorRef = e, this._parent = i, this.group = s, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = "mat-option-" + $++, this.onSelectionChange = new n.o, this._stateChanges = new c.a
                        }
                        get multiple() {
                            return this._parent && this._parent.multiple
                        }
                        get selected() {
                            return this._selected
                        }
                        get disabled() {
                            return this.group && this.group.disabled || this._disabled
                        }
                        set disabled(t) {
                            this._disabled = Object(l.c)(t)
                        }
                        get disableRipple() {
                            return this._parent && this._parent.disableRipple
                        }
                        get active() {
                            return this._active
                        }
                        get viewValue() {
                            return (this._getHostElement().textContent || "").trim()
                        }
                        select() {
                            this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent())
                        }
                        deselect() {
                            this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent())
                        }
                        focus(t, e) {
                            const i = this._getHostElement();
                            "function" == typeof i.focus && i.focus(e)
                        }
                        setActiveStyles() {
                            this._active || (this._active = !0, this._changeDetectorRef.markForCheck())
                        }
                        setInactiveStyles() {
                            this._active && (this._active = !1, this._changeDetectorRef.markForCheck())
                        }
                        getLabel() {
                            return this.viewValue
                        }
                        _handleKeydown(t) {
                            t.keyCode !== f.d && t.keyCode !== f.j || Object(f.o)(t) || (this._selectViaInteraction(), t.preventDefault())
                        }
                        _selectViaInteraction() {
                            this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0))
                        }
                        _getAriaSelected() {
                            return this.selected || !this.multiple && null
                        }
                        _getTabIndex() {
                            return this.disabled ? "-1" : "0"
                        }
                        _getHostElement() {
                            return this._element.nativeElement
                        }
                        ngAfterViewChecked() {
                            if (this._selected) {
                                const t = this.viewValue;
                                t !== this._mostRecentViewValue && (this._mostRecentViewValue = t, this._stateChanges.next())
                            }
                        }
                        ngOnDestroy() {
                            this._stateChanges.complete()
                        }
                        _emitSelectionChangeEvent(t = !1) {
                            this.onSelectionChange.emit(new Q(this, t))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(n.h), n.Pb(void 0), n.Pb(q))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        inputs: {
                            id: "id",
                            disabled: "disabled",
                            value: "value"
                        },
                        outputs: {
                            onSelectionChange: "onSelectionChange"
                        }
                    }), t
                })(),
                J = (() => {
                    class t extends K {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(n.h), n.Pb(X, 8), n.Pb(Z, 8))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["mat-option"]
                        ],
                        hostAttrs: ["role", "option", 1, "mat-option", "mat-focus-indicator"],
                        hostVars: 12,
                        hostBindings: function(t, e) {
                            1 & t && n.cc("click", function() {
                                return e._selectViaInteraction()
                            })("keydown", function(t) {
                                return e._handleKeydown(t)
                            }), 2 & t && (n.Yb("id", e.id), n.Eb("tabindex", e._getTabIndex())("aria-selected", e._getAriaSelected())("aria-disabled", e.disabled.toString()), n.Hb("mat-selected", e.selected)("mat-option-multiple", e.multiple)("mat-active", e.active)("mat-option-disabled", e.disabled))
                        },
                        exportAs: ["matOption"],
                        features: [n.Ab],
                        ngContentSelectors: b,
                        decls: 5,
                        vars: 4,
                        consts: [
                            ["class", "mat-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"],
                            [1, "mat-option-text"],
                            ["class", "cdk-visually-hidden", 4, "ngIf"],
                            ["mat-ripple", "", 1, "mat-option-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                            [1, "mat-option-pseudo-checkbox", 3, "state", "disabled"],
                            [1, "cdk-visually-hidden"]
                        ],
                        template: function(t, e) {
                            1 & t && (n.kc(), n.Bc(0, g, 1, 2, "mat-pseudo-checkbox", 0), n.Vb(1, "span", 1), n.jc(2), n.Ub(), n.Bc(3, m, 2, 1, "span", 2), n.Qb(4, "div", 3)), 2 & t && (n.lc("ngIf", e.multiple), n.Db(3), n.lc("ngIf", e.group && e.group._inert), n.Db(1), n.lc("matRippleTrigger", e._getHostElement())("matRippleDisabled", e.disabled || e.disableRipple))
                        },
                        directives: [o.l, V, H],
                        styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })();

            function tt(t, e, i) {
                if (i.length) {
                    let n = e.toArray(),
                        s = i.toArray(),
                        r = 0;
                    for (let e = 0; e < t + 1; e++) n[e].group && n[e].group === s[r] && r++;
                    return r
                }
                return 0
            }

            function et(t, e, i, n) {
                return t < i ? t : t + e > i + n ? Math.max(0, t - n + e) : i
            }
            let it = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = n.Nb({
                    type: t
                }), t.\u0275inj = n.Mb({
                    imports: [
                        [B, o.c, _, U]
                    ]
                }), t
            })()
        },
        FtGj: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return g
            }), i.d(e, "b", function() {
                return d
            }), i.d(e, "c", function() {
                return o
            }), i.d(e, "d", function() {
                return s
            }), i.d(e, "e", function() {
                return r
            }), i.d(e, "f", function() {
                return l
            }), i.d(e, "g", function() {
                return c
            }), i.d(e, "h", function() {
                return f
            }), i.d(e, "i", function() {
                return u
            }), i.d(e, "j", function() {
                return a
            }), i.d(e, "k", function() {
                return n
            }), i.d(e, "l", function() {
                return h
            }), i.d(e, "m", function() {
                return m
            }), i.d(e, "n", function() {
                return p
            }), i.d(e, "o", function() {
                return b
            });
            const n = 9,
                s = 13,
                r = 27,
                a = 32,
                o = 35,
                l = 36,
                c = 37,
                h = 38,
                u = 39,
                d = 40,
                p = 48,
                f = 57,
                g = 65,
                m = 90;

            function b(t, ...e) {
                return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey
            }
        },
        GRmh: function(t, e, i) {
            "use strict";

            function n(t) {
                const e = t(t => {
                    Error.call(t), t.stack = (new Error).stack
                });
                return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e
            }
            i.d(e, "a", function() {
                return n
            })
        },
        GU7r: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return h
            }), i.d(e, "b", function() {
                return c
            }), i.d(e, "c", function() {
                return u
            });
            var n = i("8LU1"),
                s = i("fXoL"),
                r = i("SIQg"),
                a = i("oXA7"),
                o = i("sj3c");
            let l = (() => {
                    class t {
                        create(t) {
                            return "undefined" == typeof MutationObserver ? null : new MutationObserver(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                c = (() => {
                    class t {
                        constructor(t) {
                            this._mutationObserverFactory = t, this._observedElements = new Map
                        }
                        ngOnDestroy() {
                            this._observedElements.forEach((t, e) => this._cleanupObserver(e))
                        }
                        observe(t) {
                            const e = Object(n.e)(t);
                            return new r.a(t => {
                                const i = this._observeElement(e).subscribe(t);
                                return () => {
                                    i.unsubscribe(), this._unobserveElement(e)
                                }
                            })
                        }
                        _observeElement(t) {
                            if (this._observedElements.has(t)) this._observedElements.get(t).count++;
                            else {
                                const e = new a.a,
                                    i = this._mutationObserverFactory.create(t => e.next(t));
                                i && i.observe(t, {
                                    characterData: !0,
                                    childList: !0,
                                    subtree: !0
                                }), this._observedElements.set(t, {
                                    observer: i,
                                    stream: e,
                                    count: 1
                                })
                            }
                            return this._observedElements.get(t).stream
                        }
                        _unobserveElement(t) {
                            this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t))
                        }
                        _cleanupObserver(t) {
                            if (this._observedElements.has(t)) {
                                const {
                                    observer: e,
                                    stream: i
                                } = this._observedElements.get(t);
                                e && e.disconnect(), i.complete(), this._observedElements.delete(t)
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(l))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(l))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                h = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._contentObserver = t, this._elementRef = e, this._ngZone = i, this.event = new s.o, this._disabled = !1, this._currentSubscription = null
                        }
                        get disabled() {
                            return this._disabled
                        }
                        set disabled(t) {
                            this._disabled = Object(n.c)(t), this._disabled ? this._unsubscribe() : this._subscribe()
                        }
                        get debounce() {
                            return this._debounce
                        }
                        set debounce(t) {
                            this._debounce = Object(n.f)(t), this._subscribe()
                        }
                        ngAfterContentInit() {
                            this._currentSubscription || this.disabled || this._subscribe()
                        }
                        ngOnDestroy() {
                            this._unsubscribe()
                        }
                        _subscribe() {
                            this._unsubscribe();
                            const t = this._contentObserver.observe(this._elementRef);
                            this._ngZone.runOutsideAngular(() => {
                                this._currentSubscription = (this.debounce ? t.pipe(Object(o.a)(this.debounce)) : t).subscribe(this.event)
                            })
                        }
                        _unsubscribe() {
                            var t;
                            null === (t = this._currentSubscription) || void 0 === t || t.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(c), s.Pb(s.l), s.Pb(s.B))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkObserveContent", ""]
                        ],
                        inputs: {
                            disabled: ["cdkObserveContentDisabled", "disabled"],
                            debounce: "debounce"
                        },
                        outputs: {
                            event: "cdkObserveContent"
                        },
                        exportAs: ["cdkObserveContent"]
                    }), t
                })(),
                u = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        providers: [l]
                    }), t
                })()
        },
        Jlqm: function(t, e, i) {
            "use strict";
            i.d(e, "b", function() {
                return s
            }), i.d(e, "a", function() {
                return r
            });
            var n = i("Tk8M");
            const s = new(i("3x7h").a)(n.a),
                r = s
        },
        KOvq: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return d
            });
            var n = i("SIQg"),
                s = i("1M4b"),
                r = i("O0iu"),
                a = i("2QHy"),
                o = i("CLjF"),
                l = i("vfWG");
            const c = ["addListener", "removeListener"],
                h = ["addEventListener", "removeEventListener"],
                u = ["on", "off"];

            function d(t, e, i, f) {
                if (Object(a.a)(i) && (f = i, i = void 0), f) return d(t, e, i).pipe(Object(o.a)(f));
                const [g, m] = function(t) {
                    return Object(a.a)(t.addEventListener) && Object(a.a)(t.removeEventListener)
                }(t) ? h.map(n => s => t[n](e, s, i)): function(t) {
                    return Object(a.a)(t.addListener) && Object(a.a)(t.removeListener)
                }(t) ? c.map(p(t, e)) : function(t) {
                    return Object(a.a)(t.on) && Object(a.a)(t.off)
                }(t) ? u.map(p(t, e)) : [];
                if (!g && Object(r.a)(t)) return Object(s.a)(t => d(t, e, i))(Object(l.a)(t));
                if (!g) throw new TypeError("Invalid event target");
                return new n.a(t => {
                    const e = (...e) => t.next(1 < e.length ? e : e[0]);
                    return g(e), () => m(e)
                })
            }

            function p(t, e) {
                return i => n => t[i](e, n)
            }
        },
        LNGT: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return g
            }), i.d(e, "b", function() {
                return m
            });
            var n = i("R0Ic"),
                s = i("ofXK"),
                r = i("fXoL");
            const a = ["pathEl"];

            function o(t, e) {
                if (1 & t && (r.fc(), r.Qb(0, "stop")), 2 & t) {
                    const t = e.$implicit;
                    r.Eb("key", t.idx)("offset", t.offset)("stop-color", t.stopColor)
                }
            }

            function l(t, e) {
                if (1 & t && (r.fc(), r.Vb(0, "defs"), r.Vb(1, "linearGradient", 3), r.Bc(2, o, 1, 3, "stop", 4), r.Ub(), r.Ub()), 2 & t) {
                    const t = r.gc(2);
                    r.Db(1), r.Eb("id", t.gradientId), r.Db(1), r.lc("ngForOf", t.gradientTrimmed)
                }
            }
            const c = function(t, e, i) {
                    return {
                        autoDrawDuration: t,
                        autoDrawEasing: e,
                        lineLength: i
                    }
                },
                h = function(t, e) {
                    return {
                        value: t,
                        params: e
                    }
                };

            function u(t, e) {
                if (1 & t && (r.fc(), r.Vb(0, "svg"), r.Bc(1, l, 3, 2, "defs", 0), r.Qb(2, "path", 1, 2), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.Eb("width", t.svgWidth)("height", t.svgHeight)("stroke", t.stroke)("stroke-width", t.strokeWidth)("stroke-linecap", t.strokeLinecap)("viewBox", t.viewBox)("preserveAspectRatio", t.preserveAspectRatio), r.Db(1), r.lc("ngIf", t.gradient && t.gradient.length), r.Db(1), r.lc("@pathAnimaiton", r.pc(15, h, t.animationState, r.qc(11, c, t.autoDrawDuration, t.autoDrawEasing, t.lineLength))), r.Eb("stroke", t.pathStroke)("d", t.d)
                }
            }

            function d(t, e, i, n = 0, s = 1) {
                return e === i ? n : n + (t - e) * (s - n) / (i - e)
            }

            function p(t, e, i) {
                const n = Math.sqrt((t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y));
                return {
                    x: e.x + (t.x - e.x) / n * i,
                    y: e.y + (t.y - e.y) / n * i
                }
            }
            const f = (t, e) => Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
            let g = (() => {
                    class t {
                        constructor() {
                            this.autoDraw = !1, this.autoDrawDuration = 2e3, this.autoDrawEasing = "ease", this.padding = 8, this.radius = 10, this.stroke = "black", this.strokeLinecap = "", this.strokeWidth = 1, this.gradient = [], this.svgHeight = "25%", this.svgWidth = "100%", this.animationState = "", this.id = Math.round(Math.random() * Math.pow(10, 16)), this.gradientId = `ngx-trend-vertical-gradient-${this.id}`
                        }
                        ngOnChanges() {
                            if (!this.data || this.data.length < 2) return;
                            const t = this.data.map(t => "number" == typeof t ? t : t.value),
                                e = this.width || 300,
                                i = this.height || 75;
                            this.svgWidth = this.width || "100%", this.svgHeight = this.height || "25%", this.viewBox = `0 0 ${e} ${i}`;
                            const n = location.href.split(location.hash || "#")[0];
                            this.pathStroke = this.gradient && this.gradient.length ? `url('${n}#${this.gradientId}')` : void 0, this.gradientTrimmed = this.gradient.slice().reverse().map((t, e) => ({
                                idx: e,
                                stopColor: t,
                                offset: d(e, 0, this.gradient.length - 1 || 1)
                            }));
                            const s = function(t, e, i, n, s) {
                                const r = {
                                        min: 0,
                                        max: t.length - 1
                                    },
                                    a = {
                                        min: Math.min(...t),
                                        max: Math.max(...t)
                                    },
                                    o = t.map((t, o) => ({
                                        x: d(o, r.min, r.max, e, i),
                                        y: d(t, a.min, a.max, n, s)
                                    }));
                                return a.min === a.max && (o[0].y += 1e-4), o
                            }(t, this.padding, e - this.padding, i - this.padding, this.padding);
                            this.autoDraw && "active" !== this.animationState && (this.animationState = "inactive", setTimeout(() => {
                                this.lineLength = this.pathEl.nativeElement.getTotalLength(), this.animationState = "active"
                            })), this.d = this.smooth ? function(t, e) {
                                const [i, ...n] = t;
                                return n.reduce((t, s, r) => {
                                    const a = n[r + 1],
                                        o = n[r - 1] || i,
                                        l = a && ((c = o).y - (h = s).y) * (c.x - (u = a).x) == (c.y - u.y) * (c.x - h.x);
                                    var c, h, u;
                                    if (!a || l) return `${t}\nL ${s.x},${s.y}`;
                                    const d = f(o, s),
                                        g = f(a, s),
                                        m = Math.min(d, g),
                                        b = m / 2 < e ? m / 2 : e,
                                        y = p(o, s, b),
                                        v = p(a, s, b);
                                    return [t, `L ${y.x},${y.y}`, `S ${s.x},${s.y} ${v.x},${v.y}`].join("\n")
                                }, `M ${i.x},${i.y}`)
                            }(s, this.radius) : s.reduce((t, e, i) => `${t}${0===i?"M":"L"} ${e.x},${e.y}\n`, "")
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["ngx-trend"]
                        ],
                        viewQuery: function(t, e) {
                            if (1 & t && r.Hc(a, 1), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e.pathEl = t.first)
                            }
                        },
                        inputs: {
                            autoDraw: "autoDraw",
                            autoDrawDuration: "autoDrawDuration",
                            autoDrawEasing: "autoDrawEasing",
                            padding: "padding",
                            radius: "radius",
                            stroke: "stroke",
                            strokeLinecap: "strokeLinecap",
                            strokeWidth: "strokeWidth",
                            gradient: "gradient",
                            svgHeight: "svgHeight",
                            svgWidth: "svgWidth",
                            data: "data",
                            smooth: "smooth",
                            width: "width",
                            height: "height",
                            preserveAspectRatio: "preserveAspectRatio"
                        },
                        features: [r.Bb],
                        decls: 1,
                        vars: 1,
                        consts: [
                            [4, "ngIf"],
                            ["fill", "none"],
                            ["pathEl", ""],
                            ["x1", "0%", "y1", "0%", "x2", "0%", "y2", "100%"],
                            [4, "ngFor", "ngForOf"]
                        ],
                        template: function(t, e) {
                            1 & t && r.Bc(0, u, 4, 18, "svg", 0), 2 & t && r.lc("ngIf", e.data && e.data.length >= 2)
                        },
                        directives: [s.l, s.k],
                        encapsulation: 2,
                        data: {
                            animation: [Object(n.m)("pathAnimaiton", [Object(n.j)("inactive", Object(n.k)({
                                display: "none"
                            })), Object(n.l)("* => active", [Object(n.k)({
                                display: "initial"
                            }), Object(n.e)("{{ autoDrawDuration }}ms {{ autoDrawEasing }}", Object(n.g)([Object(n.k)({
                                "stroke-dasharray": "{{ lineLength }}px",
                                "stroke-dashoffset": "{{ lineLength }}px"
                            }), Object(n.k)({
                                "stroke-dasharray": "{{ lineLength }}px",
                                "stroke-dashoffset": 0
                            })])), Object(n.k)({
                                "stroke-dashoffset": "",
                                "stroke-dasharray": ""
                            })])])]
                        }
                    }), t
                })(),
                m = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = r.Nb({
                        type: t
                    }), t.\u0275inj = r.Mb({
                        imports: [
                            [s.c]
                        ]
                    }), t
                })()
        },
        LbVS: function(t, e, i) {
            "use strict";

            function n(t) {
                return t
            }

            function s() {
                var t = document.querySelectorAll("input");
                return Array.prototype.slice.call(t).map(function(t) {
                    return t.value
                })
            }

            function r(t) {
                var e = document.querySelectorAll("input");
                t && e.length === t.length && (t.forEach(function(t, i) {
                    var n = e[i];
                    n.value = t, n.dispatchEvent(new CustomEvent("input", {
                        detail: n.value
                    }))
                }), t.length = 0)
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.bootloader = function(t, e, i) {
                "object" == typeof t && (e = t.before, i = t.after, t = t.main), e = e || n, i = i || n;
                var s = document.readyState;
                switch (s) {
                    case "loading":
                        document.addEventListener("DOMContentLoaded", function n() {
                            document.removeEventListener("DOMContentLoaded", n), i(t(e(s)))
                        });
                        break;
                    case "interactive":
                    case "complete":
                    default:
                        i(t(e(s)))
                }
            }, e.createNewHosts = function(t) {
                var e = Array.prototype.map.call(t, function(t) {
                    var e = document.createElement(t.tagName),
                        i = t.parentNode,
                        n = e.style.display;
                    return e.style.display = "none", i.insertBefore(e, t),
                        function() {
                            e.style.display = n;
                            try {
                                i.removeChild(t)
                            } catch (s) {}
                        }
                });
                return function() {
                    e.forEach(function(t) {
                        return t()
                    })
                }
            }, e.removeNgStyles = function() {
                var t = document.head,
                    e = t.querySelectorAll("style");
                Array.prototype.slice.call(e).filter(function(t) {
                    return -1 !== t.innerText.indexOf("_ng")
                }).map(function(e) {
                    return t.removeChild(e)
                })
            }, e.getInputValues = s, e.setInputValues = r, e.createInputTransfer = function() {
                var t = s();
                return function() {
                    return r(t)
                }
            }
        },
        MRCm: function(t, e, i) {
            "use strict";

            function n() {}
            i.d(e, "a", function() {
                return n
            })
        },
        MutI: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return v
            }), i.d(e, "b", function() {
                return w
            }), i.d(e, "c", function() {
                return C
            });
            var n = i("ofXK"),
                s = i("fXoL"),
                r = i("FKr1"),
                a = i("8LU1"),
                o = i("oXA7"),
                l = i("bk9D");
            i("zzs5"), i("u47x"), i("0EQZ"), i("FtGj"), i("3Pt+");
            let c = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = s.Nb({
                    type: t
                }), t.\u0275inj = s.Mb({
                    imports: [
                        [r.e], r.e
                    ]
                }), t
            })();
            const h = ["*"],
                u = [
                    [
                        ["", "mat-list-avatar", ""],
                        ["", "mat-list-icon", ""],
                        ["", "matListAvatar", ""],
                        ["", "matListIcon", ""]
                    ],
                    [
                        ["", "mat-line", ""],
                        ["", "matLine", ""]
                    ], "*"
                ],
                d = ["[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]", "[mat-line], [matLine]", "*"];
            class p {}
            const f = Object(r.s)(Object(r.r)(p));
            class g {}
            const m = Object(r.r)(g),
                b = new s.s("MatList"),
                y = new s.s("MatNavList");
            let v = (() => {
                    class t extends f {
                        constructor(t) {
                            super(), this._elementRef = t, this._stateChanges = new o.a, "action-list" === this._getListType() && t.nativeElement.classList.add("mat-action-list")
                        }
                        _getListType() {
                            const t = this._elementRef.nativeElement.nodeName.toLowerCase();
                            return "mat-list" === t ? "list" : "mat-action-list" === t ? "action-list" : null
                        }
                        ngOnChanges() {
                            this._stateChanges.next()
                        }
                        ngOnDestroy() {
                            this._stateChanges.complete()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l))
                    }, t.\u0275cmp = s.Jb({
                        type: t,
                        selectors: [
                            ["mat-list"],
                            ["mat-action-list"]
                        ],
                        hostAttrs: [1, "mat-list", "mat-list-base"],
                        inputs: {
                            disableRipple: "disableRipple",
                            disabled: "disabled"
                        },
                        exportAs: ["matList"],
                        features: [s.Cb([{
                            provide: b,
                            useExisting: t
                        }]), s.Ab, s.Bb],
                        ngContentSelectors: h,
                        decls: 1,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (s.kc(), s.jc(0))
                        },
                        styles: ['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                x = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "mat-list-avatar", ""],
                            ["", "matListAvatar", ""]
                        ],
                        hostAttrs: [1, "mat-list-avatar"]
                    }), t
                })(),
                _ = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "mat-list-icon", ""],
                            ["", "matListIcon", ""]
                        ],
                        hostAttrs: [1, "mat-list-icon"]
                    }), t
                })(),
                w = (() => {
                    class t extends m {
                        constructor(t, e, i, n) {
                            super(), this._element = t, this._isInteractiveList = !1, this._destroyed = new o.a, this._disabled = !1, this._isInteractiveList = !!(i || n && "action-list" === n._getListType()), this._list = i || n;
                            const s = this._getHostElement();
                            "button" !== s.nodeName.toLowerCase() || s.hasAttribute("type") || s.setAttribute("type", "button"), this._list && this._list._stateChanges.pipe(Object(l.a)(this._destroyed)).subscribe(() => {
                                e.markForCheck()
                            })
                        }
                        get disabled() {
                            return this._disabled || !(!this._list || !this._list.disabled)
                        }
                        set disabled(t) {
                            this._disabled = Object(a.c)(t)
                        }
                        ngAfterContentInit() {
                            Object(r.w)(this._lines, this._element)
                        }
                        ngOnDestroy() {
                            this._destroyed.next(), this._destroyed.complete()
                        }
                        _isRippleDisabled() {
                            return !this._isInteractiveList || this.disableRipple || !(!this._list || !this._list.disableRipple)
                        }
                        _getHostElement() {
                            return this._element.nativeElement
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l), s.Pb(s.h), s.Pb(y, 8), s.Pb(b, 8))
                    }, t.\u0275cmp = s.Jb({
                        type: t,
                        selectors: [
                            ["mat-list-item"],
                            ["a", "mat-list-item", ""],
                            ["button", "mat-list-item", ""]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (s.Ib(i, x, 1), s.Ib(i, _, 1), s.Ib(i, r.f, 1)), 2 & t) {
                                let t;
                                s.rc(t = s.dc()) && (e._avatar = t.first), s.rc(t = s.dc()) && (e._icon = t.first), s.rc(t = s.dc()) && (e._lines = t)
                            }
                        },
                        hostAttrs: [1, "mat-list-item", "mat-focus-indicator"],
                        hostVars: 6,
                        hostBindings: function(t, e) {
                            2 & t && s.Hb("mat-list-item-disabled", e.disabled)("mat-list-item-avatar", e._avatar || e._icon)("mat-list-item-with-avatar", e._avatar || e._icon)
                        },
                        inputs: {
                            disableRipple: "disableRipple",
                            disabled: "disabled"
                        },
                        exportAs: ["matListItem"],
                        features: [s.Ab],
                        ngContentSelectors: d,
                        decls: 6,
                        vars: 2,
                        consts: [
                            [1, "mat-list-item-content"],
                            ["mat-ripple", "", 1, "mat-list-item-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                            [1, "mat-list-text"]
                        ],
                        template: function(t, e) {
                            1 & t && (s.kc(u), s.Vb(0, "div", 0), s.Qb(1, "div", 1), s.jc(2), s.Vb(3, "div", 2), s.jc(4, 1), s.Ub(), s.jc(5, 2), s.Ub()), 2 & t && (s.Db(1), s.lc("matRippleTrigger", e._getHostElement())("matRippleDisabled", e._isRippleDisabled()))
                        },
                        directives: [r.l],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                C = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        imports: [
                            [r.g, r.m, r.e, r.k, n.c], r.g, r.e, r.k, c
                        ]
                    }), t
                })()
        },
        NFeN: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return G
            }), i.d(e, "b", function() {
                return q
            });
            var n = i("fXoL"),
                s = i("FKr1"),
                r = i("8LU1"),
                a = i("ofXK"),
                o = i("4krO"),
                l = i("lhB6"),
                c = i("zPkR"),
                h = i("jqqC"),
                u = i("sj7R"),
                d = i("rdQv"),
                p = i("VZwH"),
                f = i("BjsQ"),
                g = i("Qd51"),
                m = i("nnEh"),
                b = (i("SIQg"), i("BWBv")),
                y = i("dLTe");
            class v {}
            class x {
                constructor(t) {
                    this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => {
                        this.headers = new Map, t.split("\n").forEach(t => {
                            const e = t.indexOf(":");
                            if (e > 0) {
                                const i = t.slice(0, e),
                                    n = i.toLowerCase(),
                                    s = t.slice(e + 1).trim();
                                this.maybeSetNormalizedName(i, n), this.headers.has(n) ? this.headers.get(n).push(s) : this.headers.set(n, [s])
                            }
                        })
                    } : () => {
                        this.headers = new Map, Object.keys(t).forEach(e => {
                            let i = t[e];
                            const n = e.toLowerCase();
                            "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(n, i), this.maybeSetNormalizedName(e, n))
                        })
                    } : this.headers = new Map
                }
                has(t) {
                    return this.init(), this.headers.has(t.toLowerCase())
                }
                get(t) {
                    this.init();
                    const e = this.headers.get(t.toLowerCase());
                    return e && e.length > 0 ? e[0] : null
                }
                keys() {
                    return this.init(), Array.from(this.normalizedNames.values())
                }
                getAll(t) {
                    return this.init(), this.headers.get(t.toLowerCase()) || null
                }
                append(t, e) {
                    return this.clone({
                        name: t,
                        value: e,
                        op: "a"
                    })
                }
                set(t, e) {
                    return this.clone({
                        name: t,
                        value: e,
                        op: "s"
                    })
                }
                delete(t, e) {
                    return this.clone({
                        name: t,
                        value: e,
                        op: "d"
                    })
                }
                maybeSetNormalizedName(t, e) {
                    this.normalizedNames.has(e) || this.normalizedNames.set(e, t)
                }
                init() {
                    this.lazyInit && (this.lazyInit instanceof x ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null))
                }
                copyFrom(t) {
                    t.init(), Array.from(t.headers.keys()).forEach(e => {
                        this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e))
                    })
                }
                clone(t) {
                    const e = new x;
                    return e.lazyInit = this.lazyInit && this.lazyInit instanceof x ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e
                }
                applyUpdate(t) {
                    const e = t.name.toLowerCase();
                    switch (t.op) {
                        case "a":
                        case "s":
                            let i = t.value;
                            if ("string" == typeof i && (i = [i]), 0 === i.length) return;
                            this.maybeSetNormalizedName(t.name, e);
                            const n = ("a" === t.op ? this.headers.get(e) : void 0) || [];
                            n.push(...i), this.headers.set(e, n);
                            break;
                        case "d":
                            const s = t.value;
                            if (s) {
                                let t = this.headers.get(e);
                                if (!t) return;
                                t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t)
                            } else this.headers.delete(e), this.normalizedNames.delete(e)
                    }
                }
                forEach(t) {
                    this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e)))
                }
            }
            class _ {
                encodeKey(t) {
                    return w(t)
                }
                encodeValue(t) {
                    return w(t)
                }
                decodeKey(t) {
                    return decodeURIComponent(t)
                }
                decodeValue(t) {
                    return decodeURIComponent(t)
                }
            }

            function w(t) {
                return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/")
            }
            class C {
                constructor(t = {}) {
                    if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new _, t.fromString) {
                        if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                        this.map = function(t, e) {
                            const i = new Map;
                            return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => {
                                const n = t.indexOf("="),
                                    [s, r] = -1 == n ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, n)), e.decodeValue(t.slice(n + 1))],
                                    a = i.get(s) || [];
                                a.push(r), i.set(s, a)
                            }), i
                        }(t.fromString, this.encoder)
                    } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => {
                        const i = t.fromObject[e];
                        this.map.set(e, Array.isArray(i) ? i : [i])
                    })) : this.map = null
                }
                has(t) {
                    return this.init(), this.map.has(t)
                }
                get(t) {
                    this.init();
                    const e = this.map.get(t);
                    return e ? e[0] : null
                }
                getAll(t) {
                    return this.init(), this.map.get(t) || null
                }
                keys() {
                    return this.init(), Array.from(this.map.keys())
                }
                append(t, e) {
                    return this.clone({
                        param: t,
                        value: e,
                        op: "a"
                    })
                }
                appendAll(t) {
                    const e = [];
                    return Object.keys(t).forEach(i => {
                        const n = t[i];
                        Array.isArray(n) ? n.forEach(t => {
                            e.push({
                                param: i,
                                value: t,
                                op: "a"
                            })
                        }) : e.push({
                            param: i,
                            value: n,
                            op: "a"
                        })
                    }), this.clone(e)
                }
                set(t, e) {
                    return this.clone({
                        param: t,
                        value: e,
                        op: "s"
                    })
                }
                delete(t, e) {
                    return this.clone({
                        param: t,
                        value: e,
                        op: "d"
                    })
                }
                toString() {
                    return this.init(), this.keys().map(t => {
                        const e = this.encoder.encodeKey(t);
                        return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&")
                    }).filter(t => "" !== t).join("&")
                }
                clone(t) {
                    const e = new C({
                        encoder: this.encoder
                    });
                    return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e
                }
                init() {
                    null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => {
                        switch (t.op) {
                            case "a":
                            case "s":
                                const e = ("a" === t.op ? this.map.get(t.param) : void 0) || [];
                                e.push(t.value), this.map.set(t.param, e);
                                break;
                            case "d":
                                if (void 0 === t.value) {
                                    this.map.delete(t.param);
                                    break
                                } {
                                    let e = this.map.get(t.param) || [];
                                    const i = e.indexOf(t.value); - 1 !== i && e.splice(i, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param)
                                }
                        }
                    }), this.cloneFrom = this.updates = null)
                }
            }

            function k(t) {
                return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer
            }

            function S(t) {
                return "undefined" != typeof Blob && t instanceof Blob
            }

            function A(t) {
                return "undefined" != typeof FormData && t instanceof FormData
            }
            class O {
                constructor(t, e, i, n) {
                    let s;
                    if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function(t) {
                            switch (t) {
                                case "DELETE":
                                case "GET":
                                case "HEAD":
                                case "OPTIONS":
                                case "JSONP":
                                    return !1;
                                default:
                                    return !0
                            }
                        }(this.method) || n ? (this.body = void 0 !== i ? i : null, s = n) : s = i, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.params && (this.params = s.params)), this.headers || (this.headers = new x), this.params) {
                        const t = this.params.toString();
                        if (0 === t.length) this.urlWithParams = e;
                        else {
                            const i = e.indexOf("?");
                            this.urlWithParams = e + (-1 === i ? "?" : i < e.length - 1 ? "&" : "") + t
                        }
                    } else this.params = new C, this.urlWithParams = e
                }
                serializeBody() {
                    return null === this.body ? null : k(this.body) || S(this.body) || A(this.body) || "string" == typeof this.body ? this.body : this.body instanceof C ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
                }
                detectContentTypeHeader() {
                    return null === this.body || A(this.body) ? null : S(this.body) ? this.body.type || null : k(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof C ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null
                }
                clone(t = {}) {
                    const e = t.method || this.method,
                        i = t.url || this.url,
                        n = t.responseType || this.responseType,
                        s = void 0 !== t.body ? t.body : this.body,
                        r = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials,
                        a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress;
                    let o = t.headers || this.headers,
                        l = t.params || this.params;
                    return void 0 !== t.setHeaders && (o = Object.keys(t.setHeaders).reduce((e, i) => e.set(i, t.setHeaders[i]), o)), t.setParams && (l = Object.keys(t.setParams).reduce((e, i) => e.set(i, t.setParams[i]), l)), new O(e, i, s, {
                        params: l,
                        headers: o,
                        reportProgress: a,
                        responseType: n,
                        withCredentials: r
                    })
                }
            }
            var E = function(t) {
                return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t
            }({});
            class P extends class {
                constructor(t, e = 200, i = "OK") {
                    this.headers = t.headers || new x, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300
                }
            } {
                constructor(t = {}) {
                    super(t), this.type = E.Response, this.body = void 0 !== t.body ? t.body : null
                }
                clone(t = {}) {
                    return new P({
                        body: void 0 !== t.body ? t.body : this.body,
                        headers: t.headers || this.headers,
                        status: void 0 !== t.status ? t.status : this.status,
                        statusText: t.statusText || this.statusText,
                        url: t.url || this.url || void 0
                    })
                }
            }

            function T(t, e) {
                return {
                    body: e,
                    headers: t.headers,
                    observe: t.observe,
                    params: t.params,
                    reportProgress: t.reportProgress,
                    responseType: t.responseType,
                    withCredentials: t.withCredentials
                }
            }
            let D = (() => {
                class t {
                    constructor(t) {
                        this.handler = t
                    }
                    request(t, e, i = {}) {
                        let n;
                        if (t instanceof O) n = t;
                        else {
                            let s, r;
                            s = i.headers instanceof x ? i.headers : new x(i.headers), i.params && (r = i.params instanceof C ? i.params : new C({
                                fromObject: i.params
                            })), n = new O(t, e, void 0 !== i.body ? i.body : null, {
                                headers: s,
                                params: r,
                                reportProgress: i.reportProgress,
                                responseType: i.responseType || "json",
                                withCredentials: i.withCredentials
                            })
                        }
                        const s = Object(o.a)(n).pipe(Object(b.a)(t => this.handler.handle(t)));
                        if (t instanceof O || "events" === i.observe) return s;
                        const r = s.pipe(Object(y.a)(t => t instanceof P));
                        switch (i.observe || "body") {
                            case "body":
                                switch (n.responseType) {
                                    case "arraybuffer":
                                        return r.pipe(Object(d.a)(t => {
                                            if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                            return t.body
                                        }));
                                    case "blob":
                                        return r.pipe(Object(d.a)(t => {
                                            if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                            return t.body
                                        }));
                                    case "text":
                                        return r.pipe(Object(d.a)(t => {
                                            if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string.");
                                            return t.body
                                        }));
                                    case "json":
                                    default:
                                        return r.pipe(Object(d.a)(t => t.body))
                                }
                                case "response":
                                    return r;
                                default:
                                    throw new Error(`Unreachable: unhandled observe type ${i.observe}}`)
                        }
                    }
                    delete(t, e = {}) {
                        return this.request("DELETE", t, e)
                    }
                    get(t, e = {}) {
                        return this.request("GET", t, e)
                    }
                    head(t, e = {}) {
                        return this.request("HEAD", t, e)
                    }
                    jsonp(t, e) {
                        return this.request("JSONP", t, {
                            params: (new C).append(e, "JSONP_CALLBACK"),
                            observe: "body",
                            responseType: "json"
                        })
                    }
                    options(t, e = {}) {
                        return this.request("OPTIONS", t, e)
                    }
                    patch(t, e, i = {}) {
                        return this.request("PATCH", t, T(i, e))
                    }
                    post(t, e, i = {}) {
                        return this.request("POST", t, T(i, e))
                    }
                    put(t, e, i = {}) {
                        return this.request("PUT", t, T(i, e))
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(v))
                }, t.\u0275prov = n.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            var I = i("jhN1");
            const M = ["*"];

            function L(t) {
                return Error(`Unable to find icon with the name "${t}"`)
            }

            function R(t) {
                return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)
            }

            function j(t) {
                return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)
            }
            class F {
                constructor(t, e, i) {
                    this.url = t, this.svgText = e, this.options = i
                }
            }
            let N = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._httpClient = t, this._sanitizer = e, this._errorHandler = n, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = "material-icons", this._document = i
                    }
                    addSvgIcon(t, e, i) {
                        return this.addSvgIconInNamespace("", t, e, i)
                    }
                    addSvgIconLiteral(t, e, i) {
                        return this.addSvgIconLiteralInNamespace("", t, e, i)
                    }
                    addSvgIconInNamespace(t, e, i, n) {
                        return this._addSvgIconConfig(t, e, new F(i, null, n))
                    }
                    addSvgIconResolver(t) {
                        return this._resolvers.push(t), this
                    }
                    addSvgIconLiteralInNamespace(t, e, i, s) {
                        const r = this._sanitizer.sanitize(n.K.HTML, i);
                        if (!r) throw j(i);
                        return this._addSvgIconConfig(t, e, new F("", r, s))
                    }
                    addSvgIconSet(t, e) {
                        return this.addSvgIconSetInNamespace("", t, e)
                    }
                    addSvgIconSetLiteral(t, e) {
                        return this.addSvgIconSetLiteralInNamespace("", t, e)
                    }
                    addSvgIconSetInNamespace(t, e, i) {
                        return this._addSvgIconSetConfig(t, new F(e, null, i))
                    }
                    addSvgIconSetLiteralInNamespace(t, e, i) {
                        const s = this._sanitizer.sanitize(n.K.HTML, e);
                        if (!s) throw j(e);
                        return this._addSvgIconSetConfig(t, new F("", s, i))
                    }
                    registerFontClassAlias(t, e = t) {
                        return this._fontCssClassesByAlias.set(t, e), this
                    }
                    classNameForFontAlias(t) {
                        return this._fontCssClassesByAlias.get(t) || t
                    }
                    setDefaultFontSetClass(t) {
                        return this._defaultFontSetClass = t, this
                    }
                    getDefaultFontSetClass() {
                        return this._defaultFontSetClass
                    }
                    getSvgIconFromUrl(t) {
                        const e = this._sanitizer.sanitize(n.K.RESOURCE_URL, t);
                        if (!e) throw R(t);
                        const i = this._cachedIconsByUrl.get(e);
                        return i ? Object(o.a)(z(i)) : this._loadSvgIconFromConfig(new F(t, null)).pipe(Object(u.a)(t => this._cachedIconsByUrl.set(e, t)), Object(d.a)(t => z(t)))
                    }
                    getNamedSvgIcon(t, e = "") {
                        const i = V(e, t);
                        let n = this._svgIconConfigs.get(i);
                        if (n) return this._getSvgFromConfig(n);
                        if (n = this._getIconConfigFromResolvers(e, t), n) return this._svgIconConfigs.set(i, n), this._getSvgFromConfig(n);
                        const s = this._iconSetConfigs.get(e);
                        return s ? this._getSvgFromIconSetConfigs(t, s) : Object(l.a)(L(i))
                    }
                    ngOnDestroy() {
                        this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear()
                    }
                    _getSvgFromConfig(t) {
                        return t.svgText ? Object(o.a)(z(this._svgElementFromConfig(t))) : this._loadSvgIconFromConfig(t).pipe(Object(d.a)(t => z(t)))
                    }
                    _getSvgFromIconSetConfigs(t, e) {
                        const i = this._extractIconWithNameFromAnySet(t, e);
                        if (i) return Object(o.a)(i);
                        const s = e.filter(t => !t.svgText).map(t => this._loadSvgIconSetFromConfig(t).pipe(Object(p.a)(e => {
                            const i = this._sanitizer.sanitize(n.K.RESOURCE_URL, t.url);
                            return this._errorHandler.handleError(new Error(`Loading icon set URL: ${i} failed: ${e.message}`)), Object(o.a)(null)
                        })));
                        return Object(c.a)(s).pipe(Object(d.a)(() => {
                            const i = this._extractIconWithNameFromAnySet(t, e);
                            if (!i) throw L(t);
                            return i
                        }))
                    }
                    _extractIconWithNameFromAnySet(t, e) {
                        for (let i = e.length - 1; i >= 0; i--) {
                            const n = e[i];
                            if (n.svgText && n.svgText.indexOf(t) > -1) {
                                const e = this._svgElementFromConfig(n),
                                    i = this._extractSvgIconFromSet(e, t, n.options);
                                if (i) return i
                            }
                        }
                        return null
                    }
                    _loadSvgIconFromConfig(t) {
                        return this._fetchIcon(t).pipe(Object(u.a)(e => t.svgText = e), Object(d.a)(() => this._svgElementFromConfig(t)))
                    }
                    _loadSvgIconSetFromConfig(t) {
                        return t.svgText ? Object(o.a)(null) : this._fetchIcon(t).pipe(Object(u.a)(e => t.svgText = e))
                    }
                    _extractSvgIconFromSet(t, e, i) {
                        const n = t.querySelector(`[id="${e}"]`);
                        if (!n) return null;
                        const s = n.cloneNode(!0);
                        if (s.removeAttribute("id"), "svg" === s.nodeName.toLowerCase()) return this._setSvgAttributes(s, i);
                        if ("symbol" === s.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(s), i);
                        const r = this._svgElementFromString("<svg></svg>");
                        return r.appendChild(s), this._setSvgAttributes(r, i)
                    }
                    _svgElementFromString(t) {
                        const e = this._document.createElement("DIV");
                        e.innerHTML = t;
                        const i = e.querySelector("svg");
                        if (!i) throw Error("<svg> tag not found");
                        return i
                    }
                    _toSvgElement(t) {
                        const e = this._svgElementFromString("<svg></svg>"),
                            i = t.attributes;
                        for (let n = 0; n < i.length; n++) {
                            const {
                                name: t,
                                value: s
                            } = i[n];
                            "id" !== t && e.setAttribute(t, s)
                        }
                        for (let n = 0; n < t.childNodes.length; n++) t.childNodes[n].nodeType === this._document.ELEMENT_NODE && e.appendChild(t.childNodes[n].cloneNode(!0));
                        return e
                    }
                    _setSvgAttributes(t, e) {
                        return t.setAttribute("fit", ""), t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.setAttribute("preserveAspectRatio", "xMidYMid meet"), t.setAttribute("focusable", "false"), e && e.viewBox && t.setAttribute("viewBox", e.viewBox), t
                    }
                    _fetchIcon(t) {
                        var e;
                        const {
                            url: i,
                            options: s
                        } = t, r = null !== (e = null == s ? void 0 : s.withCredentials) && void 0 !== e && e;
                        if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");
                        if (null == i) throw Error(`Cannot fetch icon from URL "${i}".`);
                        const a = this._sanitizer.sanitize(n.K.RESOURCE_URL, i);
                        if (!a) throw R(i);
                        const o = this._inProgressUrlFetches.get(a);
                        if (o) return o;
                        const l = this._httpClient.get(a, {
                            responseType: "text",
                            withCredentials: r
                        }).pipe(Object(f.a)(() => this._inProgressUrlFetches.delete(a)), Object(g.a)());
                        return this._inProgressUrlFetches.set(a, l), l
                    }
                    _addSvgIconConfig(t, e, i) {
                        return this._svgIconConfigs.set(V(t, e), i), this
                    }
                    _addSvgIconSetConfig(t, e) {
                        const i = this._iconSetConfigs.get(t);
                        return i ? i.push(e) : this._iconSetConfigs.set(t, [e]), this
                    }
                    _svgElementFromConfig(t) {
                        if (!t.svgElement) {
                            const e = this._svgElementFromString(t.svgText);
                            this._setSvgAttributes(e, t.options), t.svgElement = e
                        }
                        return t.svgElement
                    }
                    _getIconConfigFromResolvers(t, e) {
                        for (let n = 0; n < this._resolvers.length; n++) {
                            const s = this._resolvers[n](e, t);
                            if (s) return (i = s).url && i.options ? new F(s.url, null, s.options) : new F(s, null)
                        }
                        var i
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(D, 8), n.Zb(I.b), n.Zb(a.d, 8), n.Zb(n.n))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: function() {
                        return new t(Object(n.Zb)(D, 8), Object(n.Zb)(I.b), Object(n.Zb)(a.d, 8), Object(n.Zb)(n.n))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function z(t) {
                return t.cloneNode(!0)
            }

            function V(t, e) {
                return t + ":" + e
            }
            class B {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const H = Object(s.q)(B),
                U = new n.s("mat-icon-location", {
                    providedIn: "root",
                    factory: function() {
                        const t = Object(n.X)(a.d),
                            e = t ? t.location : null;
                        return {
                            getPathname: () => e ? e.pathname + e.search : ""
                        }
                    }
                }),
                X = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"],
                W = X.map(t => `[${t}]`).join(", "),
                Y = /^url\(['"]?#(.*?)['"]?\)$/;
            let G = (() => {
                    class t extends H {
                        constructor(t, e, i, n, s) {
                            super(t), this._iconRegistry = e, this._location = n, this._errorHandler = s, this._inline = !1, this._currentIconFetch = h.b.EMPTY, i || t.nativeElement.setAttribute("aria-hidden", "true")
                        }
                        get inline() {
                            return this._inline
                        }
                        set inline(t) {
                            this._inline = Object(r.c)(t)
                        }
                        get svgIcon() {
                            return this._svgIcon
                        }
                        set svgIcon(t) {
                            t !== this._svgIcon && (t ? this._updateSvgIcon(t) : this._svgIcon && this._clearSvgElement(), this._svgIcon = t)
                        }
                        get fontSet() {
                            return this._fontSet
                        }
                        set fontSet(t) {
                            const e = this._cleanupFontValue(t);
                            e !== this._fontSet && (this._fontSet = e, this._updateFontIconClasses())
                        }
                        get fontIcon() {
                            return this._fontIcon
                        }
                        set fontIcon(t) {
                            const e = this._cleanupFontValue(t);
                            e !== this._fontIcon && (this._fontIcon = e, this._updateFontIconClasses())
                        }
                        _splitIconName(t) {
                            if (!t) return ["", ""];
                            const e = t.split(":");
                            switch (e.length) {
                                case 1:
                                    return ["", e[0]];
                                case 2:
                                    return e;
                                default:
                                    throw Error(`Invalid icon name: "${t}"`)
                            }
                        }
                        ngOnInit() {
                            this._updateFontIconClasses()
                        }
                        ngAfterViewChecked() {
                            const t = this._elementsWithExternalReferences;
                            if (t && t.size) {
                                const t = this._location.getPathname();
                                t !== this._previousPath && (this._previousPath = t, this._prependPathToReferences(t))
                            }
                        }
                        ngOnDestroy() {
                            this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear()
                        }
                        _usingFontIcon() {
                            return !this.svgIcon
                        }
                        _setSvgElement(t) {
                            this._clearSvgElement();
                            const e = t.querySelectorAll("style");
                            for (let n = 0; n < e.length; n++) e[n].textContent += " ";
                            const i = this._location.getPathname();
                            this._previousPath = i, this._cacheChildrenWithExternalReferences(t), this._prependPathToReferences(i), this._elementRef.nativeElement.appendChild(t)
                        }
                        _clearSvgElement() {
                            const t = this._elementRef.nativeElement;
                            let e = t.childNodes.length;
                            for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); e--;) {
                                const i = t.childNodes[e];
                                1 === i.nodeType && "svg" !== i.nodeName.toLowerCase() || t.removeChild(i)
                            }
                        }
                        _updateFontIconClasses() {
                            if (!this._usingFontIcon()) return;
                            const t = this._elementRef.nativeElement,
                                e = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass();
                            e != this._previousFontSetClass && (this._previousFontSetClass && t.classList.remove(this._previousFontSetClass), e && t.classList.add(e), this._previousFontSetClass = e), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && t.classList.remove(this._previousFontIconClass), this.fontIcon && t.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon)
                        }
                        _cleanupFontValue(t) {
                            return "string" == typeof t ? t.trim().split(" ")[0] : t
                        }
                        _prependPathToReferences(t) {
                            const e = this._elementsWithExternalReferences;
                            e && e.forEach((e, i) => {
                                e.forEach(e => {
                                    i.setAttribute(e.name, `url('${t}#${e.value}')`)
                                })
                            })
                        }
                        _cacheChildrenWithExternalReferences(t) {
                            const e = t.querySelectorAll(W),
                                i = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map;
                            for (let n = 0; n < e.length; n++) X.forEach(t => {
                                const s = e[n],
                                    r = s.getAttribute(t),
                                    a = r ? r.match(Y) : null;
                                if (a) {
                                    let e = i.get(s);
                                    e || (e = [], i.set(s, e)), e.push({
                                        name: t,
                                        value: a[1]
                                    })
                                }
                            })
                        }
                        _updateSvgIcon(t) {
                            if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), t) {
                                const [e, i] = this._splitIconName(t);
                                e && (this._svgNamespace = e), i && (this._svgName = i), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(i, e).pipe(Object(m.a)(1)).subscribe(t => this._setSvgElement(t), t => {
                                    this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${i}! ${t.message}`))
                                })
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(N), n.ac("aria-hidden"), n.Pb(U), n.Pb(n.n))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["mat-icon"]
                        ],
                        hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"],
                        hostVars: 7,
                        hostBindings: function(t, e) {
                            2 & t && (n.Eb("data-mat-icon-type", e._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", e._svgName || e.fontIcon)("data-mat-icon-namespace", e._svgNamespace || e.fontSet), n.Hb("mat-icon-inline", e.inline)("mat-icon-no-color", "primary" !== e.color && "accent" !== e.color && "warn" !== e.color))
                        },
                        inputs: {
                            color: "color",
                            inline: "inline",
                            svgIcon: "svgIcon",
                            fontSet: "fontSet",
                            fontIcon: "fontIcon"
                        },
                        exportAs: ["matIcon"],
                        features: [n.Ab],
                        ngContentSelectors: M,
                        decls: 1,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (n.kc(), n.jc(0))
                        },
                        styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                q = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        imports: [
                            [s.e], s.e
                        ]
                    }), t
                })()
        },
        O0iu: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = t => t && "number" == typeof t.length && "function" != typeof t
        },
        PCNd: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return y
            });
            var n = i("MutI"),
                s = i("NFeN"),
                r = i("tyNb"),
                a = i("bTqV"),
                o = i("ofXK"),
                l = i("STbY"),
                c = i("d3UM"),
                h = i("3Pt+"),
                u = i("XhcP"),
                d = i("/t3+"),
                p = i("kmnG"),
                f = i("qFsG"),
                g = i("TU8p"),
                m = i("fXoL");
            let b = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = m.Nb({
                        type: t
                    }), t.\u0275inj = m.Mb({
                        imports: [
                            [o.c, d.b, p.d, s.b, l.c, a.c, f.b, g.b]
                        ]
                    }), t
                })(),
                y = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = m.Nb({
                        type: t
                    }), t.\u0275inj = m.Mb({
                        imports: [
                            [b, n.c, s.b, r.e, a.c, o.c, l.c, c.b, h.g, u.d], b
                        ]
                    }), t
                })()
        },
        PV23: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("SIQg"),
                s = i("g/MW");

            function r(t) {
                return new n.a(e => {
                    Object(s.c)(t()).subscribe(e)
                })
            }
        },
        PsNa: function(t, e, i) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.MODULE_CONFIG = {
                OnInit: "hmrOnInit",
                OnStatus: "hmrOnStatus",
                OnCheck: "hmrOnCheck",
                OnDecline: "hmrOnDecline",
                OnDestroy: "hmrOnDestroy",
                AfterDestroy: "hmrAfterDestroy"
            }, e.hmrModule = function(t, i, n) {
                return void 0 === n && (n = e.MODULE_CONFIG), i.hot && (i.hot.accept(), t.instance[e.MODULE_CONFIG.OnInit] && i.hot.data && t.instance[e.MODULE_CONFIG.OnInit](i.hot.data), t.instance[e.MODULE_CONFIG.OnStatus] && i.hot.apply(function(i) {
                    t.instance[e.MODULE_CONFIG.OnStatus](i)
                }), t.instance[e.MODULE_CONFIG.OnCheck] && i.hot.check(function(i, n) {
                    t.instance[e.MODULE_CONFIG.OnCheck](i, n)
                }), t.instance[e.MODULE_CONFIG.OnDecline] && i.hot.decline(function(i) {
                    t.instance[e.MODULE_CONFIG.OnDecline](i)
                }), i.hot.dispose(function(i) {
                    t.instance[e.MODULE_CONFIG.OnDestroy] && t.instance[e.MODULE_CONFIG.OnDestroy](i), t.destroy(), t.instance[e.MODULE_CONFIG.AfterDestroy] && t.instance[e.MODULE_CONFIG.AfterDestroy](i)
                })), t
            }
        },
        Qd51: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            var n = i("oXA7"),
                s = i("bx2D"),
                r = i("g/MW"),
                a = i("EPzc");

            function o(t) {
                t = t || {};
                const {
                    connector: e = (() => new n.a),
                    resetOnComplete: i = !0,
                    resetOnError: o = !0,
                    resetOnRefCountZero: l = !0
                } = t;
                let c = null,
                    h = null,
                    u = 0,
                    d = !1,
                    p = !1;
                const f = () => {
                    c = h = null, d = p = !1
                };
                return Object(a.b)((t, n) => (u++, h = null != h ? h : e(), h.subscribe(n), c || (c = new s.a({
                    next: t => h.next(t),
                    error: t => {
                        p = !0;
                        const e = h;
                        o && f(), e.error(t)
                    },
                    complete: () => {
                        d = !0;
                        const t = h;
                        i && f(), t.complete()
                    }
                }), Object(r.a)(t).subscribe(c)), () => {
                    if (u--, l && !u && !p && !d) {
                        const t = c;
                        f(), null == t || t.unsubscribe()
                    }
                }))
            }
        },
        QoT1: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("SIQg"),
                s = i("Jlqm"),
                r = i("XwfS");

            function a(t = 0, e, i = s.a) {
                let a = -1;
                return null != e && (Object(r.a)(e) ? i = e : a = e), new n.a(e => {
                    let n = (s = t) instanceof Date && !isNaN(s) ? +t - i.now() : t;
                    var s;
                    n < 0 && (n = 0);
                    let r = 0;
                    return i.schedule(function() {
                        e.closed || (e.next(r++), 0 <= a ? this.schedule(void 0, a) : e.complete())
                    }, n)
                })
            }
        },
        R0Ic: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            }), i.d(e, "b", function() {
                return n
            }), i.d(e, "c", function() {
                return s
            }), i.d(e, "d", function() {
                return m
            }), i.d(e, "e", function() {
                return o
            }), i.d(e, "f", function() {
                return p
            }), i.d(e, "g", function() {
                return u
            }), i.d(e, "h", function() {
                return f
            }), i.d(e, "i", function() {
                return l
            }), i.d(e, "j", function() {
                return h
            }), i.d(e, "k", function() {
                return c
            }), i.d(e, "l", function() {
                return d
            }), i.d(e, "m", function() {
                return a
            }), i.d(e, "n", function() {
                return b
            }), i.d(e, "o", function() {
                return y
            });
            class n {}
            class s {}
            const r = "*";

            function a(t, e) {
                return {
                    type: 7,
                    name: t,
                    definitions: e,
                    options: {}
                }
            }

            function o(t, e = null) {
                return {
                    type: 4,
                    styles: e,
                    timings: t
                }
            }

            function l(t, e = null) {
                return {
                    type: 2,
                    steps: t,
                    options: e
                }
            }

            function c(t) {
                return {
                    type: 6,
                    styles: t,
                    offset: null
                }
            }

            function h(t, e, i) {
                return {
                    type: 0,
                    name: t,
                    styles: e,
                    options: i
                }
            }

            function u(t) {
                return {
                    type: 5,
                    steps: t
                }
            }

            function d(t, e, i = null) {
                return {
                    type: 1,
                    expr: t,
                    animation: e,
                    options: i
                }
            }

            function p(t = null) {
                return {
                    type: 9,
                    options: t
                }
            }

            function f(t, e, i = null) {
                return {
                    type: 11,
                    selector: t,
                    animation: e,
                    options: i
                }
            }

            function g(t) {
                Promise.resolve(null).then(t)
            }
            class m {
                constructor(t = 0, e = 0) {
                    this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = [])
                }
                onStart(t) {
                    this._onStartFns.push(t)
                }
                onDone(t) {
                    this._onDoneFns.push(t)
                }
                onDestroy(t) {
                    this._onDestroyFns.push(t)
                }
                hasStarted() {
                    return this._started
                }
                init() {}
                play() {
                    this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0
                }
                triggerMicrotask() {
                    g(() => this._onFinish())
                }
                _onStart() {
                    this._onStartFns.forEach(t => t()), this._onStartFns = []
                }
                pause() {}
                restart() {}
                finish() {
                    this._onFinish()
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
                }
                reset() {}
                setPosition(t) {
                    this._position = this.totalTime ? t * this.totalTime : 1
                }
                getPosition() {
                    return this.totalTime ? this._position / this.totalTime : 1
                }
                triggerCallback(t) {
                    const e = "start" == t ? this._onStartFns : this._onDoneFns;
                    e.forEach(t => t()), e.length = 0
                }
            }
            class b {
                constructor(t) {
                    this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t;
                    let e = 0,
                        i = 0,
                        n = 0;
                    const s = this.players.length;
                    0 == s ? g(() => this._onFinish()) : this.players.forEach(t => {
                        t.onDone(() => {
                            ++e == s && this._onFinish()
                        }), t.onDestroy(() => {
                            ++i == s && this._onDestroy()
                        }), t.onStart(() => {
                            ++n == s && this._onStart()
                        })
                    }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0)
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = [])
                }
                init() {
                    this.players.forEach(t => t.init())
                }
                onStart(t) {
                    this._onStartFns.push(t)
                }
                _onStart() {
                    this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = [])
                }
                onDone(t) {
                    this._onDoneFns.push(t)
                }
                onDestroy(t) {
                    this._onDestroyFns.push(t)
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play())
                }
                pause() {
                    this.players.forEach(t => t.pause())
                }
                restart() {
                    this.players.forEach(t => t.restart())
                }
                finish() {
                    this._onFinish(), this.players.forEach(t => t.finish())
                }
                destroy() {
                    this._onDestroy()
                }
                _onDestroy() {
                    this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
                }
                reset() {
                    this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1
                }
                setPosition(t) {
                    const e = t * this.totalTime;
                    this.players.forEach(t => {
                        const i = t.totalTime ? Math.min(1, e / t.totalTime) : 1;
                        t.setPosition(i)
                    })
                }
                getPosition() {
                    const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null);
                    return null != t ? t.getPosition() : 0
                }
                beforeDestroy() {
                    this.players.forEach(t => {
                        t.beforeDestroy && t.beforeDestroy()
                    })
                }
                triggerCallback(t) {
                    const e = "start" == t ? this._onStartFns : this._onDoneFns;
                    e.forEach(t => t()), e.length = 0
                }
            }
            const y = "!"
        },
        R1ws: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return me
            }), i.d(e, "b", function() {
                return ye
            });
            var n = i("fXoL"),
                s = i("jhN1"),
                r = i("R0Ic");

            function a() {
                return "undefined" != typeof process && "[object process]" === {}.toString.call(process)
            }

            function o(t) {
                switch (t.length) {
                    case 0:
                        return new r.d;
                    case 1:
                        return t[0];
                    default:
                        return new r.n(t)
                }
            }

            function l(t, e, i, n, s = {}, a = {}) {
                const o = [],
                    l = [];
                let c = -1,
                    h = null;
                if (n.forEach(t => {
                        const i = t.offset,
                            n = i == c,
                            u = n && h || {};
                        Object.keys(t).forEach(i => {
                            let n = i,
                                l = t[i];
                            if ("offset" !== i) switch (n = e.normalizePropertyName(n, o), l) {
                                case r.o:
                                    l = s[i];
                                    break;
                                case r.a:
                                    l = a[i];
                                    break;
                                default:
                                    l = e.normalizeStyleValue(i, n, l, o)
                            }
                            u[n] = l
                        }), n || l.push(u), h = u, c = i
                    }), o.length) {
                    const t = "\n - ";
                    throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`)
                }
                return l
            }

            function c(t, e, i, n) {
                switch (e) {
                    case "start":
                        t.onStart(() => n(i && h(i, "start", t)));
                        break;
                    case "done":
                        t.onDone(() => n(i && h(i, "done", t)));
                        break;
                    case "destroy":
                        t.onDestroy(() => n(i && h(i, "destroy", t)))
                }
            }

            function h(t, e, i) {
                const n = i.totalTime,
                    s = u(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == n ? t.totalTime : n, !!i.disabled),
                    r = t._data;
                return null != r && (s._data = r), s
            }

            function u(t, e, i, n, s = "", r = 0, a) {
                return {
                    element: t,
                    triggerName: e,
                    fromState: i,
                    toState: n,
                    phaseName: s,
                    totalTime: r,
                    disabled: !!a
                }
            }

            function d(t, e, i) {
                let n;
                return t instanceof Map ? (n = t.get(e), n || t.set(e, n = i)) : (n = t[e], n || (n = t[e] = i)), n
            }

            function p(t) {
                const e = t.indexOf(":");
                return [t.substring(1, e), t.substr(e + 1)]
            }
            let f = (t, e) => !1,
                g = (t, e) => !1,
                m = (t, e, i) => [];
            const b = a();
            (b || "undefined" != typeof Element) && (f = (t, e) => t.contains(e), g = (() => {
                if (b || Element.prototype.matches) return (t, e) => t.matches(e); {
                    const t = Element.prototype,
                        e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector;
                    return e ? (t, i) => e.apply(t, [i]) : g
                }
            })(), m = (t, e, i) => {
                let n = [];
                if (i) {
                    const i = t.querySelectorAll(e);
                    for (let t = 0; t < i.length; t++) n.push(i[t])
                } else {
                    const i = t.querySelector(e);
                    i && n.push(i)
                }
                return n
            });
            let y = null,
                v = !1;

            function x(t) {
                y || (y = ("undefined" != typeof document ? document.body : null) || {}, v = !!y.style && "WebkitAppearance" in y.style);
                let e = !0;
                return y.style && ! function(t) {
                    return "ebkit" == t.substring(1, 6)
                }(t) && (e = t in y.style, !e && v) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in y.style), e
            }
            const _ = g,
                w = f,
                C = m;

            function k(t) {
                const e = {};
                return Object.keys(t).forEach(i => {
                    const n = i.replace(/([a-z])([A-Z])/g, "$1-$2");
                    e[n] = t[i]
                }), e
            }
            let S = (() => {
                    class t {
                        validateStyleProperty(t) {
                            return x(t)
                        }
                        matchesElement(t, e) {
                            return _(t, e)
                        }
                        containsElement(t, e) {
                            return w(t, e)
                        }
                        query(t, e, i) {
                            return C(t, e, i)
                        }
                        computeStyle(t, e, i) {
                            return i || ""
                        }
                        animate(t, e, i, n, s, a = [], o) {
                            return new r.d(i, n)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = n.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                A = (() => {
                    class t {}
                    return t.NOOP = new S, t
                })();

            function O(t) {
                if ("number" == typeof t) return t;
                const e = t.match(/^(-?[\.\d]+)(m?s)/);
                return !e || e.length < 2 ? 0 : E(parseFloat(e[1]), e[2])
            }

            function E(t, e) {
                switch (e) {
                    case "s":
                        return 1e3 * t;
                    default:
                        return t
                }
            }

            function P(t, e, i) {
                return t.hasOwnProperty("duration") ? t : function(t, e, i) {
                    let n, s = 0,
                        r = "";
                    if ("string" == typeof t) {
                        const i = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);
                        if (null === i) return e.push(`The provided timing value "${t}" is invalid.`), {
                            duration: 0,
                            delay: 0,
                            easing: ""
                        };
                        n = E(parseFloat(i[1]), i[2]);
                        const a = i[3];
                        null != a && (s = E(parseFloat(a), i[4]));
                        const o = i[5];
                        o && (r = o)
                    } else n = t;
                    if (!i) {
                        let i = !1,
                            r = e.length;
                        n < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), i = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), i = !0), i && e.splice(r, 0, `The provided timing value "${t}" is invalid.`)
                    }
                    return {
                        duration: n,
                        delay: s,
                        easing: r
                    }
                }(t, e, i)
            }

            function T(t, e = {}) {
                return Object.keys(t).forEach(i => {
                    e[i] = t[i]
                }), e
            }

            function D(t, e, i = {}) {
                if (e)
                    for (let n in t) i[n] = t[n];
                else T(t, i);
                return i
            }

            function I(t, e, i) {
                return i ? e + ":" + i + ";" : ""
            }

            function M(t) {
                let e = "";
                for (let i = 0; i < t.style.length; i++) {
                    const n = t.style.item(i);
                    e += I(0, n, t.style.getPropertyValue(n))
                }
                for (const i in t.style) t.style.hasOwnProperty(i) && !i.startsWith("_") && (e += I(0, i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[i]));
                t.setAttribute("style", e)
            }

            function L(t, e, i) {
                t.style && (Object.keys(e).forEach(n => {
                    const s = H(n);
                    i && !i.hasOwnProperty(n) && (i[n] = t.style[s]), t.style[s] = e[n]
                }), a() && M(t))
            }

            function R(t, e) {
                t.style && (Object.keys(e).forEach(e => {
                    const i = H(e);
                    t.style[i] = ""
                }), a() && M(t))
            }

            function j(t) {
                return Array.isArray(t) ? 1 == t.length ? t[0] : Object(r.i)(t) : t
            }
            const F = new RegExp("{{\\s*(.+?)\\s*}}", "g");

            function N(t) {
                let e = [];
                if ("string" == typeof t) {
                    let i;
                    for (; i = F.exec(t);) e.push(i[1]);
                    F.lastIndex = 0
                }
                return e
            }

            function z(t, e, i) {
                const n = t.toString(),
                    s = n.replace(F, (t, n) => {
                        let s = e[n];
                        return e.hasOwnProperty(n) || (i.push(`Please provide a value for the animation param ${n}`), s = ""), s.toString()
                    });
                return s == n ? t : s
            }

            function V(t) {
                const e = [];
                let i = t.next();
                for (; !i.done;) e.push(i.value), i = t.next();
                return e
            }
            const B = /-+([a-z0-9])/g;

            function H(t) {
                return t.replace(B, (...t) => t[1].toUpperCase())
            }

            function U(t, e) {
                return 0 === t || 0 === e
            }

            function X(t, e, i) {
                const n = Object.keys(i);
                if (n.length && e.length) {
                    let r = e[0],
                        a = [];
                    if (n.forEach(t => {
                            r.hasOwnProperty(t) || a.push(t), r[t] = i[t]
                        }), a.length)
                        for (var s = 1; s < e.length; s++) {
                            let i = e[s];
                            a.forEach(function(e) {
                                i[e] = Y(t, e)
                            })
                        }
                }
                return e
            }

            function W(t, e, i) {
                switch (e.type) {
                    case 7:
                        return t.visitTrigger(e, i);
                    case 0:
                        return t.visitState(e, i);
                    case 1:
                        return t.visitTransition(e, i);
                    case 2:
                        return t.visitSequence(e, i);
                    case 3:
                        return t.visitGroup(e, i);
                    case 4:
                        return t.visitAnimate(e, i);
                    case 5:
                        return t.visitKeyframes(e, i);
                    case 6:
                        return t.visitStyle(e, i);
                    case 8:
                        return t.visitReference(e, i);
                    case 9:
                        return t.visitAnimateChild(e, i);
                    case 10:
                        return t.visitAnimateRef(e, i);
                    case 11:
                        return t.visitQuery(e, i);
                    case 12:
                        return t.visitStagger(e, i);
                    default:
                        throw new Error(`Unable to resolve animation metadata node #${e.type}`)
                }
            }

            function Y(t, e) {
                return window.getComputedStyle(t)[e]
            }

            function G(t, e) {
                const i = [];
                return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function(t, e, i) {
                    if (":" == t[0]) {
                        const n = function(t, e) {
                            switch (t) {
                                case ":enter":
                                    return "void => *";
                                case ":leave":
                                    return "* => void";
                                case ":increment":
                                    return (t, e) => parseFloat(e) > parseFloat(t);
                                case ":decrement":
                                    return (t, e) => parseFloat(e) < parseFloat(t);
                                default:
                                    return e.push(`The transition alias value "${t}" is not supported`), "* => *"
                            }
                        }(t, i);
                        if ("function" == typeof n) return void e.push(n);
                        t = n
                    }
                    const n = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                    if (null == n || n.length < 4) return i.push(`The provided transition expression "${t}" is not supported`), e;
                    const s = n[1],
                        r = n[2],
                        a = n[3];
                    e.push($(s, a)), "<" != r[0] || "*" == s && "*" == a || e.push($(a, s))
                }(t, i, e)) : i.push(t), i
            }
            const q = new Set(["true", "1"]),
                Z = new Set(["false", "0"]);

            function $(t, e) {
                const i = q.has(t) || Z.has(t),
                    n = q.has(e) || Z.has(e);
                return (s, r) => {
                    let a = "*" == t || t == s,
                        o = "*" == e || e == r;
                    return !a && i && "boolean" == typeof s && (a = s ? q.has(t) : Z.has(t)), !o && n && "boolean" == typeof r && (o = r ? q.has(e) : Z.has(e)), a && o
                }
            }
            const Q = new RegExp("s*:selfs*,?", "g");

            function K(t, e, i) {
                return new J(t).build(e, i)
            }
            class J {
                constructor(t) {
                    this._driver = t
                }
                build(t, e) {
                    const i = new tt(e);
                    return this._resetContextStyleTimingState(i), W(this, j(t), i)
                }
                _resetContextStyleTimingState(t) {
                    t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0
                }
                visitTrigger(t, e) {
                    let i = e.queryCount = 0,
                        n = e.depCount = 0;
                    const s = [],
                        r = [];
                    return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => {
                        if (this._resetContextStyleTimingState(e), 0 == t.type) {
                            const i = t,
                                n = i.name;
                            n.toString().split(/\s*,\s*/).forEach(t => {
                                i.name = t, s.push(this.visitState(i, e))
                            }), i.name = n
                        } else if (1 == t.type) {
                            const s = this.visitTransition(t, e);
                            i += s.queryCount, n += s.depCount, r.push(s)
                        } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")
                    }), {
                        type: 7,
                        name: t.name,
                        states: s,
                        transitions: r,
                        queryCount: i,
                        depCount: n,
                        options: null
                    }
                }
                visitState(t, e) {
                    const i = this.visitStyle(t.styles, e),
                        n = t.options && t.options.params || null;
                    if (i.containsDynamicStyles) {
                        const s = new Set,
                            r = n || {};
                        if (i.styles.forEach(t => {
                                if (et(t)) {
                                    const e = t;
                                    Object.keys(e).forEach(t => {
                                        N(e[t]).forEach(t => {
                                            r.hasOwnProperty(t) || s.add(t)
                                        })
                                    })
                                }
                            }), s.size) {
                            const i = V(s.values());
                            e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${i.join(", ")}`)
                        }
                    }
                    return {
                        type: 0,
                        name: t.name,
                        style: i,
                        options: n ? {
                            params: n
                        } : null
                    }
                }
                visitTransition(t, e) {
                    e.queryCount = 0, e.depCount = 0;
                    const i = W(this, j(t.animation), e);
                    return {
                        type: 1,
                        matchers: G(t.expr, e.errors),
                        animation: i,
                        queryCount: e.queryCount,
                        depCount: e.depCount,
                        options: it(t.options)
                    }
                }
                visitSequence(t, e) {
                    return {
                        type: 2,
                        steps: t.steps.map(t => W(this, t, e)),
                        options: it(t.options)
                    }
                }
                visitGroup(t, e) {
                    const i = e.currentTime;
                    let n = 0;
                    const s = t.steps.map(t => {
                        e.currentTime = i;
                        const s = W(this, t, e);
                        return n = Math.max(n, e.currentTime), s
                    });
                    return e.currentTime = n, {
                        type: 3,
                        steps: s,
                        options: it(t.options)
                    }
                }
                visitAnimate(t, e) {
                    const i = function(t, e) {
                        let i = null;
                        if (t.hasOwnProperty("duration")) i = t;
                        else if ("number" == typeof t) return nt(P(t, e).duration, 0, "");
                        const n = t;
                        if (n.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) {
                            const t = nt(0, 0, "");
                            return t.dynamic = !0, t.strValue = n, t
                        }
                        return i = i || P(n, e), nt(i.duration, i.delay, i.easing)
                    }(t.timings, e.errors);
                    let n;
                    e.currentAnimateTimings = i;
                    let s = t.styles ? t.styles : Object(r.k)({});
                    if (5 == s.type) n = this.visitKeyframes(s, e);
                    else {
                        let s = t.styles,
                            a = !1;
                        if (!s) {
                            a = !0;
                            const t = {};
                            i.easing && (t.easing = i.easing), s = Object(r.k)(t)
                        }
                        e.currentTime += i.duration + i.delay;
                        const o = this.visitStyle(s, e);
                        o.isEmptyStep = a, n = o
                    }
                    return e.currentAnimateTimings = null, {
                        type: 4,
                        timings: i,
                        style: n,
                        options: null
                    }
                }
                visitStyle(t, e) {
                    const i = this._makeStyleAst(t, e);
                    return this._validateStyleAst(i, e), i
                }
                _makeStyleAst(t, e) {
                    const i = [];
                    Array.isArray(t.styles) ? t.styles.forEach(t => {
                        "string" == typeof t ? t == r.a ? i.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : i.push(t)
                    }) : i.push(t.styles);
                    let n = !1,
                        s = null;
                    return i.forEach(t => {
                        if (et(t)) {
                            const e = t,
                                i = e.easing;
                            if (i && (s = i, delete e.easing), !n)
                                for (let t in e)
                                    if (e[t].toString().indexOf("{{") >= 0) {
                                        n = !0;
                                        break
                                    }
                        }
                    }), {
                        type: 6,
                        styles: i,
                        easing: s,
                        offset: t.offset,
                        containsDynamicStyles: n,
                        options: null
                    }
                }
                _validateStyleAst(t, e) {
                    const i = e.currentAnimateTimings;
                    let n = e.currentTime,
                        s = e.currentTime;
                    i && s > 0 && (s -= i.duration + i.delay), t.styles.forEach(t => {
                        "string" != typeof t && Object.keys(t).forEach(i => {
                            if (!this._driver.validateStyleProperty(i)) return void e.errors.push(`The provided animation property "${i}" is not a supported CSS property for animations`);
                            const r = e.collectedStyles[e.currentQuerySelector],
                                a = r[i];
                            let o = !0;
                            a && (s != n && s >= a.startTime && n <= a.endTime && (e.errors.push(`The CSS property "${i}" that exists between the times of "${a.startTime}ms" and "${a.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${n}ms"`), o = !1), s = a.startTime), o && (r[i] = {
                                startTime: s,
                                endTime: n
                            }), e.options && function(t, e, i) {
                                const n = e.params || {},
                                    s = N(t);
                                s.length && s.forEach(t => {
                                    n.hasOwnProperty(t) || i.push(`Unable to resolve the local animation param ${t} in the given list of values`)
                                })
                            }(t[i], e.options, e.errors)
                        })
                    })
                }
                visitKeyframes(t, e) {
                    const i = {
                        type: 5,
                        styles: [],
                        options: null
                    };
                    if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i;
                    let n = 0;
                    const s = [];
                    let r = !1,
                        a = !1,
                        o = 0;
                    const l = t.steps.map(t => {
                        const i = this._makeStyleAst(t, e);
                        let l = null != i.offset ? i.offset : function(t) {
                                if ("string" == typeof t) return null;
                                let e = null;
                                if (Array.isArray(t)) t.forEach(t => {
                                    if (et(t) && t.hasOwnProperty("offset")) {
                                        const i = t;
                                        e = parseFloat(i.offset), delete i.offset
                                    }
                                });
                                else if (et(t) && t.hasOwnProperty("offset")) {
                                    const i = t;
                                    e = parseFloat(i.offset), delete i.offset
                                }
                                return e
                            }(i.styles),
                            c = 0;
                        return null != l && (n++, c = i.offset = l), a = a || c < 0 || c > 1, r = r || c < o, o = c, s.push(c), i
                    });
                    a && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), r && e.errors.push("Please ensure that all keyframe offsets are in order");
                    const c = t.steps.length;
                    let h = 0;
                    n > 0 && n < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == n && (h = 1 / (c - 1));
                    const u = c - 1,
                        d = e.currentTime,
                        p = e.currentAnimateTimings,
                        f = p.duration;
                    return l.forEach((t, n) => {
                        const r = h > 0 ? n == u ? 1 : h * n : s[n],
                            a = r * f;
                        e.currentTime = d + p.delay + a, p.duration = a, this._validateStyleAst(t, e), t.offset = r, i.styles.push(t)
                    }), i
                }
                visitReference(t, e) {
                    return {
                        type: 8,
                        animation: W(this, j(t.animation), e),
                        options: it(t.options)
                    }
                }
                visitAnimateChild(t, e) {
                    return e.depCount++, {
                        type: 9,
                        options: it(t.options)
                    }
                }
                visitAnimateRef(t, e) {
                    return {
                        type: 10,
                        animation: this.visitReference(t.animation, e),
                        options: it(t.options)
                    }
                }
                visitQuery(t, e) {
                    const i = e.currentQuerySelector,
                        n = t.options || {};
                    e.queryCount++, e.currentQuery = t;
                    const [s, r] = function(t) {
                        const e = !!t.split(/\s*,\s*/).find(t => ":self" == t);
                        return e && (t = t.replace(Q, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e]
                    }(t.selector);
                    e.currentQuerySelector = i.length ? i + " " + s : s, d(e.collectedStyles, e.currentQuerySelector, {});
                    const a = W(this, j(t.animation), e);
                    return e.currentQuery = null, e.currentQuerySelector = i, {
                        type: 11,
                        selector: s,
                        limit: n.limit || 0,
                        optional: !!n.optional,
                        includeSelf: r,
                        animation: a,
                        originalSelector: t.selector,
                        options: it(t.options)
                    }
                }
                visitStagger(t, e) {
                    e.currentQuery || e.errors.push("stagger() can only be used inside of query()");
                    const i = "full" === t.timings ? {
                        duration: 0,
                        delay: 0,
                        easing: "full"
                    } : P(t.timings, e.errors, !0);
                    return {
                        type: 12,
                        animation: W(this, j(t.animation), e),
                        timings: i,
                        options: null
                    }
                }
            }
            class tt {
                constructor(t) {
                    this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null
                }
            }

            function et(t) {
                return !Array.isArray(t) && "object" == typeof t
            }

            function it(t) {
                var e;
                return t ? (t = T(t)).params && (t.params = (e = t.params) ? T(e) : null) : t = {}, t
            }

            function nt(t, e, i) {
                return {
                    duration: t,
                    delay: e,
                    easing: i
                }
            }

            function st(t, e, i, n, s, r, a = null, o = !1) {
                return {
                    type: 1,
                    element: t,
                    keyframes: e,
                    preStyleProps: i,
                    postStyleProps: n,
                    duration: s,
                    delay: r,
                    totalTime: s + r,
                    easing: a,
                    subTimeline: o
                }
            }
            class rt {
                constructor() {
                    this._map = new Map
                }
                consume(t) {
                    let e = this._map.get(t);
                    return e ? this._map.delete(t) : e = [], e
                }
                append(t, e) {
                    let i = this._map.get(t);
                    i || this._map.set(t, i = []), i.push(...e)
                }
                has(t) {
                    return this._map.has(t)
                }
                clear() {
                    this._map.clear()
                }
            }
            const at = new RegExp(":enter", "g"),
                ot = new RegExp(":leave", "g");

            function lt(t, e, i, n, s, r = {}, a = {}, o, l, c = []) {
                return (new ct).buildKeyframes(t, e, i, n, s, r, a, o, l, c)
            }
            class ct {
                buildKeyframes(t, e, i, n, s, r, a, o, l, c = []) {
                    l = l || new rt;
                    const h = new ut(t, e, l, n, s, c, []);
                    h.options = o, h.currentTimeline.setStyles([r], null, h.errors, o), W(this, i, h);
                    const u = h.timelines.filter(t => t.containsAnimation());
                    if (u.length && Object.keys(a).length) {
                        const t = u[u.length - 1];
                        t.allowOnlyTimelineStyles() || t.setStyles([a], null, h.errors, o)
                    }
                    return u.length ? u.map(t => t.buildKeyframes()) : [st(e, [], [], [], 0, 0, "", !1)]
                }
                visitTrigger(t, e) {}
                visitState(t, e) {}
                visitTransition(t, e) {}
                visitAnimateChild(t, e) {
                    const i = e.subInstructions.consume(e.element);
                    if (i) {
                        const n = e.createSubContext(t.options),
                            s = e.currentTimeline.currentTime,
                            r = this._visitSubInstructions(i, n, n.options);
                        s != r && e.transformIntoNewTimeline(r)
                    }
                    e.previousNode = t
                }
                visitAnimateRef(t, e) {
                    const i = e.createSubContext(t.options);
                    i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t
                }
                _visitSubInstructions(t, e, i) {
                    let n = e.currentTimeline.currentTime;
                    const s = null != i.duration ? O(i.duration) : null,
                        r = null != i.delay ? O(i.delay) : null;
                    return 0 !== s && t.forEach(t => {
                        const i = e.appendInstructionToTimeline(t, s, r);
                        n = Math.max(n, i.duration + i.delay)
                    }), n
                }
                visitReference(t, e) {
                    e.updateOptions(t.options, !0), W(this, t.animation, e), e.previousNode = t
                }
                visitSequence(t, e) {
                    const i = e.subContextCount;
                    let n = e;
                    const s = t.options;
                    if (s && (s.params || s.delay) && (n = e.createSubContext(s), n.transformIntoNewTimeline(), null != s.delay)) {
                        6 == n.previousNode.type && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = ht);
                        const t = O(s.delay);
                        n.delayNextStep(t)
                    }
                    t.steps.length && (t.steps.forEach(t => W(this, t, n)), n.currentTimeline.applyStylesToKeyframe(), n.subContextCount > i && n.transformIntoNewTimeline()), e.previousNode = t
                }
                visitGroup(t, e) {
                    const i = [];
                    let n = e.currentTimeline.currentTime;
                    const s = t.options && t.options.delay ? O(t.options.delay) : 0;
                    t.steps.forEach(r => {
                        const a = e.createSubContext(t.options);
                        s && a.delayNextStep(s), W(this, r, a), n = Math.max(n, a.currentTimeline.currentTime), i.push(a.currentTimeline)
                    }), i.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(n), e.previousNode = t
                }
                _visitTiming(t, e) {
                    if (t.dynamic) {
                        const i = t.strValue;
                        return P(e.params ? z(i, e.params, e.errors) : i, e.errors)
                    }
                    return {
                        duration: t.duration,
                        delay: t.delay,
                        easing: t.easing
                    }
                }
                visitAnimate(t, e) {
                    const i = e.currentAnimateTimings = this._visitTiming(t.timings, e),
                        n = e.currentTimeline;
                    i.delay && (e.incrementTime(i.delay), n.snapshotCurrentStyles());
                    const s = t.style;
                    5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(i.duration), this.visitStyle(s, e), n.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t
                }
                visitStyle(t, e) {
                    const i = e.currentTimeline,
                        n = e.currentAnimateTimings;
                    !n && i.getCurrentStyleProperties().length && i.forwardFrame();
                    const s = n && n.easing || t.easing;
                    t.isEmptyStep ? i.applyEmptyStep(s) : i.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t
                }
                visitKeyframes(t, e) {
                    const i = e.currentAnimateTimings,
                        n = e.currentTimeline.duration,
                        s = i.duration,
                        r = e.createSubContext().currentTimeline;
                    r.easing = i.easing, t.styles.forEach(t => {
                        r.forwardTime((t.offset || 0) * s), r.setStyles(t.styles, t.easing, e.errors, e.options), r.applyStylesToKeyframe()
                    }), e.currentTimeline.mergeTimelineCollectedStyles(r), e.transformIntoNewTimeline(n + s), e.previousNode = t
                }
                visitQuery(t, e) {
                    const i = e.currentTimeline.currentTime,
                        n = t.options || {},
                        s = n.delay ? O(n.delay) : 0;
                    s && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = ht);
                    let r = i;
                    const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!n.optional, e.errors);
                    e.currentQueryTotal = a.length;
                    let o = null;
                    a.forEach((i, n) => {
                        e.currentQueryIndex = n;
                        const a = e.createSubContext(t.options, i);
                        s && a.delayNextStep(s), i === e.element && (o = a.currentTimeline), W(this, t.animation, a), a.currentTimeline.applyStylesToKeyframe(), r = Math.max(r, a.currentTimeline.currentTime)
                    }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(r), o && (e.currentTimeline.mergeTimelineCollectedStyles(o), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t
                }
                visitStagger(t, e) {
                    const i = e.parentContext,
                        n = e.currentTimeline,
                        s = t.timings,
                        r = Math.abs(s.duration),
                        a = r * (e.currentQueryTotal - 1);
                    let o = r * e.currentQueryIndex;
                    switch (s.duration < 0 ? "reverse" : s.easing) {
                        case "reverse":
                            o = a - o;
                            break;
                        case "full":
                            o = i.currentStaggerTime
                    }
                    const l = e.currentTimeline;
                    o && l.delayNextStep(o);
                    const c = l.currentTime;
                    W(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = n.currentTime - c + (n.startTime - i.currentTimeline.startTime)
                }
            }
            const ht = {};
            class ut {
                constructor(t, e, i, n, s, r, a, o) {
                    this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = n, this._leaveClassName = s, this.errors = r, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = ht, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = o || new dt(this._driver, e, 0), a.push(this.currentTimeline)
                }
                get params() {
                    return this.options.params
                }
                updateOptions(t, e) {
                    if (!t) return;
                    const i = t;
                    let n = this.options;
                    null != i.duration && (n.duration = O(i.duration)), null != i.delay && (n.delay = O(i.delay));
                    const s = i.params;
                    if (s) {
                        let t = n.params;
                        t || (t = this.options.params = {}), Object.keys(s).forEach(i => {
                            e && t.hasOwnProperty(i) || (t[i] = z(s[i], t, this.errors))
                        })
                    }
                }
                _copyOptions() {
                    const t = {};
                    if (this.options) {
                        const e = this.options.params;
                        if (e) {
                            const i = t.params = {};
                            Object.keys(e).forEach(t => {
                                i[t] = e[t]
                            })
                        }
                    }
                    return t
                }
                createSubContext(t = null, e, i) {
                    const n = e || this.element,
                        s = new ut(this._driver, n, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(n, i || 0));
                    return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s
                }
                transformIntoNewTimeline(t) {
                    return this.previousNode = ht, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline
                }
                appendInstructionToTimeline(t, e, i) {
                    const n = {
                            duration: null != e ? e : t.duration,
                            delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay,
                            easing: ""
                        },
                        s = new pt(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, n, t.stretchStartingKeyframe);
                    return this.timelines.push(s), n
                }
                incrementTime(t) {
                    this.currentTimeline.forwardTime(this.currentTimeline.duration + t)
                }
                delayNextStep(t) {
                    t > 0 && this.currentTimeline.delayNextStep(t)
                }
                invokeQuery(t, e, i, n, s, r) {
                    let a = [];
                    if (n && a.push(this.element), t.length > 0) {
                        t = (t = t.replace(at, "." + this._enterClassName)).replace(ot, "." + this._leaveClassName);
                        let e = this._driver.query(this.element, t, 1 != i);
                        0 !== i && (e = i < 0 ? e.slice(e.length + i, e.length) : e.slice(0, i)), a.push(...e)
                    }
                    return s || 0 != a.length || r.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), a
                }
            }
            class dt {
                constructor(t, e, i, n) {
                    this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = n, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe()
                }
                containsAnimation() {
                    switch (this._keyframes.size) {
                        case 0:
                            return !1;
                        case 1:
                            return this.getCurrentStyleProperties().length > 0;
                        default:
                            return !0
                    }
                }
                getCurrentStyleProperties() {
                    return Object.keys(this._currentKeyframe)
                }
                get currentTime() {
                    return this.startTime + this.duration
                }
                delayNextStep(t) {
                    const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length;
                    this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t
                }
                fork(t, e) {
                    return this.applyStylesToKeyframe(), new dt(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup)
                }
                _loadKeyframe() {
                    this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe))
                }
                forwardFrame() {
                    this.duration += 1, this._loadKeyframe()
                }
                forwardTime(t) {
                    this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe()
                }
                _updateStyle(t, e) {
                    this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = {
                        time: this.currentTime,
                        value: e
                    }
                }
                allowOnlyTimelineStyles() {
                    return this._currentEmptyStepKeyframe !== this._currentKeyframe
                }
                applyEmptyStep(t) {
                    t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => {
                        this._backFill[t] = this._globalTimelineStyles[t] || r.a, this._currentKeyframe[t] = r.a
                    }), this._currentEmptyStepKeyframe = this._currentKeyframe
                }
                setStyles(t, e, i, n) {
                    e && (this._previousKeyframe.easing = e);
                    const s = n && n.params || {},
                        a = function(t, e) {
                            const i = {};
                            let n;
                            return t.forEach(t => {
                                "*" === t ? (n = n || Object.keys(e), n.forEach(t => {
                                    i[t] = r.a
                                })) : D(t, !1, i)
                            }), i
                        }(t, this._globalTimelineStyles);
                    Object.keys(a).forEach(t => {
                        const e = z(a[t], s, i);
                        this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : r.a), this._updateStyle(t, e)
                    })
                }
                applyStylesToKeyframe() {
                    const t = this._pendingStyles,
                        e = Object.keys(t);
                    0 != e.length && (this._pendingStyles = {}, e.forEach(e => {
                        this._currentKeyframe[e] = t[e]
                    }), Object.keys(this._localTimelineStyles).forEach(t => {
                        this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t])
                    }))
                }
                snapshotCurrentStyles() {
                    Object.keys(this._localTimelineStyles).forEach(t => {
                        const e = this._localTimelineStyles[t];
                        this._pendingStyles[t] = e, this._updateStyle(t, e)
                    })
                }
                getFinalKeyframe() {
                    return this._keyframes.get(this.duration)
                }
                get properties() {
                    const t = [];
                    for (let e in this._currentKeyframe) t.push(e);
                    return t
                }
                mergeTimelineCollectedStyles(t) {
                    Object.keys(t._styleSummary).forEach(e => {
                        const i = this._styleSummary[e],
                            n = t._styleSummary[e];
                        (!i || n.time > i.time) && this._updateStyle(e, n.value)
                    })
                }
                buildKeyframes() {
                    this.applyStylesToKeyframe();
                    const t = new Set,
                        e = new Set,
                        i = 1 === this._keyframes.size && 0 === this.duration;
                    let n = [];
                    this._keyframes.forEach((s, a) => {
                        const o = D(s, !0);
                        Object.keys(o).forEach(i => {
                            const n = o[i];
                            n == r.o ? t.add(i) : n == r.a && e.add(i)
                        }), i || (o.offset = a / this.duration), n.push(o)
                    });
                    const s = t.size ? V(t.values()) : [],
                        a = e.size ? V(e.values()) : [];
                    if (i) {
                        const t = n[0],
                            e = T(t);
                        t.offset = 0, e.offset = 1, n = [t, e]
                    }
                    return st(this.element, n, s, a, this.duration, this.startTime, this.easing, !1)
                }
            }
            class pt extends dt {
                constructor(t, e, i, n, s, r, a = !1) {
                    super(t, e, r.delay), this.element = e, this.keyframes = i, this.preStyleProps = n, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = {
                        duration: r.duration,
                        delay: r.delay,
                        easing: r.easing
                    }
                }
                containsAnimation() {
                    return this.keyframes.length > 1
                }
                buildKeyframes() {
                    let t = this.keyframes,
                        {
                            delay: e,
                            duration: i,
                            easing: n
                        } = this.timings;
                    if (this._stretchStartingKeyframe && e) {
                        const s = [],
                            r = i + e,
                            a = e / r,
                            o = D(t[0], !1);
                        o.offset = 0, s.push(o);
                        const l = D(t[0], !1);
                        l.offset = ft(a), s.push(l);
                        const c = t.length - 1;
                        for (let n = 1; n <= c; n++) {
                            let a = D(t[n], !1);
                            a.offset = ft((e + a.offset * i) / r), s.push(a)
                        }
                        i = r, e = 0, n = "", t = s
                    }
                    return st(this.element, t, this.preStyleProps, this.postStyleProps, i, e, n, !0)
                }
            }

            function ft(t, e = 3) {
                const i = Math.pow(10, e - 1);
                return Math.round(t * i) / i
            }
            class gt {}
            class mt extends gt {
                normalizePropertyName(t, e) {
                    return H(t)
                }
                normalizeStyleValue(t, e, i, n) {
                    let s = "";
                    const r = i.toString().trim();
                    if (bt[e] && 0 !== i && "0" !== i)
                        if ("number" == typeof i) s = "px";
                        else {
                            const e = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
                            e && 0 == e[1].length && n.push(`Please provide a CSS unit value for ${t}:${i}`)
                        } return r + s
                }
            }
            const bt = (() => function(t) {
                const e = {};
                return t.forEach(t => e[t] = !0), e
            }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();

            function yt(t, e, i, n, s, r, a, o, l, c, h, u, d) {
                return {
                    type: 0,
                    element: t,
                    triggerName: e,
                    isRemovalTransition: s,
                    fromState: i,
                    fromStyles: r,
                    toState: n,
                    toStyles: a,
                    timelines: o,
                    queriedElements: l,
                    preStyleProps: c,
                    postStyleProps: h,
                    totalTime: u,
                    errors: d
                }
            }
            const vt = {};
            class xt {
                constructor(t, e, i) {
                    this._triggerName = t, this.ast = e, this._stateStyles = i
                }
                match(t, e, i, n) {
                    return function(t, e, i, n, s) {
                        return t.some(t => t(e, i, n, s))
                    }(this.ast.matchers, t, e, i, n)
                }
                buildStyles(t, e, i) {
                    const n = this._stateStyles["*"],
                        s = this._stateStyles[t],
                        r = n ? n.buildStyles(e, i) : {};
                    return s ? s.buildStyles(e, i) : r
                }
                build(t, e, i, n, s, r, a, o, l, c) {
                    const h = [],
                        u = this.ast.options && this.ast.options.params || vt,
                        p = this.buildStyles(i, a && a.params || vt, h),
                        f = o && o.params || vt,
                        g = this.buildStyles(n, f, h),
                        m = new Set,
                        b = new Map,
                        y = new Map,
                        v = "void" === n,
                        x = {
                            params: Object.assign(Object.assign({}, u), f)
                        },
                        _ = c ? [] : lt(t, e, this.ast.animation, s, r, p, g, x, l, h);
                    let w = 0;
                    if (_.forEach(t => {
                            w = Math.max(t.duration + t.delay, w)
                        }), h.length) return yt(e, this._triggerName, i, n, v, p, g, [], [], b, y, w, h);
                    _.forEach(t => {
                        const i = t.element,
                            n = d(b, i, {});
                        t.preStyleProps.forEach(t => n[t] = !0);
                        const s = d(y, i, {});
                        t.postStyleProps.forEach(t => s[t] = !0), i !== e && m.add(i)
                    });
                    const C = V(m.values());
                    return yt(e, this._triggerName, i, n, v, p, g, _, C, b, y, w)
                }
            }
            class _t {
                constructor(t, e) {
                    this.styles = t, this.defaultParams = e
                }
                buildStyles(t, e) {
                    const i = {},
                        n = T(this.defaultParams);
                    return Object.keys(t).forEach(e => {
                        const i = t[e];
                        null != i && (n[e] = i)
                    }), this.styles.styles.forEach(t => {
                        if ("string" != typeof t) {
                            const s = t;
                            Object.keys(s).forEach(t => {
                                let r = s[t];
                                r.length > 1 && (r = z(r, n, e)), i[t] = r
                            })
                        }
                    }), i
                }
            }
            class wt {
                constructor(t, e) {
                    this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => {
                        this.states[t.name] = new _t(t.style, t.options && t.options.params || {})
                    }), Ct(this.states, "true", "1"), Ct(this.states, "false", "0"), e.transitions.forEach(e => {
                        this.transitionFactories.push(new xt(t, e, this.states))
                    }), this.fallbackTransition = new xt(t, {
                        type: 1,
                        animation: {
                            type: 2,
                            steps: [],
                            options: null
                        },
                        matchers: [(t, e) => !0],
                        options: null,
                        queryCount: 0,
                        depCount: 0
                    }, this.states)
                }
                get containsQueries() {
                    return this.ast.queryCount > 0
                }
                matchTransition(t, e, i, n) {
                    return this.transitionFactories.find(s => s.match(t, e, i, n)) || null
                }
                matchStyles(t, e, i) {
                    return this.fallbackTransition.buildStyles(t, e, i)
                }
            }

            function Ct(t, e, i) {
                t.hasOwnProperty(e) ? t.hasOwnProperty(i) || (t[i] = t[e]) : t.hasOwnProperty(i) && (t[e] = t[i])
            }
            const kt = new rt;
            class St {
                constructor(t, e, i) {
                    this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = []
                }
                register(t, e) {
                    const i = [],
                        n = K(this._driver, e, i);
                    if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`);
                    this._animations[t] = n
                }
                _buildPlayer(t, e, i) {
                    const n = t.element,
                        s = l(0, this._normalizer, 0, t.keyframes, e, i);
                    return this._driver.animate(n, s, t.duration, t.delay, t.easing, [], !0)
                }
                create(t, e, i = {}) {
                    const n = [],
                        s = this._animations[t];
                    let a;
                    const l = new Map;
                    if (s ? (a = lt(this._driver, e, s, "ng-enter", "ng-leave", {}, {}, i, kt, n), a.forEach(t => {
                            const e = d(l, t.element, {});
                            t.postStyleProps.forEach(t => e[t] = null)
                        })) : (n.push("The requested animation doesn't exist or has already been destroyed"), a = []), n.length) throw new Error(`Unable to create the animation due to the following errors: ${n.join("\n")}`);
                    l.forEach((t, e) => {
                        Object.keys(t).forEach(i => {
                            t[i] = this._driver.computeStyle(e, i, r.a)
                        })
                    });
                    const c = o(a.map(t => {
                        const e = l.get(t.element);
                        return this._buildPlayer(t, {}, e)
                    }));
                    return this._playersById[t] = c, c.onDestroy(() => this.destroy(t)), this.players.push(c), c
                }
                destroy(t) {
                    const e = this._getPlayer(t);
                    e.destroy(), delete this._playersById[t];
                    const i = this.players.indexOf(e);
                    i >= 0 && this.players.splice(i, 1)
                }
                _getPlayer(t) {
                    const e = this._playersById[t];
                    if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`);
                    return e
                }
                listen(t, e, i, n) {
                    const s = u(e, "", "", "");
                    return c(this._getPlayer(t), i, s, n), () => {}
                }
                command(t, e, i, n) {
                    if ("register" == i) return void this.register(t, n[0]);
                    if ("create" == i) return void this.create(t, e, n[0] || {});
                    const s = this._getPlayer(t);
                    switch (i) {
                        case "play":
                            s.play();
                            break;
                        case "pause":
                            s.pause();
                            break;
                        case "reset":
                            s.reset();
                            break;
                        case "restart":
                            s.restart();
                            break;
                        case "finish":
                            s.finish();
                            break;
                        case "init":
                            s.init();
                            break;
                        case "setPosition":
                            s.setPosition(parseFloat(n[0]));
                            break;
                        case "destroy":
                            this.destroy(t)
                    }
                }
            }
            const At = [],
                Ot = {
                    namespaceId: "",
                    setForRemoval: !1,
                    setForMove: !1,
                    hasAnimation: !1,
                    removedBeforeQueried: !1
                },
                Et = {
                    namespaceId: "",
                    setForMove: !1,
                    setForRemoval: !1,
                    hasAnimation: !1,
                    removedBeforeQueried: !0
                };
            class Pt {
                constructor(t, e = "") {
                    this.namespaceId = e;
                    const i = t && t.hasOwnProperty("value");
                    if (this.value = null != (n = i ? t.value : t) ? n : null, i) {
                        const e = T(t);
                        delete e.value, this.options = e
                    } else this.options = {};
                    var n;
                    this.options.params || (this.options.params = {})
                }
                get params() {
                    return this.options.params
                }
                absorbOptions(t) {
                    const e = t.params;
                    if (e) {
                        const t = this.options.params;
                        Object.keys(e).forEach(i => {
                            null == t[i] && (t[i] = e[i])
                        })
                    }
                }
            }
            const Tt = new Pt("void");
            class Dt {
                constructor(t, e, i) {
                    this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Nt(e, this._hostClassName)
                }
                listen(t, e, i, n) {
                    if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`);
                    if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);
                    if ("start" != (s = i) && "done" != s) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`);
                    var s;
                    const r = d(this._elementListeners, t, []),
                        a = {
                            name: e,
                            phase: i,
                            callback: n
                        };
                    r.push(a);
                    const o = d(this._engine.statesByElement, t, {});
                    return o.hasOwnProperty(e) || (Nt(t, "ng-trigger"), Nt(t, "ng-trigger-" + e), o[e] = Tt), () => {
                        this._engine.afterFlush(() => {
                            const t = r.indexOf(a);
                            t >= 0 && r.splice(t, 1), this._triggers[e] || delete o[e]
                        })
                    }
                }
                register(t, e) {
                    return !this._triggers[t] && (this._triggers[t] = e, !0)
                }
                _getTrigger(t) {
                    const e = this._triggers[t];
                    if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`);
                    return e
                }
                trigger(t, e, i, n = !0) {
                    const s = this._getTrigger(e),
                        r = new Mt(this.id, e, t);
                    let a = this._engine.statesByElement.get(t);
                    a || (Nt(t, "ng-trigger"), Nt(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, a = {}));
                    let o = a[e];
                    const l = new Pt(i, this.id);
                    if (!(i && i.hasOwnProperty("value")) && o && l.absorbOptions(o.options), a[e] = l, o || (o = Tt), "void" !== l.value && o.value === l.value) {
                        if (! function(t, e) {
                                const i = Object.keys(t),
                                    n = Object.keys(e);
                                if (i.length != n.length) return !1;
                                for (let s = 0; s < i.length; s++) {
                                    const n = i[s];
                                    if (!e.hasOwnProperty(n) || t[n] !== e[n]) return !1
                                }
                                return !0
                            }(o.params, l.params)) {
                            const e = [],
                                i = s.matchStyles(o.value, o.params, e),
                                n = s.matchStyles(l.value, l.params, e);
                            e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => {
                                R(t, i), L(t, n)
                            })
                        }
                        return
                    }
                    const c = d(this._engine.playersByElement, t, []);
                    c.forEach(t => {
                        t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy()
                    });
                    let h = s.matchTransition(o.value, l.value, t, l.params),
                        u = !1;
                    if (!h) {
                        if (!n) return;
                        h = s.fallbackTransition, u = !0
                    }
                    return this._engine.totalQueuedPlayers++, this._queue.push({
                        element: t,
                        triggerName: e,
                        transition: h,
                        fromState: o,
                        toState: l,
                        player: r,
                        isFallbackTransition: u
                    }), u || (Nt(t, "ng-animate-queued"), r.onStart(() => {
                        zt(t, "ng-animate-queued")
                    })), r.onDone(() => {
                        let e = this.players.indexOf(r);
                        e >= 0 && this.players.splice(e, 1);
                        const i = this._engine.playersByElement.get(t);
                        if (i) {
                            let t = i.indexOf(r);
                            t >= 0 && i.splice(t, 1)
                        }
                    }), this.players.push(r), c.push(r), r
                }
                deregister(t) {
                    delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => {
                        delete e[t]
                    }), this._elementListeners.forEach((e, i) => {
                        this._elementListeners.set(i, e.filter(e => e.name != t))
                    })
                }
                clearElementCache(t) {
                    this._engine.statesByElement.delete(t), this._elementListeners.delete(t);
                    const e = this._engine.playersByElement.get(t);
                    e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t))
                }
                _signalRemovalForInnerTriggers(t, e) {
                    const i = this._engine.driver.query(t, ".ng-trigger", !0);
                    i.forEach(t => {
                        if (t.__ng_removed) return;
                        const i = this._engine.fetchNamespacesByElement(t);
                        i.size ? i.forEach(i => i.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t)
                    }), this._engine.afterFlushAnimationsDone(() => i.forEach(t => this.clearElementCache(t)))
                }
                triggerLeaveAnimation(t, e, i, n) {
                    const s = this._engine.statesByElement.get(t);
                    if (s) {
                        const r = [];
                        if (Object.keys(s).forEach(e => {
                                if (this._triggers[e]) {
                                    const i = this.trigger(t, e, "void", n);
                                    i && r.push(i)
                                }
                            }), r.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), i && o(r).onDone(() => this._engine.processLeaveNode(t)), !0
                    }
                    return !1
                }
                prepareLeaveAnimationListeners(t) {
                    const e = this._elementListeners.get(t),
                        i = this._engine.statesByElement.get(t);
                    if (e && i) {
                        const n = new Set;
                        e.forEach(e => {
                            const s = e.name;
                            if (n.has(s)) return;
                            n.add(s);
                            const r = this._triggers[s].fallbackTransition,
                                a = i[s] || Tt,
                                o = new Pt("void"),
                                l = new Mt(this.id, s, t);
                            this._engine.totalQueuedPlayers++, this._queue.push({
                                element: t,
                                triggerName: s,
                                transition: r,
                                fromState: a,
                                toState: o,
                                player: l,
                                isFallbackTransition: !0
                            })
                        })
                    }
                }
                removeNode(t, e) {
                    const i = this._engine;
                    if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return;
                    let n = !1;
                    if (i.totalAnimations) {
                        const e = i.players.length ? i.playersByQueriedElement.get(t) : [];
                        if (e && e.length) n = !0;
                        else {
                            let e = t;
                            for (; e = e.parentNode;)
                                if (i.statesByElement.get(e)) {
                                    n = !0;
                                    break
                                }
                        }
                    }
                    if (this.prepareLeaveAnimationListeners(t), n) i.markElementAsRemoved(this.id, t, !1, e);
                    else {
                        const n = t.__ng_removed;
                        n && n !== Ot || (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e))
                    }
                }
                insertNode(t, e) {
                    Nt(t, this._hostClassName)
                }
                drainQueuedTransitions(t) {
                    const e = [];
                    return this._queue.forEach(i => {
                        const n = i.player;
                        if (n.destroyed) return;
                        const s = i.element,
                            r = this._elementListeners.get(s);
                        r && r.forEach(e => {
                            if (e.name == i.triggerName) {
                                const n = u(s, i.triggerName, i.fromState.value, i.toState.value);
                                n._data = t, c(i.player, e.phase, n, e.callback)
                            }
                        }), n.markedForDestroy ? this._engine.afterFlush(() => {
                            n.destroy()
                        }) : e.push(i)
                    }), this._queue = [], e.sort((t, e) => {
                        const i = t.transition.ast.depCount,
                            n = e.transition.ast.depCount;
                        return 0 == i || 0 == n ? i - n : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1
                    })
                }
                destroy(t) {
                    this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t)
                }
                elementContainsData(t) {
                    let e = !1;
                    return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e
                }
            }
            class It {
                constructor(t, e, i) {
                    this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => {}
                }
                _onRemovalComplete(t, e) {
                    this.onRemovalComplete(t, e)
                }
                get queuedPlayers() {
                    const t = [];
                    return this._namespaceList.forEach(e => {
                        e.players.forEach(e => {
                            e.queued && t.push(e)
                        })
                    }), t
                }
                createNamespace(t, e) {
                    const i = new Dt(t, e, this);
                    return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i
                }
                _balanceNamespaceList(t, e) {
                    const i = this._namespaceList.length - 1;
                    if (i >= 0) {
                        let n = !1;
                        for (let s = i; s >= 0; s--)
                            if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) {
                                this._namespaceList.splice(s + 1, 0, t), n = !0;
                                break
                            } n || this._namespaceList.splice(0, 0, t)
                    } else this._namespaceList.push(t);
                    return this.namespacesByHostElement.set(e, t), t
                }
                register(t, e) {
                    let i = this._namespaceLookup[t];
                    return i || (i = this.createNamespace(t, e)), i
                }
                registerTrigger(t, e, i) {
                    let n = this._namespaceLookup[t];
                    n && n.register(e, i) && this.totalAnimations++
                }
                destroy(t, e) {
                    if (!t) return;
                    const i = this._fetchNamespace(t);
                    this.afterFlush(() => {
                        this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t];
                        const e = this._namespaceList.indexOf(i);
                        e >= 0 && this._namespaceList.splice(e, 1)
                    }), this.afterFlushAnimationsDone(() => i.destroy(e))
                }
                _fetchNamespace(t) {
                    return this._namespaceLookup[t]
                }
                fetchNamespacesByElement(t) {
                    const e = new Set,
                        i = this.statesByElement.get(t);
                    if (i) {
                        const t = Object.keys(i);
                        for (let n = 0; n < t.length; n++) {
                            const s = i[t[n]].namespaceId;
                            if (s) {
                                const t = this._fetchNamespace(s);
                                t && e.add(t)
                            }
                        }
                    }
                    return e
                }
                trigger(t, e, i, n) {
                    if (Lt(e)) {
                        const s = this._fetchNamespace(t);
                        if (s) return s.trigger(e, i, n), !0
                    }
                    return !1
                }
                insertNode(t, e, i, n) {
                    if (!Lt(e)) return;
                    const s = e.__ng_removed;
                    if (s && s.setForRemoval) {
                        s.setForRemoval = !1, s.setForMove = !0;
                        const t = this.collectedLeaveElements.indexOf(e);
                        t >= 0 && this.collectedLeaveElements.splice(t, 1)
                    }
                    if (t) {
                        const n = this._fetchNamespace(t);
                        n && n.insertNode(e, i)
                    }
                    n && this.collectEnterElement(e)
                }
                collectEnterElement(t) {
                    this.collectedEnterElements.push(t)
                }
                markElementAsDisabled(t, e) {
                    e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Nt(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), zt(t, "ng-animate-disabled"))
                }
                removeNode(t, e, i, n) {
                    if (Lt(e)) {
                        const s = t ? this._fetchNamespace(t) : null;
                        if (s ? s.removeNode(e, n) : this.markElementAsRemoved(t, e, !1, n), i) {
                            const i = this.namespacesByHostElement.get(e);
                            i && i.id !== t && i.removeNode(e, n)
                        }
                    } else this._onRemovalComplete(e, n)
                }
                markElementAsRemoved(t, e, i, n) {
                    this.collectedLeaveElements.push(e), e.__ng_removed = {
                        namespaceId: t,
                        setForRemoval: n,
                        hasAnimation: i,
                        removedBeforeQueried: !1
                    }
                }
                listen(t, e, i, n, s) {
                    return Lt(e) ? this._fetchNamespace(t).listen(e, i, n, s) : () => {}
                }
                _buildInstruction(t, e, i, n, s) {
                    return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, n, t.fromState.options, t.toState.options, e, s)
                }
                destroyInnerAnimations(t) {
                    let e = this.driver.query(t, ".ng-trigger", !0);
                    e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t)))
                }
                destroyActiveAnimationsForElement(t) {
                    const e = this.playersByElement.get(t);
                    e && e.forEach(t => {
                        t.queued ? t.markedForDestroy = !0 : t.destroy()
                    })
                }
                finishActiveQueriedAnimationOnElement(t) {
                    const e = this.playersByQueriedElement.get(t);
                    e && e.forEach(t => t.finish())
                }
                whenRenderingDone() {
                    return new Promise(t => {
                        if (this.players.length) return o(this.players).onDone(() => t());
                        t()
                    })
                }
                processLeaveNode(t) {
                    const e = t.__ng_removed;
                    if (e && e.setForRemoval) {
                        if (t.__ng_removed = Ot, e.namespaceId) {
                            this.destroyInnerAnimations(t);
                            const i = this._fetchNamespace(e.namespaceId);
                            i && i.clearElementCache(t)
                        }
                        this._onRemovalComplete(t, e.setForRemoval)
                    }
                    this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => {
                        this.markElementAsDisabled(t, !1)
                    })
                }
                flush(t = -1) {
                    let e = [];
                    if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
                        for (let i = 0; i < this.collectedEnterElements.length; i++) Nt(this.collectedEnterElements[i], "ng-star-inserted");
                    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                        const i = [];
                        try {
                            e = this._flushAnimations(i, t)
                        } finally {
                            for (let t = 0; t < i.length; t++) i[t]()
                        }
                    } else
                        for (let i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i]);
                    if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) {
                        const t = this._whenQuietFns;
                        this._whenQuietFns = [], e.length ? o(e).onDone(() => {
                            t.forEach(t => t())
                        }) : t.forEach(t => t())
                    }
                }
                reportError(t) {
                    throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)
                }
                _flushAnimations(t, e) {
                    const i = new rt,
                        n = [],
                        s = new Map,
                        a = [],
                        l = new Map,
                        c = new Map,
                        h = new Map,
                        u = new Set;
                    this.disabledNodes.forEach(t => {
                        u.add(t);
                        const e = this.driver.query(t, ".ng-animate-queued", !0);
                        for (let i = 0; i < e.length; i++) u.add(e[i])
                    });
                    const p = this.bodyNode,
                        f = Array.from(this.statesByElement.keys()),
                        g = Ft(f, this.collectedEnterElements),
                        m = new Map;
                    let b = 0;
                    g.forEach((t, e) => {
                        const i = "ng-enter" + b++;
                        m.set(e, i), t.forEach(t => Nt(t, i))
                    });
                    const y = [],
                        v = new Set,
                        x = new Set;
                    for (let r = 0; r < this.collectedLeaveElements.length; r++) {
                        const t = this.collectedLeaveElements[r],
                            e = t.__ng_removed;
                        e && e.setForRemoval && (y.push(t), v.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => v.add(t)) : x.add(t))
                    }
                    const _ = new Map,
                        w = Ft(f, Array.from(v));
                    w.forEach((t, e) => {
                        const i = "ng-leave" + b++;
                        _.set(e, i), t.forEach(t => Nt(t, i))
                    }), t.push(() => {
                        g.forEach((t, e) => {
                            const i = m.get(e);
                            t.forEach(t => zt(t, i))
                        }), w.forEach((t, e) => {
                            const i = _.get(e);
                            t.forEach(t => zt(t, i))
                        }), y.forEach(t => {
                            this.processLeaveNode(t)
                        })
                    });
                    const C = [],
                        k = [];
                    for (let r = this._namespaceList.length - 1; r >= 0; r--) this._namespaceList[r].drainQueuedTransitions(e).forEach(t => {
                        const e = t.player,
                            s = t.element;
                        if (C.push(e), this.collectedEnterElements.length) {
                            const t = s.__ng_removed;
                            if (t && t.setForMove) return void e.destroy()
                        }
                        const r = !p || !this.driver.containsElement(p, s),
                            o = _.get(s),
                            u = m.get(s),
                            f = this._buildInstruction(t, i, u, o, r);
                        if (f.errors && f.errors.length) k.push(f);
                        else {
                            if (r) return e.onStart(() => R(s, f.fromStyles)), e.onDestroy(() => L(s, f.toStyles)), void n.push(e);
                            if (t.isFallbackTransition) return e.onStart(() => R(s, f.fromStyles)), e.onDestroy(() => L(s, f.toStyles)), void n.push(e);
                            f.timelines.forEach(t => t.stretchStartingKeyframe = !0), i.append(s, f.timelines), a.push({
                                instruction: f,
                                player: e,
                                element: s
                            }), f.queriedElements.forEach(t => d(l, t, []).push(e)), f.preStyleProps.forEach((t, e) => {
                                const i = Object.keys(t);
                                if (i.length) {
                                    let t = c.get(e);
                                    t || c.set(e, t = new Set), i.forEach(e => t.add(e))
                                }
                            }), f.postStyleProps.forEach((t, e) => {
                                const i = Object.keys(t);
                                let n = h.get(e);
                                n || h.set(e, n = new Set), i.forEach(t => n.add(t))
                            })
                        }
                    });
                    if (k.length) {
                        const t = [];
                        k.forEach(e => {
                            t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`))
                        }), C.forEach(t => t.destroy()), this.reportError(t)
                    }
                    const S = new Map,
                        A = new Map;
                    a.forEach(t => {
                        const e = t.element;
                        i.has(e) && (A.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, S))
                    }), n.forEach(t => {
                        const e = t.element;
                        this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => {
                            d(S, e, []).push(t), t.destroy()
                        })
                    });
                    const O = y.filter(t => Ht(t, c, h)),
                        E = new Map;
                    jt(E, this.driver, x, h, r.a).forEach(t => {
                        Ht(t, c, h) && O.push(t)
                    });
                    const P = new Map;
                    g.forEach((t, e) => {
                        jt(P, this.driver, new Set(t), c, r.o)
                    }), O.forEach(t => {
                        const e = E.get(t),
                            i = P.get(t);
                        E.set(t, Object.assign(Object.assign({}, e), i))
                    });
                    const T = [],
                        D = [],
                        I = {};
                    a.forEach(t => {
                        const {
                            element: e,
                            player: r,
                            instruction: a
                        } = t;
                        if (i.has(e)) {
                            if (u.has(e)) return r.onDestroy(() => L(e, a.toStyles)), r.disabled = !0, r.overrideTotalTime(a.totalTime), void n.push(r);
                            let t = I;
                            if (A.size > 1) {
                                let i = e;
                                const n = [];
                                for (; i = i.parentNode;) {
                                    const e = A.get(i);
                                    if (e) {
                                        t = e;
                                        break
                                    }
                                    n.push(i)
                                }
                                n.forEach(e => A.set(e, t))
                            }
                            const i = this._buildAnimation(r.namespaceId, a, S, s, P, E);
                            if (r.setRealPlayer(i), t === I) T.push(r);
                            else {
                                const e = this.playersByElement.get(t);
                                e && e.length && (r.parentPlayer = o(e)), n.push(r)
                            }
                        } else R(e, a.fromStyles), r.onDestroy(() => L(e, a.toStyles)), D.push(r), u.has(e) && n.push(r)
                    }), D.forEach(t => {
                        const e = s.get(t.element);
                        if (e && e.length) {
                            const i = o(e);
                            t.setRealPlayer(i)
                        }
                    }), n.forEach(t => {
                        t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy()
                    });
                    for (let r = 0; r < y.length; r++) {
                        const t = y[r],
                            e = t.__ng_removed;
                        if (zt(t, "ng-leave"), e && e.hasAnimation) continue;
                        let i = [];
                        if (l.size) {
                            let e = l.get(t);
                            e && e.length && i.push(...e);
                            let n = this.driver.query(t, ".ng-animating", !0);
                            for (let t = 0; t < n.length; t++) {
                                let e = l.get(n[t]);
                                e && e.length && i.push(...e)
                            }
                        }
                        const n = i.filter(t => !t.destroyed);
                        n.length ? Vt(this, t, n) : this.processLeaveNode(t)
                    }
                    return y.length = 0, T.forEach(t => {
                        this.players.push(t), t.onDone(() => {
                            t.destroy();
                            const e = this.players.indexOf(t);
                            this.players.splice(e, 1)
                        }), t.play()
                    }), T
                }
                elementContainsData(t, e) {
                    let i = !1;
                    const n = e.__ng_removed;
                    return n && n.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i
                }
                afterFlush(t) {
                    this._flushFns.push(t)
                }
                afterFlushAnimationsDone(t) {
                    this._whenQuietFns.push(t)
                }
                _getPreviousPlayers(t, e, i, n, s) {
                    let r = [];
                    if (e) {
                        const e = this.playersByQueriedElement.get(t);
                        e && (r = e)
                    } else {
                        const e = this.playersByElement.get(t);
                        if (e) {
                            const t = !s || "void" == s;
                            e.forEach(e => {
                                e.queued || (t || e.triggerName == n) && r.push(e)
                            })
                        }
                    }
                    return (i || n) && (r = r.filter(t => !(i && i != t.namespaceId || n && n != t.triggerName))), r
                }
                _beforeAnimationBuild(t, e, i) {
                    const n = e.element,
                        s = e.isRemovalTransition ? void 0 : t,
                        r = e.isRemovalTransition ? void 0 : e.triggerName;
                    for (const a of e.timelines) {
                        const t = a.element,
                            o = t !== n,
                            l = d(i, t, []);
                        this._getPreviousPlayers(t, o, s, r, e.toState).forEach(t => {
                            const e = t.getRealPlayer();
                            e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t)
                        })
                    }
                    R(n, e.fromStyles)
                }
                _buildAnimation(t, e, i, n, s, a) {
                    const c = e.triggerName,
                        h = e.element,
                        u = [],
                        p = new Set,
                        f = new Set,
                        g = e.timelines.map(e => {
                            const o = e.element;
                            p.add(o);
                            const d = o.__ng_removed;
                            if (d && d.removedBeforeQueried) return new r.d(e.duration, e.delay);
                            const g = o !== h,
                                m = function(t) {
                                    const e = [];
                                    return Bt(t, e), e
                                }((i.get(o) || At).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === o),
                                b = s.get(o),
                                y = a.get(o),
                                v = l(0, this._normalizer, 0, e.keyframes, b, y),
                                x = this._buildPlayer(e, v, m);
                            if (e.subTimeline && n && f.add(o), g) {
                                const e = new Mt(t, c, o);
                                e.setRealPlayer(x), u.push(e)
                            }
                            return x
                        });
                    u.forEach(t => {
                        d(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function(t, e, i) {
                            let n;
                            if (t instanceof Map) {
                                if (n = t.get(e), n) {
                                    if (n.length) {
                                        const t = n.indexOf(i);
                                        n.splice(t, 1)
                                    }
                                    0 == n.length && t.delete(e)
                                }
                            } else if (n = t[e], n) {
                                if (n.length) {
                                    const t = n.indexOf(i);
                                    n.splice(t, 1)
                                }
                                0 == n.length && delete t[e]
                            }
                            return n
                        }(this.playersByQueriedElement, t.element, t))
                    }), p.forEach(t => Nt(t, "ng-animating"));
                    const m = o(g);
                    return m.onDestroy(() => {
                        p.forEach(t => zt(t, "ng-animating")), L(h, e.toStyles)
                    }), f.forEach(t => {
                        d(n, t, []).push(m)
                    }), m
                }
                _buildPlayer(t, e, i) {
                    return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new r.d(t.duration, t.delay)
                }
            }
            class Mt {
                constructor(t, e, i) {
                    this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new r.d, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0
                }
                setRealPlayer(t) {
                    this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => {
                        this._queuedCallbacks[e].forEach(i => c(t, e, void 0, i))
                    }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1)
                }
                getRealPlayer() {
                    return this._player
                }
                overrideTotalTime(t) {
                    this.totalTime = t
                }
                syncPlayerEvents(t) {
                    const e = this._player;
                    e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy())
                }
                _queueEvent(t, e) {
                    d(this._queuedCallbacks, t, []).push(e)
                }
                onDone(t) {
                    this.queued && this._queueEvent("done", t), this._player.onDone(t)
                }
                onStart(t) {
                    this.queued && this._queueEvent("start", t), this._player.onStart(t)
                }
                onDestroy(t) {
                    this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t)
                }
                init() {
                    this._player.init()
                }
                hasStarted() {
                    return !this.queued && this._player.hasStarted()
                }
                play() {
                    !this.queued && this._player.play()
                }
                pause() {
                    !this.queued && this._player.pause()
                }
                restart() {
                    !this.queued && this._player.restart()
                }
                finish() {
                    this._player.finish()
                }
                destroy() {
                    this.destroyed = !0, this._player.destroy()
                }
                reset() {
                    !this.queued && this._player.reset()
                }
                setPosition(t) {
                    this.queued || this._player.setPosition(t)
                }
                getPosition() {
                    return this.queued ? 0 : this._player.getPosition()
                }
                triggerCallback(t) {
                    const e = this._player;
                    e.triggerCallback && e.triggerCallback(t)
                }
            }

            function Lt(t) {
                return t && 1 === t.nodeType
            }

            function Rt(t, e) {
                const i = t.style.display;
                return t.style.display = null != e ? e : "none", i
            }

            function jt(t, e, i, n, s) {
                const r = [];
                i.forEach(t => r.push(Rt(t)));
                const a = [];
                n.forEach((i, n) => {
                    const r = {};
                    i.forEach(t => {
                        const i = r[t] = e.computeStyle(n, t, s);
                        i && 0 != i.length || (n.__ng_removed = Et, a.push(n))
                    }), t.set(n, r)
                });
                let o = 0;
                return i.forEach(t => Rt(t, r[o++])), a
            }

            function Ft(t, e) {
                const i = new Map;
                if (t.forEach(t => i.set(t, [])), 0 == e.length) return i;
                const n = new Set(e),
                    s = new Map;

                function r(t) {
                    if (!t) return 1;
                    let e = s.get(t);
                    if (e) return e;
                    const a = t.parentNode;
                    return e = i.has(a) ? a : n.has(a) ? 1 : r(a), s.set(t, e), e
                }
                return e.forEach(t => {
                    const e = r(t);
                    1 !== e && i.get(e).push(t)
                }), i
            }

            function Nt(t, e) {
                if (t.classList) t.classList.add(e);
                else {
                    let i = t.$$classes;
                    i || (i = t.$$classes = {}), i[e] = !0
                }
            }

            function zt(t, e) {
                if (t.classList) t.classList.remove(e);
                else {
                    let i = t.$$classes;
                    i && delete i[e]
                }
            }

            function Vt(t, e, i) {
                o(i).onDone(() => t.processLeaveNode(e))
            }

            function Bt(t, e) {
                for (let i = 0; i < t.length; i++) {
                    const n = t[i];
                    n instanceof r.n ? Bt(n.players, e) : e.push(n)
                }
            }

            function Ht(t, e, i) {
                const n = i.get(t);
                if (!n) return !1;
                let s = e.get(t);
                return s ? n.forEach(t => s.add(t)) : e.set(t, n), i.delete(t), !0
            }
            class Ut {
                constructor(t, e, i) {
                    this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => {}, this._transitionEngine = new It(t, e, i), this._timelineEngine = new St(t, e, i), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e)
                }
                registerTrigger(t, e, i, n, s) {
                    const r = t + "-" + n;
                    let a = this._triggerCache[r];
                    if (!a) {
                        const t = [],
                            e = K(this._driver, s, t);
                        if (t.length) throw new Error(`The animation trigger "${n}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);
                        a = function(t, e) {
                            return new wt(t, e)
                        }(n, e), this._triggerCache[r] = a
                    }
                    this._transitionEngine.registerTrigger(e, n, a)
                }
                register(t, e) {
                    this._transitionEngine.register(t, e)
                }
                destroy(t, e) {
                    this._transitionEngine.destroy(t, e)
                }
                onInsert(t, e, i, n) {
                    this._transitionEngine.insertNode(t, e, i, n)
                }
                onRemove(t, e, i, n) {
                    this._transitionEngine.removeNode(t, e, n || !1, i)
                }
                disableAnimations(t, e) {
                    this._transitionEngine.markElementAsDisabled(t, e)
                }
                process(t, e, i, n) {
                    if ("@" == i.charAt(0)) {
                        const [t, s] = p(i);
                        this._timelineEngine.command(t, e, s, n)
                    } else this._transitionEngine.trigger(t, e, i, n)
                }
                listen(t, e, i, n, s) {
                    if ("@" == i.charAt(0)) {
                        const [t, n] = p(i);
                        return this._timelineEngine.listen(t, e, n, s)
                    }
                    return this._transitionEngine.listen(t, e, i, n, s)
                }
                flush(t = -1) {
                    this._transitionEngine.flush(t)
                }
                get players() {
                    return this._transitionEngine.players.concat(this._timelineEngine.players)
                }
                whenRenderingDone() {
                    return this._transitionEngine.whenRenderingDone()
                }
            }

            function Xt(t, e) {
                let i = null,
                    n = null;
                return Array.isArray(e) && e.length ? (i = Yt(e[0]), e.length > 1 && (n = Yt(e[e.length - 1]))) : e && (i = Yt(e)), i || n ? new Wt(t, i, n) : null
            }
            let Wt = (() => {
                class t {
                    constructor(e, i, n) {
                        this._element = e, this._startStyles = i, this._endStyles = n, this._state = 0;
                        let s = t.initialStylesByElement.get(e);
                        s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s
                    }
                    start() {
                        this._state < 1 && (this._startStyles && L(this._element, this._startStyles, this._initialStyles), this._state = 1)
                    }
                    finish() {
                        this.start(), this._state < 2 && (L(this._element, this._initialStyles), this._endStyles && (L(this._element, this._endStyles), this._endStyles = null), this._state = 1)
                    }
                    destroy() {
                        this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (R(this._element, this._startStyles), this._endStyles = null), this._endStyles && (R(this._element, this._endStyles), this._endStyles = null), L(this._element, this._initialStyles), this._state = 3)
                    }
                }
                return t.initialStylesByElement = new WeakMap, t
            })();

            function Yt(t) {
                let e = null;
                const i = Object.keys(t);
                for (let n = 0; n < i.length; n++) {
                    const s = i[n];
                    Gt(s) && (e = e || {}, e[s] = t[s])
                }
                return e
            }

            function Gt(t) {
                return "display" === t || "position" === t
            }
            class qt {
                constructor(t, e, i, n, s, r, a) {
                    this._element = t, this._name = e, this._duration = i, this._delay = n, this._easing = s, this._fillMode = r, this._onDoneFn = a, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t)
                }
                apply() {
                    ! function(t, e) {
                        const i = te(t, "").trim();
                        i.length && (function(t, e) {
                            let i = 0;
                            for (let n = 0; n < t.length; n++) "," === t.charAt(n) && i++
                        }(i), e = `${i}, ${e}`), Jt(t, "", e)
                    }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Kt(this._element, this._eventFn, !1), this._startTime = Date.now()
                }
                pause() {
                    Zt(this._element, this._name, "paused")
                }
                resume() {
                    Zt(this._element, this._name, "running")
                }
                setPosition(t) {
                    const e = $t(this._element, this._name);
                    this._position = t * this._duration, Jt(this._element, "Delay", `-${this._position}ms`, e)
                }
                getPosition() {
                    return this._position
                }
                _handleCallback(t) {
                    const e = t._ngTestManualTimestamp || Date.now(),
                        i = 1e3 * parseFloat(t.elapsedTime.toFixed(3));
                    t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish()
                }
                finish() {
                    this._finished || (this._finished = !0, this._onDoneFn(), Kt(this._element, this._eventFn, !0))
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this.finish(), function(t, e) {
                        const i = te(t, "").split(","),
                            n = Qt(i, e);
                        n >= 0 && (i.splice(n, 1), Jt(t, "", i.join(",")))
                    }(this._element, this._name))
                }
            }

            function Zt(t, e, i) {
                Jt(t, "PlayState", i, $t(t, e))
            }

            function $t(t, e) {
                const i = te(t, "");
                return i.indexOf(",") > 0 ? Qt(i.split(","), e) : Qt([i], e)
            }

            function Qt(t, e) {
                for (let i = 0; i < t.length; i++)
                    if (t[i].indexOf(e) >= 0) return i;
                return -1
            }

            function Kt(t, e, i) {
                i ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e)
            }

            function Jt(t, e, i, n) {
                const s = "animation" + e;
                if (null != n) {
                    const e = t.style[s];
                    if (e.length) {
                        const t = e.split(",");
                        t[n] = i, i = t.join(",")
                    }
                }
                t.style[s] = i
            }

            function te(t, e) {
                return t.style["animation" + e] || ""
            }
            class ee {
                constructor(t, e, i, n, s, r, a, o) {
                    this.element = t, this.keyframes = e, this.animationName = i, this._duration = n, this._delay = s, this._finalStyles = a, this._specialStyles = o, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = r || "linear", this.totalTime = n + s, this._buildStyler()
                }
                onStart(t) {
                    this._onStartFns.push(t)
                }
                onDone(t) {
                    this._onDoneFns.push(t)
                }
                onDestroy(t) {
                    this._onDestroyFns.push(t)
                }
                destroy() {
                    this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
                }
                _flushDoneFns() {
                    this._onDoneFns.forEach(t => t()), this._onDoneFns = []
                }
                _flushStartFns() {
                    this._onStartFns.forEach(t => t()), this._onStartFns = []
                }
                finish() {
                    this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns())
                }
                setPosition(t) {
                    this._styler.setPosition(t)
                }
                getPosition() {
                    return this._styler.getPosition()
                }
                hasStarted() {
                    return this._state >= 2
                }
                init() {
                    this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause())
                }
                play() {
                    this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume()
                }
                pause() {
                    this.init(), this._styler.pause()
                }
                restart() {
                    this.reset(), this.play()
                }
                reset() {
                    this._styler.destroy(), this._buildStyler(), this._styler.apply()
                }
                _buildStyler() {
                    this._styler = new qt(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish())
                }
                triggerCallback(t) {
                    const e = "start" == t ? this._onStartFns : this._onDoneFns;
                    e.forEach(t => t()), e.length = 0
                }
                beforeDestroy() {
                    this.init();
                    const t = {};
                    if (this.hasStarted()) {
                        const e = this._state >= 3;
                        Object.keys(this._finalStyles).forEach(i => {
                            "offset" != i && (t[i] = e ? this._finalStyles[i] : Y(this.element, i))
                        })
                    }
                    this.currentSnapshot = t
                }
            }
            class ie extends r.d {
                constructor(t, e) {
                    super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = k(e)
                }
                init() {
                    !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => {
                        this._startingStyles[t] = this.element.style[t]
                    }), super.init())
                }
                play() {
                    this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play())
                }
                destroy() {
                    this._startingStyles && (Object.keys(this._startingStyles).forEach(t => {
                        const e = this._startingStyles[t];
                        e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t)
                    }), this._startingStyles = null, super.destroy())
                }
            }
            class ne {
                constructor() {
                    this._count = 0, this._head = document.querySelector("head")
                }
                validateStyleProperty(t) {
                    return x(t)
                }
                matchesElement(t, e) {
                    return _(t, e)
                }
                containsElement(t, e) {
                    return w(t, e)
                }
                query(t, e, i) {
                    return C(t, e, i)
                }
                computeStyle(t, e, i) {
                    return window.getComputedStyle(t)[e]
                }
                buildKeyframeElement(t, e, i) {
                    i = i.map(t => k(t));
                    let n = `@keyframes ${e} {\n`,
                        s = "";
                    i.forEach(t => {
                        s = " ";
                        const e = parseFloat(t.offset);
                        n += `${s}${100*e}% {\n`, s += " ", Object.keys(t).forEach(e => {
                            const i = t[e];
                            switch (e) {
                                case "offset":
                                    return;
                                case "easing":
                                    return void(i && (n += `${s}animation-timing-function: ${i};\n`));
                                default:
                                    return void(n += `${s}${e}: ${i};\n`)
                            }
                        }), n += `${s}}\n`
                    }), n += "}\n";
                    const r = document.createElement("style");
                    return r.textContent = n, r
                }
                animate(t, e, i, n, s, r = [], a) {
                    const o = r.filter(t => t instanceof ee),
                        l = {};
                    U(i, n) && o.forEach(t => {
                        let e = t.currentSnapshot;
                        Object.keys(e).forEach(t => l[t] = e[t])
                    });
                    const c = function(t) {
                        let e = {};
                        return t && (Array.isArray(t) ? t : [t]).forEach(t => {
                            Object.keys(t).forEach(i => {
                                "offset" != i && "easing" != i && (e[i] = t[i])
                            })
                        }), e
                    }(e = X(t, e, l));
                    if (0 == i) return new ie(t, c);
                    const h = "gen_css_kf_" + this._count++,
                        u = this.buildKeyframeElement(t, h, e);
                    document.querySelector("head").appendChild(u);
                    const d = Xt(t, e),
                        p = new ee(t, e, h, i, n, s, c, d);
                    return p.onDestroy(() => {
                        var t;
                        (t = u).parentNode.removeChild(t)
                    }), p
                }
            }
            class se {
                constructor(t, e, i, n) {
                    this.element = t, this.keyframes = e, this.options = i, this._specialStyles = n, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = [])
                }
                init() {
                    this._buildPlayer(), this._preparePlayerBeforeStart()
                }
                _buildPlayer() {
                    if (this._initialized) return;
                    this._initialized = !0;
                    const t = this.keyframes;
                    this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish())
                }
                _preparePlayerBeforeStart() {
                    this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
                }
                _triggerWebAnimation(t, e, i) {
                    return t.animate(e, i)
                }
                onStart(t) {
                    this._onStartFns.push(t)
                }
                onDone(t) {
                    this._onDoneFns.push(t)
                }
                onDestroy(t) {
                    this._onDestroyFns.push(t)
                }
                play() {
                    this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play()
                }
                pause() {
                    this.init(), this.domPlayer.pause()
                }
                finish() {
                    this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish()
                }
                reset() {
                    this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1
                }
                _resetDomPlayerState() {
                    this.domPlayer && this.domPlayer.cancel()
                }
                restart() {
                    this.reset(), this.play()
                }
                hasStarted() {
                    return this._started
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = [])
                }
                setPosition(t) {
                    void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time
                }
                getPosition() {
                    return this.domPlayer.currentTime / this.time
                }
                get totalTime() {
                    return this._delay + this._duration
                }
                beforeDestroy() {
                    const t = {};
                    this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => {
                        "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : Y(this.element, e))
                    }), this.currentSnapshot = t
                }
                triggerCallback(t) {
                    const e = "start" == t ? this._onStartFns : this._onDoneFns;
                    e.forEach(t => t()), e.length = 0
                }
            }
            class re {
                constructor() {
                    this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(ae().toString()), this._cssKeyframesDriver = new ne
                }
                validateStyleProperty(t) {
                    return x(t)
                }
                matchesElement(t, e) {
                    return _(t, e)
                }
                containsElement(t, e) {
                    return w(t, e)
                }
                query(t, e, i) {
                    return C(t, e, i)
                }
                computeStyle(t, e, i) {
                    return window.getComputedStyle(t)[e]
                }
                overrideWebAnimationsSupport(t) {
                    this._isNativeImpl = t
                }
                animate(t, e, i, n, s, r = [], a) {
                    if (!a && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, n, s, r);
                    const o = {
                        duration: i,
                        delay: n,
                        fill: 0 == n ? "both" : "forwards"
                    };
                    s && (o.easing = s);
                    const l = {},
                        c = r.filter(t => t instanceof se);
                    U(i, n) && c.forEach(t => {
                        let e = t.currentSnapshot;
                        Object.keys(e).forEach(t => l[t] = e[t])
                    });
                    const h = Xt(t, e = X(t, e = e.map(t => D(t, !1)), l));
                    return new se(t, e, o, h)
                }
            }

            function ae() {
                return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {}
            }
            var oe = i("ofXK");
            let le = (() => {
                class t extends r.b {
                    constructor(t, e) {
                        super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, {
                            id: "0",
                            encapsulation: n.T.None,
                            styles: [],
                            data: {
                                animation: []
                            }
                        })
                    }
                    build(t) {
                        const e = this._nextAnimationId.toString();
                        this._nextAnimationId++;
                        const i = Array.isArray(t) ? Object(r.i)(t) : t;
                        return ue(this._renderer, null, e, "register", [i]), new ce(e, this._renderer)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(n.H), n.Zb(oe.d))
                }, t.\u0275prov = n.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class ce extends r.c {
                constructor(t, e) {
                    super(), this._id = t, this._renderer = e
                }
                create(t, e) {
                    return new he(this._id, t, e || {}, this._renderer)
                }
            }
            class he {
                constructor(t, e, i, n) {
                    this.id = t, this.element = e, this._renderer = n, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i)
                }
                _listen(t, e) {
                    return this._renderer.listen(this.element, `@@${this.id}:${t}`, e)
                }
                _command(t, ...e) {
                    return ue(this._renderer, this.element, this.id, t, e)
                }
                onDone(t) {
                    this._listen("done", t)
                }
                onStart(t) {
                    this._listen("start", t)
                }
                onDestroy(t) {
                    this._listen("destroy", t)
                }
                init() {
                    this._command("init")
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this._command("play"), this._started = !0
                }
                pause() {
                    this._command("pause")
                }
                restart() {
                    this._command("restart")
                }
                finish() {
                    this._command("finish")
                }
                destroy() {
                    this._command("destroy")
                }
                reset() {
                    this._command("reset")
                }
                setPosition(t) {
                    this._command("setPosition", t)
                }
                getPosition() {
                    var t, e;
                    return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0
                }
            }

            function ue(t, e, i, n, s) {
                return t.setProperty(e, `@@${i}:${n}`, s)
            }
            let de = (() => {
                class t {
                    constructor(t, e, i) {
                        this.delegate = t, this.engine = e, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => {
                            e && e.parentNode(t) && e.removeChild(t.parentNode, t)
                        }
                    }
                    createRenderer(t, e) {
                        const i = this.delegate.createRenderer(t, e);
                        if (!(t && e && e.data && e.data.animation)) {
                            let t = this._rendererCache.get(i);
                            return t || (t = new pe("", i, this.engine), this._rendererCache.set(i, t)), t
                        }
                        const n = e.id,
                            s = e.id + "-" + this._currentId;
                        this._currentId++, this.engine.register(s, t);
                        const r = e => {
                            Array.isArray(e) ? e.forEach(r) : this.engine.registerTrigger(n, s, t, e.name, e)
                        };
                        return e.data.animation.forEach(r), new fe(this, s, i, this.engine)
                    }
                    begin() {
                        this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
                    }
                    _scheduleCountTask() {
                        this.promise.then(() => {
                            this._microtaskId++
                        })
                    }
                    scheduleListenerCallback(t, e, i) {
                        t >= 0 && t < this._microtaskId ? this._zone.run(() => e(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => {
                            this._zone.run(() => {
                                this._animationCallbacksBuffer.forEach(t => {
                                    const [e, i] = t;
                                    e(i)
                                }), this._animationCallbacksBuffer = []
                            })
                        }), this._animationCallbacksBuffer.push([e, i]))
                    }
                    end() {
                        this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => {
                            this._scheduleCountTask(), this.engine.flush(this._microtaskId)
                        }), this.delegate.end && this.delegate.end()
                    }
                    whenRenderingDone() {
                        return this.engine.whenRenderingDone()
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(n.H), n.Zb(Ut), n.Zb(n.B))
                }, t.\u0275prov = n.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class pe {
                constructor(t, e, i) {
                    this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null
                }
                get data() {
                    return this.delegate.data
                }
                destroy() {
                    this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy()
                }
                createElement(t, e) {
                    return this.delegate.createElement(t, e)
                }
                createComment(t) {
                    return this.delegate.createComment(t)
                }
                createText(t) {
                    return this.delegate.createText(t)
                }
                appendChild(t, e) {
                    this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1)
                }
                insertBefore(t, e, i, n = !0) {
                    this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, n)
                }
                removeChild(t, e, i) {
                    this.engine.onRemove(this.namespaceId, e, this.delegate, i)
                }
                selectRootElement(t, e) {
                    return this.delegate.selectRootElement(t, e)
                }
                parentNode(t) {
                    return this.delegate.parentNode(t)
                }
                nextSibling(t) {
                    return this.delegate.nextSibling(t)
                }
                setAttribute(t, e, i, n) {
                    this.delegate.setAttribute(t, e, i, n)
                }
                removeAttribute(t, e, i) {
                    this.delegate.removeAttribute(t, e, i)
                }
                addClass(t, e) {
                    this.delegate.addClass(t, e)
                }
                removeClass(t, e) {
                    this.delegate.removeClass(t, e)
                }
                setStyle(t, e, i, n) {
                    this.delegate.setStyle(t, e, i, n)
                }
                removeStyle(t, e, i) {
                    this.delegate.removeStyle(t, e, i)
                }
                setProperty(t, e, i) {
                    "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i)
                }
                setValue(t, e) {
                    this.delegate.setValue(t, e)
                }
                listen(t, e, i) {
                    return this.delegate.listen(t, e, i)
                }
                disableAnimations(t, e) {
                    this.engine.disableAnimations(t, e)
                }
            }
            class fe extends pe {
                constructor(t, e, i, n) {
                    super(e, i, n), this.factory = t, this.namespaceId = e
                }
                setProperty(t, e, i) {
                    "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i)
                }
                listen(t, e, i) {
                    if ("@" == e.charAt(0)) {
                        const n = function(t) {
                            switch (t) {
                                case "body":
                                    return document.body;
                                case "document":
                                    return document;
                                case "window":
                                    return window;
                                default:
                                    return t
                            }
                        }(t);
                        let s = e.substr(1),
                            r = "";
                        return "@" != s.charAt(0) && ([s, r] = function(t) {
                            const e = t.indexOf(".");
                            return [t.substring(0, e), t.substr(e + 1)]
                        }(s)), this.engine.listen(this.namespaceId, n, s, r, t => {
                            this.factory.scheduleListenerCallback(t._data || -1, i, t)
                        })
                    }
                    return this.delegate.listen(t, e, i)
                }
            }
            let ge = (() => {
                class t extends Ut {
                    constructor(t, e, i) {
                        super(t.body, e, i)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(oe.d), n.Zb(A), n.Zb(gt))
                }, t.\u0275prov = n.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const me = new n.s("AnimationModuleType"),
                be = [{
                    provide: A,
                    useFactory: function() {
                        return "function" == typeof ae() ? new re : new ne
                    }
                }, {
                    provide: me,
                    useValue: "BrowserAnimations"
                }, {
                    provide: r.b,
                    useClass: le
                }, {
                    provide: gt,
                    useFactory: function() {
                        return new mt
                    }
                }, {
                    provide: Ut,
                    useClass: ge
                }, {
                    provide: n.H,
                    useFactory: function(t, e, i) {
                        return new de(t, e, i)
                    },
                    deps: [s.d, Ut, n.B]
                }];
            let ye = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = n.Nb({
                    type: t
                }), t.\u0275inj = n.Mb({
                    providers: be,
                    imports: [s.a]
                }), t
            })()
        },
        SIQg: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return c
            });
            var n = i("bx2D"),
                s = i("jqqC"),
                r = i("5CXX"),
                a = i("TYm1"),
                o = i("WGFi"),
                l = i("2QHy");
            class c {
                constructor(t) {
                    t && (this._subscribe = t)
                }
                lift(t) {
                    const e = new c;
                    return e.source = this, e.operator = t, e
                }
                subscribe(t, e, i) {
                    const r = (a = t) && a instanceof n.b || function(t) {
                        return t && Object(l.a)(t.next) && Object(l.a)(t.error) && Object(l.a)(t.complete)
                    }(a) && Object(s.c)(a) ? t : new n.a(t, e, i);
                    var a;
                    if (o.a.useDeprecatedSynchronousErrorHandling) this._deprecatedSyncErrorSubscribe(r);
                    else {
                        const {
                            operator: t,
                            source: e
                        } = this;
                        r.add(t ? t.call(r, e) : e ? this._subscribe(r) : this._trySubscribe(r))
                    }
                    return r
                }
                _deprecatedSyncErrorSubscribe(t) {
                    const e = t;
                    e._syncErrorHack_isSubscribing = !0;
                    const {
                        operator: i
                    } = this;
                    if (i) t.add(i.call(t, this.source));
                    else try {
                        this._subscribe(t)
                    } catch (s) {
                        e.__syncError = s
                    }
                    let n = e;
                    for (; n;) {
                        if ("__syncError" in n) try {
                            throw n.__syncError
                        } finally {
                            t.unsubscribe()
                        }
                        n = n.destination
                    }
                    e._syncErrorHack_isSubscribing = !1
                }
                _trySubscribe(t) {
                    try {
                        return this._subscribe(t)
                    } catch (e) {
                        t.error(e)
                    }
                }
                forEach(t, e) {
                    return new(e = h(e))((e, i) => {
                        let n;
                        n = this.subscribe(e => {
                            try {
                                t(e)
                            } catch (s) {
                                i(s), null == n || n.unsubscribe()
                            }
                        }, i, e)
                    })
                }
                _subscribe(t) {
                    var e;
                    return null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)
                } [r.a]() {
                    return this
                }
                pipe(...t) {
                    return t.length ? (0 === (e = t).length ? a.a : 1 === e.length ? e[0] : function(t) {
                        return e.reduce((t, e) => e(t), t)
                    })(this) : this;
                    var e
                }
                toPromise(t) {
                    return new(t = h(t))((t, e) => {
                        let i;
                        this.subscribe(t => i = t, t => e(t), () => t(i))
                    })
                }
            }

            function h(t) {
                var e;
                return null !== (e = null != t ? t : o.a.Promise) && void 0 !== e ? e : Promise
            }
            c.create = t => new c(t)
        },
        STbY: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return G
            }), i.d(e, "b", function() {
                return U
            }), i.d(e, "c", function() {
                return J
            }), i.d(e, "d", function() {
                return Q
            });
            var n = i("u47x"),
                s = i("8LU1"),
                r = i("FtGj"),
                a = i("fXoL"),
                o = i("oXA7"),
                l = i("jqqC"),
                c = i("2btn"),
                h = i("4krO"),
                u = i("2nZi"),
                d = i("zzs5"),
                p = i("1q39"),
                f = i("nnEh"),
                g = i("dLTe"),
                m = i("bk9D"),
                b = i("Jlqm"),
                y = i("g+Sw"),
                v = i("EPzc"),
                x = i("xt23"),
                _ = i("MRCm"),
                w = i("sIyT"),
                C = i("1M4b");

            function k(t, e) {
                return e ? i => Object(y.a)(e.pipe(Object(f.a)(1), Object(v.b)((t, e) => {
                    t.subscribe(new x.a(e, _.a))
                })), i.pipe(k(t))) : Object(C.a)((e, i) => t(e, i).pipe(Object(f.a)(1), Object(w.a)(e)))
            }
            var S = i("QoT1");

            function A(t, e = b.b) {
                const i = Object(S.a)(t, e);
                return k(() => i)
            }
            var O = i("R0Ic"),
                E = i("+rOU"),
                P = i("ofXK"),
                T = i("FKr1"),
                D = i("rDax"),
                I = i("nLfN"),
                M = i("vxfF"),
                L = i("cH1L");
            const R = ["mat-menu-item", ""],
                j = ["*"];

            function F(t, e) {
                if (1 & t) {
                    const t = a.Wb();
                    a.Vb(0, "div", 0), a.cc("keydown", function(e) {
                        return a.uc(t), a.gc()._handleKeydown(e)
                    })("click", function() {
                        return a.uc(t), a.gc().closed.emit("click")
                    })("@transformMenu.start", function(e) {
                        return a.uc(t), a.gc()._onAnimationStart(e)
                    })("@transformMenu.done", function(e) {
                        return a.uc(t), a.gc()._onAnimationDone(e)
                    }), a.Vb(1, "div", 1), a.jc(2), a.Ub(), a.Ub()
                }
                if (2 & t) {
                    const t = a.gc();
                    a.lc("id", t.panelId)("ngClass", t._classList)("@transformMenu", t._panelAnimationState), a.Eb("aria-label", t.ariaLabel || null)("aria-labelledby", t.ariaLabelledby || null)("aria-describedby", t.ariaDescribedby || null)
                }
            }
            const N = {
                    transformMenu: Object(O.m)("transformMenu", [Object(O.j)("void", Object(O.k)({
                        opacity: 0,
                        transform: "scale(0.8)"
                    })), Object(O.l)("void => enter", Object(O.e)("120ms cubic-bezier(0, 0, 0.2, 1)", Object(O.k)({
                        opacity: 1,
                        transform: "scale(1)"
                    }))), Object(O.l)("* => void", Object(O.e)("100ms 25ms linear", Object(O.k)({
                        opacity: 0
                    })))]),
                    fadeInItems: Object(O.m)("fadeInItems", [Object(O.j)("showing", Object(O.k)({
                        opacity: 1
                    })), Object(O.l)("void => *", [Object(O.k)({
                        opacity: 0
                    }), Object(O.e)("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])
                },
                z = new a.s("MatMenuContent"),
                V = new a.s("MAT_MENU_PANEL");
            class B {}
            const H = Object(T.r)(Object(T.s)(B));
            let U = (() => {
                class t extends H {
                    constructor(t, e, i, n) {
                        super(), this._elementRef = t, this._focusMonitor = i, this._parentMenu = n, this.role = "menuitem", this._hovered = new o.a, this._focused = new o.a, this._highlighted = !1, this._triggersSubmenu = !1, n && n.addItem && n.addItem(this)
                    }
                    focus(t, e) {
                        this._focusMonitor && t ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e), this._focused.next(this)
                    }
                    ngAfterViewInit() {
                        this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1)
                    }
                    ngOnDestroy() {
                        this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete()
                    }
                    _getTabIndex() {
                        return this.disabled ? "-1" : "0"
                    }
                    _getHostElement() {
                        return this._elementRef.nativeElement
                    }
                    _checkDisabled(t) {
                        this.disabled && (t.preventDefault(), t.stopPropagation())
                    }
                    _handleMouseEnter() {
                        this._hovered.next(this)
                    }
                    getLabel() {
                        var t, e;
                        const i = this._elementRef.nativeElement.cloneNode(!0),
                            n = i.querySelectorAll("mat-icon, .material-icons");
                        for (let s = 0; s < n.length; s++) {
                            const e = n[s];
                            null === (t = e.parentNode) || void 0 === t || t.removeChild(e)
                        }
                        return (null === (e = i.textContent) || void 0 === e ? void 0 : e.trim()) || ""
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(a.Pb(a.l), a.Pb(P.d), a.Pb(n.f), a.Pb(V, 8))
                }, t.\u0275cmp = a.Jb({
                    type: t,
                    selectors: [
                        ["", "mat-menu-item", ""]
                    ],
                    hostAttrs: [1, "mat-focus-indicator"],
                    hostVars: 10,
                    hostBindings: function(t, e) {
                        1 & t && a.cc("click", function(t) {
                            return e._checkDisabled(t)
                        })("mouseenter", function() {
                            return e._handleMouseEnter()
                        }), 2 & t && (a.Eb("role", e.role)("tabindex", e._getTabIndex())("aria-disabled", e.disabled.toString())("disabled", e.disabled || null), a.Hb("mat-menu-item", !0)("mat-menu-item-highlighted", e._highlighted)("mat-menu-item-submenu-trigger", e._triggersSubmenu))
                    },
                    inputs: {
                        disabled: "disabled",
                        disableRipple: "disableRipple",
                        role: "role"
                    },
                    exportAs: ["matMenuItem"],
                    features: [a.Ab],
                    attrs: R,
                    ngContentSelectors: j,
                    decls: 2,
                    vars: 2,
                    consts: [
                        ["matRipple", "", 1, "mat-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"]
                    ],
                    template: function(t, e) {
                        1 & t && (a.kc(), a.jc(0), a.Qb(1, "div", 0)), 2 & t && (a.Db(1), a.lc("matRippleDisabled", e.disableRipple || e.disabled)("matRippleTrigger", e._getHostElement()))
                    },
                    directives: [T.l],
                    encapsulation: 2,
                    changeDetection: 0
                }), t
            })();
            const X = new a.s("mat-menu-default-options", {
                providedIn: "root",
                factory: function() {
                    return {
                        overlapTrigger: !1,
                        xPosition: "after",
                        yPosition: "below",
                        backdropClass: "cdk-overlay-transparent-backdrop"
                    }
                }
            });
            let W = 0,
                Y = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._elementRef = t, this._ngZone = e, this._defaultOptions = i, this._xPosition = this._defaultOptions.xPosition, this._yPosition = this._defaultOptions.yPosition, this._directDescendantItems = new a.F, this._tabSubscription = l.b.EMPTY, this._classList = {}, this._panelAnimationState = "void", this._animationDone = new o.a, this.overlayPanelClass = this._defaultOptions.overlayPanelClass || "", this.backdropClass = this._defaultOptions.backdropClass, this._overlapTrigger = this._defaultOptions.overlapTrigger, this._hasBackdrop = this._defaultOptions.hasBackdrop, this.closed = new a.o, this.close = this.closed, this.panelId = "mat-menu-panel-" + W++
                        }
                        get xPosition() {
                            return this._xPosition
                        }
                        set xPosition(t) {
                            this._xPosition = t, this.setPositionClasses()
                        }
                        get yPosition() {
                            return this._yPosition
                        }
                        set yPosition(t) {
                            this._yPosition = t, this.setPositionClasses()
                        }
                        get overlapTrigger() {
                            return this._overlapTrigger
                        }
                        set overlapTrigger(t) {
                            this._overlapTrigger = Object(s.c)(t)
                        }
                        get hasBackdrop() {
                            return this._hasBackdrop
                        }
                        set hasBackdrop(t) {
                            this._hasBackdrop = Object(s.c)(t)
                        }
                        set panelClass(t) {
                            const e = this._previousPanelClass;
                            e && e.length && e.split(" ").forEach(t => {
                                this._classList[t] = !1
                            }), this._previousPanelClass = t, t && t.length && (t.split(" ").forEach(t => {
                                this._classList[t] = !0
                            }), this._elementRef.nativeElement.className = "")
                        }
                        get classList() {
                            return this.panelClass
                        }
                        set classList(t) {
                            this.panelClass = t
                        }
                        ngOnInit() {
                            this.setPositionClasses()
                        }
                        ngAfterContentInit() {
                            this._updateDirectDescendants(), this._keyManager = new n.e(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(), this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe(Object(d.a)(this._directDescendantItems), Object(p.a)(t => Object(c.a)(...t.map(t => t._focused)))).subscribe(t => this._keyManager.updateActiveItem(t))
                        }
                        ngOnDestroy() {
                            this._directDescendantItems.destroy(), this._tabSubscription.unsubscribe(), this.closed.complete()
                        }
                        _hovered() {
                            return this._directDescendantItems.changes.pipe(Object(d.a)(this._directDescendantItems), Object(p.a)(t => Object(c.a)(...t.map(t => t._hovered))))
                        }
                        addItem(t) {}
                        removeItem(t) {}
                        _handleKeydown(t) {
                            const e = t.keyCode,
                                i = this._keyManager;
                            switch (e) {
                                case r.e:
                                    Object(r.o)(t) || (t.preventDefault(), this.closed.emit("keydown"));
                                    break;
                                case r.g:
                                    this.parentMenu && "ltr" === this.direction && this.closed.emit("keydown");
                                    break;
                                case r.i:
                                    this.parentMenu && "rtl" === this.direction && this.closed.emit("keydown");
                                    break;
                                default:
                                    e !== r.l && e !== r.b || i.setFocusOrigin("keyboard"), i.onKeydown(t)
                            }
                        }
                        focusFirstItem(t = "program") {
                            this.lazyContent ? this._ngZone.onStable.pipe(Object(f.a)(1)).subscribe(() => this._focusFirstItem(t)) : this._focusFirstItem(t)
                        }
                        _focusFirstItem(t) {
                            const e = this._keyManager;
                            if (e.setFocusOrigin(t).setFirstItemActive(), !e.activeItem && this._directDescendantItems.length) {
                                let t = this._directDescendantItems.first._getHostElement().parentElement;
                                for (; t;) {
                                    if ("menu" === t.getAttribute("role")) {
                                        t.focus();
                                        break
                                    }
                                    t = t.parentElement
                                }
                            }
                        }
                        resetActiveItem() {
                            this._keyManager.setActiveItem(-1)
                        }
                        setElevation(t) {
                            const e = `mat-elevation-z${Math.min(4+t,24)}`,
                                i = Object.keys(this._classList).find(t => t.startsWith("mat-elevation-z"));
                            i && i !== this._previousElevation || (this._previousElevation && (this._classList[this._previousElevation] = !1), this._classList[e] = !0, this._previousElevation = e)
                        }
                        setPositionClasses(t = this.xPosition, e = this.yPosition) {
                            const i = this._classList;
                            i["mat-menu-before"] = "before" === t, i["mat-menu-after"] = "after" === t, i["mat-menu-above"] = "above" === e, i["mat-menu-below"] = "below" === e
                        }
                        _startAnimation() {
                            this._panelAnimationState = "enter"
                        }
                        _resetAnimation() {
                            this._panelAnimationState = "void"
                        }
                        _onAnimationDone(t) {
                            this._animationDone.next(t), this._isAnimating = !1
                        }
                        _onAnimationStart(t) {
                            this._isAnimating = !0, "enter" === t.toState && 0 === this._keyManager.activeItemIndex && (t.element.scrollTop = 0)
                        }
                        _updateDirectDescendants() {
                            this._allItems.changes.pipe(Object(d.a)(this._allItems)).subscribe(t => {
                                this._directDescendantItems.reset(t.filter(t => t._parentMenu === this)), this._directDescendantItems.notifyOnChanges()
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(a.l), a.Pb(a.B), a.Pb(X))
                    }, t.\u0275dir = a.Kb({
                        type: t,
                        contentQueries: function(t, e, i) {
                            if (1 & t && (a.Ib(i, z, 1), a.Ib(i, U, 1), a.Ib(i, U, 0)), 2 & t) {
                                let t;
                                a.rc(t = a.dc()) && (e.lazyContent = t.first), a.rc(t = a.dc()) && (e._allItems = t), a.rc(t = a.dc()) && (e.items = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && a.Hc(a.O, 1), 2 & t) {
                                let t;
                                a.rc(t = a.dc()) && (e.templateRef = t.first)
                            }
                        },
                        inputs: {
                            backdropClass: "backdropClass",
                            xPosition: "xPosition",
                            yPosition: "yPosition",
                            overlapTrigger: "overlapTrigger",
                            hasBackdrop: "hasBackdrop",
                            panelClass: ["class", "panelClass"],
                            classList: "classList",
                            ariaLabel: ["aria-label", "ariaLabel"],
                            ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
                            ariaDescribedby: ["aria-describedby", "ariaDescribedby"]
                        },
                        outputs: {
                            closed: "closed",
                            close: "close"
                        }
                    }), t
                })(),
                G = (() => {
                    class t extends Y {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(a.l), a.Pb(a.B), a.Pb(X))
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-menu"]
                        ],
                        hostVars: 3,
                        hostBindings: function(t, e) {
                            2 & t && a.Eb("aria-label", null)("aria-labelledby", null)("aria-describedby", null)
                        },
                        exportAs: ["matMenu"],
                        features: [a.Cb([{
                            provide: V,
                            useExisting: t
                        }]), a.Ab],
                        ngContentSelectors: j,
                        decls: 1,
                        vars: 0,
                        consts: [
                            ["tabindex", "-1", "role", "menu", 1, "mat-menu-panel", 3, "id", "ngClass", "keydown", "click"],
                            [1, "mat-menu-content"]
                        ],
                        template: function(t, e) {
                            1 & t && (a.kc(), a.Bc(0, F, 3, 6, "ng-template"))
                        },
                        directives: [P.j],
                        styles: ['mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n'],
                        encapsulation: 2,
                        data: {
                            animation: [N.transformMenu, N.fadeInItems]
                        },
                        changeDetection: 0
                    }), t
                })();
            const q = new a.s("mat-menu-scroll-strategy"),
                Z = {
                    provide: q,
                    deps: [D.c],
                    useFactory: function(t) {
                        return () => t.scrollStrategies.reposition()
                    }
                },
                $ = Object(I.f)({
                    passive: !0
                });
            let Q = (() => {
                    class t {
                        constructor(t, e, i, s, r, o, c, h) {
                            this._overlay = t, this._element = e, this._viewContainerRef = i, this._menuItemInstance = o, this._dir = c, this._focusMonitor = h, this._overlayRef = null, this._menuOpen = !1, this._closingActionsSubscription = l.b.EMPTY, this._hoverSubscription = l.b.EMPTY, this._menuCloseSubscription = l.b.EMPTY, this._handleTouchStart = t => {
                                Object(n.k)(t) || (this._openedBy = "touch")
                            }, this._openedBy = void 0, this.restoreFocus = !0, this.menuOpened = new a.o, this.onMenuOpen = this.menuOpened, this.menuClosed = new a.o, this.onMenuClose = this.menuClosed, this._scrollStrategy = s, this._parentMaterialMenu = r instanceof Y ? r : void 0, e.nativeElement.addEventListener("touchstart", this._handleTouchStart, $), o && (o._triggersSubmenu = this.triggersSubmenu())
                        }
                        get _deprecatedMatMenuTriggerFor() {
                            return this.menu
                        }
                        set _deprecatedMatMenuTriggerFor(t) {
                            this.menu = t
                        }
                        get menu() {
                            return this._menu
                        }
                        set menu(t) {
                            t !== this._menu && (this._menu = t, this._menuCloseSubscription.unsubscribe(), t && (this._menuCloseSubscription = t.close.subscribe(t => {
                                this._destroyMenu(t), "click" !== t && "tab" !== t || !this._parentMaterialMenu || this._parentMaterialMenu.closed.emit(t)
                            })))
                        }
                        ngAfterContentInit() {
                            this._checkMenu(), this._handleHover()
                        }
                        ngOnDestroy() {
                            this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null), this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, $), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe()
                        }
                        get menuOpen() {
                            return this._menuOpen
                        }
                        get dir() {
                            return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr"
                        }
                        triggersSubmenu() {
                            return !(!this._menuItemInstance || !this._parentMaterialMenu)
                        }
                        toggleMenu() {
                            return this._menuOpen ? this.closeMenu() : this.openMenu()
                        }
                        openMenu() {
                            if (this._menuOpen) return;
                            this._checkMenu();
                            const t = this._createOverlay(),
                                e = t.getConfig();
                            this._setPosition(e.positionStrategy), e.hasBackdrop = null == this.menu.hasBackdrop ? !this.triggersSubmenu() : this.menu.hasBackdrop, t.attach(this._getPortal()), this.menu.lazyContent && this.menu.lazyContent.attach(this.menuData), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), this._initMenu(), this.menu instanceof Y && this.menu._startAnimation()
                        }
                        closeMenu() {
                            this.menu.close.emit()
                        }
                        focus(t, e) {
                            this._focusMonitor && t ? this._focusMonitor.focusVia(this._element, t, e) : this._element.nativeElement.focus(e)
                        }
                        _destroyMenu(t) {
                            if (!this._overlayRef || !this.menuOpen) return;
                            const e = this.menu;
                            this._closingActionsSubscription.unsubscribe(), this._overlayRef.detach(), !this.restoreFocus || "keydown" !== t && this._openedBy && this.triggersSubmenu() || this.focus(this._openedBy), this._openedBy = void 0, e instanceof Y ? (e._resetAnimation(), e.lazyContent ? e._animationDone.pipe(Object(g.a)(t => "void" === t.toState), Object(f.a)(1), Object(m.a)(e.lazyContent._attached)).subscribe({
                                next: () => e.lazyContent.detach(),
                                complete: () => this._setIsMenuOpen(!1)
                            }) : this._setIsMenuOpen(!1)) : (this._setIsMenuOpen(!1), e.lazyContent && e.lazyContent.detach())
                        }
                        _initMenu() {
                            this.menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0, this.menu.direction = this.dir, this._setMenuElevation(), this.menu.focusFirstItem(this._openedBy || "program"), this._setIsMenuOpen(!0)
                        }
                        _setMenuElevation() {
                            if (this.menu.setElevation) {
                                let t = 0,
                                    e = this.menu.parentMenu;
                                for (; e;) t++, e = e.parentMenu;
                                this.menu.setElevation(t)
                            }
                        }
                        _setIsMenuOpen(t) {
                            this._menuOpen = t, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && (this._menuItemInstance._highlighted = t)
                        }
                        _checkMenu() {}
                        _createOverlay() {
                            if (!this._overlayRef) {
                                const t = this._getOverlayConfig();
                                this._subscribeToPositions(t.positionStrategy), this._overlayRef = this._overlay.create(t), this._overlayRef.keydownEvents().subscribe()
                            }
                            return this._overlayRef
                        }
                        _getOverlayConfig() {
                            return new D.d({
                                positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
                                backdropClass: this.menu.backdropClass || "cdk-overlay-transparent-backdrop",
                                panelClass: this.menu.overlayPanelClass,
                                scrollStrategy: this._scrollStrategy(),
                                direction: this._dir
                            })
                        }
                        _subscribeToPositions(t) {
                            this.menu.setPositionClasses && t.positionChanges.subscribe(t => {
                                this.menu.setPositionClasses("start" === t.connectionPair.overlayX ? "after" : "before", "top" === t.connectionPair.overlayY ? "below" : "above")
                            })
                        }
                        _setPosition(t) {
                            let [e, i] = "before" === this.menu.xPosition ? ["end", "start"] : ["start", "end"], [n, s] = "above" === this.menu.yPosition ? ["bottom", "top"] : ["top", "bottom"], [r, a] = [n, s], [o, l] = [e, i], c = 0;
                            this.triggersSubmenu() ? (l = e = "before" === this.menu.xPosition ? "start" : "end", i = o = "end" === e ? "start" : "end", c = "bottom" === n ? 8 : -8) : this.menu.overlapTrigger || (r = "top" === n ? "bottom" : "top", a = "top" === s ? "bottom" : "top"), t.withPositions([{
                                originX: e,
                                originY: r,
                                overlayX: o,
                                overlayY: n,
                                offsetY: c
                            }, {
                                originX: i,
                                originY: r,
                                overlayX: l,
                                overlayY: n,
                                offsetY: c
                            }, {
                                originX: e,
                                originY: a,
                                overlayX: o,
                                overlayY: s,
                                offsetY: -c
                            }, {
                                originX: i,
                                originY: a,
                                overlayX: l,
                                overlayY: s,
                                offsetY: -c
                            }])
                        }
                        _menuClosingActions() {
                            const t = this._overlayRef.backdropClick(),
                                e = this._overlayRef.detachments(),
                                i = this._parentMaterialMenu ? this._parentMaterialMenu.closed : Object(h.a)(),
                                n = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(Object(g.a)(t => t !== this._menuItemInstance), Object(g.a)(() => this._menuOpen)) : Object(h.a)();
                            return Object(c.a)(t, i, n, e)
                        }
                        _handleMousedown(t) {
                            Object(n.j)(t) || (this._openedBy = 0 === t.button ? "mouse" : void 0, this.triggersSubmenu() && t.preventDefault())
                        }
                        _handleKeydown(t) {
                            const e = t.keyCode;
                            e !== r.d && e !== r.j || (this._openedBy = "keyboard"), this.triggersSubmenu() && (e === r.i && "ltr" === this.dir || e === r.g && "rtl" === this.dir) && (this._openedBy = "keyboard", this.openMenu())
                        }
                        _handleClick(t) {
                            this.triggersSubmenu() ? (t.stopPropagation(), this.openMenu()) : this.toggleMenu()
                        }
                        _handleHover() {
                            this.triggersSubmenu() && this._parentMaterialMenu && (this._hoverSubscription = this._parentMaterialMenu._hovered().pipe(Object(g.a)(t => t === this._menuItemInstance && !t.disabled), A(0, u.a)).subscribe(() => {
                                this._openedBy = "mouse", this.menu instanceof Y && this.menu._isAnimating ? this.menu._animationDone.pipe(Object(f.a)(1), A(0, u.a), Object(m.a)(this._parentMaterialMenu._hovered())).subscribe(() => this.openMenu()) : this.openMenu()
                            }))
                        }
                        _getPortal() {
                            return this._portal && this._portal.templateRef === this.menu.templateRef || (this._portal = new E.f(this.menu.templateRef, this._viewContainerRef)), this._portal
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(D.c), a.Pb(a.l), a.Pb(a.S), a.Pb(q), a.Pb(V, 8), a.Pb(U, 10), a.Pb(L.b, 8), a.Pb(n.f))
                    }, t.\u0275dir = a.Kb({
                        type: t,
                        selectors: [
                            ["", "mat-menu-trigger-for", ""],
                            ["", "matMenuTriggerFor", ""]
                        ],
                        hostAttrs: ["aria-haspopup", "true", 1, "mat-menu-trigger"],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            1 & t && a.cc("mousedown", function(t) {
                                return e._handleMousedown(t)
                            })("keydown", function(t) {
                                return e._handleKeydown(t)
                            })("click", function(t) {
                                return e._handleClick(t)
                            }), 2 & t && a.Eb("aria-expanded", e.menuOpen || null)("aria-controls", e.menuOpen ? e.menu.panelId : null)
                        },
                        inputs: {
                            restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"],
                            _deprecatedMatMenuTriggerFor: ["mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"],
                            menu: ["matMenuTriggerFor", "menu"],
                            menuData: ["matMenuTriggerData", "menuData"]
                        },
                        outputs: {
                            menuOpened: "menuOpened",
                            onMenuOpen: "onMenuOpen",
                            menuClosed: "menuClosed",
                            onMenuClose: "onMenuClose"
                        },
                        exportAs: ["matMenuTrigger"]
                    }), t
                })(),
                K = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = a.Nb({
                        type: t
                    }), t.\u0275inj = a.Mb({
                        providers: [Z],
                        imports: [T.e]
                    }), t
                })(),
                J = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = a.Nb({
                        type: t
                    }), t.\u0275inj = a.Mb({
                        providers: [Z],
                        imports: [
                            [P.c, T.e, T.m, D.e, K], M.b, T.e, K
                        ]
                    }), t
                })()
        },
        TU8p: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return u
            }), i.d(e, "b", function() {
                return d
            });
            var n = i("FKr1"),
                s = i("u47x"),
                r = i("8LU1"),
                a = i("R1ws"),
                o = i("fXoL");
            let l = 0;
            class c {}
            const h = Object(n.s)(c);
            let u = (() => {
                    class t extends h {
                        constructor(t, e, i, n, s) {
                            super(), this._ngZone = t, this._elementRef = e, this._ariaDescriber = i, this._renderer = n, this._animationMode = s, this._hasContent = !1, this._color = "primary", this._overlap = !0, this.position = "above after", this.size = "medium", this._id = l++
                        }
                        get color() {
                            return this._color
                        }
                        set color(t) {
                            this._setColor(t), this._color = t
                        }
                        get overlap() {
                            return this._overlap
                        }
                        set overlap(t) {
                            this._overlap = Object(r.c)(t)
                        }
                        get description() {
                            return this._description
                        }
                        set description(t) {
                            if (t !== this._description) {
                                const e = this._badgeElement;
                                this._updateHostAriaDescription(t, this._description), this._description = t, e && (t ? e.setAttribute("aria-label", t) : e.removeAttribute("aria-label"))
                            }
                        }
                        get hidden() {
                            return this._hidden
                        }
                        set hidden(t) {
                            this._hidden = Object(r.c)(t)
                        }
                        isAbove() {
                            return -1 === this.position.indexOf("below")
                        }
                        isAfter() {
                            return -1 === this.position.indexOf("before")
                        }
                        ngOnChanges(t) {
                            const e = t.content;
                            if (e) {
                                const t = e.currentValue;
                                this._hasContent = null != t && `${t}`.trim().length > 0, this._updateTextContent()
                            }
                        }
                        ngOnDestroy() {
                            const t = this._badgeElement;
                            t && (this.description && this._ariaDescriber.removeDescription(t, this.description), this._renderer.destroyNode && this._renderer.destroyNode(t))
                        }
                        getBadgeElement() {
                            return this._badgeElement
                        }
                        _updateTextContent() {
                            return this._badgeElement ? this._badgeElement.textContent = this._stringifyContent() : this._badgeElement = this._createBadgeElement(), this._badgeElement
                        }
                        _createBadgeElement() {
                            const t = this._renderer.createElement("span");
                            return this._clearExistingBadges("mat-badge-content"), t.setAttribute("id", `mat-badge-content-${this._id}`), t.classList.add("mat-badge-content"), t.textContent = this._stringifyContent(), "NoopAnimations" === this._animationMode && t.classList.add("_mat-animation-noopable"), this.description && t.setAttribute("aria-label", this.description), this._elementRef.nativeElement.appendChild(t), "function" == typeof requestAnimationFrame && "NoopAnimations" !== this._animationMode ? this._ngZone.runOutsideAngular(() => {
                                requestAnimationFrame(() => {
                                    t.classList.add("mat-badge-active")
                                })
                            }) : t.classList.add("mat-badge-active"), t
                        }
                        _updateHostAriaDescription(t, e) {
                            const i = this._updateTextContent();
                            e && this._ariaDescriber.removeDescription(i, e), t && this._ariaDescriber.describe(i, t)
                        }
                        _setColor(t) {
                            if (t !== this._color) {
                                const e = this._elementRef.nativeElement.classList;
                                this._color && e.remove(`mat-badge-${this._color}`), t && e.add(`mat-badge-${t}`)
                            }
                        }
                        _clearExistingBadges(t) {
                            const e = this._elementRef.nativeElement;
                            let i = e.children.length;
                            for (; i--;) {
                                const n = e.children[i];
                                n.classList.contains(t) && e.removeChild(n)
                            }
                        }
                        _stringifyContent() {
                            const t = this.content;
                            return null == t ? "" : `${t}`
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.B), o.Pb(o.l), o.Pb(s.c), o.Pb(o.G), o.Pb(a.a, 8))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        selectors: [
                            ["", "matBadge", ""]
                        ],
                        hostAttrs: [1, "mat-badge"],
                        hostVars: 20,
                        hostBindings: function(t, e) {
                            2 & t && o.Hb("mat-badge-overlap", e.overlap)("mat-badge-above", e.isAbove())("mat-badge-below", !e.isAbove())("mat-badge-before", !e.isAfter())("mat-badge-after", e.isAfter())("mat-badge-small", "small" === e.size)("mat-badge-medium", "medium" === e.size)("mat-badge-large", "large" === e.size)("mat-badge-hidden", e.hidden || !e._hasContent)("mat-badge-disabled", e.disabled)
                        },
                        inputs: {
                            disabled: ["matBadgeDisabled", "disabled"],
                            position: ["matBadgePosition", "position"],
                            size: ["matBadgeSize", "size"],
                            color: ["matBadgeColor", "color"],
                            overlap: ["matBadgeOverlap", "overlap"],
                            description: ["matBadgeDescription", "description"],
                            hidden: ["matBadgeHidden", "hidden"],
                            content: ["matBadge", "content"]
                        },
                        features: [o.Ab, o.Bb]
                    }), t
                })(),
                d = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = o.Nb({
                        type: t
                    }), t.\u0275inj = o.Mb({
                        imports: [
                            [s.a, n.e], n.e
                        ]
                    }), t
                })()
        },
        TYm1: function(t, e, i) {
            "use strict";

            function n(t) {
                return t
            }
            i.d(e, "a", function() {
                return n
            })
        },
        Tk8M: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            var n = i("jqqC");
            class s extends n.b {
                constructor(t, e) {
                    super()
                }
                schedule(t, e = 0) {
                    return this
                }
            }
            const r = {
                setInterval(...t) {
                    const {
                        delegate: e
                    } = r;
                    return ((null == e ? void 0 : e.setInterval) || setInterval)(...t)
                },
                clearInterval(t) {
                    const {
                        delegate: e
                    } = r;
                    return ((null == e ? void 0 : e.clearInterval) || clearInterval)(t)
                },
                delegate: void 0
            };
            var a = i("vRMS");
            class o extends s {
                constructor(t, e) {
                    super(t, e), this.scheduler = t, this.work = e, this.pending = !1
                }
                schedule(t, e = 0) {
                    if (this.closed) return this;
                    this.state = t;
                    const i = this.id,
                        n = this.scheduler;
                    return null != i && (this.id = this.recycleAsyncId(n, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(n, this.id, e), this
                }
                requestAsyncId(t, e, i = 0) {
                    return r.setInterval(t.flush.bind(t, this), i)
                }
                recycleAsyncId(t, e, i = 0) {
                    if (null != i && this.delay === i && !1 === this.pending) return e;
                    r.clearInterval(e)
                }
                execute(t, e) {
                    if (this.closed) return new Error("executing a cancelled action");
                    this.pending = !1;
                    const i = this._execute(t, e);
                    if (i) return i;
                    !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
                }
                _execute(t, e) {
                    let i, n = !1;
                    try {
                        this.work(t)
                    } catch (s) {
                        n = !0, i = !!s && s || new Error(s)
                    }
                    if (n) return this.unsubscribe(), i
                }
                unsubscribe() {
                    if (!this.closed) {
                        const {
                            id: t,
                            scheduler: e
                        } = this, {
                            actions: i
                        } = e;
                        this.work = this.state = this.scheduler = null, this.pending = !1, Object(a.a)(i, this), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null, super.unsubscribe()
                    }
                }
            }
        },
        UtzL: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            var n = function(t) {
                return t.DASHBOARD = "/dashboard", t.TYPOGRAPHY = "/typography", t.TABLES = "/tables", t.NOTIFICATION = "/notification", t.UI_ELEMENTS_ICONS = "/ui/icons", t.UI_ELEMENTS_CHARTS = "/ui/charts", t.UI_ELEMENTS_MAP = "/ui/map", t.LOGIN = "/login", t
            }({})
        },
        VZwH: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("g/MW"),
                s = i("xt23"),
                r = i("EPzc");

            function a(t) {
                return Object(r.b)((e, i) => {
                    let r, o = null,
                        l = !1;
                    o = e.subscribe(new s.a(i, void 0, void 0, s => {
                        r = Object(n.c)(t(s, a(t)(e))), o ? (o.unsubscribe(), o = null, r.subscribe(i)) : l = !0
                    })), l && (o.unsubscribe(), o = null, r.subscribe(i))
                })
            }
        },
        WGFi: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = {
                onUnhandledError: null,
                onStoppedNotification: null,
                Promise: void 0,
                useDeprecatedSynchronousErrorHandling: !1,
                useDeprecatedNextContext: !1
            }
        },
        Wp6s: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return u
            }), i.d(e, "b", function() {
                return l
            }), i.d(e, "c", function() {
                return d
            }), i.d(e, "d", function() {
                return h
            }), i.d(e, "e", function() {
                return c
            });
            var n = i("R1ws"),
                s = i("FKr1"),
                r = i("fXoL");
            const a = ["*", [
                    ["mat-card-footer"]
                ]],
                o = ["*", "mat-card-footer"];
            let l = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-card-content"],
                            ["", "mat-card-content", ""],
                            ["", "matCardContent", ""]
                        ],
                        hostAttrs: [1, "mat-card-content"]
                    }), t
                })(),
                c = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-card-title"],
                            ["", "mat-card-title", ""],
                            ["", "matCardTitle", ""]
                        ],
                        hostAttrs: [1, "mat-card-title"]
                    }), t
                })(),
                h = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-card-subtitle"],
                            ["", "mat-card-subtitle", ""],
                            ["", "matCardSubtitle", ""]
                        ],
                        hostAttrs: [1, "mat-card-subtitle"]
                    }), t
                })(),
                u = (() => {
                    class t {
                        constructor(t) {
                            this._animationMode = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(n.a, 8))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["mat-card"]
                        ],
                        hostAttrs: [1, "mat-card", "mat-focus-indicator"],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            2 & t && r.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode)
                        },
                        exportAs: ["matCard"],
                        ngContentSelectors: o,
                        decls: 2,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (r.kc(a), r.jc(0), r.jc(1, 1))
                        },
                        styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                d = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = r.Nb({
                        type: t
                    }), t.\u0275inj = r.Mb({
                        imports: [
                            [s.e], s.e
                        ]
                    }), t
                })()
        },
        WwWl: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            var n = i("fXoL"),
                s = i("bTqV"),
                r = i("STbY"),
                a = i("NFeN");
            let o = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-settings-menu"]
                    ],
                    decls: 14,
                    vars: 1,
                    consts: [
                        ["mat-mini-fab", "", 1, "settings-button", 3, "matMenuTriggerFor"],
                        [1, "settings-button__icon"],
                        [1, "settings-menu"],
                        ["xPosition", "before"],
                        ["settings", "matMenu"],
                        ["mat-menu-item", "", 1, "settings-menu__item"]
                    ],
                    template: function(t, e) {
                        if (1 & t && (n.Vb(0, "button", 0), n.Vb(1, "mat-icon", 1), n.Cc(2, "more_vert"), n.Ub(), n.Ub(), n.Vb(3, "div", 2), n.Vb(4, "mat-menu", 3, 4), n.Vb(6, "button", 5), n.Cc(7, "Edit"), n.Ub(), n.Vb(8, "button", 5), n.Cc(9, "Copy"), n.Ub(), n.Vb(10, "button", 5), n.Cc(11, "Delete"), n.Ub(), n.Vb(12, "button", 5), n.Cc(13, "Print"), n.Ub(), n.Ub(), n.Ub()), 2 & t) {
                            const t = n.sc(5);
                            n.lc("matMenuTriggerFor", t)
                        }
                    },
                    directives: [s.b, r.d, a.a, r.a, r.b],
                    styles: [".settings-button[_ngcontent-%COMP%]{box-shadow:none;background-color:#fff;color:#b9b9b9}.settings-button[_ngcontent-%COMP%]:hover{background-color:#536dfe;color:hsla(0,0%,100%,.35)}.settings-button__icon[_ngcontent-%COMP%]{color:inherit}.settings-menu[_ngcontent-%COMP%]{position:absolute}.settings-menu__item[_ngcontent-%COMP%]{color:#4a4a4a}.settings-menu__item[_ngcontent-%COMP%]:hover{background-color:#f3f5ff}"]
                }), t
            })()
        },
        "X/DG": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("oXA7");
            class s extends n.a {
                constructor(t) {
                    super(), this._value = t
                }
                get value() {
                    return this.getValue()
                }
                _subscribe(t) {
                    const e = super._subscribe(t);
                    return !e.closed && t.next(this._value), e
                }
                getValue() {
                    const {
                        hasError: t,
                        thrownError: e,
                        _value: i
                    } = this;
                    if (t) throw e;
                    return this._throwIfClosed(), i
                }
                next(t) {
                    super.next(this._value = t)
                }
            }
        },
        XJvv: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("TYm1"),
                s = i("EPzc"),
                r = i("xt23");

            function a(t, e = n.a) {
                return t = null != t ? t : o, Object(s.b)((i, n) => {
                    let s, a = !0;
                    i.subscribe(new r.a(n, i => {
                        const r = e(i);
                        !a && t(s, r) || (a = !1, s = r, n.next(i))
                    }))
                })
            }

            function o(t, e) {
                return t === e
            }
        },
        XhcP: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return H
            }), i.d(e, "b", function() {
                return X
            }), i.d(e, "c", function() {
                return B
            }), i.d(e, "d", function() {
                return Y
            });
            var n = i("nLfN"),
                s = i("vxfF"),
                r = i("ofXK"),
                a = i("fXoL"),
                o = i("FKr1"),
                l = i("8LU1"),
                c = i("FtGj"),
                h = i("oXA7"),
                u = i("KOvq"),
                d = i("2btn"),
                p = i("dLTe"),
                f = i("rdQv"),
                g = i("sIyT"),
                m = i("bk9D"),
                b = i("XJvv"),
                y = i("nnEh"),
                v = i("zzs5"),
                x = i("sj3c"),
                _ = i("R0Ic"),
                w = i("R1ws"),
                C = i("u47x"),
                k = i("cH1L");
            const S = ["*"];

            function A(t, e) {
                if (1 & t) {
                    const t = a.Wb();
                    a.Vb(0, "div", 2), a.cc("click", function() {
                        return a.uc(t), a.gc()._onBackdropClicked()
                    }), a.Ub()
                }
                if (2 & t) {
                    const t = a.gc();
                    a.Hb("mat-drawer-shown", t._isShowingBackdrop())
                }
            }

            function O(t, e) {
                1 & t && (a.Vb(0, "mat-drawer-content"), a.jc(1, 2), a.Ub())
            }
            const E = [
                    [
                        ["mat-drawer"]
                    ],
                    [
                        ["mat-drawer-content"]
                    ], "*"
                ],
                P = ["mat-drawer", "mat-drawer-content", "*"];

            function T(t, e) {
                if (1 & t) {
                    const t = a.Wb();
                    a.Vb(0, "div", 2), a.cc("click", function() {
                        return a.uc(t), a.gc()._onBackdropClicked()
                    }), a.Ub()
                }
                if (2 & t) {
                    const t = a.gc();
                    a.Hb("mat-drawer-shown", t._isShowingBackdrop())
                }
            }

            function D(t, e) {
                1 & t && (a.Vb(0, "mat-sidenav-content", 3), a.jc(1, 2), a.Ub())
            }
            const I = [
                    [
                        ["mat-sidenav"]
                    ],
                    [
                        ["mat-sidenav-content"]
                    ], "*"
                ],
                M = ["mat-sidenav", "mat-sidenav-content", "*"],
                L = ".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n",
                R = {
                    transformDrawer: Object(_.m)("transform", [Object(_.j)("open, open-instant", Object(_.k)({
                        transform: "none",
                        visibility: "visible"
                    })), Object(_.j)("void", Object(_.k)({
                        "box-shadow": "none",
                        visibility: "hidden"
                    })), Object(_.l)("void => open-instant", Object(_.e)("0ms")), Object(_.l)("void <=> open, open-instant => void", Object(_.e)("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))])
                },
                j = new a.s("MAT_DRAWER_DEFAULT_AUTOSIZE", {
                    providedIn: "root",
                    factory: function() {
                        return !1
                    }
                }),
                F = new a.s("MAT_DRAWER_CONTAINER");
            let N = (() => {
                    class t extends s.a {
                        constructor(t, e, i, n, s) {
                            super(i, n, s), this._changeDetectorRef = t, this._container = e
                        }
                        ngAfterContentInit() {
                            this._container._contentMarginChanges.subscribe(() => {
                                this._changeDetectorRef.markForCheck()
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(a.h), a.Pb(Object(a.W)(() => V)), a.Pb(a.l), a.Pb(s.c), a.Pb(a.B))
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-drawer-content"]
                        ],
                        hostAttrs: [1, "mat-drawer-content"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && a.yc("margin-left", e._container._contentMargins.left, "px")("margin-right", e._container._contentMargins.right, "px")
                        },
                        features: [a.Ab],
                        ngContentSelectors: S,
                        decls: 1,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (a.kc(), a.jc(0))
                        },
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                z = (() => {
                    class t {
                        constructor(t, e, i, n, s, r, o) {
                            this._elementRef = t, this._focusTrapFactory = e, this._focusMonitor = i, this._platform = n, this._ngZone = s, this._doc = r, this._container = o, this._elementFocusedBeforeDrawerWasOpened = null, this._enableAnimations = !1, this._position = "start", this._mode = "over", this._disableClose = !1, this._opened = !1, this._animationStarted = new h.a, this._animationEnd = new h.a, this._animationState = "void", this.openedChange = new a.o(!0), this._openedStream = this.openedChange.pipe(Object(p.a)(t => t), Object(f.a)(() => {})), this.openedStart = this._animationStarted.pipe(Object(p.a)(t => t.fromState !== t.toState && 0 === t.toState.indexOf("open")), Object(g.a)(void 0)), this._closedStream = this.openedChange.pipe(Object(p.a)(t => !t), Object(f.a)(() => {})), this.closedStart = this._animationStarted.pipe(Object(p.a)(t => t.fromState !== t.toState && "void" === t.toState), Object(g.a)(void 0)), this._destroyed = new h.a, this.onPositionChanged = new a.o, this._modeChanged = new h.a, this.openedChange.subscribe(t => {
                                t ? (this._doc && (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement), this._takeFocus()) : this._isFocusWithinDrawer() && this._restoreFocus()
                            }), this._ngZone.runOutsideAngular(() => {
                                Object(u.a)(this._elementRef.nativeElement, "keydown").pipe(Object(p.a)(t => t.keyCode === c.e && !this.disableClose && !Object(c.o)(t)), Object(m.a)(this._destroyed)).subscribe(t => this._ngZone.run(() => {
                                    this.close(), t.stopPropagation(), t.preventDefault()
                                }))
                            }), this._animationEnd.pipe(Object(b.a)((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => {
                                const {
                                    fromState: e,
                                    toState: i
                                } = t;
                                (0 === i.indexOf("open") && "void" === e || "void" === i && 0 === e.indexOf("open")) && this.openedChange.emit(this._opened)
                            })
                        }
                        get position() {
                            return this._position
                        }
                        set position(t) {
                            (t = "end" === t ? "end" : "start") != this._position && (this._position = t, this.onPositionChanged.emit())
                        }
                        get mode() {
                            return this._mode
                        }
                        set mode(t) {
                            this._mode = t, this._updateFocusTrapState(), this._modeChanged.next()
                        }
                        get disableClose() {
                            return this._disableClose
                        }
                        set disableClose(t) {
                            this._disableClose = Object(l.c)(t)
                        }
                        get autoFocus() {
                            const t = this._autoFocus;
                            return null == t ? "side" !== this.mode : t
                        }
                        set autoFocus(t) {
                            this._autoFocus = Object(l.c)(t)
                        }
                        get opened() {
                            return this._opened
                        }
                        set opened(t) {
                            this.toggle(Object(l.c)(t))
                        }
                        _takeFocus() {
                            this.autoFocus && this._focusTrap && this._focusTrap.focusInitialElementWhenReady().then(t => {
                                t || "function" != typeof this._elementRef.nativeElement.focus || this._elementRef.nativeElement.focus()
                            })
                        }
                        _restoreFocus() {
                            this.autoFocus && (this._elementFocusedBeforeDrawerWasOpened ? this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia) : this._elementRef.nativeElement.blur(), this._elementFocusedBeforeDrawerWasOpened = null, this._openedVia = null)
                        }
                        _isFocusWithinDrawer() {
                            var t;
                            const e = null === (t = this._doc) || void 0 === t ? void 0 : t.activeElement;
                            return !!e && this._elementRef.nativeElement.contains(e)
                        }
                        ngAfterContentInit() {
                            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._updateFocusTrapState()
                        }
                        ngAfterContentChecked() {
                            this._platform.isBrowser && (this._enableAnimations = !0)
                        }
                        ngOnDestroy() {
                            this._focusTrap && this._focusTrap.destroy(), this._animationStarted.complete(), this._animationEnd.complete(), this._modeChanged.complete(), this._destroyed.next(), this._destroyed.complete()
                        }
                        open(t) {
                            return this.toggle(!0, t)
                        }
                        close() {
                            return this.toggle(!1)
                        }
                        _closeViaBackdropClick() {
                            return this._setOpen(!1, !0)
                        }
                        toggle(t = !this.opened, e) {
                            return this._setOpen(t, !t && this._isFocusWithinDrawer(), e)
                        }
                        _setOpen(t, e, i = "program") {
                            return this._opened = t, t ? (this._animationState = this._enableAnimations ? "open" : "open-instant", this._openedVia = i) : (this._animationState = "void", e && this._restoreFocus()), this._updateFocusTrapState(), new Promise(t => {
                                this.openedChange.pipe(Object(y.a)(1)).subscribe(e => t(e ? "open" : "close"))
                            })
                        }
                        _getWidth() {
                            return this._elementRef.nativeElement && this._elementRef.nativeElement.offsetWidth || 0
                        }
                        _updateFocusTrapState() {
                            this._focusTrap && (this._focusTrap.enabled = this.opened && "side" !== this.mode)
                        }
                        _animationStartListener(t) {
                            this._animationStarted.next(t)
                        }
                        _animationDoneListener(t) {
                            this._animationEnd.next(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(a.l), a.Pb(C.g), a.Pb(C.f), a.Pb(n.a), a.Pb(a.B), a.Pb(r.d, 8), a.Pb(F, 8))
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-drawer"]
                        ],
                        hostAttrs: ["tabIndex", "-1", 1, "mat-drawer"],
                        hostVars: 12,
                        hostBindings: function(t, e) {
                            1 & t && a.zc("@transform.start", function(t) {
                                return e._animationStartListener(t)
                            })("@transform.done", function(t) {
                                return e._animationDoneListener(t)
                            }), 2 & t && (a.Eb("align", null), a.Ac("@transform", e._animationState), a.Hb("mat-drawer-end", "end" === e.position)("mat-drawer-over", "over" === e.mode)("mat-drawer-push", "push" === e.mode)("mat-drawer-side", "side" === e.mode)("mat-drawer-opened", e.opened))
                        },
                        inputs: {
                            position: "position",
                            mode: "mode",
                            disableClose: "disableClose",
                            autoFocus: "autoFocus",
                            opened: "opened"
                        },
                        outputs: {
                            openedChange: "openedChange",
                            _openedStream: "opened",
                            openedStart: "openedStart",
                            _closedStream: "closed",
                            closedStart: "closedStart",
                            onPositionChanged: "positionChanged"
                        },
                        exportAs: ["matDrawer"],
                        ngContentSelectors: S,
                        decls: 2,
                        vars: 0,
                        consts: [
                            ["cdkScrollable", "", 1, "mat-drawer-inner-container"]
                        ],
                        template: function(t, e) {
                            1 & t && (a.kc(), a.Vb(0, "div", 0), a.jc(1), a.Ub())
                        },
                        directives: [s.a],
                        encapsulation: 2,
                        data: {
                            animation: [R.transformDrawer]
                        },
                        changeDetection: 0
                    }), t
                })(),
                V = (() => {
                    class t {
                        constructor(t, e, i, n, s, r = !1, o) {
                            this._dir = t, this._element = e, this._ngZone = i, this._changeDetectorRef = n, this._animationMode = o, this._drawers = new a.F, this.backdropClick = new a.o, this._destroyed = new h.a, this._doCheckSubject = new h.a, this._contentMargins = {
                                left: null,
                                right: null
                            }, this._contentMarginChanges = new h.a, t && t.change.pipe(Object(m.a)(this._destroyed)).subscribe(() => {
                                this._validateDrawers(), this.updateContentMargins()
                            }), s.change().pipe(Object(m.a)(this._destroyed)).subscribe(() => this.updateContentMargins()), this._autosize = r
                        }
                        get start() {
                            return this._start
                        }
                        get end() {
                            return this._end
                        }
                        get autosize() {
                            return this._autosize
                        }
                        set autosize(t) {
                            this._autosize = Object(l.c)(t)
                        }
                        get hasBackdrop() {
                            return null == this._backdropOverride ? !this._start || "side" !== this._start.mode || !this._end || "side" !== this._end.mode : this._backdropOverride
                        }
                        set hasBackdrop(t) {
                            this._backdropOverride = null == t ? null : Object(l.c)(t)
                        }
                        get scrollable() {
                            return this._userContent || this._content
                        }
                        ngAfterContentInit() {
                            this._allDrawers.changes.pipe(Object(v.a)(this._allDrawers), Object(m.a)(this._destroyed)).subscribe(t => {
                                this._drawers.reset(t.filter(t => !t._container || t._container === this)), this._drawers.notifyOnChanges()
                            }), this._drawers.changes.pipe(Object(v.a)(null)).subscribe(() => {
                                this._validateDrawers(), this._drawers.forEach(t => {
                                    this._watchDrawerToggle(t), this._watchDrawerPosition(t), this._watchDrawerMode(t)
                                }), (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) && this.updateContentMargins(), this._changeDetectorRef.markForCheck()
                            }), this._ngZone.runOutsideAngular(() => {
                                this._doCheckSubject.pipe(Object(x.a)(10), Object(m.a)(this._destroyed)).subscribe(() => this.updateContentMargins())
                            })
                        }
                        ngOnDestroy() {
                            this._contentMarginChanges.complete(), this._doCheckSubject.complete(), this._drawers.destroy(), this._destroyed.next(), this._destroyed.complete()
                        }
                        open() {
                            this._drawers.forEach(t => t.open())
                        }
                        close() {
                            this._drawers.forEach(t => t.close())
                        }
                        updateContentMargins() {
                            let t = 0,
                                e = 0;
                            if (this._left && this._left.opened)
                                if ("side" == this._left.mode) t += this._left._getWidth();
                                else if ("push" == this._left.mode) {
                                const i = this._left._getWidth();
                                t += i, e -= i
                            }
                            if (this._right && this._right.opened)
                                if ("side" == this._right.mode) e += this._right._getWidth();
                                else if ("push" == this._right.mode) {
                                const i = this._right._getWidth();
                                e += i, t -= i
                            }
                            t = t || null, e = e || null, t === this._contentMargins.left && e === this._contentMargins.right || (this._contentMargins = {
                                left: t,
                                right: e
                            }, this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins)))
                        }
                        ngDoCheck() {
                            this._autosize && this._isPushed() && this._ngZone.runOutsideAngular(() => this._doCheckSubject.next())
                        }
                        _watchDrawerToggle(t) {
                            t._animationStarted.pipe(Object(p.a)(t => t.fromState !== t.toState), Object(m.a)(this._drawers.changes)).subscribe(t => {
                                "open-instant" !== t.toState && "NoopAnimations" !== this._animationMode && this._element.nativeElement.classList.add("mat-drawer-transition"), this.updateContentMargins(), this._changeDetectorRef.markForCheck()
                            }), "side" !== t.mode && t.openedChange.pipe(Object(m.a)(this._drawers.changes)).subscribe(() => this._setContainerClass(t.opened))
                        }
                        _watchDrawerPosition(t) {
                            t && t.onPositionChanged.pipe(Object(m.a)(this._drawers.changes)).subscribe(() => {
                                this._ngZone.onMicrotaskEmpty.pipe(Object(y.a)(1)).subscribe(() => {
                                    this._validateDrawers()
                                })
                            })
                        }
                        _watchDrawerMode(t) {
                            t && t._modeChanged.pipe(Object(m.a)(Object(d.a)(this._drawers.changes, this._destroyed))).subscribe(() => {
                                this.updateContentMargins(), this._changeDetectorRef.markForCheck()
                            })
                        }
                        _setContainerClass(t) {
                            const e = this._element.nativeElement.classList,
                                i = "mat-drawer-container-has-open";
                            t ? e.add(i) : e.remove(i)
                        }
                        _validateDrawers() {
                            this._start = this._end = null, this._drawers.forEach(t => {
                                "end" == t.position ? this._end = t : this._start = t
                            }), this._right = this._left = null, this._dir && "rtl" === this._dir.value ? (this._left = this._end, this._right = this._start) : (this._left = this._start, this._right = this._end)
                        }
                        _isPushed() {
                            return this._isDrawerOpen(this._start) && "over" != this._start.mode || this._isDrawerOpen(this._end) && "over" != this._end.mode
                        }
                        _onBackdropClicked() {
                            this.backdropClick.emit(), this._closeModalDrawersViaBackdrop()
                        }
                        _closeModalDrawersViaBackdrop() {
                            [this._start, this._end].filter(t => t && !t.disableClose && this._canHaveBackdrop(t)).forEach(t => t._closeViaBackdropClick())
                        }
                        _isShowingBackdrop() {
                            return this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start) || this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end)
                        }
                        _canHaveBackdrop(t) {
                            return "side" !== t.mode || !!this._backdropOverride
                        }
                        _isDrawerOpen(t) {
                            return null != t && t.opened
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(k.b, 8), a.Pb(a.l), a.Pb(a.B), a.Pb(a.h), a.Pb(s.e), a.Pb(j), a.Pb(w.a, 8))
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-drawer-container"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (a.Ib(i, N, 1), a.Ib(i, z, 1)), 2 & t) {
                                let t;
                                a.rc(t = a.dc()) && (e._content = t.first), a.rc(t = a.dc()) && (e._allDrawers = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && a.Hc(N, 1), 2 & t) {
                                let t;
                                a.rc(t = a.dc()) && (e._userContent = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-drawer-container"],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            2 & t && a.Hb("mat-drawer-container-explicit-backdrop", e._backdropOverride)
                        },
                        inputs: {
                            autosize: "autosize",
                            hasBackdrop: "hasBackdrop"
                        },
                        outputs: {
                            backdropClick: "backdropClick"
                        },
                        exportAs: ["matDrawerContainer"],
                        features: [a.Cb([{
                            provide: F,
                            useExisting: t
                        }])],
                        ngContentSelectors: P,
                        decls: 4,
                        vars: 2,
                        consts: [
                            ["class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf"],
                            [4, "ngIf"],
                            [1, "mat-drawer-backdrop", 3, "click"]
                        ],
                        template: function(t, e) {
                            1 & t && (a.kc(E), a.Bc(0, A, 1, 2, "div", 0), a.jc(1), a.jc(2, 1), a.Bc(3, O, 2, 0, "mat-drawer-content", 1)), 2 & t && (a.lc("ngIf", e.hasBackdrop), a.Db(3), a.lc("ngIf", !e._content))
                        },
                        directives: [r.l, N],
                        styles: [L],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                B = (() => {
                    class t extends N {
                        constructor(t, e, i, n, s) {
                            super(t, e, i, n, s)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(a.Pb(a.h), a.Pb(Object(a.W)(() => X)), a.Pb(a.l), a.Pb(s.c), a.Pb(a.B))
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-sidenav-content"]
                        ],
                        hostAttrs: [1, "mat-drawer-content", "mat-sidenav-content"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && a.yc("margin-left", e._container._contentMargins.left, "px")("margin-right", e._container._contentMargins.right, "px")
                        },
                        features: [a.Ab],
                        ngContentSelectors: S,
                        decls: 1,
                        vars: 0,
                        template: function(t, e) {
                            1 & t && (a.kc(), a.jc(0))
                        },
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                H = (() => {
                    class t extends z {
                        constructor() {
                            super(...arguments), this._fixedInViewport = !1, this._fixedTopGap = 0, this._fixedBottomGap = 0
                        }
                        get fixedInViewport() {
                            return this._fixedInViewport
                        }
                        set fixedInViewport(t) {
                            this._fixedInViewport = Object(l.c)(t)
                        }
                        get fixedTopGap() {
                            return this._fixedTopGap
                        }
                        set fixedTopGap(t) {
                            this._fixedTopGap = Object(l.f)(t)
                        }
                        get fixedBottomGap() {
                            return this._fixedBottomGap
                        }
                        set fixedBottomGap(t) {
                            this._fixedBottomGap = Object(l.f)(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return U(e || t)
                    }, t.\u0275cmp = a.Jb({
                        type: t,
                        selectors: [
                            ["mat-sidenav"]
                        ],
                        hostAttrs: ["tabIndex", "-1", 1, "mat-drawer", "mat-sidenav"],
                        hostVars: 17,
                        hostBindings: function(t, e) {
                            2 & t && (a.Eb("align", null), a.yc("top", e.fixedInViewport ? e.fixedTopGap : null, "px")("bottom", e.fixedInViewport ? e.fixedBottomGap : null, "px"), a.Hb("mat-drawer-end", "end" === e.position)("mat-drawer-over", "over" === e.mode)("mat-drawer-push", "push" === e.mode)("mat-drawer-side", "side" === e.mode)("mat-drawer-opened", e.opened)("mat-sidenav-fixed", e.fixedInViewport))
                        },
                        inputs: {
                            fixedInViewport: "fixedInViewport",
                            fixedTopGap: "fixedTopGap",
                            fixedBottomGap: "fixedBottomGap"
                        },
                        exportAs: ["matSidenav"],
                        features: [a.Ab],
                        ngContentSelectors: S,
                        decls: 2,
                        vars: 0,
                        consts: [
                            ["cdkScrollable", "", 1, "mat-drawer-inner-container"]
                        ],
                        template: function(t, e) {
                            1 & t && (a.kc(), a.Vb(0, "div", 0), a.jc(1), a.Ub())
                        },
                        directives: [s.a],
                        encapsulation: 2,
                        data: {
                            animation: [R.transformDrawer]
                        },
                        changeDetection: 0
                    }), t
                })();
            const U = a.Xb(H);
            let X = (() => {
                class t extends V {}
                return t.\u0275fac = function(e) {
                    return W(e || t)
                }, t.\u0275cmp = a.Jb({
                    type: t,
                    selectors: [
                        ["mat-sidenav-container"]
                    ],
                    contentQueries: function(t, e, i) {
                        if (1 & t && (a.Ib(i, B, 1), a.Ib(i, H, 1)), 2 & t) {
                            let t;
                            a.rc(t = a.dc()) && (e._content = t.first), a.rc(t = a.dc()) && (e._allDrawers = t)
                        }
                    },
                    hostAttrs: [1, "mat-drawer-container", "mat-sidenav-container"],
                    hostVars: 2,
                    hostBindings: function(t, e) {
                        2 & t && a.Hb("mat-drawer-container-explicit-backdrop", e._backdropOverride)
                    },
                    exportAs: ["matSidenavContainer"],
                    features: [a.Cb([{
                        provide: F,
                        useExisting: t
                    }]), a.Ab],
                    ngContentSelectors: M,
                    decls: 4,
                    vars: 2,
                    consts: [
                        ["class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf"],
                        ["cdkScrollable", "", 4, "ngIf"],
                        [1, "mat-drawer-backdrop", 3, "click"],
                        ["cdkScrollable", ""]
                    ],
                    template: function(t, e) {
                        1 & t && (a.kc(I), a.Bc(0, T, 1, 2, "div", 0), a.jc(1), a.jc(2, 1), a.Bc(3, D, 2, 0, "mat-sidenav-content", 1)), 2 & t && (a.lc("ngIf", e.hasBackdrop), a.Db(3), a.lc("ngIf", !e._content))
                    },
                    directives: [r.l, B, s.a],
                    styles: [L],
                    encapsulation: 2,
                    changeDetection: 0
                }), t
            })();
            const W = a.Xb(X);
            let Y = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = a.Nb({
                    type: t
                }), t.\u0275inj = a.Mb({
                    imports: [
                        [r.c, o.e, n.b, s.b], s.b, o.e
                    ]
                }), t
            })()
        },
        XwfS: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("2QHy");

            function s(t) {
                return t && Object(n.a)(t.schedule)
            }
        },
        ZXg6: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            });
            var n = i("SIQg"),
                s = i("jqqC"),
                r = i("42oE"),
                a = i("xt23"),
                o = i("EPzc");
            class l extends n.a {
                constructor(t, e) {
                    super(), this.source = t, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, Object(o.a)(t) && (this.lift = t.lift)
                }
                _subscribe(t) {
                    return this.getSubject().subscribe(t)
                }
                getSubject() {
                    const t = this._subject;
                    return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject
                }
                _teardown() {
                    this._refCount = 0;
                    const {
                        _connection: t
                    } = this;
                    this._subject = this._connection = null, null == t || t.unsubscribe()
                }
                connect() {
                    let t = this._connection;
                    if (!t) {
                        t = this._connection = new s.b;
                        const e = this.getSubject();
                        t.add(this.source.subscribe(new a.a(e, void 0, () => {
                            this._teardown(), e.complete()
                        }, t => {
                            this._teardown(), e.error(t)
                        }, () => this._teardown()))), t.closed && (this._connection = null, t = s.b.EMPTY)
                    }
                    return t
                }
                refCount() {
                    return Object(r.a)()(this)
                }
            }
        },
        ZjGG: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = {
                setTimeout(...t) {
                    const {
                        delegate: e
                    } = n;
                    return ((null == e ? void 0 : e.setTimeout) || setTimeout)(...t)
                },
                clearTimeout(t) {
                    const {
                        delegate: e
                    } = n;
                    return ((null == e ? void 0 : e.clearTimeout) || clearTimeout)(t)
                },
                delegate: void 0
            }
        },
        bTqV: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return f
            }), i.d(e, "b", function() {
                return p
            }), i.d(e, "c", function() {
                return g
            });
            var n = i("FKr1"),
                s = i("R1ws"),
                r = i("fXoL"),
                a = i("u47x");
            const o = ["mat-button", ""],
                l = ["*"],
                c = ".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n",
                h = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"];
            class u {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const d = Object(n.q)(Object(n.s)(Object(n.r)(u)));
            let p = (() => {
                    class t extends d {
                        constructor(t, e, i) {
                            super(t), this._focusMonitor = e, this._animationMode = i, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button");
                            for (const n of h) this._hasHostAttributes(n) && this._getHostElement().classList.add(n);
                            t.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent")
                        }
                        ngAfterViewInit() {
                            this._focusMonitor.monitor(this._elementRef, !0)
                        }
                        ngOnDestroy() {
                            this._focusMonitor.stopMonitoring(this._elementRef)
                        }
                        focus(t, e) {
                            t ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e)
                        }
                        _getHostElement() {
                            return this._elementRef.nativeElement
                        }
                        _isRippleDisabled() {
                            return this.disableRipple || this.disabled
                        }
                        _hasHostAttributes(...t) {
                            return t.some(t => this._getHostElement().hasAttribute(t))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.l), r.Pb(a.f), r.Pb(s.a, 8))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["button", "mat-button", ""],
                            ["button", "mat-raised-button", ""],
                            ["button", "mat-icon-button", ""],
                            ["button", "mat-fab", ""],
                            ["button", "mat-mini-fab", ""],
                            ["button", "mat-stroked-button", ""],
                            ["button", "mat-flat-button", ""]
                        ],
                        viewQuery: function(t, e) {
                            if (1 & t && r.Hc(n.l, 1), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e.ripple = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-focus-indicator"],
                        hostVars: 5,
                        hostBindings: function(t, e) {
                            2 & t && (r.Eb("disabled", e.disabled || null), r.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-button-disabled", e.disabled))
                        },
                        inputs: {
                            disabled: "disabled",
                            disableRipple: "disableRipple",
                            color: "color"
                        },
                        exportAs: ["matButton"],
                        features: [r.Ab],
                        attrs: o,
                        ngContentSelectors: l,
                        decls: 4,
                        vars: 5,
                        consts: [
                            [1, "mat-button-wrapper"],
                            ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"],
                            [1, "mat-button-focus-overlay"]
                        ],
                        template: function(t, e) {
                            1 & t && (r.kc(), r.Vb(0, "span", 0), r.jc(1), r.Ub(), r.Qb(2, "span", 1), r.Qb(3, "span", 2)), 2 & t && (r.Db(2), r.Hb("mat-button-ripple-round", e.isRoundButton || e.isIconButton), r.lc("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement()))
                        },
                        directives: [n.l],
                        styles: [c],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                f = (() => {
                    class t extends p {
                        constructor(t, e, i) {
                            super(e, t, i)
                        }
                        _haltDisabledEvents(t) {
                            this.disabled && (t.preventDefault(), t.stopImmediatePropagation())
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(a.f), r.Pb(r.l), r.Pb(s.a, 8))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["a", "mat-button", ""],
                            ["a", "mat-raised-button", ""],
                            ["a", "mat-icon-button", ""],
                            ["a", "mat-fab", ""],
                            ["a", "mat-mini-fab", ""],
                            ["a", "mat-stroked-button", ""],
                            ["a", "mat-flat-button", ""]
                        ],
                        hostAttrs: [1, "mat-focus-indicator"],
                        hostVars: 7,
                        hostBindings: function(t, e) {
                            1 & t && r.cc("click", function(t) {
                                return e._haltDisabledEvents(t)
                            }), 2 & t && (r.Eb("tabindex", e.disabled ? -1 : e.tabIndex || 0)("disabled", e.disabled || null)("aria-disabled", e.disabled.toString()), r.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-button-disabled", e.disabled))
                        },
                        inputs: {
                            disabled: "disabled",
                            disableRipple: "disableRipple",
                            color: "color",
                            tabIndex: "tabIndex"
                        },
                        exportAs: ["matButton", "matAnchor"],
                        features: [r.Ab],
                        attrs: o,
                        ngContentSelectors: l,
                        decls: 4,
                        vars: 5,
                        consts: [
                            [1, "mat-button-wrapper"],
                            ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"],
                            [1, "mat-button-focus-overlay"]
                        ],
                        template: function(t, e) {
                            1 & t && (r.kc(), r.Vb(0, "span", 0), r.jc(1), r.Ub(), r.Qb(2, "span", 1), r.Qb(3, "span", 2)), 2 & t && (r.Db(2), r.Hb("mat-button-ripple-round", e.isRoundButton || e.isIconButton), r.lc("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement()))
                        },
                        directives: [n.l],
                        styles: [c],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })(),
                g = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = r.Nb({
                        type: t
                    }), t.\u0275inj = r.Mb({
                        imports: [
                            [n.m, n.e], n.e
                        ]
                    }), t
                })()
        },
        bk9D: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            var n = i("EPzc"),
                s = i("xt23"),
                r = i("g/MW"),
                a = i("MRCm");

            function o(t) {
                return Object(n.b)((e, i) => {
                    Object(r.c)(t).subscribe(new s.a(i, () => i.complete(), a.a)), !i.closed && e.subscribe(i)
                })
            }
        },
        bv9b: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return m
            }), i.d(e, "b", function() {
                return y
            });
            var n = i("fXoL"),
                s = i("ofXK"),
                r = i("FKr1"),
                a = i("8LU1"),
                o = i("R1ws"),
                l = i("jqqC"),
                c = i("KOvq"),
                h = i("dLTe");
            const u = ["primaryValueBar"];
            class d {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const p = Object(r.q)(d, "primary"),
                f = new n.s("mat-progress-bar-location", {
                    providedIn: "root",
                    factory: function() {
                        const t = Object(n.X)(s.d),
                            e = t ? t.location : null;
                        return {
                            getPathname: () => e ? e.pathname + e.search : ""
                        }
                    }
                });
            let g = 0,
                m = (() => {
                    class t extends p {
                        constructor(t, e, i, s) {
                            super(t), this._elementRef = t, this._ngZone = e, this._animationMode = i, this._isNoopAnimation = !1, this._value = 0, this._bufferValue = 0, this.animationEnd = new n.o, this._animationEndSubscription = l.b.EMPTY, this.mode = "determinate", this.progressbarId = "mat-progress-bar-" + g++;
                            const r = s ? s.getPathname().split("#")[0] : "";
                            this._rectangleFillValue = `url('${r}#${this.progressbarId}')`, this._isNoopAnimation = "NoopAnimations" === i
                        }
                        get value() {
                            return this._value
                        }
                        set value(t) {
                            this._value = b(Object(a.f)(t) || 0)
                        }
                        get bufferValue() {
                            return this._bufferValue
                        }
                        set bufferValue(t) {
                            this._bufferValue = b(t || 0)
                        }
                        _primaryTransform() {
                            return {
                                transform: `scale3d(${this.value/100}, 1, 1)`
                            }
                        }
                        _bufferTransform() {
                            return "buffer" === this.mode ? {
                                transform: `scale3d(${this.bufferValue/100}, 1, 1)`
                            } : null
                        }
                        ngAfterViewInit() {
                            this._ngZone.runOutsideAngular(() => {
                                const t = this._primaryValueBar.nativeElement;
                                this._animationEndSubscription = Object(c.a)(t, "transitionend").pipe(Object(h.a)(e => e.target === t)).subscribe(() => {
                                    "determinate" !== this.mode && "buffer" !== this.mode || this._ngZone.run(() => this.animationEnd.next({
                                        value: this.value
                                    }))
                                })
                            })
                        }
                        ngOnDestroy() {
                            this._animationEndSubscription.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(n.B), n.Pb(o.a, 8), n.Pb(f, 8))
                    }, t.\u0275cmp = n.Jb({
                        type: t,
                        selectors: [
                            ["mat-progress-bar"]
                        ],
                        viewQuery: function(t, e) {
                            if (1 & t && n.Hc(u, 1), 2 & t) {
                                let t;
                                n.rc(t = n.dc()) && (e._primaryValueBar = t.first)
                            }
                        },
                        hostAttrs: ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "tabindex", "-1", 1, "mat-progress-bar"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && (n.Eb("aria-valuenow", "indeterminate" === e.mode || "query" === e.mode ? null : e.value)("mode", e.mode), n.Hb("_mat-animation-noopable", e._isNoopAnimation))
                        },
                        inputs: {
                            color: "color",
                            mode: "mode",
                            value: "value",
                            bufferValue: "bufferValue"
                        },
                        outputs: {
                            animationEnd: "animationEnd"
                        },
                        exportAs: ["matProgressBar"],
                        features: [n.Ab],
                        decls: 10,
                        vars: 4,
                        consts: [
                            ["aria-hidden", "true"],
                            ["width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element"],
                            ["x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id"],
                            ["cx", "2", "cy", "2", "r", "2"],
                            ["width", "100%", "height", "100%"],
                            [1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle"],
                            [1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle"],
                            ["primaryValueBar", ""],
                            [1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element"]
                        ],
                        template: function(t, e) {
                            1 & t && (n.Vb(0, "div", 0), n.fc(), n.Vb(1, "svg", 1), n.Vb(2, "defs"), n.Vb(3, "pattern", 2), n.Qb(4, "circle", 3), n.Ub(), n.Ub(), n.Qb(5, "rect", 4), n.Ub(), n.ec(), n.Qb(6, "div", 5), n.Qb(7, "div", 6, 7), n.Qb(9, "div", 8), n.Ub()), 2 & t && (n.Db(3), n.lc("id", e.progressbarId), n.Db(2), n.Eb("fill", e._rectangleFillValue), n.Db(1), n.lc("ngStyle", e._bufferTransform()), n.Db(1), n.lc("ngStyle", e._primaryTransform()))
                        },
                        directives: [s.m],
                        styles: ['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'],
                        encapsulation: 2,
                        changeDetection: 0
                    }), t
                })();

            function b(t, e = 0, i = 100) {
                return Math.max(e, Math.min(i, t))
            }
            let y = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = n.Nb({
                    type: t
                }), t.\u0275inj = n.Mb({
                    imports: [
                        [s.c, r.e], r.e
                    ]
                }), t
            })()
        },
        bx2D: function(t, e, i) {
            "use strict";
            i.d(e, "b", function() {
                return u
            }), i.d(e, "a", function() {
                return d
            });
            var n = i("2QHy"),
                s = i("jqqC"),
                r = i("WGFi"),
                a = i("+qId"),
                o = i("MRCm");
            const l = c("C", void 0, void 0);

            function c(t, e, i) {
                return {
                    kind: t,
                    value: e,
                    error: i
                }
            }
            var h = i("ZjGG");
            class u extends s.b {
                constructor(t) {
                    super(), this.isStopped = !1, t ? (this.destination = t, Object(s.c)(t) && t.add(this)) : this.destination = m
                }
                static create(t, e, i) {
                    return new d(t, e, i)
                }
                next(t) {
                    this.isStopped ? g(function(t) {
                        return c("N", t, void 0)
                    }(t), this) : this._next(t)
                }
                error(t) {
                    this.isStopped ? g(c("E", void 0, t), this) : (this.isStopped = !0, this._error(t))
                }
                complete() {
                    this.isStopped ? g(l, this) : (this.isStopped = !0, this._complete())
                }
                unsubscribe() {
                    this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null)
                }
                _next(t) {
                    this.destination.next(t)
                }
                _error(t) {
                    try {
                        this.destination.error(t)
                    } finally {
                        this.unsubscribe()
                    }
                }
                _complete() {
                    try {
                        this.destination.complete()
                    } finally {
                        this.unsubscribe()
                    }
                }
            }
            class d extends u {
                constructor(t, e, i) {
                    let s;
                    if (super(), Object(n.a)(t)) s = t;
                    else if (t) {
                        let n;
                        ({
                            next: s,
                            error: e,
                            complete: i
                        } = t), this && r.a.useDeprecatedNextContext ? (n = Object.create(t), n.unsubscribe = () => this.unsubscribe()) : n = t, s = null == s ? void 0 : s.bind(n), e = null == e ? void 0 : e.bind(n), i = null == i ? void 0 : i.bind(n)
                    }
                    this.destination = {
                        next: s ? p(s, this) : o.a,
                        error: p(null != e ? e : f, this),
                        complete: i ? p(i, this) : o.a
                    }
                }
            }

            function p(t, e) {
                return (...i) => {
                    try {
                        t(...i)
                    } catch (n) {
                        if (r.a.useDeprecatedSynchronousErrorHandling) {
                            if (!e._syncErrorHack_isSubscribing) throw n;
                            e.__syncError = n
                        } else Object(a.a)(n)
                    }
                }
            }

            function f(t) {
                throw t
            }

            function g(t, e) {
                const {
                    onStoppedNotification: i
                } = r.a;
                i && h.a.setTimeout(() => i(t, e))
            }
            const m = {
                closed: !0,
                next: o.a,
                error: f,
                complete: o.a
            }
        },
        cH1L: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            }), i.d(e, "b", function() {
                return a
            });
            var n = i("fXoL"),
                s = i("ofXK");
            const r = new n.s("cdk-dir-doc", {
                providedIn: "root",
                factory: function() {
                    return Object(n.X)(s.d)
                }
            });
            let a = (() => {
                    class t {
                        constructor(t) {
                            if (this.value = "ltr", this.change = new n.o, t) {
                                const e = t.documentElement ? t.documentElement.dir : null,
                                    i = (t.body ? t.body.dir : null) || e;
                                this.value = "ltr" === i || "rtl" === i ? i : "ltr"
                            }
                        }
                        ngOnDestroy() {
                            this.change.complete()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(r, 8))
                    }, t.\u0275prov = Object(n.Lb)({
                        factory: function() {
                            return new t(Object(n.Zb)(r, 8))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                o = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({}), t
                })()
        },
        d3UM: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return W
            }), i.d(e, "b", function() {
                return G
            });
            var n = i("rDax"),
                s = i("ofXK"),
                r = i("fXoL"),
                a = i("FKr1"),
                o = i("kmnG"),
                l = i("vxfF"),
                c = i("u47x"),
                h = i("8LU1"),
                u = i("0EQZ"),
                d = i("FtGj"),
                p = i("oXA7"),
                f = i("PV23"),
                g = i("2btn"),
                m = i("zzs5"),
                b = i("1q39"),
                y = i("nnEh"),
                v = i("dLTe"),
                x = i("rdQv"),
                _ = i("XJvv"),
                w = i("bk9D"),
                C = i("R0Ic"),
                k = i("cH1L"),
                S = i("3Pt+");
            const A = ["trigger"],
                O = ["panel"];

            function E(t, e) {
                if (1 & t && (r.Vb(0, "span", 8), r.Cc(1), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.Db(1), r.Dc(t.placeholder)
                }
            }

            function P(t, e) {
                if (1 & t && (r.Vb(0, "span", 12), r.Cc(1), r.Ub()), 2 & t) {
                    const t = r.gc(2);
                    r.Db(1), r.Dc(t.triggerValue)
                }
            }

            function T(t, e) {
                1 & t && r.jc(0, 0, ["*ngSwitchCase", "true"])
            }

            function D(t, e) {
                if (1 & t && (r.Vb(0, "span", 9), r.Bc(1, P, 2, 1, "span", 10), r.Bc(2, T, 1, 0, "ng-content", 11), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.lc("ngSwitch", !!t.customTrigger), r.Db(2), r.lc("ngSwitchCase", !0)
                }
            }

            function I(t, e) {
                if (1 & t) {
                    const t = r.Wb();
                    r.Vb(0, "div", 13), r.Vb(1, "div", 14, 15), r.cc("@transformPanel.done", function(e) {
                        return r.uc(t), r.gc()._panelDoneAnimatingStream.next(e.toState)
                    })("keydown", function(e) {
                        return r.uc(t), r.gc()._handleKeydown(e)
                    }), r.jc(3, 1), r.Ub(), r.Ub()
                }
                if (2 & t) {
                    const t = r.gc();
                    r.lc("@transformPanelWrap", void 0), r.Db(1), r.Gb("mat-select-panel ", t._getPanelTheme(), ""), r.yc("transform-origin", t._transformOrigin)("font-size", t._triggerFontSize, "px"), r.lc("ngClass", t.panelClass)("@transformPanel", t.multiple ? "showing-multiple" : "showing"), r.Eb("id", t.id + "-panel")("aria-multiselectable", t.multiple)("aria-label", t.ariaLabel || null)("aria-labelledby", t._getPanelAriaLabelledby())
                }
            }
            const M = [
                    [
                        ["mat-select-trigger"]
                    ], "*"
                ],
                L = ["mat-select-trigger", "*"],
                R = {
                    transformPanelWrap: Object(C.m)("transformPanelWrap", [Object(C.l)("* => void", Object(C.h)("@transformPanel", [Object(C.f)()], {
                        optional: !0
                    }))]),
                    transformPanel: Object(C.m)("transformPanel", [Object(C.j)("void", Object(C.k)({
                        transform: "scaleY(0.8)",
                        minWidth: "100%",
                        opacity: 0
                    })), Object(C.j)("showing", Object(C.k)({
                        opacity: 1,
                        minWidth: "calc(100% + 32px)",
                        transform: "scaleY(1)"
                    })), Object(C.j)("showing-multiple", Object(C.k)({
                        opacity: 1,
                        minWidth: "calc(100% + 64px)",
                        transform: "scaleY(1)"
                    })), Object(C.l)("void => *", Object(C.e)("120ms cubic-bezier(0, 0, 0.2, 1)")), Object(C.l)("* => void", Object(C.e)("100ms 25ms linear", Object(C.k)({
                        opacity: 0
                    })))])
                };
            let j = 0;
            const F = new r.s("mat-select-scroll-strategy"),
                N = new r.s("MAT_SELECT_CONFIG"),
                z = {
                    provide: F,
                    deps: [n.c],
                    useFactory: function(t) {
                        return () => t.scrollStrategies.reposition()
                    }
                };
            class V {
                constructor(t, e) {
                    this.source = t, this.value = e
                }
            }
            class B {
                constructor(t, e, i, n, s) {
                    this._elementRef = t, this._defaultErrorStateMatcher = e, this._parentForm = i, this._parentFormGroup = n, this.ngControl = s
                }
            }
            const H = Object(a.r)(Object(a.v)(Object(a.s)(Object(a.t)(B)))),
                U = new r.s("MatSelectTrigger");
            let X = (() => {
                    class t extends H {
                        constructor(t, e, i, n, s, a, o, l, c, h, u, d, _, w) {
                            var C, k, S;
                            super(s, n, o, l, h), this._viewportRuler = t, this._changeDetectorRef = e, this._ngZone = i, this._dir = a, this._parentFormField = c, this.ngControl = h, this._liveAnnouncer = _, this._defaultOptions = w, this._panelOpen = !1, this._compareWith = (t, e) => t === e, this._uid = "mat-select-" + j++, this._triggerAriaLabelledBy = null, this._destroy = new p.a, this._onChange = () => {}, this._onTouched = () => {}, this._valueId = "mat-select-value-" + j++, this._panelDoneAnimatingStream = new p.a, this._overlayPanelClass = (null === (C = this._defaultOptions) || void 0 === C ? void 0 : C.overlayPanelClass) || "", this._focused = !1, this.controlType = "mat-select", this._required = !1, this._multiple = !1, this._disableOptionCentering = null !== (S = null === (k = this._defaultOptions) || void 0 === k ? void 0 : k.disableOptionCentering) && void 0 !== S && S, this.ariaLabel = "", this.optionSelectionChanges = Object(f.a)(() => {
                                const t = this.options;
                                return t ? t.changes.pipe(Object(m.a)(t), Object(b.a)(() => Object(g.a)(...t.map(t => t.onSelectionChange)))) : this._ngZone.onStable.pipe(Object(y.a)(1), Object(b.a)(() => this.optionSelectionChanges))
                            }), this.openedChange = new r.o, this._openedStream = this.openedChange.pipe(Object(v.a)(t => t), Object(x.a)(() => {})), this._closedStream = this.openedChange.pipe(Object(v.a)(t => !t), Object(x.a)(() => {})), this.selectionChange = new r.o, this.valueChange = new r.o, this.ngControl && (this.ngControl.valueAccessor = this), null != (null == w ? void 0 : w.typeaheadDebounceInterval) && (this._typeaheadDebounceInterval = w.typeaheadDebounceInterval), this._scrollStrategyFactory = d, this._scrollStrategy = this._scrollStrategyFactory(), this.tabIndex = parseInt(u) || 0, this.id = this.id
                        }
                        get focused() {
                            return this._focused || this._panelOpen
                        }
                        get placeholder() {
                            return this._placeholder
                        }
                        set placeholder(t) {
                            this._placeholder = t, this.stateChanges.next()
                        }
                        get required() {
                            return this._required
                        }
                        set required(t) {
                            this._required = Object(h.c)(t), this.stateChanges.next()
                        }
                        get multiple() {
                            return this._multiple
                        }
                        set multiple(t) {
                            this._multiple = Object(h.c)(t)
                        }
                        get disableOptionCentering() {
                            return this._disableOptionCentering
                        }
                        set disableOptionCentering(t) {
                            this._disableOptionCentering = Object(h.c)(t)
                        }
                        get compareWith() {
                            return this._compareWith
                        }
                        set compareWith(t) {
                            this._compareWith = t, this._selectionModel && this._initializeSelection()
                        }
                        get value() {
                            return this._value
                        }
                        set value(t) {
                            (t !== this._value || this._multiple && Array.isArray(t)) && (this.options && this._setSelectionByValue(t), this._value = t)
                        }
                        get typeaheadDebounceInterval() {
                            return this._typeaheadDebounceInterval
                        }
                        set typeaheadDebounceInterval(t) {
                            this._typeaheadDebounceInterval = Object(h.f)(t)
                        }
                        get id() {
                            return this._id
                        }
                        set id(t) {
                            this._id = t || this._uid, this.stateChanges.next()
                        }
                        ngOnInit() {
                            this._selectionModel = new u.c(this.multiple), this.stateChanges.next(), this._panelDoneAnimatingStream.pipe(Object(_.a)(), Object(w.a)(this._destroy)).subscribe(() => this._panelDoneAnimating(this.panelOpen))
                        }
                        ngAfterContentInit() {
                            this._initKeyManager(), this._selectionModel.changed.pipe(Object(w.a)(this._destroy)).subscribe(t => {
                                t.added.forEach(t => t.select()), t.removed.forEach(t => t.deselect())
                            }), this.options.changes.pipe(Object(m.a)(null), Object(w.a)(this._destroy)).subscribe(() => {
                                this._resetOptions(), this._initializeSelection()
                            })
                        }
                        ngDoCheck() {
                            const t = this._getTriggerAriaLabelledby();
                            if (t !== this._triggerAriaLabelledBy) {
                                const e = this._elementRef.nativeElement;
                                this._triggerAriaLabelledBy = t, t ? e.setAttribute("aria-labelledby", t) : e.removeAttribute("aria-labelledby")
                            }
                            this.ngControl && this.updateErrorState()
                        }
                        ngOnChanges(t) {
                            t.disabled && this.stateChanges.next(), t.typeaheadDebounceInterval && this._keyManager && this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)
                        }
                        ngOnDestroy() {
                            this._destroy.next(), this._destroy.complete(), this.stateChanges.complete()
                        }
                        toggle() {
                            this.panelOpen ? this.close() : this.open()
                        }
                        open() {
                            this._canOpen() && (this._panelOpen = !0, this._keyManager.withHorizontalOrientation(null), this._highlightCorrectOption(), this._changeDetectorRef.markForCheck())
                        }
                        close() {
                            this._panelOpen && (this._panelOpen = !1, this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"), this._changeDetectorRef.markForCheck(), this._onTouched())
                        }
                        writeValue(t) {
                            this.value = t
                        }
                        registerOnChange(t) {
                            this._onChange = t
                        }
                        registerOnTouched(t) {
                            this._onTouched = t
                        }
                        setDisabledState(t) {
                            this.disabled = t, this._changeDetectorRef.markForCheck(), this.stateChanges.next()
                        }
                        get panelOpen() {
                            return this._panelOpen
                        }
                        get selected() {
                            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0]
                        }
                        get triggerValue() {
                            if (this.empty) return "";
                            if (this._multiple) {
                                const t = this._selectionModel.selected.map(t => t.viewValue);
                                return this._isRtl() && t.reverse(), t.join(", ")
                            }
                            return this._selectionModel.selected[0].viewValue
                        }
                        _isRtl() {
                            return !!this._dir && "rtl" === this._dir.value
                        }
                        _handleKeydown(t) {
                            this.disabled || (this.panelOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t))
                        }
                        _handleClosedKeydown(t) {
                            const e = t.keyCode,
                                i = e === d.b || e === d.l || e === d.g || e === d.i,
                                n = e === d.d || e === d.j,
                                s = this._keyManager;
                            if (!s.isTyping() && n && !Object(d.o)(t) || (this.multiple || t.altKey) && i) t.preventDefault(), this.open();
                            else if (!this.multiple) {
                                const e = this.selected;
                                s.onKeydown(t);
                                const i = this.selected;
                                i && e !== i && this._liveAnnouncer.announce(i.viewValue, 1e4)
                            }
                        }
                        _handleOpenKeydown(t) {
                            const e = this._keyManager,
                                i = t.keyCode,
                                n = i === d.b || i === d.l,
                                s = e.isTyping();
                            if (n && t.altKey) t.preventDefault(), this.close();
                            else if (s || i !== d.d && i !== d.j || !e.activeItem || Object(d.o)(t))
                                if (!s && this._multiple && i === d.a && t.ctrlKey) {
                                    t.preventDefault();
                                    const e = this.options.some(t => !t.disabled && !t.selected);
                                    this.options.forEach(t => {
                                        t.disabled || (e ? t.select() : t.deselect())
                                    })
                                } else {
                                    const i = e.activeItemIndex;
                                    e.onKeydown(t), this._multiple && n && t.shiftKey && e.activeItem && e.activeItemIndex !== i && e.activeItem._selectViaInteraction()
                                }
                            else t.preventDefault(), e.activeItem._selectViaInteraction()
                        }
                        _onFocus() {
                            this.disabled || (this._focused = !0, this.stateChanges.next())
                        }
                        _onBlur() {
                            this._focused = !1, this.disabled || this.panelOpen || (this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next())
                        }
                        _onAttached() {
                            this.overlayDir.positionChange.pipe(Object(y.a)(1)).subscribe(() => {
                                this._changeDetectorRef.detectChanges(), this._positioningSettled()
                            })
                        }
                        _getPanelTheme() {
                            return this._parentFormField ? `mat-${this._parentFormField.color}` : ""
                        }
                        get empty() {
                            return !this._selectionModel || this._selectionModel.isEmpty()
                        }
                        _initializeSelection() {
                            Promise.resolve().then(() => {
                                this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value), this.stateChanges.next()
                            })
                        }
                        _setSelectionByValue(t) {
                            if (this._selectionModel.selected.forEach(t => t.setInactiveStyles()), this._selectionModel.clear(), this.multiple && t) Array.isArray(t), t.forEach(t => this._selectValue(t)), this._sortValues();
                            else {
                                const e = this._selectValue(t);
                                e ? this._keyManager.updateActiveItem(e) : this.panelOpen || this._keyManager.updateActiveItem(-1)
                            }
                            this._changeDetectorRef.markForCheck()
                        }
                        _selectValue(t) {
                            const e = this.options.find(e => {
                                if (this._selectionModel.isSelected(e)) return !1;
                                try {
                                    return null != e.value && this._compareWith(e.value, t)
                                } catch (i) {
                                    return !1
                                }
                            });
                            return e && this._selectionModel.select(e), e
                        }
                        _initKeyManager() {
                            this._keyManager = new c.b(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withHomeAndEnd().withAllowedModifierKeys(["shiftKey"]), this._keyManager.tabOut.pipe(Object(w.a)(this._destroy)).subscribe(() => {
                                this.panelOpen && (!this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction(), this.focus(), this.close())
                            }), this._keyManager.change.pipe(Object(w.a)(this._destroy)).subscribe(() => {
                                this._panelOpen && this.panel ? this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0) : this._panelOpen || this.multiple || !this._keyManager.activeItem || this._keyManager.activeItem._selectViaInteraction()
                            })
                        }
                        _resetOptions() {
                            const t = Object(g.a)(this.options.changes, this._destroy);
                            this.optionSelectionChanges.pipe(Object(w.a)(t)).subscribe(t => {
                                this._onSelect(t.source, t.isUserInput), t.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus())
                            }), Object(g.a)(...this.options.map(t => t._stateChanges)).pipe(Object(w.a)(t)).subscribe(() => {
                                this._changeDetectorRef.markForCheck(), this.stateChanges.next()
                            })
                        }
                        _onSelect(t, e) {
                            const i = this._selectionModel.isSelected(t);
                            null != t.value || this._multiple ? (i !== t.selected && (t.selected ? this._selectionModel.select(t) : this._selectionModel.deselect(t)), e && this._keyManager.setActiveItem(t), this.multiple && (this._sortValues(), e && this.focus())) : (t.deselect(), this._selectionModel.clear(), null != this.value && this._propagateChanges(t.value)), i !== this._selectionModel.isSelected(t) && this._propagateChanges(), this.stateChanges.next()
                        }
                        _sortValues() {
                            if (this.multiple) {
                                const t = this.options.toArray();
                                this._selectionModel.sort((e, i) => this.sortComparator ? this.sortComparator(e, i, t) : t.indexOf(e) - t.indexOf(i)), this.stateChanges.next()
                            }
                        }
                        _propagateChanges(t) {
                            let e = null;
                            e = this.multiple ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.valueChange.emit(e), this._onChange(e), this.selectionChange.emit(this._getChangeEvent(e)), this._changeDetectorRef.markForCheck()
                        }
                        _highlightCorrectOption() {
                            this._keyManager && (this.empty ? this._keyManager.setFirstItemActive() : this._keyManager.setActiveItem(this._selectionModel.selected[0]))
                        }
                        _canOpen() {
                            var t;
                            return !this._panelOpen && !this.disabled && (null === (t = this.options) || void 0 === t ? void 0 : t.length) > 0
                        }
                        focus(t) {
                            this._elementRef.nativeElement.focus(t)
                        }
                        _getPanelAriaLabelledby() {
                            var t;
                            if (this.ariaLabel) return null;
                            const e = null === (t = this._parentFormField) || void 0 === t ? void 0 : t.getLabelId();
                            return this.ariaLabelledby ? (e ? e + " " : "") + this.ariaLabelledby : e
                        }
                        _getAriaActiveDescendant() {
                            return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null
                        }
                        _getTriggerAriaLabelledby() {
                            var t;
                            if (this.ariaLabel) return null;
                            const e = null === (t = this._parentFormField) || void 0 === t ? void 0 : t.getLabelId();
                            let i = (e ? e + " " : "") + this._valueId;
                            return this.ariaLabelledby && (i += " " + this.ariaLabelledby), i
                        }
                        _panelDoneAnimating(t) {
                            this.openedChange.emit(t)
                        }
                        setDescribedByIds(t) {
                            this._ariaDescribedby = t.join(" ")
                        }
                        onContainerClick() {
                            this.focus(), this.open()
                        }
                        get shouldLabelFloat() {
                            return this._panelOpen || !this.empty || this._focused && !!this._placeholder
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(l.e), r.Pb(r.h), r.Pb(r.B), r.Pb(a.a), r.Pb(r.l), r.Pb(k.b, 8), r.Pb(S.m, 8), r.Pb(S.f, 8), r.Pb(o.a, 8), r.Pb(S.j, 10), r.ac("tabindex"), r.Pb(F), r.Pb(c.i), r.Pb(N, 8))
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        viewQuery: function(t, e) {
                            if (1 & t && (r.Hc(A, 1), r.Hc(O, 1), r.Hc(n.a, 1)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e.trigger = t.first), r.rc(t = r.dc()) && (e.panel = t.first), r.rc(t = r.dc()) && (e.overlayDir = t.first)
                            }
                        },
                        inputs: {
                            ariaLabel: ["aria-label", "ariaLabel"],
                            id: "id",
                            placeholder: "placeholder",
                            required: "required",
                            multiple: "multiple",
                            disableOptionCentering: "disableOptionCentering",
                            compareWith: "compareWith",
                            value: "value",
                            typeaheadDebounceInterval: "typeaheadDebounceInterval",
                            panelClass: "panelClass",
                            ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
                            errorStateMatcher: "errorStateMatcher",
                            sortComparator: "sortComparator"
                        },
                        outputs: {
                            openedChange: "openedChange",
                            _openedStream: "opened",
                            _closedStream: "closed",
                            selectionChange: "selectionChange",
                            valueChange: "valueChange"
                        },
                        features: [r.Ab, r.Bb]
                    }), t
                })(),
                W = (() => {
                    class t extends X {
                        constructor() {
                            super(...arguments), this._scrollTop = 0, this._triggerFontSize = 0, this._transformOrigin = "top", this._offsetY = 0, this._positions = [{
                                originX: "start",
                                originY: "top",
                                overlayX: "start",
                                overlayY: "top"
                            }, {
                                originX: "start",
                                originY: "bottom",
                                overlayX: "start",
                                overlayY: "bottom"
                            }]
                        }
                        _calculateOverlayScroll(t, e, i) {
                            const n = this._getItemHeight();
                            return Math.min(Math.max(0, n * t - e + n / 2), i)
                        }
                        ngOnInit() {
                            super.ngOnInit(), this._viewportRuler.change().pipe(Object(w.a)(this._destroy)).subscribe(() => {
                                this.panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._changeDetectorRef.markForCheck())
                            })
                        }
                        open() {
                            super._canOpen() && (super.open(), this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || "0"), this._calculateOverlayPosition(), this._ngZone.onStable.pipe(Object(y.a)(1)).subscribe(() => {
                                this._triggerFontSize && this.overlayDir.overlayRef && this.overlayDir.overlayRef.overlayElement && (this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`)
                            }))
                        }
                        _scrollOptionIntoView(t) {
                            const e = Object(a.o)(t, this.options, this.optionGroups),
                                i = this._getItemHeight();
                            this.panel.nativeElement.scrollTop = Object(a.p)((t + e) * i, i, this.panel.nativeElement.scrollTop, 256)
                        }
                        _positioningSettled() {
                            this._calculateOverlayOffsetX(), this.panel.nativeElement.scrollTop = this._scrollTop
                        }
                        _panelDoneAnimating(t) {
                            this.panelOpen ? this._scrollTop = 0 : (this.overlayDir.offsetX = 0, this._changeDetectorRef.markForCheck()), super._panelDoneAnimating(t)
                        }
                        _getChangeEvent(t) {
                            return new V(this, t)
                        }
                        _calculateOverlayOffsetX() {
                            const t = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect(),
                                e = this._viewportRuler.getViewportSize(),
                                i = this._isRtl(),
                                n = this.multiple ? 56 : 32;
                            let s;
                            if (this.multiple) s = 40;
                            else if (this.disableOptionCentering) s = 16;
                            else {
                                let t = this._selectionModel.selected[0] || this.options.first;
                                s = t && t.group ? 32 : 16
                            }
                            i || (s *= -1);
                            const r = 0 - (t.left + s - (i ? n : 0)),
                                a = t.right + s - e.width + (i ? 0 : n);
                            r > 0 ? s += r + 8 : a > 0 && (s -= a + 8), this.overlayDir.offsetX = Math.round(s), this.overlayDir.overlayRef.updatePosition()
                        }
                        _calculateOverlayOffsetY(t, e, i) {
                            const n = this._getItemHeight(),
                                s = (n - this._triggerRect.height) / 2,
                                r = Math.floor(256 / n);
                            let a;
                            return this.disableOptionCentering ? 0 : (a = 0 === this._scrollTop ? t * n : this._scrollTop === i ? (t - (this._getItemCount() - r)) * n + (n - (this._getItemCount() * n - 256) % n) : e - n / 2, Math.round(-1 * a - s))
                        }
                        _checkOverlayWithinViewport(t) {
                            const e = this._getItemHeight(),
                                i = this._viewportRuler.getViewportSize(),
                                n = this._triggerRect.top - 8,
                                s = i.height - this._triggerRect.bottom - 8,
                                r = Math.abs(this._offsetY),
                                a = Math.min(this._getItemCount() * e, 256) - r - this._triggerRect.height;
                            a > s ? this._adjustPanelUp(a, s) : r > n ? this._adjustPanelDown(r, n, t) : this._transformOrigin = this._getOriginBasedOnOption()
                        }
                        _adjustPanelUp(t, e) {
                            const i = Math.round(t - e);
                            this._scrollTop -= i, this._offsetY -= i, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop <= 0 && (this._scrollTop = 0, this._offsetY = 0, this._transformOrigin = "50% bottom 0px")
                        }
                        _adjustPanelDown(t, e, i) {
                            const n = Math.round(t - e);
                            if (this._scrollTop += n, this._offsetY += n, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop >= i) return this._scrollTop = i, this._offsetY = 0, void(this._transformOrigin = "50% top 0px")
                        }
                        _calculateOverlayPosition() {
                            const t = this._getItemHeight(),
                                e = this._getItemCount(),
                                i = Math.min(e * t, 256),
                                n = e * t - i;
                            let s;
                            s = this.empty ? 0 : Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]), 0), s += Object(a.o)(s, this.options, this.optionGroups);
                            const r = i / 2;
                            this._scrollTop = this._calculateOverlayScroll(s, r, n), this._offsetY = this._calculateOverlayOffsetY(s, r, n), this._checkOverlayWithinViewport(n)
                        }
                        _getOriginBasedOnOption() {
                            const t = this._getItemHeight(),
                                e = (t - this._triggerRect.height) / 2;
                            return `50% ${Math.abs(this._offsetY)-e+t/2}px 0px`
                        }
                        _getItemHeight() {
                            return 3 * this._triggerFontSize
                        }
                        _getItemCount() {
                            return this.options.length + this.optionGroups.length
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return Y(e || t)
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["mat-select"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (r.Ib(i, U, 1), r.Ib(i, a.h, 1), r.Ib(i, a.b, 1)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e.customTrigger = t.first), r.rc(t = r.dc()) && (e.options = t), r.rc(t = r.dc()) && (e.optionGroups = t)
                            }
                        },
                        hostAttrs: ["role", "combobox", "aria-autocomplete", "none", "aria-haspopup", "true", 1, "mat-select"],
                        hostVars: 20,
                        hostBindings: function(t, e) {
                            1 & t && r.cc("keydown", function(t) {
                                return e._handleKeydown(t)
                            })("focus", function() {
                                return e._onFocus()
                            })("blur", function() {
                                return e._onBlur()
                            }), 2 & t && (r.Eb("id", e.id)("tabindex", e.tabIndex)("aria-controls", e.panelOpen ? e.id + "-panel" : null)("aria-expanded", e.panelOpen)("aria-label", e.ariaLabel || null)("aria-required", e.required.toString())("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-describedby", e._ariaDescribedby || null)("aria-activedescendant", e._getAriaActiveDescendant()), r.Hb("mat-select-disabled", e.disabled)("mat-select-invalid", e.errorState)("mat-select-required", e.required)("mat-select-empty", e.empty)("mat-select-multiple", e.multiple))
                        },
                        inputs: {
                            disabled: "disabled",
                            disableRipple: "disableRipple",
                            tabIndex: "tabIndex"
                        },
                        exportAs: ["matSelect"],
                        features: [r.Cb([{
                            provide: o.c,
                            useExisting: t
                        }, {
                            provide: a.c,
                            useExisting: t
                        }]), r.Ab],
                        ngContentSelectors: L,
                        decls: 9,
                        vars: 12,
                        consts: [
                            ["cdk-overlay-origin", "", 1, "mat-select-trigger", 3, "click"],
                            ["origin", "cdkOverlayOrigin", "trigger", ""],
                            [1, "mat-select-value", 3, "ngSwitch"],
                            ["class", "mat-select-placeholder mat-select-min-line", 4, "ngSwitchCase"],
                            ["class", "mat-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"],
                            [1, "mat-select-arrow-wrapper"],
                            [1, "mat-select-arrow"],
                            ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOffsetY", "backdropClick", "attach", "detach"],
                            [1, "mat-select-placeholder", "mat-select-min-line"],
                            [1, "mat-select-value-text", 3, "ngSwitch"],
                            ["class", "mat-select-min-line", 4, "ngSwitchDefault"],
                            [4, "ngSwitchCase"],
                            [1, "mat-select-min-line"],
                            [1, "mat-select-panel-wrap"],
                            ["role", "listbox", "tabindex", "-1", 3, "ngClass", "keydown"],
                            ["panel", ""]
                        ],
                        template: function(t, e) {
                            if (1 & t && (r.kc(M), r.Vb(0, "div", 0, 1), r.cc("click", function() {
                                    return e.toggle()
                                }), r.Vb(3, "div", 2), r.Bc(4, E, 2, 1, "span", 3), r.Bc(5, D, 3, 2, "span", 4), r.Ub(), r.Vb(6, "div", 5), r.Qb(7, "div", 6), r.Ub(), r.Ub(), r.Bc(8, I, 4, 14, "ng-template", 7), r.cc("backdropClick", function() {
                                    return e.close()
                                })("attach", function() {
                                    return e._onAttached()
                                })("detach", function() {
                                    return e.close()
                                })), 2 & t) {
                                const t = r.sc(1);
                                r.Eb("aria-owns", e.panelOpen ? e.id + "-panel" : null), r.Db(3), r.lc("ngSwitch", e.empty), r.Eb("id", e._valueId), r.Db(1), r.lc("ngSwitchCase", !0), r.Db(1), r.lc("ngSwitchCase", !1), r.Db(3), r.lc("cdkConnectedOverlayPanelClass", e._overlayPanelClass)("cdkConnectedOverlayScrollStrategy", e._scrollStrategy)("cdkConnectedOverlayOrigin", t)("cdkConnectedOverlayOpen", e.panelOpen)("cdkConnectedOverlayPositions", e._positions)("cdkConnectedOverlayMinWidth", null == e._triggerRect ? null : e._triggerRect.width)("cdkConnectedOverlayOffsetY", e._offsetY)
                            }
                        },
                        directives: [n.b, s.n, s.o, n.a, s.p, s.j],
                        styles: ['.mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:" ";white-space:pre;width:1px}\n'],
                        encapsulation: 2,
                        data: {
                            animation: [R.transformPanelWrap, R.transformPanel]
                        },
                        changeDetection: 0
                    }), t
                })();
            const Y = r.Xb(W);
            let G = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = r.Nb({
                    type: t
                }), t.\u0275inj = r.Mb({
                    providers: [z],
                    imports: [
                        [s.c, n.e, a.i, a.e], l.b, o.d, a.i, a.e
                    ]
                }), t
            })()
        },
        dLTe: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("EPzc"),
                s = i("xt23");

            function r(t, e) {
                return Object(n.b)((i, n) => {
                    let r = 0;
                    i.subscribe(new s.a(n, i => t.call(e, i, r++) && n.next(i)))
                })
            }
        },
        eX4W: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = new(i("SIQg").a)(t => t.complete())
        },
        fXoL: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return ri
            }), i.d(e, "b", function() {
                return Jl
            }), i.d(e, "c", function() {
                return ql
            }), i.d(e, "d", function() {
                return Yl
            }), i.d(e, "e", function() {
                return Gl
            }), i.d(e, "f", function() {
                return qc
            }), i.d(e, "g", function() {
                return jc
            }), i.d(e, "h", function() {
                return Uo
            }), i.d(e, "i", function() {
                return hc
            }), i.d(e, "j", function() {
                return po
            }), i.d(e, "k", function() {
                return ic
            }), i.d(e, "l", function() {
                return bo
            }), i.d(e, "m", function() {
                return Xc
            }), i.d(e, "n", function() {
                return kn
            }), i.d(e, "o", function() {
                return Al
            }), i.d(e, "p", function() {
                return dr
            }), i.d(e, "q", function() {
                return Si
            }), i.d(e, "r", function() {
                return P
            }), i.d(e, "s", function() {
                return si
            }), i.d(e, "t", function() {
                return Er
            }), i.d(e, "u", function() {
                return jo
            }), i.d(e, "v", function() {
                return No
            }), i.d(e, "w", function() {
                return ec
            }), i.d(e, "x", function() {
                return tl
            }), i.d(e, "y", function() {
                return Nc
            }), i.d(e, "z", function() {
                return Jo
            }), i.d(e, "A", function() {
                return Dc
            }), i.d(e, "B", function() {
                return pc
            }), i.d(e, "C", function() {
                return Ai
            }), i.d(e, "D", function() {
                return Kl
            }), i.d(e, "E", function() {
                return Ql
            }), i.d(e, "F", function() {
                return El
            }), i.d(e, "G", function() {
                return xo
            }), i.d(e, "H", function() {
                return vo
            }), i.d(e, "I", function() {
                return Pn
            }), i.d(e, "J", function() {
                return wo
            }), i.d(e, "K", function() {
                return bn
            }), i.d(e, "L", function() {
                return Oi
            }), i.d(e, "M", function() {
                return Ei
            }), i.d(e, "N", function() {
                return Bc
            }), i.d(e, "O", function() {
                return Zo
            }), i.d(e, "P", function() {
                return xc
            }), i.d(e, "Q", function() {
                return ai
            }), i.d(e, "R", function() {
                return Co
            }), i.d(e, "S", function() {
                return il
            }), i.d(e, "T", function() {
                return R
            }), i.d(e, "U", function() {
                return Ic
            }), i.d(e, "V", function() {
                return Pc
            }), i.d(e, "W", function() {
                return p
            }), i.d(e, "X", function() {
                return wi
            }), i.d(e, "Y", function() {
                return Ec
            }), i.d(e, "Z", function() {
                return Yc
            }), i.d(e, "ab", function() {
                return Cc
            }), i.d(e, "bb", function() {
                return tc
            }), i.d(e, "cb", function() {
                return fr
            }), i.d(e, "db", function() {
                return Ja
            }), i.d(e, "eb", function() {
                return gn
            }), i.d(e, "fb", function() {
                return Qi
            }), i.d(e, "gb", function() {
                return Vi
            }), i.d(e, "hb", function() {
                return Hi
            }), i.d(e, "ib", function() {
                return Yi
            }), i.d(e, "jb", function() {
                return Xi
            }), i.d(e, "kb", function() {
                return Ui
            }), i.d(e, "lb", function() {
                return Wi
            }), i.d(e, "mb", function() {
                return Za
            }), i.d(e, "nb", function() {
                return Wc
            }), i.d(e, "ob", function() {
                return $a
            }), i.d(e, "pb", function() {
                return Qa
            }), i.d(e, "qb", function() {
                return Bi
            }), i.d(e, "rb", function() {
                return V
            }), i.d(e, "sb", function() {
                return Nr
            }), i.d(e, "tb", function() {
                return ra
            }), i.d(e, "ub", function() {
                return na
            }), i.d(e, "vb", function() {
                return sa
            }), i.d(e, "wb", function() {
                return qa
            }), i.d(e, "xb", function() {
                return Ct
            }), i.d(e, "yb", function() {
                return h
            }), i.d(e, "zb", function() {
                return zi
            }), i.d(e, "Ab", function() {
                return Tr
            }), i.d(e, "Bb", function() {
                return bt
            }), i.d(e, "Cb", function() {
                return co
            }), i.d(e, "Db", function() {
                return gs
            }), i.d(e, "Eb", function() {
                return Ur
            }), i.d(e, "Fb", function() {
                return Sa
            }), i.d(e, "Gb", function() {
                return Ha
            }), i.d(e, "Hb", function() {
                return ka
            }), i.d(e, "Ib", function() {
                return Vl
            }), i.d(e, "Jb", function() {
                return K
            }), i.d(e, "Kb", function() {
                return rt
            }), i.d(e, "Lb", function() {
                return x
            }), i.d(e, "Mb", function() {
                return _
            }), i.d(e, "Nb", function() {
                return it
            }), i.d(e, "Ob", function() {
                return at
            }), i.d(e, "Pb", function() {
                return Gr
            }), i.d(e, "Qb", function() {
                return Kr
            }), i.d(e, "Rb", function() {
                return ea
            }), i.d(e, "Sb", function() {
                return ta
            }), i.d(e, "Tb", function() {
                return Jr
            }), i.d(e, "Ub", function() {
                return Qr
            }), i.d(e, "Vb", function() {
                return $r
            }), i.d(e, "Wb", function() {
                return ia
            }), i.d(e, "Xb", function() {
                return ti
            }), i.d(e, "Yb", function() {
                return Ua
            }), i.d(e, "Zb", function() {
                return _i
            }), i.d(e, "ac", function() {
                return ii
            }), i.d(e, "bc", function() {
                return Wl
            }), i.d(e, "cc", function() {
                return aa
            }), i.d(e, "dc", function() {
                return Bl
            }), i.d(e, "ec", function() {
                return ve
            }), i.d(e, "fc", function() {
                return ye
            }), i.d(e, "gc", function() {
                return ua
            }), i.d(e, "hc", function() {
                return Cl
            }), i.d(e, "ic", function() {
                return kl
            }), i.d(e, "jc", function() {
                return fa
            }), i.d(e, "kc", function() {
                return pa
            }), i.d(e, "lc", function() {
                return qr
            }), i.d(e, "mc", function() {
                return ga
            }), i.d(e, "nc", function() {
                return bl
            }), i.d(e, "oc", function() {
                return yl
            }), i.d(e, "pc", function() {
                return vl
            }), i.d(e, "qc", function() {
                return xl
            }), i.d(e, "rc", function() {
                return Nl
            }), i.d(e, "sc", function() {
                return Yr
            }), i.d(e, "tc", function() {
                return On
            }), i.d(e, "uc", function() {
                return Ut
            }), i.d(e, "vc", function() {
                return yn
            }), i.d(e, "wc", function() {
                return vn
            }), i.d(e, "xc", function() {
                return nt
            }), i.d(e, "yc", function() {
                return Ca
            }), i.d(e, "zc", function() {
                return oa
            }), i.d(e, "Ac", function() {
                return Xa
            }), i.d(e, "Bc", function() {
                return Wr
            }), i.d(e, "Cc", function() {
                return Fa
            }), i.d(e, "Dc", function() {
                return Na
            }), i.d(e, "Ec", function() {
                return za
            }), i.d(e, "Fc", function() {
                return Va
            }), i.d(e, "Gc", function() {
                return Ba
            }), i.d(e, "Hc", function() {
                return zl
            });
            var n = i("oXA7"),
                s = i("jqqC"),
                r = i("SIQg"),
                a = i("2btn"),
                o = i("Qd51");

            function l(t) {
                for (let e in t)
                    if (t[e] === l) return e;
                throw Error("Could not find renamed property on target object.")
            }

            function c(t, e) {
                for (const i in e) e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i])
            }

            function h(t) {
                if ("string" == typeof t) return t;
                if (Array.isArray(t)) return "[" + t.map(h).join(", ") + "]";
                if (null == t) return "" + t;
                if (t.overriddenName) return `${t.overriddenName}`;
                if (t.name) return `${t.name}`;
                const e = t.toString();
                if (null == e) return "" + e;
                const i = e.indexOf("\n");
                return -1 === i ? e : e.substring(0, i)
            }

            function u(t, e) {
                return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e
            }
            const d = l({
                __forward_ref__: l
            });

            function p(t) {
                return t.__forward_ref__ = p, t.toString = function() {
                    return h(this())
                }, t
            }

            function f(t) {
                return g(t) ? t() : t
            }

            function g(t) {
                return "function" == typeof t && t.hasOwnProperty(d) && t.__forward_ref__ === p
            }
            class m extends Error {
                constructor(t, e) {
                    super(function(t, e) {
                        return `${t?`NG0${t}: `:""}${e}`
                    }(t, e)), this.code = t
                }
            }

            function b(t) {
                return "string" == typeof t ? t : null == t ? "" : String(t)
            }

            function y(t) {
                return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : b(t)
            }

            function v(t, e) {
                const i = e ? ` in ${e}` : "";
                throw new m("201", `No provider for ${y(t)} found${i}`)
            }

            function x(t) {
                return {
                    token: t.token,
                    providedIn: t.providedIn || null,
                    factory: t.factory,
                    value: void 0
                }
            }

            function _(t) {
                return {
                    providers: t.providers || [],
                    imports: t.imports || []
                }
            }

            function w(t) {
                return C(t, S) || C(t, O)
            }

            function C(t, e) {
                return t.hasOwnProperty(e) ? t[e] : null
            }

            function k(t) {
                return t && (t.hasOwnProperty(A) || t.hasOwnProperty(E)) ? t[A] : null
            }
            const S = l({
                    "\u0275prov": l
                }),
                A = l({
                    "\u0275inj": l
                }),
                O = l({
                    ngInjectableDef: l
                }),
                E = l({
                    ngInjectorDef: l
                });
            var P = function(t) {
                return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t
            }({});
            let T;

            function D(t) {
                const e = T;
                return T = t, e
            }

            function I(t, e, i) {
                const n = w(t);
                return n && "root" == n.providedIn ? void 0 === n.value ? n.value = n.factory() : n.value : i & P.Optional ? null : void 0 !== e ? e : void v(h(t), "Injector")
            }

            function M(t) {
                return {
                    toString: t
                }.toString()
            }
            var L = function(t) {
                    return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t
                }({}),
                R = function(t) {
                    return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t
                }({});
            const j = "undefined" != typeof globalThis && globalThis,
                F = "undefined" != typeof window && window,
                N = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
                z = "undefined" != typeof global && global,
                V = j || z || F || N,
                B = {},
                H = [],
                U = [],
                X = l({
                    "\u0275cmp": l
                }),
                W = l({
                    "\u0275dir": l
                }),
                Y = l({
                    "\u0275pipe": l
                }),
                G = l({
                    "\u0275mod": l
                }),
                q = l({
                    "\u0275loc": l
                }),
                Z = l({
                    "\u0275fac": l
                }),
                $ = l({
                    __NG_ELEMENT_ID__: l
                });
            let Q = 0;

            function K(t) {
                return M(() => {
                    const e = {},
                        i = {
                            type: t.type,
                            providersResolver: null,
                            decls: t.decls,
                            vars: t.vars,
                            factory: null,
                            template: t.template || null,
                            consts: t.consts || null,
                            ngContentSelectors: t.ngContentSelectors,
                            hostBindings: t.hostBindings || null,
                            hostVars: t.hostVars || 0,
                            hostAttrs: t.hostAttrs || null,
                            contentQueries: t.contentQueries || null,
                            declaredInputs: e,
                            inputs: null,
                            outputs: null,
                            exportAs: t.exportAs || null,
                            onPush: t.changeDetection === L.OnPush,
                            directiveDefs: null,
                            pipeDefs: null,
                            selectors: t.selectors || U,
                            viewQuery: t.viewQuery || null,
                            features: t.features || null,
                            data: t.data || {},
                            encapsulation: t.encapsulation || R.Emulated,
                            id: "c",
                            styles: t.styles || U,
                            _: null,
                            setInput: null,
                            schemas: t.schemas || null,
                            tView: null
                        },
                        n = t.directives,
                        s = t.features,
                        r = t.pipes;
                    return i.id += Q++, i.inputs = st(t.inputs, e), i.outputs = st(t.outputs), s && s.forEach(t => t(i)), i.directiveDefs = n ? () => ("function" == typeof n ? n() : n).map(J) : null, i.pipeDefs = r ? () => ("function" == typeof r ? r() : r).map(tt) : null, i
                })
            }

            function J(t) {
                return ot(t) || function(t) {
                    return t[W] || null
                }(t)
            }

            function tt(t) {
                return function(t) {
                    return t[Y] || null
                }(t)
            }
            const et = {};

            function it(t) {
                const e = {
                    type: t.type,
                    bootstrap: t.bootstrap || U,
                    declarations: t.declarations || U,
                    imports: t.imports || U,
                    exports: t.exports || U,
                    transitiveCompileScopes: null,
                    schemas: t.schemas || null,
                    id: t.id || null
                };
                return null != t.id && M(() => {
                    et[t.id] = t.type
                }), e
            }

            function nt(t, e) {
                return M(() => {
                    const i = lt(t, !0);
                    i.declarations = e.declarations || U, i.imports = e.imports || U, i.exports = e.exports || U
                })
            }

            function st(t, e) {
                if (null == t) return B;
                const i = {};
                for (const n in t)
                    if (t.hasOwnProperty(n)) {
                        let s = t[n],
                            r = s;
                        Array.isArray(s) && (r = s[1], s = s[0]), i[s] = n, e && (e[s] = r)
                    } return i
            }
            const rt = K;

            function at(t) {
                return {
                    type: t.type,
                    name: t.name,
                    factory: null,
                    pure: !1 !== t.pure,
                    onDestroy: t.type.prototype.ngOnDestroy || null
                }
            }

            function ot(t) {
                return t[X] || null
            }

            function lt(t, e) {
                const i = t[G] || null;
                if (!i && !0 === e) throw new Error(`Type ${h(t)} does not have '\u0275mod' property.`);
                return i
            }

            function ct(t) {
                return Array.isArray(t) && "object" == typeof t[1]
            }

            function ht(t) {
                return Array.isArray(t) && !0 === t[1]
            }

            function ut(t) {
                return 0 != (8 & t.flags)
            }

            function dt(t) {
                return 2 == (2 & t.flags)
            }

            function pt(t) {
                return 1 == (1 & t.flags)
            }

            function ft(t) {
                return null !== t.template
            }

            function gt(t, e) {
                return t.hasOwnProperty(Z) ? t[Z] : null
            }
            class mt {
                constructor(t, e, i) {
                    this.previousValue = t, this.currentValue = e, this.firstChange = i
                }
                isFirstChange() {
                    return this.firstChange
                }
            }

            function bt() {
                return yt
            }

            function yt(t) {
                return t.type.prototype.ngOnChanges && (t.setInput = xt), vt
            }

            function vt() {
                const t = _t(this),
                    e = null == t ? void 0 : t.current;
                if (e) {
                    const i = t.previous;
                    if (i === B) t.previous = e;
                    else
                        for (let t in e) i[t] = e[t];
                    t.current = null, this.ngOnChanges(e)
                }
            }

            function xt(t, e, i, n) {
                const s = _t(t) || function(t, e) {
                        return t.__ngSimpleChanges__ = e
                    }(t, {
                        previous: B,
                        current: null
                    }),
                    r = s.current || (s.current = {}),
                    a = s.previous,
                    o = this.declaredInputs[i],
                    l = a[o];
                r[o] = new mt(l && l.currentValue, e, a === B), t[n] = e
            }

            function _t(t) {
                return t.__ngSimpleChanges__ || null
            }
            let wt;

            function Ct(t) {
                wt = t
            }

            function kt() {
                return void 0 !== wt ? wt : "undefined" != typeof document ? document : void 0
            }

            function St(t) {
                return !!t.listen
            }
            bt.ngInherit = !0;
            const At = {
                createRenderer: (t, e) => kt()
            };

            function Ot(t) {
                for (; Array.isArray(t);) t = t[0];
                return t
            }

            function Et(t, e) {
                return Ot(e[t])
            }

            function Pt(t, e) {
                return Ot(e[t.index])
            }

            function Tt(t, e) {
                return t.data[e]
            }

            function Dt(t, e) {
                return t[e]
            }

            function It(t, e) {
                const i = e[t];
                return ct(i) ? i : i[0]
            }

            function Mt(t) {
                const e = function(t) {
                    return t.__ngContext__ || null
                }(t);
                return e ? Array.isArray(e) ? e : e.lView : null
            }

            function Lt(t) {
                return 4 == (4 & t[2])
            }

            function Rt(t) {
                return 128 == (128 & t[2])
            }

            function jt(t, e) {
                return null == e ? null : t[e]
            }

            function Ft(t) {
                t[18] = 0
            }

            function Nt(t, e) {
                t[5] += e;
                let i = t,
                    n = t[3];
                for (; null !== n && (1 === e && 1 === i[5] || -1 === e && 0 === i[5]);) n[5] += e, i = n, n = n[3]
            }
            const zt = {
                lFrame: ue(null),
                bindingsEnabled: !0,
                isInCheckNoChangesMode: !1
            };

            function Vt() {
                return zt.bindingsEnabled
            }

            function Bt() {
                return zt.lFrame.lView
            }

            function Ht() {
                return zt.lFrame.tView
            }

            function Ut(t) {
                zt.lFrame.contextLView = t
            }

            function Xt() {
                let t = Wt();
                for (; null !== t && 64 === t.type;) t = t.parent;
                return t
            }

            function Wt() {
                return zt.lFrame.currentTNode
            }

            function Yt(t, e) {
                const i = zt.lFrame;
                i.currentTNode = t, i.isParent = e
            }

            function Gt() {
                return zt.lFrame.isParent
            }

            function qt() {
                zt.lFrame.isParent = !1
            }

            function Zt() {
                return zt.isInCheckNoChangesMode
            }

            function $t(t) {
                zt.isInCheckNoChangesMode = t
            }

            function Qt() {
                const t = zt.lFrame;
                let e = t.bindingRootIndex;
                return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e
            }

            function Kt() {
                return zt.lFrame.bindingIndex
            }

            function Jt(t) {
                return zt.lFrame.bindingIndex = t
            }

            function te() {
                return zt.lFrame.bindingIndex++
            }

            function ee(t) {
                const e = zt.lFrame,
                    i = e.bindingIndex;
                return e.bindingIndex = e.bindingIndex + t, i
            }

            function ie(t, e) {
                const i = zt.lFrame;
                i.bindingIndex = i.bindingRootIndex = t, ne(e)
            }

            function ne(t) {
                zt.lFrame.currentDirectiveIndex = t
            }

            function se(t) {
                const e = zt.lFrame.currentDirectiveIndex;
                return -1 === e ? null : t[e]
            }

            function re() {
                return zt.lFrame.currentQueryIndex
            }

            function ae(t) {
                zt.lFrame.currentQueryIndex = t
            }

            function oe(t) {
                const e = t[1];
                return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null
            }

            function le(t, e, i) {
                if (i & P.SkipSelf) {
                    let n = e,
                        s = t;
                    for (; n = n.parent, !(null !== n || i & P.Host || (n = oe(s), null === n) || (s = s[15], 10 & n.type)););
                    if (null === n) return !1;
                    e = n, t = s
                }
                const n = zt.lFrame = he();
                return n.currentTNode = e, n.lView = t, !0
            }

            function ce(t) {
                const e = he(),
                    i = t[1];
                zt.lFrame = e, e.currentTNode = i.firstChild, e.lView = t, e.tView = i, e.contextLView = t, e.bindingIndex = i.bindingStartIndex, e.inI18n = !1
            }

            function he() {
                const t = zt.lFrame,
                    e = null === t ? null : t.child;
                return null === e ? ue(t) : e
            }

            function ue(t) {
                const e = {
                    currentTNode: null,
                    isParent: !0,
                    lView: null,
                    tView: null,
                    selectedIndex: -1,
                    contextLView: null,
                    elementDepthCount: 0,
                    currentNamespace: null,
                    currentDirectiveIndex: -1,
                    bindingRootIndex: -1,
                    bindingIndex: -1,
                    currentQueryIndex: 0,
                    parent: t,
                    child: null,
                    inI18n: !1
                };
                return null !== t && (t.child = e), e
            }

            function de() {
                const t = zt.lFrame;
                return zt.lFrame = t.parent, t.currentTNode = null, t.lView = null, t
            }
            const pe = de;

            function fe() {
                const t = de();
                t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0
            }

            function ge() {
                return zt.lFrame.selectedIndex
            }

            function me(t) {
                zt.lFrame.selectedIndex = t
            }

            function be() {
                const t = zt.lFrame;
                return Tt(t.tView, t.selectedIndex)
            }

            function ye() {
                zt.lFrame.currentNamespace = "http://www.w3.org/2000/svg"
            }

            function ve() {
                zt.lFrame.currentNamespace = null
            }

            function xe(t, e) {
                for (let i = e.directiveStart, n = e.directiveEnd; i < n; i++) {
                    const e = t.data[i].type.prototype,
                        {
                            ngAfterContentInit: n,
                            ngAfterContentChecked: s,
                            ngAfterViewInit: r,
                            ngAfterViewChecked: a,
                            ngOnDestroy: o
                        } = e;
                    n && (t.contentHooks || (t.contentHooks = [])).push(-i, n), s && ((t.contentHooks || (t.contentHooks = [])).push(i, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(i, s)), r && (t.viewHooks || (t.viewHooks = [])).push(-i, r), a && ((t.viewHooks || (t.viewHooks = [])).push(i, a), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(i, a)), null != o && (t.destroyHooks || (t.destroyHooks = [])).push(i, o)
                }
            }

            function _e(t, e, i) {
                ke(t, e, 3, i)
            }

            function we(t, e, i, n) {
                (3 & t[2]) === i && ke(t, e, i, n)
            }

            function Ce(t, e) {
                let i = t[2];
                (3 & i) === e && (i &= 2047, i += 1, t[2] = i)
            }

            function ke(t, e, i, n) {
                const s = null != n ? n : -1,
                    r = e.length - 1;
                let a = 0;
                for (let o = void 0 !== n ? 65535 & t[18] : 0; o < r; o++)
                    if ("number" == typeof e[o + 1]) {
                        if (a = e[o], null != n && a >= n) break
                    } else e[o] < 0 && (t[18] += 65536), (a < s || -1 == s) && (Se(t, i, e, o), t[18] = (4294901760 & t[18]) + o + 2), o++
            }

            function Se(t, e, i, n) {
                const s = i[n] < 0,
                    r = i[n + 1],
                    a = t[s ? -i[n] : i[n]];
                if (s) {
                    if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) {
                        t[2] += 2048;
                        try {
                            r.call(a)
                        } finally {}
                    }
                } else try {
                    r.call(a)
                } finally {}
            }
            class Ae {
                constructor(t, e, i) {
                    this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i
                }
            }

            function Oe(t, e, i) {
                const n = St(t);
                let s = 0;
                for (; s < i.length;) {
                    const r = i[s];
                    if ("number" == typeof r) {
                        if (0 !== r) break;
                        s++;
                        const a = i[s++],
                            o = i[s++],
                            l = i[s++];
                        n ? t.setAttribute(e, o, l, a) : e.setAttributeNS(a, o, l)
                    } else {
                        const a = r,
                            o = i[++s];
                        Pe(a) ? n && t.setProperty(e, a, o) : n ? t.setAttribute(e, a, o) : e.setAttribute(a, o), s++
                    }
                }
                return s
            }

            function Ee(t) {
                return 3 === t || 4 === t || 6 === t
            }

            function Pe(t) {
                return 64 === t.charCodeAt(0)
            }

            function Te(t, e) {
                if (null === e || 0 === e.length);
                else if (null === t || 0 === t.length) t = e.slice();
                else {
                    let i = -1;
                    for (let n = 0; n < e.length; n++) {
                        const s = e[n];
                        "number" == typeof s ? i = s : 0 === i || De(t, i, s, null, -1 === i || 2 === i ? e[++n] : null)
                    }
                }
                return t
            }

            function De(t, e, i, n, s) {
                let r = 0,
                    a = t.length;
                if (-1 === e) a = -1;
                else
                    for (; r < t.length;) {
                        const i = t[r++];
                        if ("number" == typeof i) {
                            if (i === e) {
                                a = -1;
                                break
                            }
                            if (i > e) {
                                a = r - 1;
                                break
                            }
                        }
                    }
                for (; r < t.length;) {
                    const e = t[r];
                    if ("number" == typeof e) break;
                    if (e === i) {
                        if (null === n) return void(null !== s && (t[r + 1] = s));
                        if (n === t[r + 1]) return void(t[r + 2] = s)
                    }
                    r++, null !== n && r++, null !== s && r++
                } - 1 !== a && (t.splice(a, 0, e), r = a + 1), t.splice(r++, 0, i), null !== n && t.splice(r++, 0, n), null !== s && t.splice(r++, 0, s)
            }

            function Ie(t) {
                return -1 !== t
            }

            function Me(t) {
                return 32767 & t
            }

            function Le(t, e) {
                let i = t >> 16,
                    n = e;
                for (; i > 0;) n = n[15], i--;
                return n
            }
            let Re = !0;

            function je(t) {
                const e = Re;
                return Re = t, e
            }
            let Fe = 0;

            function Ne(t, e) {
                const i = Ve(t, e);
                if (-1 !== i) return i;
                const n = e[1];
                n.firstCreatePass && (t.injectorIndex = e.length, ze(n.data, t), ze(e, null), ze(n.blueprint, null));
                const s = Be(t, e),
                    r = t.injectorIndex;
                if (Ie(s)) {
                    const t = Me(s),
                        i = Le(s, e),
                        n = i[1].data;
                    for (let s = 0; s < 8; s++) e[r + s] = i[t + s] | n[t + s]
                }
                return e[r + 8] = s, r
            }

            function ze(t, e) {
                t.push(0, 0, 0, 0, 0, 0, 0, 0, e)
            }

            function Ve(t, e) {
                return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex
            }

            function Be(t, e) {
                if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex;
                let i = 0,
                    n = null,
                    s = e;
                for (; null !== s;) {
                    const t = s[1],
                        e = t.type;
                    if (n = 2 === e ? t.declTNode : 1 === e ? s[6] : null, null === n) return -1;
                    if (i++, s = s[15], -1 !== n.injectorIndex) return n.injectorIndex | i << 16
                }
                return -1
            }

            function He(t, e, i) {
                ! function(t, e, i) {
                    let n;
                    "string" == typeof i ? n = i.charCodeAt(0) || 0 : i.hasOwnProperty($) && (n = i[$]), null == n && (n = i[$] = Fe++);
                    const s = 255 & n;
                    e.data[t + (s >> 5)] |= 1 << s
                }(t, e, i)
            }

            function Ue(t, e, i) {
                if (i & P.Optional) return t;
                v(e, "NodeInjector")
            }

            function Xe(t, e, i, n) {
                if (i & P.Optional && void 0 === n && (n = null), 0 == (i & (P.Self | P.Host))) {
                    const s = t[9],
                        r = D(void 0);
                    try {
                        return s ? s.get(e, n, i & P.Optional) : I(e, n, i & P.Optional)
                    } finally {
                        D(r)
                    }
                }
                return Ue(n, e, i)
            }

            function We(t, e, i, n = P.Default, s) {
                if (null !== t) {
                    const r = function(t) {
                        if ("string" == typeof t) return t.charCodeAt(0) || 0;
                        const e = t.hasOwnProperty($) ? t[$] : void 0;
                        return "number" == typeof e ? e >= 0 ? 255 & e : Ge : e
                    }(i);
                    if ("function" == typeof r) {
                        if (!le(e, t, n)) return n & P.Host ? Ue(s, i, n) : Xe(e, i, n, s);
                        try {
                            const t = r();
                            if (null != t || n & P.Optional) return t;
                            v(i)
                        } finally {
                            pe()
                        }
                    } else if ("number" == typeof r) {
                        let s = null,
                            a = Ve(t, e),
                            o = -1,
                            l = n & P.Host ? e[16][6] : null;
                        for ((-1 === a || n & P.SkipSelf) && (o = -1 === a ? Be(t, e) : e[a + 8], -1 !== o && Ke(n, !1) ? (s = e[1], a = Me(o), e = Le(o, e)) : a = -1); - 1 !== a;) {
                            const t = e[1];
                            if (Qe(r, a, t.data)) {
                                const t = qe(a, e, i, s, n, l);
                                if (t !== Ye) return t
                            }
                            o = e[a + 8], -1 !== o && Ke(n, e[1].data[a + 8] === l) && Qe(r, a, e) ? (s = t, a = Me(o), e = Le(o, e)) : a = -1
                        }
                    }
                }
                return Xe(e, i, n, s)
            }
            const Ye = {};

            function Ge() {
                return new Je(Xt(), Bt())
            }

            function qe(t, e, i, n, s, r) {
                const a = e[1],
                    o = a.data[t + 8],
                    l = Ze(o, a, i, null == n ? dt(o) && Re : n != a && 0 != (3 & o.type), s & P.Host && r === o);
                return null !== l ? $e(e, a, l, o) : Ye
            }

            function Ze(t, e, i, n, s) {
                const r = t.providerIndexes,
                    a = e.data,
                    o = 1048575 & r,
                    l = t.directiveStart,
                    c = r >> 20,
                    h = s ? o + c : t.directiveEnd;
                for (let u = n ? o : o + c; u < h; u++) {
                    const t = a[u];
                    if (u < l && i === t || u >= l && t.type === i) return u
                }
                if (s) {
                    const t = a[l];
                    if (t && ft(t) && t.type === i) return l
                }
                return null
            }

            function $e(t, e, i, n) {
                let s = t[i];
                const r = e.data;
                if (s instanceof Ae) {
                    const a = s;
                    a.resolving && function(t, e) {
                        throw new m("200", `Circular dependency in DI detected for ${t}`)
                    }(y(r[i]));
                    const o = je(a.canSeeViewProviders);
                    a.resolving = !0;
                    const l = a.injectImpl ? D(a.injectImpl) : null;
                    le(t, n, P.Default);
                    try {
                        s = t[i] = a.factory(void 0, r, t, n), e.firstCreatePass && i >= n.directiveStart && function(t, e, i) {
                            const {
                                ngOnChanges: n,
                                ngOnInit: s,
                                ngDoCheck: r
                            } = e.type.prototype;
                            if (n) {
                                const n = yt(e);
                                (i.preOrderHooks || (i.preOrderHooks = [])).push(t, n), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, n)
                            }
                            s && (i.preOrderHooks || (i.preOrderHooks = [])).push(0 - t, s), r && ((i.preOrderHooks || (i.preOrderHooks = [])).push(t, r), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, r))
                        }(i, r[i], e)
                    } finally {
                        null !== l && D(l), je(o), a.resolving = !1, pe()
                    }
                }
                return s
            }

            function Qe(t, e, i) {
                return !!(i[e + (t >> 5)] & 1 << t)
            }

            function Ke(t, e) {
                return !(t & P.Self || t & P.Host && e)
            }
            class Je {
                constructor(t, e) {
                    this._tNode = t, this._lView = e
                }
                get(t, e) {
                    return We(this._tNode, this._lView, t, void 0, e)
                }
            }

            function ti(t) {
                return M(() => {
                    const e = t.prototype.constructor,
                        i = e[Z] || ei(e),
                        n = Object.prototype;
                    let s = Object.getPrototypeOf(t.prototype).constructor;
                    for (; s && s !== n;) {
                        const t = s[Z] || ei(s);
                        if (t && t !== i) return t;
                        s = Object.getPrototypeOf(s)
                    }
                    return t => new t
                })
            }

            function ei(t) {
                return g(t) ? () => {
                    const e = ei(f(t));
                    return e && e()
                } : gt(t)
            }

            function ii(t) {
                return function(t, e) {
                    if ("class" === e) return t.classes;
                    if ("style" === e) return t.styles;
                    const i = t.attrs;
                    if (i) {
                        const t = i.length;
                        let n = 0;
                        for (; n < t;) {
                            const s = i[n];
                            if (Ee(s)) break;
                            if (0 === s) n += 2;
                            else if ("number" == typeof s)
                                for (n++; n < t && "string" == typeof i[n];) n++;
                            else {
                                if (s === e) return i[n + 1];
                                n += 2
                            }
                        }
                    }
                    return null
                }(Xt(), t)
            }

            function ni(t, e, i) {
                return M(() => {
                    const n = function(t) {
                        return function(...e) {
                            if (t) {
                                const i = t(...e);
                                for (const t in i) this[t] = i[t]
                            }
                        }
                    }(e);

                    function s(...t) {
                        if (this instanceof s) return n.apply(this, t), this;
                        const e = new s(...t);
                        return i.annotation = e, i;

                        function i(t, i, n) {
                            const s = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", {
                                value: []
                            }).__parameters__;
                            for (; s.length <= n;) s.push(null);
                            return (s[n] = s[n] || []).push(e), t
                        }
                    }
                    return i && (s.prototype = Object.create(i.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s
                })
            }
            class si {
                constructor(t, e) {
                    this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = x({
                        token: this,
                        providedIn: e.providedIn || "root",
                        factory: e.factory
                    }))
                }
                toString() {
                    return `InjectionToken ${this._desc}`
                }
            }
            const ri = new si("AnalyzeForEntryComponents"),
                ai = Function;

            function oi(t, e) {
                void 0 === e && (e = t);
                for (let i = 0; i < t.length; i++) {
                    let n = t[i];
                    Array.isArray(n) ? (e === t && (e = t.slice(0, i)), oi(n, e)) : e !== t && e.push(n)
                }
                return e
            }

            function li(t, e) {
                t.forEach(t => Array.isArray(t) ? li(t, e) : e(t))
            }

            function ci(t, e, i) {
                e >= t.length ? t.push(i) : t.splice(e, 0, i)
            }

            function hi(t, e) {
                return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0]
            }

            function ui(t, e) {
                const i = [];
                for (let n = 0; n < t; n++) i.push(e);
                return i
            }

            function di(t, e, i) {
                let n = fi(t, e);
                return n >= 0 ? t[1 | n] = i : (n = ~n, function(t, e, i, n) {
                    let s = t.length;
                    if (s == e) t.push(i, n);
                    else if (1 === s) t.push(n, t[0]), t[0] = i;
                    else {
                        for (s--, t.push(t[s - 1], t[s]); s > e;) t[s] = t[s - 2], s--;
                        t[e] = i, t[e + 1] = n
                    }
                }(t, n, e, i)), n
            }

            function pi(t, e) {
                const i = fi(t, e);
                if (i >= 0) return t[1 | i]
            }

            function fi(t, e) {
                return function(t, e, i) {
                    let n = 0,
                        s = t.length >> 1;
                    for (; s !== n;) {
                        const i = n + (s - n >> 1),
                            r = t[i << 1];
                        if (e === r) return i << 1;
                        r > e ? s = i : n = i + 1
                    }
                    return ~(s << 1)
                }(t, e)
            }
            const gi = {},
                mi = /\n/gm,
                bi = l({
                    provide: String,
                    useValue: l
                });
            let yi;

            function vi(t) {
                const e = yi;
                return yi = t, e
            }

            function xi(t, e = P.Default) {
                if (void 0 === yi) throw new Error("inject() must be called from an injection context");
                return null === yi ? I(t, void 0, e) : yi.get(t, e & P.Optional ? null : void 0, e)
            }

            function _i(t, e = P.Default) {
                return (T || xi)(f(t), e)
            }
            const wi = _i;

            function Ci(t) {
                const e = [];
                for (let i = 0; i < t.length; i++) {
                    const n = f(t[i]);
                    if (Array.isArray(n)) {
                        if (0 === n.length) throw new Error("Arguments array must have arguments.");
                        let t, i = P.Default;
                        for (let e = 0; e < n.length; e++) {
                            const s = n[e],
                                r = s.__NG_DI_FLAG__;
                            "number" == typeof r ? -1 === r ? t = s.token : i |= r : t = s
                        }
                        e.push(_i(t, i))
                    } else e.push(_i(n))
                }
                return e
            }

            function ki(t, e) {
                return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t
            }
            const Si = ki(ni("Inject", t => ({
                    token: t
                })), -1),
                Ai = ki(ni("Optional"), 8),
                Oi = ki(ni("Self"), 2),
                Ei = ki(ni("SkipSelf"), 4);
            let Pi, Ti;

            function Di(t) {
                var e;
                return (null === (e = function() {
                    if (void 0 === Pi && (Pi = null, V.trustedTypes)) try {
                        Pi = V.trustedTypes.createPolicy("angular", {
                            createHTML: t => t,
                            createScript: t => t,
                            createScriptURL: t => t
                        })
                    } catch (e) {}
                    return Pi
                }()) || void 0 === e ? void 0 : e.createHTML(t)) || t
            }

            function Ii(t) {
                var e;
                return (null === (e = function() {
                    if (void 0 === Ti && (Ti = null, V.trustedTypes)) try {
                        Ti = V.trustedTypes.createPolicy("angular#unsafe-bypass", {
                            createHTML: t => t,
                            createScript: t => t,
                            createScriptURL: t => t
                        })
                    } catch (e) {}
                    return Ti
                }()) || void 0 === e ? void 0 : e.createHTML(t)) || t
            }
            class Mi {
                constructor(t) {
                    this.changingThisBreaksApplicationSecurity = t
                }
                toString() {
                    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`
                }
            }
            class Li extends Mi {
                getTypeName() {
                    return "HTML"
                }
            }
            class Ri extends Mi {
                getTypeName() {
                    return "Style"
                }
            }
            class ji extends Mi {
                getTypeName() {
                    return "Script"
                }
            }
            class Fi extends Mi {
                getTypeName() {
                    return "URL"
                }
            }
            class Ni extends Mi {
                getTypeName() {
                    return "ResourceURL"
                }
            }

            function zi(t) {
                return t instanceof Mi ? t.changingThisBreaksApplicationSecurity : t
            }

            function Vi(t, e) {
                const i = Bi(t);
                if (null != i && i !== e) {
                    if ("ResourceURL" === i && "URL" === e) return !0;
                    throw new Error(`Required a safe ${e}, got a ${i} (see https://g.co/ng/security#xss)`)
                }
                return i === e
            }

            function Bi(t) {
                return t instanceof Mi && t.getTypeName() || null
            }

            function Hi(t) {
                return new Li(t)
            }

            function Ui(t) {
                return new Ri(t)
            }

            function Xi(t) {
                return new ji(t)
            }

            function Wi(t) {
                return new Fi(t)
            }

            function Yi(t) {
                return new Ni(t)
            }
            class Gi {
                constructor(t) {
                    this.inertDocumentHelper = t
                }
                getInertBodyElement(t) {
                    t = "<body><remove></remove>" + t;
                    try {
                        const e = (new window.DOMParser).parseFromString(Di(t), "text/html").body;
                        return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e)
                    } catch (e) {
                        return null
                    }
                }
            }
            class qi {
                constructor(t) {
                    if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) {
                        const t = this.inertDocument.createElement("html");
                        this.inertDocument.appendChild(t);
                        const e = this.inertDocument.createElement("body");
                        t.appendChild(e)
                    }
                }
                getInertBodyElement(t) {
                    const e = this.inertDocument.createElement("template");
                    if ("content" in e) return e.innerHTML = Di(t), e;
                    const i = this.inertDocument.createElement("body");
                    return i.innerHTML = Di(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i
                }
                stripCustomNsAttrs(t) {
                    const e = t.attributes;
                    for (let n = e.length - 1; 0 < n; n--) {
                        const i = e.item(n).name;
                        "xmlns:ns1" !== i && 0 !== i.indexOf("ns1:") || t.removeAttribute(i)
                    }
                    let i = t.firstChild;
                    for (; i;) i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling
                }
            }
            const Zi = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
                $i = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;

            function Qi(t) {
                return (t = String(t)).match(Zi) || t.match($i) ? t : "unsafe:" + t
            }

            function Ki(t) {
                const e = {};
                for (const i of t.split(",")) e[i] = !0;
                return e
            }

            function Ji(...t) {
                const e = {};
                for (const i of t)
                    for (const t in i) i.hasOwnProperty(t) && (e[t] = !0);
                return e
            }
            const tn = Ki("area,br,col,hr,img,wbr"),
                en = Ki("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                nn = Ki("rp,rt"),
                sn = Ji(nn, en),
                rn = Ji(tn, Ji(en, Ki("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Ji(nn, Ki("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), sn),
                an = Ki("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
                on = Ki("srcset"),
                ln = Ji(an, on, Ki("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Ki("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),
                cn = Ki("script,style,template");
            class hn {
                constructor() {
                    this.sanitizedSomething = !1, this.buf = []
                }
                sanitizeChildren(t) {
                    let e = t.firstChild,
                        i = !0;
                    for (; e;)
                        if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild;
                        else
                            for (; e;) {
                                e.nodeType === Node.ELEMENT_NODE && this.endElement(e);
                                let t = this.checkClobberedElement(e, e.nextSibling);
                                if (t) {
                                    e = t;
                                    break
                                }
                                e = this.checkClobberedElement(e, e.parentNode)
                            }
                    return this.buf.join("")
                }
                startElement(t) {
                    const e = t.nodeName.toLowerCase();
                    if (!rn.hasOwnProperty(e)) return this.sanitizedSomething = !0, !cn.hasOwnProperty(e);
                    this.buf.push("<"), this.buf.push(e);
                    const i = t.attributes;
                    for (let s = 0; s < i.length; s++) {
                        const t = i.item(s),
                            e = t.name,
                            r = e.toLowerCase();
                        if (!ln.hasOwnProperty(r)) {
                            this.sanitizedSomething = !0;
                            continue
                        }
                        let a = t.value;
                        an[r] && (a = Qi(a)), on[r] && (n = a, a = (n = String(n)).split(",").map(t => Qi(t.trim())).join(", ")), this.buf.push(" ", e, '="', pn(a), '"')
                    }
                    var n;
                    return this.buf.push(">"), !0
                }
                endElement(t) {
                    const e = t.nodeName.toLowerCase();
                    rn.hasOwnProperty(e) && !tn.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">"))
                }
                chars(t) {
                    this.buf.push(pn(t))
                }
                checkClobberedElement(t, e) {
                    if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);
                    return e
                }
            }
            const un = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                dn = /([^\#-~ |!])/g;

            function pn(t) {
                return t.replace(/&/g, "&amp;").replace(un, function(t) {
                    return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";"
                }).replace(dn, function(t) {
                    return "&#" + t.charCodeAt(0) + ";"
                }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
            }
            let fn;

            function gn(t, e) {
                let i = null;
                try {
                    fn = fn || function(t) {
                        const e = new qi(t);
                        return function() {
                            try {
                                return !!(new window.DOMParser).parseFromString(Di(""), "text/html")
                            } catch (t) {
                                return !1
                            }
                        }() ? new Gi(e) : e
                    }(t);
                    let n = e ? String(e) : "";
                    i = fn.getInertBodyElement(n);
                    let s = 5,
                        r = n;
                    do {
                        if (0 === s) throw new Error("Failed to sanitize html because the input is unstable");
                        s--, n = r, r = i.innerHTML, i = fn.getInertBodyElement(n)
                    } while (n !== r);
                    return Di((new hn).sanitizeChildren(mn(i) || i))
                } finally {
                    if (i) {
                        const t = mn(i) || i;
                        for (; t.firstChild;) t.removeChild(t.firstChild)
                    }
                }
            }

            function mn(t) {
                return "content" in t && function(t) {
                    return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName
                }(t) ? t.content : null
            }
            var bn = function(t) {
                return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t
            }({});

            function yn(t) {
                const e = xn();
                return e ? Ii(e.sanitize(bn.HTML, t) || "") : Vi(t, "HTML") ? Ii(zi(t)) : gn(kt(), b(t))
            }

            function vn(t) {
                const e = xn();
                return e ? e.sanitize(bn.URL, t) || "" : Vi(t, "URL") ? zi(t) : Qi(b(t))
            }

            function xn() {
                const t = Bt();
                return t && t[12]
            }

            function _n(t) {
                return t.ngDebugContext
            }

            function wn(t) {
                return t.ngOriginalError
            }

            function Cn(t, ...e) {
                t.error(...e)
            }
            class kn {
                constructor() {
                    this._console = console
                }
                handleError(t) {
                    const e = this._findOriginalError(t),
                        i = this._findContext(t),
                        n = function(t) {
                            return t.ngErrorLogger || Cn
                        }(t);
                    n(this._console, "ERROR", t), e && n(this._console, "ORIGINAL ERROR", e), i && n(this._console, "ERROR CONTEXT", i)
                }
                _findContext(t) {
                    return t ? _n(t) ? _n(t) : this._findContext(wn(t)) : null
                }
                _findOriginalError(t) {
                    let e = wn(t);
                    for (; e && wn(e);) e = wn(e);
                    return e
                }
            }

            function Sn(t, e) {
                t.__ngContext__ = e
            }
            const An = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(V))();

            function On(t) {
                return {
                    name: "body",
                    target: t.ownerDocument.body
                }
            }

            function En(t) {
                return t instanceof Function ? t() : t
            }
            var Pn = function(t) {
                return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t
            }({});

            function Tn(t, e) {
                return (void 0)(t, e)
            }

            function Dn(t) {
                const e = t[3];
                return ht(e) ? e[3] : e
            }

            function In(t) {
                return Ln(t[13])
            }

            function Mn(t) {
                return Ln(t[4])
            }

            function Ln(t) {
                for (; null !== t && !ht(t);) t = t[4];
                return t
            }

            function Rn(t, e, i, n, s) {
                if (null != n) {
                    let r, a = !1;
                    ht(n) ? r = n : ct(n) && (a = !0, n = n[0]);
                    const o = Ot(n);
                    0 === t && null !== i ? null == s ? Un(e, i, o) : Hn(e, i, o, s || null, !0) : 1 === t && null !== i ? Hn(e, i, o, s || null, !0) : 2 === t ? function(t, e, i) {
                        const n = Wn(t, e);
                        n && function(t, e, i, n) {
                            St(t) ? t.removeChild(e, i, n) : e.removeChild(i)
                        }(t, n, e, i)
                    }(e, o, a) : 3 === t && e.destroyNode(o), null != r && function(t, e, i, n, s) {
                        const r = i[7];
                        r !== Ot(i) && Rn(e, t, n, r, s);
                        for (let a = 10; a < i.length; a++) {
                            const s = i[a];
                            Jn(s[1], s, t, e, n, r)
                        }
                    }(e, t, r, i, s)
                }
            }

            function jn(t, e, i) {
                return St(t) ? t.createElement(e, i) : null === i ? t.createElement(e) : t.createElementNS(i, e)
            }

            function Fn(t, e) {
                const i = t[9],
                    n = i.indexOf(e),
                    s = e[3];
                1024 & e[2] && (e[2] &= -1025, Nt(s, -1)), i.splice(n, 1)
            }

            function Nn(t, e) {
                if (t.length <= 10) return;
                const i = 10 + e,
                    n = t[i];
                if (n) {
                    const r = n[17];
                    null !== r && r !== t && Fn(r, n), e > 0 && (t[i - 1][4] = n[4]);
                    const a = hi(t, 10 + e);
                    Jn(n[1], s = n, s[11], 2, null, null), s[0] = null, s[6] = null;
                    const o = a[19];
                    null !== o && o.detachView(a[1]), n[3] = null, n[4] = null, n[2] &= -129
                }
                var s;
                return n
            }

            function zn(t, e) {
                if (!(256 & e[2])) {
                    const i = e[11];
                    St(i) && i.destroyNode && Jn(t, e, i, 3, null, null),
                        function(t) {
                            let e = t[13];
                            if (!e) return Vn(t[1], t);
                            for (; e;) {
                                let i = null;
                                if (ct(e)) i = e[13];
                                else {
                                    const t = e[10];
                                    t && (i = t)
                                }
                                if (!i) {
                                    for (; e && !e[4] && e !== t;) ct(e) && Vn(e[1], e), e = e[3];
                                    null === e && (e = t), ct(e) && Vn(e[1], e), i = e && e[4]
                                }
                                e = i
                            }
                        }(e)
                }
            }

            function Vn(t, e) {
                if (!(256 & e[2])) {
                    e[2] &= -129, e[2] |= 256,
                        function(t, e) {
                            let i;
                            if (null != t && null != (i = t.destroyHooks))
                                for (let n = 0; n < i.length; n += 2) {
                                    const t = e[i[n]];
                                    if (!(t instanceof Ae)) {
                                        const e = i[n + 1];
                                        if (Array.isArray(e))
                                            for (let i = 0; i < e.length; i += 2) e[i + 1].call(t[e[i]]);
                                        else e.call(t)
                                    }
                                }
                        }(t, e),
                        function(t, e) {
                            const i = t.cleanup,
                                n = e[7];
                            let s = -1;
                            if (null !== i)
                                for (let r = 0; r < i.length - 1; r += 2)
                                    if ("string" == typeof i[r]) {
                                        const t = i[r + 1],
                                            a = "function" == typeof t ? t(e) : Ot(e[t]),
                                            o = n[s = i[r + 2]],
                                            l = i[r + 3];
                                        "boolean" == typeof l ? a.removeEventListener(i[r], o, l) : l >= 0 ? n[s = l]() : n[s = -l].unsubscribe(), r += 2
                                    } else {
                                        const t = n[s = i[r + 1]];
                                        i[r].call(t)
                                    } if (null !== n) {
                                for (let t = s + 1; t < n.length; t++)(0, n[t])();
                                e[7] = null
                            }
                        }(t, e), 1 === e[1].type && St(e[11]) && e[11].destroy();
                    const i = e[17];
                    if (null !== i && ht(e[3])) {
                        i !== e[3] && Fn(i, e);
                        const n = e[19];
                        null !== n && n.detachView(t)
                    }
                }
            }

            function Bn(t, e, i) {
                return function(t, e, i) {
                    let n = e;
                    for (; null !== n && 40 & n.type;) n = (e = n).parent;
                    if (null === n) return i[0];
                    if (2 & n.flags) {
                        const e = t.data[n.directiveStart].encapsulation;
                        if (e === R.None || e === R.Emulated) return null
                    }
                    return Pt(n, i)
                }(t, e.parent, i)
            }

            function Hn(t, e, i, n, s) {
                St(t) ? t.insertBefore(e, i, n, s) : e.insertBefore(i, n, s)
            }

            function Un(t, e, i) {
                St(t) ? t.appendChild(e, i) : e.appendChild(i)
            }

            function Xn(t, e, i, n, s) {
                null !== n ? Hn(t, e, i, n, s) : Un(t, e, i)
            }

            function Wn(t, e) {
                return St(t) ? t.parentNode(e) : e.parentNode
            }

            function Yn(t, e, i) {
                return Gn(t, e, i)
            }
            let Gn = function(t, e, i) {
                return 40 & t.type ? Pt(t, i) : null
            };

            function qn(t, e, i, n) {
                const s = Bn(t, n, e),
                    r = e[11],
                    a = Yn(n.parent || e[6], n, e);
                if (null != s)
                    if (Array.isArray(i))
                        for (let o = 0; o < i.length; o++) Xn(r, s, i[o], a, !1);
                    else Xn(r, s, i, a, !1)
            }

            function Zn(t, e) {
                if (null !== e) {
                    const i = e.type;
                    if (3 & i) return Pt(e, t);
                    if (4 & i) return Qn(-1, t[e.index]);
                    if (8 & i) {
                        const i = e.child;
                        if (null !== i) return Zn(t, i); {
                            const i = t[e.index];
                            return ht(i) ? Qn(-1, i) : Ot(i)
                        }
                    }
                    if (32 & i) return Tn(e, t)() || Ot(t[e.index]); {
                        const i = $n(t, e);
                        return null !== i ? Array.isArray(i) ? i[0] : Zn(Dn(t[16]), i) : Zn(t, e.next)
                    }
                }
                return null
            }

            function $n(t, e) {
                return null !== e ? t[16][6].projection[e.projection] : null
            }

            function Qn(t, e) {
                const i = 10 + t + 1;
                if (i < e.length) {
                    const t = e[i],
                        n = t[1].firstChild;
                    if (null !== n) return Zn(t, n)
                }
                return e[7]
            }

            function Kn(t, e, i, n, s, r, a) {
                for (; null != i;) {
                    const o = n[i.index],
                        l = i.type;
                    if (a && 0 === e && (o && Sn(Ot(o), n), i.flags |= 4), 64 != (64 & i.flags))
                        if (8 & l) Kn(t, e, i.child, n, s, r, !1), Rn(e, t, s, o, r);
                        else if (32 & l) {
                        const a = Tn(i, n);
                        let l;
                        for (; l = a();) Rn(e, t, s, l, r);
                        Rn(e, t, s, o, r)
                    } else 16 & l ? ts(t, e, n, i, s, r) : Rn(e, t, s, o, r);
                    i = a ? i.projectionNext : i.next
                }
            }

            function Jn(t, e, i, n, s, r) {
                Kn(i, n, t.firstChild, e, s, r, !1)
            }

            function ts(t, e, i, n, s, r) {
                const a = i[16],
                    o = a[6].projection[n.projection];
                if (Array.isArray(o))
                    for (let l = 0; l < o.length; l++) Rn(e, t, s, o[l], r);
                else Kn(t, e, o, a[3], s, r, !0)
            }

            function es(t, e, i) {
                St(t) ? t.setAttribute(e, "style", i) : e.style.cssText = i
            }

            function is(t, e, i) {
                St(t) ? "" === i ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", i) : e.className = i
            }

            function ns(t, e, i) {
                let n = t.length;
                for (;;) {
                    const s = t.indexOf(e, i);
                    if (-1 === s) return s;
                    if (0 === s || t.charCodeAt(s - 1) <= 32) {
                        const i = e.length;
                        if (s + i === n || t.charCodeAt(s + i) <= 32) return s
                    }
                    i = s + 1
                }
            }

            function ss(t, e, i) {
                let n = 0;
                for (; n < t.length;) {
                    let s = t[n++];
                    if (i && "class" === s) {
                        if (s = t[n], -1 !== ns(s.toLowerCase(), e, 0)) return !0
                    } else if (1 === s) {
                        for (; n < t.length && "string" == typeof(s = t[n++]);)
                            if (s.toLowerCase() === e) return !0;
                        return !1
                    }
                }
                return !1
            }

            function rs(t) {
                return 4 === t.type && "ng-template" !== t.value
            }

            function as(t, e, i) {
                return e === (4 !== t.type || i ? t.value : "ng-template")
            }

            function os(t, e, i) {
                let n = 4;
                const s = t.attrs || [],
                    r = function(t) {
                        for (let e = 0; e < t.length; e++)
                            if (Ee(t[e])) return e;
                        return t.length
                    }(s);
                let a = !1;
                for (let o = 0; o < e.length; o++) {
                    const l = e[o];
                    if ("number" != typeof l) {
                        if (!a)
                            if (4 & n) {
                                if (n = 2 | 1 & n, "" !== l && !as(t, l, i) || "" === l && 1 === e.length) {
                                    if (ls(n)) return !1;
                                    a = !0
                                }
                            } else {
                                const c = 8 & n ? l : e[++o];
                                if (8 & n && null !== t.attrs) {
                                    if (!ss(t.attrs, c, i)) {
                                        if (ls(n)) return !1;
                                        a = !0
                                    }
                                    continue
                                }
                                const h = cs(8 & n ? "class" : l, s, rs(t), i);
                                if (-1 === h) {
                                    if (ls(n)) return !1;
                                    a = !0;
                                    continue
                                }
                                if ("" !== c) {
                                    let t;
                                    t = h > r ? "" : s[h + 1].toLowerCase();
                                    const e = 8 & n ? t : null;
                                    if (e && -1 !== ns(e, c, 0) || 2 & n && c !== t) {
                                        if (ls(n)) return !1;
                                        a = !0
                                    }
                                }
                            }
                    } else {
                        if (!a && !ls(n) && !ls(l)) return !1;
                        if (a && ls(l)) continue;
                        a = !1, n = l | 1 & n
                    }
                }
                return ls(n) || a
            }

            function ls(t) {
                return 0 == (1 & t)
            }

            function cs(t, e, i, n) {
                if (null === e) return -1;
                let s = 0;
                if (n || !i) {
                    let i = !1;
                    for (; s < e.length;) {
                        const n = e[s];
                        if (n === t) return s;
                        if (3 === n || 6 === n) i = !0;
                        else {
                            if (1 === n || 2 === n) {
                                let t = e[++s];
                                for (;
                                    "string" == typeof t;) t = e[++s];
                                continue
                            }
                            if (4 === n) break;
                            if (0 === n) {
                                s += 4;
                                continue
                            }
                        }
                        s += i ? 1 : 2
                    }
                    return -1
                }
                return function(t, e) {
                    let i = t.indexOf(4);
                    if (i > -1)
                        for (i++; i < t.length;) {
                            const n = t[i];
                            if ("number" == typeof n) return -1;
                            if (n === e) return i;
                            i++
                        }
                    return -1
                }(e, t)
            }

            function hs(t, e, i = !1) {
                for (let n = 0; n < e.length; n++)
                    if (os(t, e[n], i)) return !0;
                return !1
            }

            function us(t, e) {
                t: for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    if (t.length === n.length) {
                        for (let e = 0; e < t.length; e++)
                            if (t[e] !== n[e]) continue t;
                        return !0
                    }
                }
                return !1
            }

            function ds(t, e) {
                return t ? ":not(" + e.trim() + ")" : e
            }

            function ps(t) {
                let e = t[0],
                    i = 1,
                    n = 2,
                    s = "",
                    r = !1;
                for (; i < t.length;) {
                    let a = t[i];
                    if ("string" == typeof a)
                        if (2 & n) {
                            const e = t[++i];
                            s += "[" + a + (e.length > 0 ? '="' + e + '"' : "") + "]"
                        } else 8 & n ? s += "." + a : 4 & n && (s += " " + a);
                    else "" === s || ls(a) || (e += ds(r, s), s = ""), n = a, r = r || !ls(n);
                    i++
                }
                return "" !== s && (e += ds(r, s)), e
            }
            const fs = {};

            function gs(t) {
                ms(Ht(), Bt(), ge() + t, Zt())
            }

            function ms(t, e, i, n) {
                if (!n)
                    if (3 == (3 & e[2])) {
                        const n = t.preOrderCheckHooks;
                        null !== n && _e(e, n, i)
                    } else {
                        const n = t.preOrderHooks;
                        null !== n && we(e, n, 0, i)
                    } me(i)
            }

            function bs(t, e) {
                return t << 17 | e << 2
            }

            function ys(t) {
                return t >> 17 & 32767
            }

            function vs(t) {
                return 2 | t
            }

            function xs(t) {
                return (131068 & t) >> 2
            }

            function _s(t, e) {
                return -131069 & t | e << 2
            }

            function ws(t) {
                return 1 | t
            }

            function Cs(t, e) {
                const i = t.contentQueries;
                if (null !== i)
                    for (let n = 0; n < i.length; n += 2) {
                        const s = i[n],
                            r = i[n + 1];
                        if (-1 !== r) {
                            const i = t.data[r];
                            ae(s), i.contentQueries(2, e[r], r)
                        }
                    }
            }

            function ks(t, e, i, n, s, r, a, o, l, c) {
                const h = e.blueprint.slice();
                return h[0] = s, h[2] = 140 | n, Ft(h), h[3] = h[15] = t, h[8] = i, h[10] = a || t && t[10], h[11] = o || t && t[11], h[12] = l || t && t[12] || null, h[9] = c || t && t[9] || null, h[6] = r, h[16] = 2 == e.type ? t[16] : h, h
            }

            function Ss(t, e, i, n, s) {
                let r = t.data[e];
                if (null === r) r = function(t, e, i, n, s) {
                    const r = Wt(),
                        a = Gt(),
                        o = t.data[e] = function(t, e, i, n, s, r) {
                            return {
                                type: i,
                                index: n,
                                insertBeforeIndex: null,
                                injectorIndex: e ? e.injectorIndex : -1,
                                directiveStart: -1,
                                directiveEnd: -1,
                                directiveStylingLast: -1,
                                propertyBindings: null,
                                flags: 0,
                                providerIndexes: 0,
                                value: s,
                                attrs: r,
                                mergedAttrs: null,
                                localNames: null,
                                initialInputs: void 0,
                                inputs: null,
                                outputs: null,
                                tViews: null,
                                next: null,
                                projectionNext: null,
                                child: null,
                                parent: e,
                                projection: null,
                                styles: null,
                                stylesWithoutHost: null,
                                residualStyles: void 0,
                                classes: null,
                                classesWithoutHost: null,
                                residualClasses: void 0,
                                classBindings: 0,
                                styleBindings: 0
                            }
                        }(0, a ? r : r && r.parent, i, e, n, s);
                    return null === t.firstChild && (t.firstChild = o), null !== r && (a ? null == r.child && null !== o.parent && (r.child = o) : null === r.next && (r.next = o)), o
                }(t, e, i, n, s), zt.lFrame.inI18n && (r.flags |= 64);
                else if (64 & r.type) {
                    r.type = i, r.value = n, r.attrs = s;
                    const t = function() {
                        const t = zt.lFrame,
                            e = t.currentTNode;
                        return t.isParent ? e : e.parent
                    }();
                    r.injectorIndex = null === t ? -1 : t.injectorIndex
                }
                return Yt(r, !0), r
            }

            function As(t, e, i, n) {
                if (0 === i) return -1;
                const s = e.length;
                for (let r = 0; r < i; r++) e.push(n), t.blueprint.push(n), t.data.push(null);
                return s
            }

            function Os(t, e, i) {
                ce(e);
                try {
                    const n = t.viewQuery;
                    null !== n && nr(1, n, i);
                    const s = t.template;
                    null !== s && Ts(t, e, s, 1, i), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Cs(t, e), t.staticViewQueries && nr(2, t.viewQuery, i);
                    const r = t.components;
                    null !== r && function(t, e) {
                        for (let i = 0; i < e.length; i++) Ks(t, e[i])
                    }(e, r)
                } catch (n) {
                    throw t.firstCreatePass && (t.incompleteFirstPass = !0), n
                } finally {
                    e[2] &= -5, fe()
                }
            }

            function Es(t, e, i, n) {
                const s = e[2];
                if (256 == (256 & s)) return;
                ce(e);
                const r = Zt();
                try {
                    Ft(e), Jt(t.bindingStartIndex), null !== i && Ts(t, e, i, 2, n);
                    const a = 3 == (3 & s);
                    if (!r)
                        if (a) {
                            const i = t.preOrderCheckHooks;
                            null !== i && _e(e, i, null)
                        } else {
                            const i = t.preOrderHooks;
                            null !== i && we(e, i, 0, null), Ce(e, 0)
                        } if (function(t) {
                            for (let e = In(t); null !== e; e = Mn(e)) {
                                if (!e[2]) continue;
                                const t = e[9];
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e],
                                        n = i[3];
                                    0 == (1024 & i[2]) && Nt(n, 1), i[2] |= 1024
                                }
                            }
                        }(e), function(t) {
                            for (let e = In(t); null !== e; e = Mn(e))
                                for (let t = 10; t < e.length; t++) {
                                    const i = e[t],
                                        n = i[1];
                                    Rt(i) && Es(n, i, n.template, i[8])
                                }
                        }(e), null !== t.contentQueries && Cs(t, e), !r)
                        if (a) {
                            const i = t.contentCheckHooks;
                            null !== i && _e(e, i)
                        } else {
                            const i = t.contentHooks;
                            null !== i && we(e, i, 1), Ce(e, 1)
                        }!
                    function(t, e) {
                        const i = t.hostBindingOpCodes;
                        if (null !== i) try {
                            for (let t = 0; t < i.length; t++) {
                                const n = i[t];
                                if (n < 0) me(~n);
                                else {
                                    const s = n,
                                        r = i[++t],
                                        a = i[++t];
                                    ie(r, s), a(2, e[s])
                                }
                            }
                        } finally {
                            me(-1)
                        }
                    }(t, e);
                    const o = t.components;
                    null !== o && function(t, e) {
                        for (let i = 0; i < e.length; i++) $s(t, e[i])
                    }(e, o);
                    const l = t.viewQuery;
                    if (null !== l && nr(2, l, n), !r)
                        if (a) {
                            const i = t.viewCheckHooks;
                            null !== i && _e(e, i)
                        } else {
                            const i = t.viewHooks;
                            null !== i && we(e, i, 2), Ce(e, 2)
                        }! 0 === t.firstUpdatePass && (t.firstUpdatePass = !1), r || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, Nt(e[3], -1))
                } finally {
                    fe()
                }
            }

            function Ps(t, e, i, n) {
                const s = e[10],
                    r = !Zt(),
                    a = Lt(e);
                try {
                    r && !a && s.begin && s.begin(), a && Os(t, e, n), Es(t, e, i, n)
                } finally {
                    r && !a && s.end && s.end()
                }
            }

            function Ts(t, e, i, n, s) {
                const r = ge(),
                    a = 2 & n;
                try {
                    me(-1), a && e.length > 20 && ms(t, e, 20, Zt()), i(n, s)
                } finally {
                    me(r)
                }
            }

            function Ds(t, e, i) {
                if (ut(e)) {
                    const n = e.directiveEnd;
                    for (let s = e.directiveStart; s < n; s++) {
                        const e = t.data[s];
                        e.contentQueries && e.contentQueries(1, i[s], s)
                    }
                }
            }

            function Is(t, e, i) {
                Vt() && (function(t, e, i, n) {
                    const s = i.directiveStart,
                        r = i.directiveEnd;
                    t.firstCreatePass || Ne(i, e), Sn(n, e);
                    const a = i.initialInputs;
                    for (let o = s; o < r; o++) {
                        const n = t.data[o],
                            r = ft(n);
                        r && Ys(e, i, n);
                        const l = $e(e, t, o, i);
                        Sn(l, e), null !== a && Gs(0, o - s, l, n, 0, a), r && (It(i.index, e)[8] = l)
                    }
                }(t, e, i, Pt(i, e)), 128 == (128 & i.flags) && function(t, e, i) {
                    const n = i.directiveStart,
                        s = i.directiveEnd,
                        r = i.index,
                        a = zt.lFrame.currentDirectiveIndex;
                    try {
                        me(r);
                        for (let i = n; i < s; i++) {
                            const n = t.data[i],
                                s = e[i];
                            ne(i), null === n.hostBindings && 0 === n.hostVars && null === n.hostAttrs || Bs(n, s)
                        }
                    } finally {
                        me(-1), ne(a)
                    }
                }(t, e, i))
            }

            function Ms(t, e, i = Pt) {
                const n = e.localNames;
                if (null !== n) {
                    let s = e.index + 1;
                    for (let r = 0; r < n.length; r += 2) {
                        const a = n[r + 1],
                            o = -1 === a ? i(e, t) : t[a];
                        t[s++] = o
                    }
                }
            }

            function Ls(t) {
                const e = t.tView;
                return null === e || e.incompleteFirstPass ? t.tView = Rs(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e
            }

            function Rs(t, e, i, n, s, r, a, o, l, c) {
                const h = 20 + n,
                    u = h + s,
                    d = function(t, e) {
                        const i = [];
                        for (let n = 0; n < e; n++) i.push(n < t ? null : fs);
                        return i
                    }(h, u),
                    p = "function" == typeof c ? c() : c;
                return d[1] = {
                    type: t,
                    blueprint: d,
                    template: i,
                    queries: null,
                    viewQuery: o,
                    declTNode: e,
                    data: d.slice().fill(null, h),
                    bindingStartIndex: h,
                    expandoStartIndex: u,
                    hostBindingOpCodes: null,
                    firstCreatePass: !0,
                    firstUpdatePass: !0,
                    staticViewQueries: !1,
                    staticContentQueries: !1,
                    preOrderHooks: null,
                    preOrderCheckHooks: null,
                    contentHooks: null,
                    contentCheckHooks: null,
                    viewHooks: null,
                    viewCheckHooks: null,
                    destroyHooks: null,
                    cleanup: null,
                    contentQueries: null,
                    components: null,
                    directiveRegistry: "function" == typeof r ? r() : r,
                    pipeRegistry: "function" == typeof a ? a() : a,
                    firstChild: null,
                    schemas: l,
                    consts: p,
                    incompleteFirstPass: !1
                }
            }

            function js(t, e, i, n) {
                const s = rr(e);
                null === i ? s.push(n) : (s.push(i), t.firstCreatePass && ar(t).push(n, s.length - 1))
            }

            function Fs(t, e, i) {
                for (let n in t)
                    if (t.hasOwnProperty(n)) {
                        const s = t[n];
                        (i = null === i ? {} : i).hasOwnProperty(n) ? i[n].push(e, s) : i[n] = [e, s]
                    } return i
            }

            function Ns(t, e, i, n, s, r, a, o) {
                const l = Pt(e, i);
                let c, h = e.inputs;
                var u;
                !o && null != h && (c = h[n]) ? (cr(t, i, c, n, s), dt(e) && function(t, e) {
                    const i = It(e, t);
                    16 & i[2] || (i[2] |= 64)
                }(i, e.index)) : 3 & e.type && (n = "class" === (u = n) ? "className" : "for" === u ? "htmlFor" : "formaction" === u ? "formAction" : "innerHtml" === u ? "innerHTML" : "readonly" === u ? "readOnly" : "tabindex" === u ? "tabIndex" : u, s = null != a ? a(s, e.value || "", n) : s, St(r) ? r.setProperty(l, n, s) : Pe(n) || (l.setProperty ? l.setProperty(n, s) : l[n] = s))
            }

            function zs(t, e, i, n) {
                let s = !1;
                if (Vt()) {
                    const r = function(t, e, i) {
                            const n = t.directiveRegistry;
                            let s = null;
                            if (n)
                                for (let r = 0; r < n.length; r++) {
                                    const a = n[r];
                                    hs(i, a.selectors, !1) && (s || (s = []), He(Ne(i, e), t, a.type), ft(a) ? (Hs(t, i), s.unshift(a)) : s.push(a))
                                }
                            return s
                        }(t, e, i),
                        a = null === n ? null : {
                            "": -1
                        };
                    if (null !== r) {
                        s = !0, Xs(i, t.data.length, r.length);
                        for (let t = 0; t < r.length; t++) {
                            const e = r[t];
                            e.providersResolver && e.providersResolver(e)
                        }
                        let n = !1,
                            o = !1,
                            l = As(t, e, r.length, null);
                        for (let s = 0; s < r.length; s++) {
                            const c = r[s];
                            i.mergedAttrs = Te(i.mergedAttrs, c.hostAttrs), Ws(t, i, e, l, c), Us(l, c, a), null !== c.contentQueries && (i.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (i.flags |= 128);
                            const h = c.type.prototype;
                            !n && (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(i.index), n = !0), o || !h.ngOnChanges && !h.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(i.index), o = !0), l++
                        }! function(t, e) {
                            const i = e.directiveEnd,
                                n = t.data,
                                s = e.attrs,
                                r = [];
                            let a = null,
                                o = null;
                            for (let l = e.directiveStart; l < i; l++) {
                                const t = n[l],
                                    i = t.inputs,
                                    c = null === s || rs(e) ? null : qs(i, s);
                                r.push(c), a = Fs(i, l, a), o = Fs(t.outputs, l, o)
                            }
                            null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = r, e.inputs = a, e.outputs = o
                        }(t, i)
                    }
                    a && function(t, e, i) {
                        if (e) {
                            const n = t.localNames = [];
                            for (let t = 0; t < e.length; t += 2) {
                                const s = i[e[t + 1]];
                                if (null == s) throw new m("301", `Export of name '${e[t+1]}' not found!`);
                                n.push(e[t], s)
                            }
                        }
                    }(i, n, a)
                }
                return i.mergedAttrs = Te(i.mergedAttrs, i.attrs), s
            }

            function Vs(t, e, i, n, s, r) {
                const a = r.hostBindings;
                if (a) {
                    let i = t.hostBindingOpCodes;
                    null === i && (i = t.hostBindingOpCodes = []);
                    const r = ~e.index;
                    (function(t) {
                        let e = t.length;
                        for (; e > 0;) {
                            const i = t[--e];
                            if ("number" == typeof i && i < 0) return i
                        }
                        return 0
                    })(i) != r && i.push(r), i.push(n, s, a)
                }
            }

            function Bs(t, e) {
                null !== t.hostBindings && t.hostBindings(1, e)
            }

            function Hs(t, e) {
                e.flags |= 2, (t.components || (t.components = [])).push(e.index)
            }

            function Us(t, e, i) {
                if (i) {
                    if (e.exportAs)
                        for (let n = 0; n < e.exportAs.length; n++) i[e.exportAs[n]] = t;
                    ft(e) && (i[""] = t)
                }
            }

            function Xs(t, e, i) {
                t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + i, t.providerIndexes = e
            }

            function Ws(t, e, i, n, s) {
                t.data[n] = s;
                const r = s.factory || (s.factory = gt(s.type)),
                    a = new Ae(r, ft(s), null);
                t.blueprint[n] = a, i[n] = a, Vs(t, e, 0, n, As(t, i, s.hostVars, fs), s)
            }

            function Ys(t, e, i) {
                const n = Pt(e, t),
                    s = Ls(i),
                    r = t[10],
                    a = Js(t, ks(t, s, null, i.onPush ? 64 : 16, n, e, r, r.createRenderer(n, i), null, null));
                t[e.index] = a
            }

            function Gs(t, e, i, n, s, r) {
                const a = r[e];
                if (null !== a) {
                    const t = n.setInput;
                    for (let e = 0; e < a.length;) {
                        const s = a[e++],
                            r = a[e++],
                            o = a[e++];
                        null !== t ? n.setInput(i, o, s, r) : i[r] = o
                    }
                }
            }

            function qs(t, e) {
                let i = null,
                    n = 0;
                for (; n < e.length;) {
                    const s = e[n];
                    if (0 !== s)
                        if (5 !== s) {
                            if ("number" == typeof s) break;
                            t.hasOwnProperty(s) && (null === i && (i = []), i.push(s, t[s], e[n + 1])), n += 2
                        } else n += 2;
                    else n += 4
                }
                return i
            }

            function Zs(t, e, i, n) {
                return new Array(t, !0, !1, e, null, 0, n, i, null, null)
            }

            function $s(t, e) {
                const i = It(e, t);
                if (Rt(i)) {
                    const t = i[1];
                    80 & i[2] ? Es(t, i, t.template, i[8]) : i[5] > 0 && Qs(i)
                }
            }

            function Qs(t) {
                for (let i = In(t); null !== i; i = Mn(i))
                    for (let t = 10; t < i.length; t++) {
                        const e = i[t];
                        if (1024 & e[2]) {
                            const t = e[1];
                            Es(t, e, t.template, e[8])
                        } else e[5] > 0 && Qs(e)
                    }
                const e = t[1].components;
                if (null !== e)
                    for (let i = 0; i < e.length; i++) {
                        const n = It(e[i], t);
                        Rt(n) && n[5] > 0 && Qs(n)
                    }
            }

            function Ks(t, e) {
                const i = It(e, t),
                    n = i[1];
                ! function(t, e) {
                    for (let i = e.length; i < t.blueprint.length; i++) e.push(t.blueprint[i])
                }(n, i), Os(n, i, i[8])
            }

            function Js(t, e) {
                return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e
            }

            function tr(t) {
                for (; t;) {
                    t[2] |= 64;
                    const e = Dn(t);
                    if (0 != (512 & t[2]) && !e) return t;
                    t = e
                }
                return null
            }

            function er(t, e, i) {
                const n = e[10];
                n.begin && n.begin();
                try {
                    Es(t, e, t.template, i)
                } catch (s) {
                    throw lr(e, s), s
                } finally {
                    n.end && n.end()
                }
            }

            function ir(t) {
                ! function(t) {
                    for (let e = 0; e < t.components.length; e++) {
                        const i = t.components[e],
                            n = Mt(i),
                            s = n[1];
                        Ps(s, n, s.template, i)
                    }
                }(t[8])
            }

            function nr(t, e, i) {
                ae(0), e(t, i)
            }
            const sr = (() => Promise.resolve(null))();

            function rr(t) {
                return t[7] || (t[7] = [])
            }

            function ar(t) {
                return t.cleanup || (t.cleanup = [])
            }

            function or(t, e, i) {
                return (null === t || ft(t)) && (i = function(t) {
                    for (; Array.isArray(t);) {
                        if ("object" == typeof t[1]) return t;
                        t = t[0]
                    }
                    return null
                }(i[e.index])), i[11]
            }

            function lr(t, e) {
                const i = t[9],
                    n = i ? i.get(kn, null) : null;
                n && n.handleError(e)
            }

            function cr(t, e, i, n, s) {
                for (let r = 0; r < i.length;) {
                    const a = i[r++],
                        o = i[r++],
                        l = e[a],
                        c = t.data[a];
                    null !== c.setInput ? c.setInput(l, s, n, o) : l[o] = s
                }
            }

            function hr(t, e, i) {
                const n = Et(e, t);
                ! function(t, e, i) {
                    St(t) ? t.setValue(e, i) : e.textContent = i
                }(t[11], n, i)
            }

            function ur(t, e, i) {
                let n = i ? t.styles : null,
                    s = i ? t.classes : null,
                    r = 0;
                if (null !== e)
                    for (let a = 0; a < e.length; a++) {
                        const t = e[a];
                        "number" == typeof t ? r = t : 1 == r ? s = u(s, t) : 2 == r && (n = u(n, t + ": " + e[++a] + ";"))
                    }
                i ? t.styles = n : t.stylesWithoutHost = n, i ? t.classes = s : t.classesWithoutHost = s
            }
            const dr = new si("INJECTOR", -1);
            class pr {
                get(t, e = gi) {
                    if (e === gi) {
                        const e = new Error(`NullInjectorError: No provider for ${h(t)}!`);
                        throw e.name = "NullInjectorError", e
                    }
                    return e
                }
            }
            const fr = new si("Set Injector scope."),
                gr = {},
                mr = {},
                br = [];
            let yr;

            function vr() {
                return void 0 === yr && (yr = new pr), yr
            }

            function xr(t, e = null, i = null, n) {
                return new _r(t, i, e || vr(), n)
            }
            class _r {
                constructor(t, e, i, n = null) {
                    this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1;
                    const s = [];
                    e && li(e, i => this.processProvider(i, t, e)), li([t], t => this.processInjectorType(t, [], s)), this.records.set(dr, kr(void 0, this));
                    const r = this.records.get(fr);
                    this.scope = null != r ? r.value : null, this.source = n || ("object" == typeof t ? null : h(t))
                }
                get destroyed() {
                    return this._destroyed
                }
                destroy() {
                    this.assertNotDestroyed(), this._destroyed = !0;
                    try {
                        this.onDestroy.forEach(t => t.ngOnDestroy())
                    } finally {
                        this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear()
                    }
                }
                get(t, e = gi, i = P.Default) {
                    this.assertNotDestroyed();
                    const n = vi(this);
                    try {
                        if (!(i & P.SkipSelf)) {
                            let e = this.records.get(t);
                            if (void 0 === e) {
                                const i = ("function" == typeof(s = t) || "object" == typeof s && s instanceof si) && w(t);
                                e = i && this.injectableDefInScope(i) ? kr(wr(t), gr) : null, this.records.set(t, e)
                            }
                            if (null != e) return this.hydrate(t, e)
                        }
                        return (i & P.Self ? vr() : this.parent).get(t, e = i & P.Optional && e === gi ? null : e)
                    } catch (r) {
                        if ("NullInjectorError" === r.name) {
                            if ((r.ngTempTokenPath = r.ngTempTokenPath || []).unshift(h(t)), n) throw r;
                            return function(t, e, i, n) {
                                const s = t.ngTempTokenPath;
                                throw e.__source && s.unshift(e.__source), t.message = function(t, e, i, n = null) {
                                    t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t;
                                    let s = h(e);
                                    if (Array.isArray(e)) s = e.map(h).join(" -> ");
                                    else if ("object" == typeof e) {
                                        let t = [];
                                        for (let i in e)
                                            if (e.hasOwnProperty(i)) {
                                                let n = e[i];
                                                t.push(i + ":" + ("string" == typeof n ? JSON.stringify(n) : h(n)))
                                            } s = `{${t.join(", ")}}`
                                    }
                                    return `${i}${n?"("+n+")":""}[${s}]: ${t.replace(mi,"\n  ")}`
                                }("\n" + t.message, s, i, n), t.ngTokenPath = s, t.ngTempTokenPath = null, t
                            }(r, t, "R3InjectorError", this.source)
                        }
                        throw r
                    } finally {
                        vi(n)
                    }
                    var s
                }
                _resolveInjectorDefTypes() {
                    this.injectorDefTypes.forEach(t => this.get(t))
                }
                toString() {
                    const t = [];
                    return this.records.forEach((e, i) => t.push(h(i))), `R3Injector[${t.join(", ")}]`
                }
                assertNotDestroyed() {
                    if (this._destroyed) throw new Error("Injector has already been destroyed.")
                }
                processInjectorType(t, e, i) {
                    if (!(t = f(t))) return !1;
                    let n = k(t);
                    const s = null == n && t.ngModule || void 0,
                        r = void 0 === s ? t : s,
                        a = -1 !== i.indexOf(r);
                    if (void 0 !== s && (n = k(s)), null == n) return !1;
                    if (null != n.imports && !a) {
                        let t;
                        i.push(r);
                        try {
                            li(n.imports, n => {
                                this.processInjectorType(n, e, i) && (void 0 === t && (t = []), t.push(n))
                            })
                        } finally {}
                        if (void 0 !== t)
                            for (let e = 0; e < t.length; e++) {
                                const {
                                    ngModule: i,
                                    providers: n
                                } = t[e];
                                li(n, t => this.processProvider(t, i, n || br))
                            }
                    }
                    this.injectorDefTypes.add(r);
                    const o = gt(r) || (() => new r);
                    this.records.set(r, kr(o, gr));
                    const l = n.providers;
                    if (null != l && !a) {
                        const e = t;
                        li(l, t => this.processProvider(t, e, l))
                    }
                    return void 0 !== s && void 0 !== t.providers
                }
                processProvider(t, e, i) {
                    let n = Ar(t = f(t)) ? t : f(t && t.provide);
                    const s = function(t, e, i) {
                        return Sr(t) ? kr(void 0, t.useValue) : kr(Cr(t), gr)
                    }(t);
                    if (Ar(t) || !0 !== t.multi) this.records.get(n);
                    else {
                        let e = this.records.get(n);
                        e || (e = kr(void 0, gr, !0), e.factory = () => Ci(e.multi), this.records.set(n, e)), n = t, e.multi.push(t)
                    }
                    this.records.set(n, s)
                }
                hydrate(t, e) {
                    var i;
                    return e.value === gr && (e.value = mr, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (i = e.value) && "object" == typeof i && "function" == typeof i.ngOnDestroy && this.onDestroy.add(e.value), e.value
                }
                injectableDefInScope(t) {
                    return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn))
                }
            }

            function wr(t) {
                const e = w(t),
                    i = null !== e ? e.factory : gt(t);
                if (null !== i) return i;
                if (t instanceof si) throw new Error(`Token ${h(t)} is missing a \u0275prov definition.`);
                if (t instanceof Function) return function(t) {
                    const e = t.length;
                    if (e > 0) {
                        const i = ui(e, "?");
                        throw new Error(`Can't resolve all parameters for ${h(t)}: (${i.join(", ")}).`)
                    }
                    const i = function(t) {
                        const e = t && (t[S] || t[O]);
                        if (e) {
                            const i = function(t) {
                                if (t.hasOwnProperty("name")) return t.name;
                                const e = ("" + t).match(/^function\s*([^\s(]+)/);
                                return null === e ? "" : e[1]
                            }(t);
                            return console.warn(`DEPRECATED: DI is instantiating a token "${i}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${i}" class.`), e
                        }
                        return null
                    }(t);
                    return null !== i ? () => i.factory(t) : () => new t
                }(t);
                throw new Error("unreachable")
            }

            function Cr(t, e, i) {
                let n;
                if (Ar(t)) {
                    const e = f(t);
                    return gt(e) || wr(e)
                }
                if (Sr(t)) n = () => f(t.useValue);
                else if ((s = t) && s.useFactory) n = () => t.useFactory(...Ci(t.deps || []));
                else if (function(t) {
                        return !(!t || !t.useExisting)
                    }(t)) n = () => _i(f(t.useExisting));
                else {
                    const e = f(t && (t.useClass || t.provide));
                    if (! function(t) {
                            return !!t.deps
                        }(t)) return gt(e) || wr(e);
                    n = () => new e(...Ci(t.deps))
                }
                var s;
                return n
            }

            function kr(t, e, i = !1) {
                return {
                    factory: t,
                    value: e,
                    multi: i ? [] : void 0
                }
            }

            function Sr(t) {
                return null !== t && "object" == typeof t && bi in t
            }

            function Ar(t) {
                return "function" == typeof t
            }
            const Or = function(t, e, i) {
                return function(t, e = null, i = null, n) {
                    const s = xr(t, e, i, n);
                    return s._resolveInjectorDefTypes(), s
                }({
                    name: i
                }, e, t, i)
            };
            let Er = (() => {
                class t {
                    static create(t, e) {
                        return Array.isArray(t) ? Or(t, e, "") : Or(t.providers, t.parent, t.name || "")
                    }
                }
                return t.THROW_IF_NOT_FOUND = gi, t.NULL = new pr, t.\u0275prov = x({
                    token: t,
                    providedIn: "any",
                    factory: () => _i(dr)
                }), t.__NG_ELEMENT_ID__ = -1, t
            })();

            function Pr(t, e) {
                xe(Mt(t)[1], Xt())
            }

            function Tr(t) {
                let e = Object.getPrototypeOf(t.type.prototype).constructor,
                    i = !0;
                const n = [t];
                for (; e;) {
                    let s;
                    if (ft(t)) s = e.\u0275cmp || e.\u0275dir;
                    else {
                        if (e.\u0275cmp) throw new Error("Directives cannot inherit Components");
                        s = e.\u0275dir
                    }
                    if (s) {
                        if (i) {
                            n.push(s);
                            const e = t;
                            e.inputs = Dr(t.inputs), e.declaredInputs = Dr(t.declaredInputs), e.outputs = Dr(t.outputs);
                            const i = s.hostBindings;
                            i && Lr(t, i);
                            const r = s.viewQuery,
                                a = s.contentQueries;
                            if (r && Ir(t, r), a && Mr(t, a), c(t.inputs, s.inputs), c(t.declaredInputs, s.declaredInputs), c(t.outputs, s.outputs), ft(s) && s.data.animation) {
                                const e = t.data;
                                e.animation = (e.animation || []).concat(s.data.animation)
                            }
                        }
                        const e = s.features;
                        if (e)
                            for (let n = 0; n < e.length; n++) {
                                const s = e[n];
                                s && s.ngInherit && s(t), s === Tr && (i = !1)
                            }
                    }
                    e = Object.getPrototypeOf(e)
                }! function(t) {
                    let e = 0,
                        i = null;
                    for (let n = t.length - 1; n >= 0; n--) {
                        const s = t[n];
                        s.hostVars = e += s.hostVars, s.hostAttrs = Te(s.hostAttrs, i = Te(i, s.hostAttrs))
                    }
                }(n)
            }

            function Dr(t) {
                return t === B ? {} : t === U ? [] : t
            }

            function Ir(t, e) {
                const i = t.viewQuery;
                t.viewQuery = i ? (t, n) => {
                    e(t, n), i(t, n)
                } : e
            }

            function Mr(t, e) {
                const i = t.contentQueries;
                t.contentQueries = i ? (t, n, s) => {
                    e(t, n, s), i(t, n, s)
                } : e
            }

            function Lr(t, e) {
                const i = t.hostBindings;
                t.hostBindings = i ? (t, n) => {
                    e(t, n), i(t, n)
                } : e
            }
            let Rr = null;

            function jr() {
                if (!Rr) {
                    const t = V.Symbol;
                    if (t && t.iterator) Rr = t.iterator;
                    else {
                        const t = Object.getOwnPropertyNames(Map.prototype);
                        for (let e = 0; e < t.length; ++e) {
                            const i = t[e];
                            "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (Rr = i)
                        }
                    }
                }
                return Rr
            }
            class Fr {
                constructor(t) {
                    this.wrapped = t
                }
                static wrap(t) {
                    return new Fr(t)
                }
                static unwrap(t) {
                    return Fr.isWrapped(t) ? t.wrapped : t
                }
                static isWrapped(t) {
                    return t instanceof Fr
                }
            }

            function Nr(t) {
                return !!zr(t) && (Array.isArray(t) || !(t instanceof Map) && jr() in t)
            }

            function zr(t) {
                return null !== t && ("function" == typeof t || "object" == typeof t)
            }

            function Vr(t, e, i) {
                return t[e] = i
            }

            function Br(t, e, i) {
                return !Object.is(t[e], i) && (t[e] = i, !0)
            }

            function Hr(t, e, i, n) {
                const s = Br(t, e, i);
                return Br(t, e + 1, n) || s
            }

            function Ur(t, e, i, n) {
                const s = Bt();
                return Br(s, te(), e) && (Ht(), function(t, e, i, n, s, r) {
                    const a = Pt(t, e);
                    ! function(t, e, i, n, s, r, a) {
                        if (null == r) St(t) ? t.removeAttribute(e, s, i) : e.removeAttribute(s);
                        else {
                            const o = null == a ? b(r) : a(r, n || "", s);
                            St(t) ? t.setAttribute(e, s, o, i) : i ? e.setAttributeNS(i, s, o) : e.setAttribute(s, o)
                        }
                    }(e[11], a, r, t.value, i, n, s)
                }(be(), s, t, e, i, n)), Ur
            }

            function Xr(t, e, i, n) {
                return Br(t, te(), i) ? e + b(i) + n : fs
            }

            function Wr(t, e, i, n, s, r, a, o) {
                const l = Bt(),
                    c = Ht(),
                    h = t + 20,
                    u = c.firstCreatePass ? function(t, e, i, n, s, r, a, o, l) {
                        const c = e.consts,
                            h = Ss(e, t, 4, a || null, jt(c, o));
                        zs(e, i, h, jt(c, l)), xe(e, h);
                        const u = h.tViews = Rs(2, h, n, s, r, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c);
                        return null !== e.queries && (e.queries.template(e, h), u.queries = e.queries.embeddedTView(h)), h
                    }(h, c, l, e, i, n, s, r, a) : c.data[h];
                Yt(u, !1);
                const d = l[11].createComment("");
                qn(c, l, d, u), Sn(d, l), Js(l, l[h] = Zs(d, l, d, u)), pt(u) && Is(c, l, u), null != a && Ms(l, u, o)
            }

            function Yr(t) {
                return Dt(zt.lFrame.contextLView, 20 + t)
            }

            function Gr(t, e = P.Default) {
                const i = Bt();
                return null === i ? _i(t, e) : We(Xt(), i, f(t), e)
            }

            function qr(t, e, i) {
                const n = Bt();
                return Br(n, te(), e) && Ns(Ht(), be(), n, t, e, n[11], i, !1), qr
            }

            function Zr(t, e, i, n, s) {
                const r = s ? "class" : "style";
                cr(t, i, e.inputs[r], r, n)
            }

            function $r(t, e, i, n) {
                const s = Bt(),
                    r = Ht(),
                    a = 20 + t,
                    o = s[11],
                    l = s[a] = jn(o, e, zt.lFrame.currentNamespace),
                    c = r.firstCreatePass ? function(t, e, i, n, s, r, a) {
                        const o = e.consts,
                            l = Ss(e, t, 2, s, jt(o, r));
                        return zs(e, i, l, jt(o, a)), null !== l.attrs && ur(l, l.attrs, !1), null !== l.mergedAttrs && ur(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l
                    }(a, r, s, 0, e, i, n) : r.data[a];
                Yt(c, !0);
                const h = c.mergedAttrs;
                null !== h && Oe(o, l, h);
                const u = c.classes;
                null !== u && is(o, l, u);
                const d = c.styles;
                null !== d && es(o, l, d), 64 != (64 & c.flags) && qn(r, s, l, c), 0 === zt.lFrame.elementDepthCount && Sn(l, s), zt.lFrame.elementDepthCount++, pt(c) && (Is(r, s, c), Ds(r, c, s)), null !== n && Ms(s, c)
            }

            function Qr() {
                let t = Xt();
                Gt() ? qt() : (t = t.parent, Yt(t, !1));
                const e = t;
                zt.lFrame.elementDepthCount--;
                const i = Ht();
                i.firstCreatePass && (xe(i, t), ut(t) && i.queries.elementEnd(t)), null != e.classesWithoutHost && function(t) {
                    return 0 != (16 & t.flags)
                }(e) && Zr(i, e, Bt(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function(t) {
                    return 0 != (32 & t.flags)
                }(e) && Zr(i, e, Bt(), e.stylesWithoutHost, !1)
            }

            function Kr(t, e, i, n) {
                $r(t, e, i, n), Qr()
            }

            function Jr(t, e, i) {
                const n = Bt(),
                    s = Ht(),
                    r = t + 20,
                    a = s.firstCreatePass ? function(t, e, i, n, s) {
                        const r = e.consts,
                            a = jt(r, n),
                            o = Ss(e, t, 8, "ng-container", a);
                        return null !== a && ur(o, a, !0), zs(e, i, o, jt(r, s)), null !== e.queries && e.queries.elementStart(e, o), o
                    }(r, s, n, e, i) : s.data[r];
                Yt(a, !0);
                const o = n[r] = n[11].createComment("");
                qn(s, n, o, a), Sn(o, n), pt(a) && (Is(s, n, a), Ds(s, a, n)), null != i && Ms(n, a)
            }

            function ta() {
                let t = Xt();
                const e = Ht();
                Gt() ? qt() : (t = t.parent, Yt(t, !1)), e.firstCreatePass && (xe(e, t), ut(t) && e.queries.elementEnd(t))
            }

            function ea(t, e, i) {
                Jr(t, e, i), ta()
            }

            function ia() {
                return Bt()
            }

            function na(t) {
                return !!t && "function" == typeof t.then
            }

            function sa(t) {
                return !!t && "function" == typeof t.subscribe
            }
            const ra = sa;

            function aa(t, e, i = !1, n) {
                const s = Bt(),
                    r = Ht(),
                    a = Xt();
                return la(r, s, s[11], a, t, e, i, n), aa
            }

            function oa(t, e, i = !1, n) {
                const s = Xt(),
                    r = Bt(),
                    a = Ht();
                return la(a, r, or(se(a.data), s, r), s, t, e, i, n), oa
            }

            function la(t, e, i, n, s, r, a = !1, o) {
                const l = pt(n),
                    c = t.firstCreatePass && ar(t),
                    h = rr(e);
                let u = !0;
                if (3 & n.type) {
                    const d = Pt(n, e),
                        p = o ? o(d) : B,
                        f = p.target || d,
                        g = h.length,
                        m = o ? t => o(Ot(t[n.index])).target : n.index;
                    if (St(i)) {
                        let a = null;
                        if (!o && l && (a = function(t, e, i, n) {
                                const s = t.cleanup;
                                if (null != s)
                                    for (let r = 0; r < s.length - 1; r += 2) {
                                        const t = s[r];
                                        if (t === i && s[r + 1] === n) {
                                            const t = e[7],
                                                i = s[r + 2];
                                            return t.length > i ? t[i] : null
                                        }
                                        "string" == typeof t && (r += 2)
                                    }
                                return null
                            }(t, e, s, n.index)), null !== a)(a.__ngLastListenerFn__ || a).__ngNextListenerFn__ = r, a.__ngLastListenerFn__ = r, u = !1;
                        else {
                            r = ha(n, e, 0, r, !1);
                            const t = i.listen(p.name || f, s, r);
                            h.push(r, t), c && c.push(s, m, g, g + 1)
                        }
                    } else r = ha(n, e, 0, r, !0), f.addEventListener(s, r, a), h.push(r), c && c.push(s, m, g, a)
                } else r = ha(n, e, 0, r, !1);
                const d = n.outputs;
                let p;
                if (u && null !== d && (p = d[s])) {
                    const t = p.length;
                    if (t)
                        for (let i = 0; i < t; i += 2) {
                            const t = e[p[i]][p[i + 1]].subscribe(r),
                                a = h.length;
                            h.push(r, t), c && c.push(s, n.index, a, -(a + 1))
                        }
                }
            }

            function ca(t, e, i, n) {
                try {
                    return !1 !== i(n)
                } catch (s) {
                    return lr(t, s), !1
                }
            }

            function ha(t, e, i, n, s) {
                return function i(r) {
                    if (r === Function) return n;
                    const a = 2 & t.flags ? It(t.index, e) : e;
                    0 == (32 & e[2]) && tr(a);
                    let o = ca(e, 0, n, r),
                        l = i.__ngNextListenerFn__;
                    for (; l;) o = ca(e, 0, l, r) && o, l = l.__ngNextListenerFn__;
                    return s && !1 === o && (r.preventDefault(), r.returnValue = !1), o
                }
            }

            function ua(t = 1) {
                return function(t) {
                    return (zt.lFrame.contextLView = function(t, e) {
                        for (; t > 0;) e = e[15], t--;
                        return e
                    }(t, zt.lFrame.contextLView))[8]
                }(t)
            }

            function da(t, e) {
                let i = null;
                const n = function(t) {
                    const e = t.attrs;
                    if (null != e) {
                        const t = e.indexOf(5);
                        if (0 == (1 & t)) return e[t + 1]
                    }
                    return null
                }(t);
                for (let s = 0; s < e.length; s++) {
                    const r = e[s];
                    if ("*" !== r) {
                        if (null === n ? hs(t, r, !0) : us(n, r)) return s
                    } else i = s
                }
                return i
            }

            function pa(t) {
                const e = Bt()[16][6];
                if (!e.projection) {
                    const i = e.projection = ui(t ? t.length : 1, null),
                        n = i.slice();
                    let s = e.child;
                    for (; null !== s;) {
                        const e = t ? da(s, t) : 0;
                        null !== e && (n[e] ? n[e].projectionNext = s : i[e] = s, n[e] = s), s = s.next
                    }
                }
            }

            function fa(t, e = 0, i) {
                const n = Bt(),
                    s = Ht(),
                    r = Ss(s, 20 + t, 16, null, i || null);
                null === r.projection && (r.projection = e), qt(), 64 != (64 & r.flags) && function(t, e, i) {
                    ts(e[11], 0, e, i, Bn(t, i, e), Yn(i.parent || e[6], i, e))
                }(s, n, r)
            }

            function ga(t, e, i) {
                return ma(t, "", e, "", i), ga
            }

            function ma(t, e, i, n, s) {
                const r = Bt(),
                    a = Xr(r, e, i, n);
                return a !== fs && Ns(Ht(), be(), r, t, a, r[11], s, !1), ma
            }

            function ba(t, e, i, n, s) {
                const r = t[i + 1],
                    a = null === e;
                let o = n ? ys(r) : xs(r),
                    l = !1;
                for (; 0 !== o && (!1 === l || a);) {
                    const i = t[o + 1];
                    ya(t[o], e) && (l = !0, t[o + 1] = n ? ws(i) : vs(i)), o = n ? ys(i) : xs(i)
                }
                l && (t[i + 1] = n ? vs(r) : ws(r))
            }

            function ya(t, e) {
                return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && fi(t, e) >= 0
            }
            const va = {
                textEnd: 0,
                key: 0,
                keyEnd: 0,
                value: 0,
                valueEnd: 0
            };

            function xa(t) {
                return t.substring(va.key, va.keyEnd)
            }

            function _a(t, e) {
                const i = va.textEnd;
                return i === e ? -1 : (e = va.keyEnd = function(t, e, i) {
                    for (; e < i && t.charCodeAt(e) > 32;) e++;
                    return e
                }(t, va.key = e, i), wa(t, e, i))
            }

            function wa(t, e, i) {
                for (; e < i && t.charCodeAt(e) <= 32;) e++;
                return e
            }

            function Ca(t, e, i) {
                return Oa(t, e, i, !1), Ca
            }

            function ka(t, e) {
                return Oa(t, e, null, !0), ka
            }

            function Sa(t) {
                Ea(di, Aa, t, !0)
            }

            function Aa(t, e) {
                for (let i = function(t) {
                        return function(t) {
                            va.key = 0, va.keyEnd = 0, va.value = 0, va.valueEnd = 0, va.textEnd = t.length
                        }(t), _a(t, wa(t, 0, va.textEnd))
                    }(e); i >= 0; i = _a(e, i)) di(t, xa(e), !0)
            }

            function Oa(t, e, i, n) {
                const s = Bt(),
                    r = Ht(),
                    a = ee(2);
                r.firstUpdatePass && Ta(r, t, a, n), e !== fs && Br(s, a, e) && Ma(r, r.data[ge()], s, s[11], t, s[a + 1] = function(t, e) {
                    return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = h(zi(t)))), t
                }(e, i), n, a)
            }

            function Ea(t, e, i, n) {
                const s = Ht(),
                    r = ee(2);
                s.firstUpdatePass && Ta(s, null, r, n);
                const a = Bt();
                if (i !== fs && Br(a, r, i)) {
                    const o = s.data[ge()];
                    if (ja(o, n) && !Pa(s, r)) {
                        let t = n ? o.classesWithoutHost : o.stylesWithoutHost;
                        null !== t && (i = u(t, i || "")), Zr(s, o, a, i, n)
                    } else ! function(t, e, i, n, s, r, a, o) {
                        s === fs && (s = H);
                        let l = 0,
                            c = 0,
                            h = 0 < s.length ? s[0] : null,
                            u = 0 < r.length ? r[0] : null;
                        for (; null !== h || null !== u;) {
                            const d = l < s.length ? s[l + 1] : void 0,
                                p = c < r.length ? r[c + 1] : void 0;
                            let f, g = null;
                            h === u ? (l += 2, c += 2, d !== p && (g = u, f = p)) : null === u || null !== h && h < u ? (l += 2, g = h) : (c += 2, g = u, f = p), null !== g && Ma(t, e, i, n, g, f, a, o), h = l < s.length ? s[l] : null, u = c < r.length ? r[c] : null
                        }
                    }(s, o, a, a[11], a[r + 1], a[r + 1] = function(t, e, i) {
                        if (null == i || "" === i) return H;
                        const n = [],
                            s = zi(i);
                        if (Array.isArray(s))
                            for (let r = 0; r < s.length; r++) t(n, s[r], !0);
                        else if ("object" == typeof s)
                            for (const r in s) s.hasOwnProperty(r) && t(n, r, s[r]);
                        else "string" == typeof s && e(n, s);
                        return n
                    }(t, e, i), n, r)
                }
            }

            function Pa(t, e) {
                return e >= t.expandoStartIndex
            }

            function Ta(t, e, i, n) {
                const s = t.data;
                if (null === s[i + 1]) {
                    const r = s[ge()],
                        a = Pa(t, i);
                    ja(r, n) && null === e && !a && (e = !1), e = function(t, e, i, n) {
                            const s = se(t);
                            let r = n ? e.residualClasses : e.residualStyles;
                            if (null === s) 0 === (n ? e.classBindings : e.styleBindings) && (i = Ia(i = Da(null, t, e, i, n), e.attrs, n), r = null);
                            else {
                                const a = e.directiveStylingLast;
                                if (-1 === a || t[a] !== s)
                                    if (i = Da(s, t, e, i, n), null === r) {
                                        let i = function(t, e, i) {
                                            const n = i ? e.classBindings : e.styleBindings;
                                            if (0 !== xs(n)) return t[ys(n)]
                                        }(t, e, n);
                                        void 0 !== i && Array.isArray(i) && (i = Da(null, t, e, i[1], n), i = Ia(i, e.attrs, n), function(t, e, i, n) {
                                            t[ys(i ? e.classBindings : e.styleBindings)] = n
                                        }(t, e, n, i))
                                    } else r = function(t, e, i) {
                                        let n;
                                        const s = e.directiveEnd;
                                        for (let r = 1 + e.directiveStylingLast; r < s; r++) n = Ia(n, t[r].hostAttrs, i);
                                        return Ia(n, e.attrs, i)
                                    }(t, e, n)
                            }
                            return void 0 !== r && (n ? e.residualClasses = r : e.residualStyles = r), i
                        }(s, r, e, n),
                        function(t, e, i, n, s, r) {
                            let a = r ? e.classBindings : e.styleBindings,
                                o = ys(a),
                                l = xs(a);
                            t[n] = i;
                            let c, h = !1;
                            if (Array.isArray(i)) {
                                const t = i;
                                c = t[1], (null === c || fi(t, c) > 0) && (h = !0)
                            } else c = i;
                            if (s)
                                if (0 !== l) {
                                    const e = ys(t[o + 1]);
                                    t[n + 1] = bs(e, o), 0 !== e && (t[e + 1] = _s(t[e + 1], n)), t[o + 1] = 131071 & t[o + 1] | n << 17
                                } else t[n + 1] = bs(o, 0), 0 !== o && (t[o + 1] = _s(t[o + 1], n)), o = n;
                            else t[n + 1] = bs(l, 0), 0 === o ? o = n : t[l + 1] = _s(t[l + 1], n), l = n;
                            h && (t[n + 1] = vs(t[n + 1])), ba(t, c, n, !0), ba(t, c, n, !1),
                                function(t, e, i, n, s) {
                                    const r = s ? t.residualClasses : t.residualStyles;
                                    null != r && "string" == typeof e && fi(r, e) >= 0 && (i[n + 1] = ws(i[n + 1]))
                                }(e, c, t, n, r), a = bs(o, l), r ? e.classBindings = a : e.styleBindings = a
                        }(s, r, e, i, a, n)
                }
            }

            function Da(t, e, i, n, s) {
                let r = null;
                const a = i.directiveEnd;
                let o = i.directiveStylingLast;
                for (-1 === o ? o = i.directiveStart : o++; o < a && (r = e[o], n = Ia(n, r.hostAttrs, s), r !== t);) o++;
                return null !== t && (i.directiveStylingLast = o), n
            }

            function Ia(t, e, i) {
                const n = i ? 1 : 2;
                let s = -1;
                if (null !== e)
                    for (let r = 0; r < e.length; r++) {
                        const a = e[r];
                        "number" == typeof a ? s = a : s === n && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), di(t, a, !!i || e[++r]))
                    }
                return void 0 === t ? null : t
            }

            function Ma(t, e, i, n, s, r, a, o) {
                if (!(3 & e.type)) return;
                const l = t.data,
                    c = l[o + 1];
                Ra(1 == (1 & c) ? La(l, e, i, s, xs(c), a) : void 0) || (Ra(r) || 2 == (2 & c) && (r = La(l, null, i, s, o, a)), function(t, e, i, n, s) {
                    const r = St(t);
                    if (e) s ? r ? t.addClass(i, n) : i.classList.add(n) : r ? t.removeClass(i, n) : i.classList.remove(n);
                    else {
                        let e = -1 === n.indexOf("-") ? void 0 : Pn.DashCase;
                        if (null == s) r ? t.removeStyle(i, n, e) : i.style.removeProperty(n);
                        else {
                            const a = "string" == typeof s && s.endsWith("!important");
                            a && (s = s.slice(0, -10), e |= Pn.Important), r ? t.setStyle(i, n, s, e) : i.style.setProperty(n, s, a ? "important" : "")
                        }
                    }
                }(n, a, Et(ge(), i), s, r))
            }

            function La(t, e, i, n, s, r) {
                const a = null === e;
                let o;
                for (; s > 0;) {
                    const e = t[s],
                        r = Array.isArray(e),
                        l = r ? e[1] : e,
                        c = null === l;
                    let h = i[s + 1];
                    h === fs && (h = c ? H : void 0);
                    let u = c ? pi(h, n) : l === n ? h : void 0;
                    if (r && !Ra(u) && (u = pi(e, n)), Ra(u) && (o = u, a)) return o;
                    const d = t[s + 1];
                    s = a ? ys(d) : xs(d)
                }
                if (null !== e) {
                    let t = r ? e.residualClasses : e.residualStyles;
                    null != t && (o = pi(t, n))
                }
                return o
            }

            function Ra(t) {
                return void 0 !== t
            }

            function ja(t, e) {
                return 0 != (t.flags & (e ? 16 : 32))
            }

            function Fa(t, e = "") {
                const i = Bt(),
                    n = Ht(),
                    s = t + 20,
                    r = n.firstCreatePass ? Ss(n, s, 1, e, null) : n.data[s],
                    a = i[s] = function(t, e) {
                        return St(t) ? t.createText(e) : t.createTextNode(e)
                    }(i[11], e);
                qn(n, i, a, r), Yt(r, !1)
            }

            function Na(t) {
                return za("", t, ""), Na
            }

            function za(t, e, i) {
                const n = Bt(),
                    s = Xr(n, t, e, i);
                return s !== fs && hr(n, ge(), s), za
            }

            function Va(t, e, i, n, s) {
                const r = Bt(),
                    a = function(t, e, i, n, s, r) {
                        const a = Hr(t, Kt(), i, s);
                        return ee(2), a ? e + b(i) + n + b(s) + r : fs
                    }(r, t, e, i, n, s);
                return a !== fs && hr(r, ge(), a), Va
            }

            function Ba(t) {
                const e = Bt(),
                    i = function(t, e) {
                        let i = !1,
                            n = Kt();
                        for (let r = 1; r < e.length; r += 2) i = Br(t, n++, e[r]) || i;
                        if (Jt(n), !i) return fs;
                        let s = e[0];
                        for (let r = 1; r < e.length; r += 2) s += b(e[r]) + e[r + 1];
                        return s
                    }(e, t);
                return i !== fs && hr(e, ge(), i), Ba
            }

            function Ha(t, e, i) {
                Ea(di, Aa, Xr(Bt(), t, e, i), !0)
            }

            function Ua(t, e, i) {
                const n = Bt();
                return Br(n, te(), e) && Ns(Ht(), be(), n, t, e, n[11], i, !0), Ua
            }

            function Xa(t, e, i) {
                const n = Bt();
                if (Br(n, te(), e)) {
                    const s = Ht(),
                        r = be();
                    Ns(s, r, n, t, e, or(se(s.data), r, n), i, !0)
                }
                return Xa
            }
            const Wa = void 0;
            var Ya = ["en", [
                    ["a", "p"],
                    ["AM", "PM"], Wa
                ],
                [
                    ["AM", "PM"], Wa, Wa
                ],
                [
                    ["S", "M", "T", "W", "T", "F", "S"],
                    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                ], Wa, [
                    ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                    ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                ], Wa, [
                    ["B", "A"],
                    ["BC", "AD"],
                    ["Before Christ", "Anno Domini"]
                ], 0, [6, 0],
                ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
                ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
                ["{1}, {0}", Wa, "{1} 'at' {0}", Wa],
                [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
                ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
                function(t) {
                    let e = Math.floor(Math.abs(t)),
                        i = t.toString().replace(/^[^.]*\.?/, "").length;
                    return 1 === e && 0 === i ? 1 : 5
                }
            ];
            let Ga = {};

            function qa(t, e, i) {
                "string" != typeof e && (i = e, e = t[Ja.LocaleId]), e = e.toLowerCase().replace(/_/g, "-"), Ga[e] = t, i && (Ga[e][Ja.ExtraData] = i)
            }

            function Za(t) {
                const e = function(t) {
                    return t.toLowerCase().replace(/_/g, "-")
                }(t);
                let i = Ka(e);
                if (i) return i;
                const n = e.split("-")[0];
                if (i = Ka(n), i) return i;
                if ("en" === n) return Ya;
                throw new Error(`Missing locale data for the locale "${t}".`)
            }

            function $a(t) {
                return Za(t)[Ja.CurrencyCode] || null
            }

            function Qa(t) {
                return Za(t)[Ja.PluralCase]
            }

            function Ka(t) {
                return t in Ga || (Ga[t] = V.ng && V.ng.common && V.ng.common.locales && V.ng.common.locales[t]), Ga[t]
            }
            var Ja = function(t) {
                return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t
            }({});
            let to = "en-US";

            function eo(t) {
                var e, i;
                i = "Expected localeId to be defined", null == (e = t) && function(t, e, i, n) {
                    throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)
                }(i, e), "string" == typeof t && (to = t.toLowerCase().replace(/_/g, "-"))
            }

            function io(t, e, i, n, s) {
                if (t = f(t), Array.isArray(t))
                    for (let r = 0; r < t.length; r++) io(t[r], e, i, n, s);
                else {
                    const r = Ht(),
                        a = Bt();
                    let o = Ar(t) ? t : f(t.provide),
                        l = Cr(t);
                    const c = Xt(),
                        h = 1048575 & c.providerIndexes,
                        u = c.directiveStart,
                        d = c.providerIndexes >> 20;
                    if (Ar(t) || !t.multi) {
                        const n = new Ae(l, s, Gr),
                            p = ro(o, e, s ? h : h + d, u); - 1 === p ? (He(Ne(c, a), r, o), no(r, t, e.length), e.push(o), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), i.push(n), a.push(n)) : (i[p] = n, a[p] = n)
                    } else {
                        const p = ro(o, e, h + d, u),
                            f = ro(o, e, h, h + d),
                            g = p >= 0 && i[p],
                            m = f >= 0 && i[f];
                        if (s && !m || !s && !g) {
                            He(Ne(c, a), r, o);
                            const h = function(t, e, i, n, s) {
                                const r = new Ae(t, i, Gr);
                                return r.multi = [], r.index = e, r.componentProviders = 0, so(r, s, n && !i), r
                            }(s ? oo : ao, i.length, s, n, l);
                            !s && m && (i[f].providerFactory = h), no(r, t, e.length, 0), e.push(o), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), i.push(h), a.push(h)
                        } else no(r, t, p > -1 ? p : f, so(i[s ? f : p], l, !s && n));
                        !s && n && m && i[f].componentProviders++
                    }
                }
            }

            function no(t, e, i, n) {
                const s = Ar(e);
                if (s || e.useClass) {
                    const r = (e.useClass || e).prototype.ngOnDestroy;
                    if (r) {
                        const a = t.destroyHooks || (t.destroyHooks = []);
                        if (!s && e.multi) {
                            const t = a.indexOf(i); - 1 === t ? a.push(i, [n, r]) : a[t + 1].push(n, r)
                        } else a.push(i, r)
                    }
                }
            }

            function so(t, e, i) {
                return i && t.componentProviders++, t.multi.push(e) - 1
            }

            function ro(t, e, i, n) {
                for (let s = i; s < n; s++)
                    if (e[s] === t) return s;
                return -1
            }

            function ao(t, e, i, n) {
                return lo(this.multi, [])
            }

            function oo(t, e, i, n) {
                const s = this.multi;
                let r;
                if (this.providerFactory) {
                    const t = this.providerFactory.componentProviders,
                        e = $e(i, i[1], this.providerFactory.index, n);
                    r = e.slice(0, t), lo(s, r);
                    for (let i = t; i < e.length; i++) r.push(e[i])
                } else r = [], lo(s, r);
                return r
            }

            function lo(t, e) {
                for (let i = 0; i < t.length; i++) e.push((0, t[i])());
                return e
            }

            function co(t, e = []) {
                return i => {
                    i.providersResolver = (i, n) => function(t, e, i) {
                        const n = Ht();
                        if (n.firstCreatePass) {
                            const s = ft(t);
                            io(i, n.data, n.blueprint, s, !0), io(e, n.data, n.blueprint, s, !1)
                        }
                    }(i, n ? n(t) : t, e)
                }
            }
            class ho {}
            class uo {
                resolveComponentFactory(t) {
                    throw function(t) {
                        const e = Error(`No component factory found for ${h(t)}. Did you add it to @NgModule.entryComponents?`);
                        return e.ngComponent = t, e
                    }(t)
                }
            }
            let po = (() => {
                class t {}
                return t.NULL = new uo, t
            })();

            function fo(...t) {}

            function go(t, e) {
                return new bo(Pt(t, e))
            }
            const mo = function() {
                return go(Xt(), Bt())
            };
            let bo = (() => {
                class t {
                    constructor(t) {
                        this.nativeElement = t
                    }
                }
                return t.__NG_ELEMENT_ID__ = mo, t
            })();

            function yo(t) {
                return t instanceof bo ? t.nativeElement : t
            }
            class vo {}
            let xo = (() => {
                class t {}
                return t.__NG_ELEMENT_ID__ = () => _o(), t
            })();
            const _o = function() {
                const t = Bt(),
                    e = It(Xt().index, t);
                return function(t) {
                    return t[11]
                }(ct(e) ? e : t)
            };
            let wo = (() => {
                class t {}
                return t.\u0275prov = x({
                    token: t,
                    providedIn: "root",
                    factory: () => null
                }), t
            })();
            class Co {
                constructor(t) {
                    this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".")
                }
            }
            const ko = new Co("11.2.13");
            class So {
                constructor() {}
                supports(t) {
                    return Nr(t)
                }
                create(t) {
                    return new Oo(t)
                }
            }
            const Ao = (t, e) => e;
            class Oo {
                constructor(t) {
                    this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || Ao
                }
                forEachItem(t) {
                    let e;
                    for (e = this._itHead; null !== e; e = e._next) t(e)
                }
                forEachOperation(t) {
                    let e = this._itHead,
                        i = this._removalsHead,
                        n = 0,
                        s = null;
                    for (; e || i;) {
                        const r = !i || e && e.currentIndex < Do(i, n, s) ? e : i,
                            a = Do(r, n, s),
                            o = r.currentIndex;
                        if (r === i) n--, i = i._nextRemoved;
                        else if (e = e._next, null == r.previousIndex) n++;
                        else {
                            s || (s = []);
                            const t = a - n,
                                e = o - n;
                            if (t != e) {
                                for (let i = 0; i < t; i++) {
                                    const n = i < s.length ? s[i] : s[i] = 0,
                                        r = n + i;
                                    e <= r && r < t && (s[i] = n + 1)
                                }
                                s[r.previousIndex] = e - t
                            }
                        }
                        a !== o && t(r, a, o)
                    }
                }
                forEachPreviousItem(t) {
                    let e;
                    for (e = this._previousItHead; null !== e; e = e._nextPrevious) t(e)
                }
                forEachAddedItem(t) {
                    let e;
                    for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
                }
                forEachMovedItem(t) {
                    let e;
                    for (e = this._movesHead; null !== e; e = e._nextMoved) t(e)
                }
                forEachRemovedItem(t) {
                    let e;
                    for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
                }
                forEachIdentityChange(t) {
                    let e;
                    for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange) t(e)
                }
                diff(t) {
                    if (null == t && (t = []), !Nr(t)) throw new Error(`Error trying to diff '${h(t)}'. Only arrays and iterables are allowed`);
                    return this.check(t) ? this : null
                }
                onDestroy() {}
                check(t) {
                    this._reset();
                    let e, i, n, s = this._itHead,
                        r = !1;
                    if (Array.isArray(t)) {
                        this.length = t.length;
                        for (let e = 0; e < this.length; e++) i = t[e], n = this._trackByFn(e, i), null !== s && Object.is(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, i, n, e)), Object.is(s.item, i) || this._addIdentityChange(s, i)) : (s = this._mismatch(s, i, n, e), r = !0), s = s._next
                    } else e = 0,
                        function(t, e) {
                            if (Array.isArray(t))
                                for (let i = 0; i < t.length; i++) e(t[i]);
                            else {
                                const i = t[jr()]();
                                let n;
                                for (; !(n = i.next()).done;) e(n.value)
                            }
                        }(t, t => {
                            n = this._trackByFn(e, t), null !== s && Object.is(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, t, n, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, n, e), r = !0), s = s._next, e++
                        }), this.length = e;
                    return this._truncate(s), this.collection = t, this.isDirty
                }
                get isDirty() {
                    return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
                }
                _reset() {
                    if (this.isDirty) {
                        let t;
                        for (t = this._previousItHead = this._itHead; null !== t; t = t._next) t._nextPrevious = t._next;
                        for (t = this._additionsHead; null !== t; t = t._nextAdded) t.previousIndex = t.currentIndex;
                        for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved) t.previousIndex = t.currentIndex;
                        this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
                    }
                }
                _mismatch(t, e, i, n) {
                    let s;
                    return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, n)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, n)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, n)) : t = this._addAfter(new Eo(e, i), s, n), t
                }
                _verifyReinsertion(t, e, i, n) {
                    let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null);
                    return null !== s ? t = this._reinsertAfter(s, t._prev, n) : t.currentIndex != n && (t.currentIndex = n, this._addToMoves(t, n)), t
                }
                _truncate(t) {
                    for (; null !== t;) {
                        const e = t._next;
                        this._addToRemovals(this._unlink(t)), t = e
                    }
                    null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
                }
                _reinsertAfter(t, e, i) {
                    null !== this._unlinkedRecords && this._unlinkedRecords.remove(t);
                    const n = t._prevRemoved,
                        s = t._nextRemoved;
                    return null === n ? this._removalsHead = s : n._nextRemoved = s, null === s ? this._removalsTail = n : s._prevRemoved = n, this._insertAfter(t, e, i), this._addToMoves(t, i), t
                }
                _moveAfter(t, e, i) {
                    return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t
                }
                _addAfter(t, e, i) {
                    return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t
                }
                _insertAfter(t, e, i) {
                    const n = null === e ? this._itHead : e._next;
                    return t._next = n, t._prev = e, null === n ? this._itTail = t : n._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new To), this._linkedRecords.put(t), t.currentIndex = i, t
                }
                _remove(t) {
                    return this._addToRemovals(this._unlink(t))
                }
                _unlink(t) {
                    null !== this._linkedRecords && this._linkedRecords.remove(t);
                    const e = t._prev,
                        i = t._next;
                    return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t
                }
                _addToMoves(t, e) {
                    return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t
                }
                _addToRemovals(t) {
                    return null === this._unlinkedRecords && (this._unlinkedRecords = new To), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t
                }
                _addIdentityChange(t, e) {
                    return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t
                }
            }
            class Eo {
                constructor(t, e) {
                    this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
                }
            }
            class Po {
                constructor() {
                    this._head = null, this._tail = null
                }
                add(t) {
                    null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t)
                }
                get(t, e) {
                    let i;
                    for (i = this._head; null !== i; i = i._nextDup)
                        if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i;
                    return null
                }
                remove(t) {
                    const e = t._prevDup,
                        i = t._nextDup;
                    return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head
                }
            }
            class To {
                constructor() {
                    this.map = new Map
                }
                put(t) {
                    const e = t.trackById;
                    let i = this.map.get(e);
                    i || (i = new Po, this.map.set(e, i)), i.add(t)
                }
                get(t, e) {
                    const i = this.map.get(t);
                    return i ? i.get(t, e) : null
                }
                remove(t) {
                    const e = t.trackById;
                    return this.map.get(e).remove(t) && this.map.delete(e), t
                }
                get isEmpty() {
                    return 0 === this.map.size
                }
                clear() {
                    this.map.clear()
                }
            }

            function Do(t, e, i) {
                const n = t.previousIndex;
                if (null === n) return n;
                let s = 0;
                return i && n < i.length && (s = i[n]), n + e + s
            }
            class Io {
                constructor() {}
                supports(t) {
                    return t instanceof Map || zr(t)
                }
                create() {
                    return new Mo
                }
            }
            class Mo {
                constructor() {
                    this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
                }
                get isDirty() {
                    return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
                }
                forEachItem(t) {
                    let e;
                    for (e = this._mapHead; null !== e; e = e._next) t(e)
                }
                forEachPreviousItem(t) {
                    let e;
                    for (e = this._previousMapHead; null !== e; e = e._nextPrevious) t(e)
                }
                forEachChangedItem(t) {
                    let e;
                    for (e = this._changesHead; null !== e; e = e._nextChanged) t(e)
                }
                forEachAddedItem(t) {
                    let e;
                    for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
                }
                forEachRemovedItem(t) {
                    let e;
                    for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
                }
                diff(t) {
                    if (t) {
                        if (!(t instanceof Map || zr(t))) throw new Error(`Error trying to diff '${h(t)}'. Only maps and objects are allowed`)
                    } else t = new Map;
                    return this.check(t) ? this : null
                }
                onDestroy() {}
                check(t) {
                    this._reset();
                    let e = this._mapHead;
                    if (this._appendAfter = null, this._forEach(t, (t, i) => {
                            if (e && e.key === i) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next;
                            else {
                                const n = this._getOrCreateRecordForKey(i, t);
                                e = this._insertBeforeOrAppend(e, n)
                            }
                        }), e) {
                        e._prev && (e._prev._next = null), this._removalsHead = e;
                        for (let t = e; null !== t; t = t._nextRemoved) t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null
                    }
                    return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
                }
                _insertBeforeOrAppend(t, e) {
                    if (t) {
                        const i = t._prev;
                        return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t
                    }
                    return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null
                }
                _getOrCreateRecordForKey(t, e) {
                    if (this._records.has(t)) {
                        const i = this._records.get(t);
                        this._maybeAddToChanges(i, e);
                        const n = i._prev,
                            s = i._next;
                        return n && (n._next = s), s && (s._prev = n), i._next = null, i._prev = null, i
                    }
                    const i = new Lo(t);
                    return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i
                }
                _reset() {
                    if (this.isDirty) {
                        let t;
                        for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next) t._nextPrevious = t._next;
                        for (t = this._changesHead; null !== t; t = t._nextChanged) t.previousValue = t.currentValue;
                        for (t = this._additionsHead; null != t; t = t._nextAdded) t.previousValue = t.currentValue;
                        this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
                    }
                }
                _maybeAddToChanges(t, e) {
                    Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t))
                }
                _addToAdditions(t) {
                    null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t)
                }
                _addToChanges(t) {
                    null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t)
                }
                _forEach(t, e) {
                    t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i))
                }
            }
            class Lo {
                constructor(t) {
                    this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
                }
            }

            function Ro() {
                return new jo([new So])
            }
            let jo = (() => {
                class t {
                    constructor(t) {
                        this.factories = t
                    }
                    static create(e, i) {
                        if (null != i) {
                            const t = i.factories.slice();
                            e = e.concat(t)
                        }
                        return new t(e)
                    }
                    static extend(e) {
                        return {
                            provide: t,
                            useFactory: i => t.create(e, i || Ro()),
                            deps: [
                                [t, new Ei, new Ai]
                            ]
                        }
                    }
                    find(t) {
                        const e = this.factories.find(e => e.supports(t));
                        if (null != e) return e;
                        throw new Error(`Cannot find a differ supporting object '${t}' of type '${i=t,i.name||typeof i}'`);
                        var i
                    }
                }
                return t.\u0275prov = x({
                    token: t,
                    providedIn: "root",
                    factory: Ro
                }), t
            })();

            function Fo() {
                return new No([new Io])
            }
            let No = (() => {
                class t {
                    constructor(t) {
                        this.factories = t
                    }
                    static create(e, i) {
                        if (i) {
                            const t = i.factories.slice();
                            e = e.concat(t)
                        }
                        return new t(e)
                    }
                    static extend(e) {
                        return {
                            provide: t,
                            useFactory: i => t.create(e, i || Fo()),
                            deps: [
                                [t, new Ei, new Ai]
                            ]
                        }
                    }
                    find(t) {
                        const e = this.factories.find(e => e.supports(t));
                        if (e) return e;
                        throw new Error(`Cannot find a differ supporting object '${t}'`)
                    }
                }
                return t.\u0275prov = x({
                    token: t,
                    providedIn: "root",
                    factory: Fo
                }), t
            })();

            function zo(t, e, i, n, s = !1) {
                for (; null !== i;) {
                    const r = e[i.index];
                    if (null !== r && n.push(Ot(r)), ht(r))
                        for (let t = 10; t < r.length; t++) {
                            const e = r[t],
                                i = e[1].firstChild;
                            null !== i && zo(e[1], e, i, n)
                        }
                    const a = i.type;
                    if (8 & a) zo(t, e, i.child, n);
                    else if (32 & a) {
                        const t = Tn(i, e);
                        let s;
                        for (; s = t();) n.push(s)
                    } else if (16 & a) {
                        const t = $n(e, i);
                        if (Array.isArray(t)) n.push(...t);
                        else {
                            const i = Dn(e[16]);
                            zo(i[1], i, t, n, !0)
                        }
                    }
                    i = s ? i.projectionNext : i.next
                }
                return n
            }
            class Vo {
                constructor(t, e) {
                    this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1
                }
                get rootNodes() {
                    const t = this._lView,
                        e = t[1];
                    return zo(e, t, e.firstChild, [])
                }
                get context() {
                    return this._lView[8]
                }
                get destroyed() {
                    return 256 == (256 & this._lView[2])
                }
                destroy() {
                    if (this._appRef) this._appRef.detachView(this);
                    else if (this._attachedToViewContainer) {
                        const t = this._lView[3];
                        if (ht(t)) {
                            const e = t[8],
                                i = e ? e.indexOf(this) : -1;
                            i > -1 && (Nn(t, i), hi(e, i))
                        }
                        this._attachedToViewContainer = !1
                    }
                    zn(this._lView[1], this._lView)
                }
                onDestroy(t) {
                    js(this._lView[1], this._lView, null, t)
                }
                markForCheck() {
                    tr(this._cdRefInjectingView || this._lView)
                }
                detach() {
                    this._lView[2] &= -129
                }
                reattach() {
                    this._lView[2] |= 128
                }
                detectChanges() {
                    er(this._lView[1], this._lView, this.context)
                }
                checkNoChanges() {
                    ! function(t, e, i) {
                        $t(!0);
                        try {
                            er(t, e, i)
                        } finally {
                            $t(!1)
                        }
                    }(this._lView[1], this._lView, this.context)
                }
                attachToViewContainerRef() {
                    if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                    this._attachedToViewContainer = !0
                }
                detachFromAppRef() {
                    var t;
                    this._appRef = null, Jn(this._lView[1], t = this._lView, t[11], 2, null, null)
                }
                attachToAppRef(t) {
                    if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!");
                    this._appRef = t
                }
            }
            class Bo extends Vo {
                constructor(t) {
                    super(t), this._view = t
                }
                detectChanges() {
                    ir(this._view)
                }
                checkNoChanges() {
                    ! function(t) {
                        $t(!0);
                        try {
                            ir(t)
                        } finally {
                            $t(!1)
                        }
                    }(this._view)
                }
                get context() {
                    return null
                }
            }
            const Ho = Xo;
            let Uo = (() => {
                class t {}
                return t.__NG_ELEMENT_ID__ = Ho, t.__ChangeDetectorRef__ = !0, t
            })();

            function Xo(t = !1) {
                return function(t, e, i) {
                    if (!i && dt(t)) {
                        const i = It(t.index, e);
                        return new Vo(i, i)
                    }
                    return 47 & t.type ? new Vo(e[16], e) : null
                }(Xt(), Bt(), t)
            }
            const Wo = [new Io],
                Yo = new jo([new So]),
                Go = new No(Wo),
                qo = function() {
                    return Ko(Xt(), Bt())
                };
            let Zo = (() => {
                class t {}
                return t.__NG_ELEMENT_ID__ = qo, t
            })();
            const $o = Zo,
                Qo = class extends $o {
                    constructor(t, e, i) {
                        super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i
                    }
                    createEmbeddedView(t) {
                        const e = this._declarationTContainer.tViews,
                            i = ks(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null);
                        i[17] = this._declarationLView[this._declarationTContainer.index];
                        const n = this._declarationLView[19];
                        return null !== n && (i[19] = n.createEmbeddedView(e)), Os(e, i, t), new Vo(i)
                    }
                };

            function Ko(t, e) {
                return 4 & t.type ? new Qo(e, t, go(t, e)) : null
            }
            class Jo {}
            class tl {}
            const el = function() {
                return ol(Xt(), Bt())
            };
            let il = (() => {
                class t {}
                return t.__NG_ELEMENT_ID__ = el, t
            })();
            const nl = il,
                sl = class extends nl {
                    constructor(t, e, i) {
                        super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i
                    }
                    get element() {
                        return go(this._hostTNode, this._hostLView)
                    }
                    get injector() {
                        return new Je(this._hostTNode, this._hostLView)
                    }
                    get parentInjector() {
                        const t = Be(this._hostTNode, this._hostLView);
                        if (Ie(t)) {
                            const e = Le(t, this._hostLView),
                                i = Me(t);
                            return new Je(e[1].data[i + 8], e)
                        }
                        return new Je(null, this._hostLView)
                    }
                    clear() {
                        for (; this.length > 0;) this.remove(this.length - 1)
                    }
                    get(t) {
                        const e = rl(this._lContainer);
                        return null !== e && e[t] || null
                    }
                    get length() {
                        return this._lContainer.length - 10
                    }
                    createEmbeddedView(t, e, i) {
                        const n = t.createEmbeddedView(e || {});
                        return this.insert(n, i), n
                    }
                    createComponent(t, e, i, n, s) {
                        const r = i || this.parentInjector;
                        if (!s && null == t.ngModule && r) {
                            const t = r.get(Jo, null);
                            t && (s = t)
                        }
                        const a = t.create(r, n, void 0, s);
                        return this.insert(a.hostView, e), a
                    }
                    insert(t, e) {
                        const i = t._lView,
                            n = i[1];
                        if (ht(i[3])) {
                            const e = this.indexOf(t);
                            if (-1 !== e) this.detach(e);
                            else {
                                const e = i[3],
                                    n = new sl(e, e[6], e[3]);
                                n.detach(n.indexOf(t))
                            }
                        }
                        const s = this._adjustIndex(e),
                            r = this._lContainer;
                        ! function(t, e, i, n) {
                            const s = 10 + n,
                                r = i.length;
                            n > 0 && (i[s - 1][4] = e), n < r - 10 ? (e[4] = i[s], ci(i, 10 + n, e)) : (i.push(e), e[4] = null), e[3] = i;
                            const a = e[17];
                            null !== a && i !== a && function(t, e) {
                                const i = t[9];
                                e[16] !== e[3][3][16] && (t[2] = !0), null === i ? t[9] = [e] : i.push(e)
                            }(a, e);
                            const o = e[19];
                            null !== o && o.insertView(t), e[2] |= 128
                        }(n, i, r, s);
                        const a = Qn(s, r),
                            o = i[11],
                            l = Wn(o, r[7]);
                        return null !== l && function(t, e, i, n, s, r) {
                            n[0] = s, n[6] = e, Jn(t, n, i, 1, s, r)
                        }(n, r[6], o, i, l, a), t.attachToViewContainerRef(), ci(al(r), s, t), t
                    }
                    move(t, e) {
                        return this.insert(t, e)
                    }
                    indexOf(t) {
                        const e = rl(this._lContainer);
                        return null !== e ? e.indexOf(t) : -1
                    }
                    remove(t) {
                        const e = this._adjustIndex(t, -1),
                            i = Nn(this._lContainer, e);
                        i && (hi(al(this._lContainer), e), zn(i[1], i))
                    }
                    detach(t) {
                        const e = this._adjustIndex(t, -1),
                            i = Nn(this._lContainer, e);
                        return i && null != hi(al(this._lContainer), e) ? new Vo(i) : null
                    }
                    _adjustIndex(t, e = 0) {
                        return null == t ? this.length + e : t
                    }
                };

            function rl(t) {
                return t[8]
            }

            function al(t) {
                return t[8] || (t[8] = [])
            }

            function ol(t, e) {
                let i;
                const n = e[t.index];
                if (ht(n)) i = n;
                else {
                    let s;
                    if (8 & t.type) s = Ot(n);
                    else {
                        const i = e[11];
                        s = i.createComment("");
                        const n = Pt(t, e);
                        Hn(i, Wn(i, n), s, function(t, e) {
                            return St(t) ? t.nextSibling(e) : e.nextSibling
                        }(i, n), !1)
                    }
                    e[t.index] = i = Zs(n, e, s, t), Js(e, i)
                }
                return new sl(i, t, e)
            }
            const ll = {};
            class cl extends po {
                constructor(t) {
                    super(), this.ngModule = t
                }
                resolveComponentFactory(t) {
                    const e = ot(t);
                    return new dl(e, this.ngModule)
                }
            }

            function hl(t) {
                const e = [];
                for (let i in t) t.hasOwnProperty(i) && e.push({
                    propName: t[i],
                    templateName: i
                });
                return e
            }
            const ul = new si("SCHEDULER_TOKEN", {
                providedIn: "root",
                factory: () => An
            });
            class dl extends ho {
                constructor(t, e) {
                    super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(ps).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e
                }
                get inputs() {
                    return hl(this.componentDef.inputs)
                }
                get outputs() {
                    return hl(this.componentDef.outputs)
                }
                create(t, e, i, n) {
                    const s = (n = n || this.ngModule) ? function(t, e) {
                            return {
                                get: (i, n, s) => {
                                    const r = t.get(i, ll, s);
                                    return r !== ll || n === ll ? r : e.get(i, n, s)
                                }
                            }
                        }(t, n.injector) : t,
                        r = s.get(vo, At),
                        a = s.get(wo, null),
                        o = r.createRenderer(null, this.componentDef),
                        l = this.componentDef.selectors[0][0] || "div",
                        c = i ? function(t, e, i) {
                            if (St(t)) return t.selectRootElement(e, i === R.ShadowDom);
                            let n = "string" == typeof e ? t.querySelector(e) : e;
                            return n.textContent = "", n
                        }(o, i, this.componentDef.encapsulation) : jn(r.createRenderer(null, this.componentDef), l, function(t) {
                            const e = t.toLowerCase();
                            return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null
                        }(l)),
                        h = this.componentDef.onPush ? 576 : 528,
                        u = {
                            components: [],
                            scheduler: An,
                            clean: sr,
                            playerHandler: null,
                            flags: 0
                        },
                        d = Rs(0, null, null, 1, 0, null, null, null, null, null),
                        p = ks(null, d, u, h, null, null, r, o, a, s);
                    let f, g;
                    ce(p);
                    try {
                        const t = function(t, e, i, n, s, r) {
                            const a = i[1];
                            i[20] = t;
                            const o = Ss(a, 20, 2, "#host", null),
                                l = o.mergedAttrs = e.hostAttrs;
                            null !== l && (ur(o, l, !0), null !== t && (Oe(s, t, l), null !== o.classes && is(s, t, o.classes), null !== o.styles && es(s, t, o.styles)));
                            const c = n.createRenderer(t, e),
                                h = ks(i, Ls(e), null, e.onPush ? 64 : 16, i[20], o, n, c, null, null);
                            return a.firstCreatePass && (He(Ne(o, i), a, e.type), Hs(a, o), Xs(o, i.length, 1)), Js(i, h), i[20] = h
                        }(c, this.componentDef, p, r, o);
                        if (c)
                            if (i) Oe(o, c, ["ng-version", ko.full]);
                            else {
                                const {
                                    attrs: t,
                                    classes: e
                                } = function(t) {
                                    const e = [],
                                        i = [];
                                    let n = 1,
                                        s = 2;
                                    for (; n < t.length;) {
                                        let r = t[n];
                                        if ("string" == typeof r) 2 === s ? "" !== r && e.push(r, t[++n]) : 8 === s && i.push(r);
                                        else {
                                            if (!ls(s)) break;
                                            s = r
                                        }
                                        n++
                                    }
                                    return {
                                        attrs: e,
                                        classes: i
                                    }
                                }(this.componentDef.selectors[0]);
                                t && Oe(o, c, t), e && e.length > 0 && is(o, c, e.join(" "))
                            } if (g = Tt(d, 20), void 0 !== e) {
                            const t = g.projection = [];
                            for (let i = 0; i < this.ngContentSelectors.length; i++) {
                                const n = e[i];
                                t.push(null != n ? Array.from(n) : null)
                            }
                        }
                        f = function(t, e, i, n, s) {
                            const r = i[1],
                                a = function(t, e, i) {
                                    const n = Xt();
                                    t.firstCreatePass && (i.providersResolver && i.providersResolver(i), Ws(t, n, e, As(t, e, 1, null), i));
                                    const s = $e(e, t, n.directiveStart, n);
                                    Sn(s, e);
                                    const r = Pt(n, e);
                                    return r && Sn(r, e), s
                                }(r, i, e);
                            if (n.components.push(a), t[8] = a, s && s.forEach(t => t(a, e)), e.contentQueries) {
                                const t = Xt();
                                e.contentQueries(1, a, t.directiveStart)
                            }
                            const o = Xt();
                            return !r.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (me(o.index), Vs(i[1], o, 0, o.directiveStart, o.directiveEnd, e), Bs(e, a)), a
                        }(t, this.componentDef, p, u, [Pr]), Os(d, p, null)
                    } finally {
                        fe()
                    }
                    return new pl(this.componentType, f, go(g, p), p, g)
                }
            }
            class pl extends class {} {
                constructor(t, e, i, n, s) {
                    super(), this.location = i, this._rootLView = n, this._tNode = s, this.instance = e, this.hostView = this.changeDetectorRef = new Bo(n), this.componentType = t
                }
                get injector() {
                    return new Je(this._tNode, this._rootLView)
                }
                destroy() {
                    this.hostView.destroy()
                }
                onDestroy(t) {
                    this.hostView.onDestroy(t)
                }
            }
            const fl = new Map;
            class gl extends Jo {
                constructor(t, e) {
                    super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new cl(this);
                    const i = lt(t),
                        n = t[q] || null;
                    n && eo(n), this._bootstrapComponents = En(i.bootstrap), this._r3Injector = xr(t, e, [{
                        provide: Jo,
                        useValue: this
                    }, {
                        provide: po,
                        useValue: this.componentFactoryResolver
                    }], h(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t)
                }
                get(t, e = Er.THROW_IF_NOT_FOUND, i = P.Default) {
                    return t === Er || t === Jo || t === dr ? this : this._r3Injector.get(t, e, i)
                }
                destroy() {
                    const t = this._r3Injector;
                    !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null
                }
                onDestroy(t) {
                    this.destroyCbs.push(t)
                }
            }
            class ml extends tl {
                constructor(t) {
                    super(), this.moduleType = t, null !== lt(t) && function(t) {
                        const e = new Set;
                        ! function t(i) {
                            const n = lt(i, !0),
                                s = n.id;
                            null !== s && (function(t, e, i) {
                                if (e && e !== i) throw new Error(`Duplicate module registered for ${t} - ${h(e)} vs ${h(e.name)}`)
                            }(s, fl.get(s), i), fl.set(s, i));
                            const r = En(n.imports);
                            for (const a of r) e.has(a) || (e.add(a), t(a))
                        }(t)
                    }(t)
                }
                create(t) {
                    return new gl(this.moduleType, t)
                }
            }

            function bl(t, e, i) {
                const n = Qt() + t,
                    s = Bt();
                return s[n] === fs ? Vr(s, n, i ? e.call(i) : e()) : function(t, e) {
                    return t[e]
                }(s, n)
            }

            function yl(t, e, i, n) {
                return wl(Bt(), Qt(), t, e, i, n)
            }

            function vl(t, e, i, n, s) {
                return function(t, e, i, n, s, r, a) {
                    const o = e + i;
                    return Hr(t, o, s, r) ? Vr(t, o + 2, a ? n.call(a, s, r) : n(s, r)) : _l(t, o + 2)
                }(Bt(), Qt(), t, e, i, n, s)
            }

            function xl(t, e, i, n, s, r) {
                return function(t, e, i, n, s, r, a, o) {
                    const l = e + i;
                    return function(t, e, i, n, s) {
                        const r = Hr(t, e, i, n);
                        return Br(t, e + 2, s) || r
                    }(t, l, s, r, a) ? Vr(t, l + 3, o ? n.call(o, s, r, a) : n(s, r, a)) : _l(t, l + 3)
                }(Bt(), Qt(), t, e, i, n, s, r)
            }

            function _l(t, e) {
                const i = t[e];
                return i === fs ? void 0 : i
            }

            function wl(t, e, i, n, s, r) {
                const a = e + i;
                return Br(t, a, s) ? Vr(t, a + 1, r ? n.call(r, s) : n(s)) : _l(t, a + 1)
            }

            function Cl(t, e) {
                const i = Ht();
                let n;
                const s = t + 20;
                i.firstCreatePass ? (n = function(t, e) {
                    if (e)
                        for (let i = e.length - 1; i >= 0; i--) {
                            const n = e[i];
                            if (t === n.name) return n
                        }
                    throw new m("302", `The pipe '${t}' could not be found!`)
                }(e, i.pipeRegistry), i.data[s] = n, n.onDestroy && (i.destroyHooks || (i.destroyHooks = [])).push(s, n.onDestroy)) : n = i.data[s];
                const r = n.factory || (n.factory = gt(n.type)),
                    a = D(Gr);
                try {
                    const t = je(!1),
                        e = r();
                    return je(t),
                        function(t, e, i, n) {
                            i >= t.data.length && (t.data[i] = null, t.blueprint[i] = null), e[i] = n
                        }(i, Bt(), s, e), e
                } finally {
                    D(a)
                }
            }

            function kl(t, e, i) {
                const n = t + 20,
                    s = Bt(),
                    r = Dt(s, n);
                return function(t, e) {
                    return Fr.isWrapped(e) && (e = Fr.unwrap(e), t[Kt()] = fs), e
                }(s, function(t, e) {
                    return t[1].data[e].pure
                }(s, n) ? wl(s, Qt(), e, r.transform, i, r) : r.transform(i))
            }

            function Sl(t) {
                return e => {
                    setTimeout(t, void 0, e)
                }
            }
            const Al = class extends n.a {
                constructor(t = !1) {
                    super(), this.__isAsync = t
                }
                emit(t) {
                    super.next(t)
                }
                subscribe(t, e, i) {
                    var n, r, a;
                    let o = t,
                        l = e || (() => null),
                        c = i;
                    if (t && "object" == typeof t) {
                        const e = t;
                        o = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e), l = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e), c = null === (a = e.complete) || void 0 === a ? void 0 : a.bind(e)
                    }
                    this.__isAsync && (l = Sl(l), o && (o = Sl(o)), c && (c = Sl(c)));
                    const h = super.subscribe({
                        next: o,
                        error: l,
                        complete: c
                    });
                    return t instanceof s.b && t.add(h), h
                }
            };

            function Ol() {
                return this._results[jr()]()
            }
            class El {
                constructor(t = !1) {
                    this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0;
                    const e = jr(),
                        i = El.prototype;
                    i[e] || (i[e] = Ol)
                }
                get changes() {
                    return this._changes || (this._changes = new Al)
                }
                get(t) {
                    return this._results[t]
                }
                map(t) {
                    return this._results.map(t)
                }
                filter(t) {
                    return this._results.filter(t)
                }
                find(t) {
                    return this._results.find(t)
                }
                reduce(t, e) {
                    return this._results.reduce(t, e)
                }
                forEach(t) {
                    this._results.forEach(t)
                }
                some(t) {
                    return this._results.some(t)
                }
                toArray() {
                    return this._results.slice()
                }
                toString() {
                    return this._results.toString()
                }
                reset(t, e) {
                    this.dirty = !1;
                    const i = oi(t);
                    (this._changesDetected = ! function(t, e, i) {
                        if (t.length !== e.length) return !1;
                        for (let n = 0; n < t.length; n++) {
                            let s = t[n],
                                r = e[n];
                            if (i && (s = i(s), r = i(r)), r !== s) return !1
                        }
                        return !0
                    }(this._results, i, e)) && (this._results = i, this.length = i.length, this.last = i[this.length - 1], this.first = i[0])
                }
                notifyOnChanges() {
                    !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this)
                }
                setDirty() {
                    this.dirty = !0
                }
                destroy() {
                    this.changes.complete(), this.changes.unsubscribe()
                }
            }
            class Pl {
                constructor(t) {
                    this.queryList = t, this.matches = null
                }
                clone() {
                    return new Pl(this.queryList)
                }
                setDirty() {
                    this.queryList.setDirty()
                }
            }
            class Tl {
                constructor(t = []) {
                    this.queries = t
                }
                createEmbeddedView(t) {
                    const e = t.queries;
                    if (null !== e) {
                        const i = null !== t.contentQueries ? t.contentQueries[0] : e.length,
                            n = [];
                        for (let t = 0; t < i; t++) {
                            const i = e.getByIndex(t);
                            n.push(this.queries[i.indexInDeclarationView].clone())
                        }
                        return new Tl(n)
                    }
                    return null
                }
                insertView(t) {
                    this.dirtyQueriesWithMatches(t)
                }
                detachView(t) {
                    this.dirtyQueriesWithMatches(t)
                }
                dirtyQueriesWithMatches(t) {
                    for (let e = 0; e < this.queries.length; e++) null !== Xl(t, e).matches && this.queries[e].setDirty()
                }
            }
            class Dl {
                constructor(t, e, i = null) {
                    this.predicate = t, this.flags = e, this.read = i
                }
            }
            class Il {
                constructor(t = []) {
                    this.queries = t
                }
                elementStart(t, e) {
                    for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(t, e)
                }
                elementEnd(t) {
                    for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(t)
                }
                embeddedTView(t) {
                    let e = null;
                    for (let i = 0; i < this.length; i++) {
                        const n = null !== e ? e.length : 0,
                            s = this.getByIndex(i).embeddedTView(t, n);
                        s && (s.indexInDeclarationView = i, null !== e ? e.push(s) : e = [s])
                    }
                    return null !== e ? new Il(e) : null
                }
                template(t, e) {
                    for (let i = 0; i < this.queries.length; i++) this.queries[i].template(t, e)
                }
                getByIndex(t) {
                    return this.queries[t]
                }
                get length() {
                    return this.queries.length
                }
                track(t) {
                    this.queries.push(t)
                }
            }
            class Ml {
                constructor(t, e = -1) {
                    this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e
                }
                elementStart(t, e) {
                    this.isApplyingToNode(e) && this.matchTNode(t, e)
                }
                elementEnd(t) {
                    this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1)
                }
                template(t, e) {
                    this.elementStart(t, e)
                }
                embeddedTView(t, e) {
                    return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Ml(this.metadata)) : null
                }
                isApplyingToNode(t) {
                    if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
                        const e = this._declarationNodeIndex;
                        let i = t.parent;
                        for (; null !== i && 8 & i.type && i.index !== e;) i = i.parent;
                        return e === (null !== i ? i.index : -1)
                    }
                    return this._appliesToNextNode
                }
                matchTNode(t, e) {
                    const i = this.metadata.predicate;
                    if (Array.isArray(i))
                        for (let n = 0; n < i.length; n++) {
                            const s = i[n];
                            this.matchTNodeWithReadOption(t, e, Ll(e, s)), this.matchTNodeWithReadOption(t, e, Ze(e, t, s, !1, !1))
                        } else i === Zo ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Ze(e, t, i, !1, !1))
                }
                matchTNodeWithReadOption(t, e, i) {
                    if (null !== i) {
                        const n = this.metadata.read;
                        if (null !== n)
                            if (n === bo || n === il || n === Zo && 4 & e.type) this.addMatch(e.index, -2);
                            else {
                                const i = Ze(e, t, n, !1, !1);
                                null !== i && this.addMatch(e.index, i)
                            }
                        else this.addMatch(e.index, i)
                    }
                }
                addMatch(t, e) {
                    null === this.matches ? this.matches = [t, e] : this.matches.push(t, e)
                }
            }

            function Ll(t, e) {
                const i = t.localNames;
                if (null !== i)
                    for (let n = 0; n < i.length; n += 2)
                        if (i[n] === e) return i[n + 1];
                return null
            }

            function Rl(t, e, i, n) {
                return -1 === i ? function(t, e) {
                    return 11 & t.type ? go(t, e) : 4 & t.type ? Ko(t, e) : null
                }(e, t) : -2 === i ? function(t, e, i) {
                    return i === bo ? go(e, t) : i === Zo ? Ko(e, t) : i === il ? ol(e, t) : void 0
                }(t, e, n) : $e(t, t[1], i, e)
            }

            function jl(t, e, i, n) {
                const s = e[19].queries[n];
                if (null === s.matches) {
                    const n = t.data,
                        r = i.matches,
                        a = [];
                    for (let t = 0; t < r.length; t += 2) {
                        const s = r[t];
                        a.push(s < 0 ? null : Rl(e, n[s], r[t + 1], i.metadata.read))
                    }
                    s.matches = a
                }
                return s.matches
            }

            function Fl(t, e, i, n) {
                const s = t.queries.getByIndex(i),
                    r = s.matches;
                if (null !== r) {
                    const a = jl(t, e, s, i);
                    for (let t = 0; t < r.length; t += 2) {
                        const i = r[t];
                        if (i > 0) n.push(a[t / 2]);
                        else {
                            const s = r[t + 1],
                                a = e[-i];
                            for (let t = 10; t < a.length; t++) {
                                const e = a[t];
                                e[17] === e[3] && Fl(e[1], e, s, n)
                            }
                            if (null !== a[9]) {
                                const t = a[9];
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e];
                                    Fl(i[1], i, s, n)
                                }
                            }
                        }
                    }
                }
                return n
            }

            function Nl(t) {
                const e = Bt(),
                    i = Ht(),
                    n = re();
                ae(n + 1);
                const s = Xl(i, n);
                if (t.dirty && Lt(e) === (2 == (2 & s.metadata.flags))) {
                    if (null === s.matches) t.reset([]);
                    else {
                        const r = s.crossesNgTemplate ? Fl(i, e, n, []) : jl(i, e, s, n);
                        t.reset(r, yo), t.notifyOnChanges()
                    }
                    return !0
                }
                return !1
            }

            function zl(t, e, i) {
                const n = Ht();
                n.firstCreatePass && (Ul(n, new Dl(t, e, i), -1), 2 == (2 & e) && (n.staticViewQueries = !0)), Hl(n, Bt(), e)
            }

            function Vl(t, e, i, n) {
                const s = Ht();
                if (s.firstCreatePass) {
                    const r = Xt();
                    Ul(s, new Dl(e, i, n), r.index),
                        function(t, e) {
                            const i = t.contentQueries || (t.contentQueries = []);
                            e !== (i.length ? i[i.length - 1] : -1) && i.push(t.queries.length - 1, e)
                        }(s, t), 2 == (2 & i) && (s.staticContentQueries = !0)
                }
                Hl(s, Bt(), i)
            }

            function Bl() {
                return t = Bt(), e = re(), t[19].queries[e].queryList;
                var t, e
            }

            function Hl(t, e, i) {
                const n = new El(4 == (4 & i));
                js(t, e, n, n.destroy), null === e[19] && (e[19] = new Tl), e[19].queries.push(new Pl(n))
            }

            function Ul(t, e, i) {
                null === t.queries && (t.queries = new Il), t.queries.track(new Ml(e, i))
            }

            function Xl(t, e) {
                return t.queries.getByIndex(e)
            }

            function Wl(t = P.Default) {
                const e = Xo(!0);
                if (null != e || t & P.Optional) return e;
                v("ChangeDetectorRef")
            }
            const Yl = new si("Application Initializer");
            let Gl = (() => {
                class t {
                    constructor(t) {
                        this.appInits = t, this.resolve = fo, this.reject = fo, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => {
                            this.resolve = t, this.reject = e
                        })
                    }
                    runInitializers() {
                        if (this.initialized) return;
                        const t = [],
                            e = () => {
                                this.done = !0, this.resolve()
                            };
                        if (this.appInits)
                            for (let i = 0; i < this.appInits.length; i++) {
                                const e = this.appInits[i]();
                                na(e) && t.push(e)
                            }
                        Promise.all(t).then(() => {
                            e()
                        }).catch(t => {
                            this.reject(t)
                        }), 0 === t.length && e(), this.initialized = !0
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_i(Yl, 8))
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const ql = new si("AppId"),
                Zl = {
                    provide: ql,
                    useFactory: function() {
                        return `${$l()}${$l()}${$l()}`
                    },
                    deps: []
                };

            function $l() {
                return String.fromCharCode(97 + Math.floor(25 * Math.random()))
            }
            const Ql = new si("Platform Initializer"),
                Kl = new si("Platform ID"),
                Jl = new si("appBootstrapListener");
            let tc = (() => {
                class t {
                    log(t) {
                        console.log(t)
                    }
                    warn(t) {
                        console.warn(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const ec = new si("LocaleId"),
                ic = new si("DefaultCurrencyCode");
            class nc {
                constructor(t, e) {
                    this.ngModuleFactory = t, this.componentFactories = e
                }
            }
            const sc = function(t) {
                    return new ml(t)
                },
                rc = sc,
                ac = function(t) {
                    return Promise.resolve(sc(t))
                },
                oc = function(t) {
                    const e = sc(t),
                        i = En(lt(t).declarations).reduce((t, e) => {
                            const i = ot(e);
                            return i && t.push(new dl(i)), t
                        }, []);
                    return new nc(e, i)
                },
                lc = oc,
                cc = function(t) {
                    return Promise.resolve(oc(t))
                };
            let hc = (() => {
                class t {
                    constructor() {
                        this.compileModuleSync = rc, this.compileModuleAsync = ac, this.compileModuleAndAllComponentsSync = lc, this.compileModuleAndAllComponentsAsync = cc
                    }
                    clearCache() {}
                    clearCacheFor(t) {}
                    getModuleId(t) {}
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const uc = (() => Promise.resolve(0))();

            function dc(t) {
                "undefined" == typeof Zone ? uc.then(() => {
                    t && t.apply(null, null)
                }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t)
            }
            class pc {
                constructor({
                    enableLongStackTrace: t = !1,
                    shouldCoalesceEventChangeDetection: e = !1,
                    shouldCoalesceRunChangeDetection: i = !1
                }) {
                    if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Al(!1), this.onMicrotaskEmpty = new Al(!1), this.onStable = new Al(!1), this.onError = new Al(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                    Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), this.shouldCoalesceEventChangeDetection = !i && e, this.shouldCoalesceRunChangeDetection = i, this.lastRequestAnimationFrameId = -1, this.nativeRequestAnimationFrame = function() {
                            let t = V.requestAnimationFrame,
                                e = V.cancelAnimationFrame;
                            if ("undefined" != typeof Zone && t && e) {
                                const i = t[Zone.__symbol__("OriginalDelegate")];
                                i && (t = i);
                                const n = e[Zone.__symbol__("OriginalDelegate")];
                                n && (e = n)
                            }
                            return {
                                nativeRequestAnimationFrame: t,
                                nativeCancelAnimationFrame: e
                            }
                        }().nativeRequestAnimationFrame,
                        function(t) {
                            const e = () => {
                                ! function(t) {
                                    -1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(V, () => {
                                        t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
                                            t.lastRequestAnimationFrameId = -1, mc(t), gc(t)
                                        }, void 0, () => {}, () => {})), t.fakeTopEventTask.invoke()
                                    }), mc(t))
                                }(t)
                            };
                            t._inner = t._inner.fork({
                                name: "angular",
                                properties: {
                                    isAngularZone: !0
                                },
                                onInvokeTask: (i, n, s, r, a, o) => {
                                    try {
                                        return bc(t), i.invokeTask(s, r, a, o)
                                    } finally {
                                        (t.shouldCoalesceEventChangeDetection && "eventTask" === r.type || t.shouldCoalesceRunChangeDetection) && e(), yc(t)
                                    }
                                },
                                onInvoke: (i, n, s, r, a, o, l) => {
                                    try {
                                        return bc(t), i.invoke(s, r, a, o, l)
                                    } finally {
                                        t.shouldCoalesceRunChangeDetection && e(), yc(t)
                                    }
                                },
                                onHasTask: (e, i, n, s) => {
                                    e.hasTask(n, s), i === n && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, mc(t), gc(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask))
                                },
                                onHandleError: (e, i, n, s) => (e.handleError(n, s), t.runOutsideAngular(() => t.onError.emit(s)), !1)
                            })
                        }(this)
                }
                static isInAngularZone() {
                    return !0 === Zone.current.get("isAngularZone")
                }
                static assertInAngularZone() {
                    if (!pc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!")
                }
                static assertNotInAngularZone() {
                    if (pc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!")
                }
                run(t, e, i) {
                    return this._inner.run(t, e, i)
                }
                runTask(t, e, i, n) {
                    const s = this._inner,
                        r = s.scheduleEventTask("NgZoneEvent: " + n, t, fc, fo, fo);
                    try {
                        return s.runTask(r, e, i)
                    } finally {
                        s.cancelTask(r)
                    }
                }
                runGuarded(t, e, i) {
                    return this._inner.runGuarded(t, e, i)
                }
                runOutsideAngular(t) {
                    return this._outer.run(t)
                }
            }
            const fc = {};

            function gc(t) {
                if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try {
                    t._nesting++, t.onMicrotaskEmpty.emit(null)
                } finally {
                    if (t._nesting--, !t.hasPendingMicrotasks) try {
                        t.runOutsideAngular(() => t.onStable.emit(null))
                    } finally {
                        t.isStable = !0
                    }
                }
            }

            function mc(t) {
                t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId)
            }

            function bc(t) {
                t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null))
            }

            function yc(t) {
                t._nesting--, gc(t)
            }
            class vc {
                constructor() {
                    this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Al, this.onMicrotaskEmpty = new Al, this.onStable = new Al, this.onError = new Al
                }
                run(t, e, i) {
                    return t.apply(e, i)
                }
                runGuarded(t, e, i) {
                    return t.apply(e, i)
                }
                runOutsideAngular(t) {
                    return t()
                }
                runTask(t, e, i, n) {
                    return t.apply(e, i)
                }
            }
            let xc = (() => {
                    class t {
                        constructor(t) {
                            this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => {
                                this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone")
                            })
                        }
                        _watchAngularEvents() {
                            this._ngZone.onUnstable.subscribe({
                                next: () => {
                                    this._didWork = !0, this._isZoneStable = !1
                                }
                            }), this._ngZone.runOutsideAngular(() => {
                                this._ngZone.onStable.subscribe({
                                    next: () => {
                                        pc.assertNotInAngularZone(), dc(() => {
                                            this._isZoneStable = !0, this._runCallbacksIfReady()
                                        })
                                    }
                                })
                            })
                        }
                        increasePendingRequestCount() {
                            return this._pendingCount += 1, this._didWork = !0, this._pendingCount
                        }
                        decreasePendingRequestCount() {
                            if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                            return this._runCallbacksIfReady(), this._pendingCount
                        }
                        isStable() {
                            return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
                        }
                        _runCallbacksIfReady() {
                            if (this.isStable()) dc(() => {
                                for (; 0 !== this._callbacks.length;) {
                                    let t = this._callbacks.pop();
                                    clearTimeout(t.timeoutId), t.doneCb(this._didWork)
                                }
                                this._didWork = !1
                            });
                            else {
                                let t = this.getPendingTasks();
                                this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0
                            }
                        }
                        getPendingTasks() {
                            return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({
                                source: t.source,
                                creationLocation: t.creationLocation,
                                data: t.data
                            })) : []
                        }
                        addCallback(t, e, i) {
                            let n = -1;
                            e && e > 0 && (n = setTimeout(() => {
                                this._callbacks = this._callbacks.filter(t => t.timeoutId !== n), t(this._didWork, this.getPendingTasks())
                            }, e)), this._callbacks.push({
                                doneCb: t,
                                timeoutId: n,
                                updateCb: i
                            })
                        }
                        whenStable(t, e, i) {
                            if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                            this.addCallback(t, e, i), this._runCallbacksIfReady()
                        }
                        getPendingRequestCount() {
                            return this._pendingCount
                        }
                        findProviders(t, e, i) {
                            return []
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(_i(pc))
                    }, t.\u0275prov = x({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                _c = (() => {
                    class t {
                        constructor() {
                            this._applications = new Map, Sc.addToWindow(this)
                        }
                        registerApplication(t, e) {
                            this._applications.set(t, e)
                        }
                        unregisterApplication(t) {
                            this._applications.delete(t)
                        }
                        unregisterAllApplications() {
                            this._applications.clear()
                        }
                        getTestability(t) {
                            return this._applications.get(t) || null
                        }
                        getAllTestabilities() {
                            return Array.from(this._applications.values())
                        }
                        getAllRootElements() {
                            return Array.from(this._applications.keys())
                        }
                        findTestabilityInTree(t, e = !0) {
                            return Sc.findTestabilityInTree(this, t, e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = x({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })();
            class wc {
                addToWindow(t) {}
                findTestabilityInTree(t, e, i) {
                    return null
                }
            }

            function Cc(t) {
                Sc = t
            }
            let kc, Sc = new wc,
                Ac = !0,
                Oc = !1;

            function Ec() {
                return Oc = !0, Ac
            }

            function Pc() {
                if (Oc) throw new Error("Cannot enable prod mode after platform setup.");
                Ac = !1
            }
            const Tc = new si("AllowMultipleToken");
            class Dc {
                constructor(t, e) {
                    this.name = t, this.token = e
                }
            }

            function Ic(t, e, i = []) {
                const n = `Platform: ${e}`,
                    s = new si(n);
                return (e = []) => {
                    let r = Mc();
                    if (!r || r.injector.get(Tc, !1))
                        if (t) t(i.concat(e).concat({
                            provide: s,
                            useValue: !0
                        }));
                        else {
                            const t = i.concat(e).concat({
                                provide: s,
                                useValue: !0
                            }, {
                                provide: fr,
                                useValue: "platform"
                            });
                            ! function(t) {
                                if (kc && !kc.destroyed && !kc.injector.get(Tc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                                kc = t.get(Lc);
                                const e = t.get(Ql, null);
                                e && e.forEach(t => t())
                            }(Er.create({
                                providers: t,
                                name: n
                            }))
                        } return function(t) {
                        const e = Mc();
                        if (!e) throw new Error("No platform exists!");
                        if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                        return e
                    }(s)
                }
            }

            function Mc() {
                return kc && !kc.destroyed ? kc : null
            }
            let Lc = (() => {
                class t {
                    constructor(t) {
                        this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1
                    }
                    bootstrapModuleFactory(t, e) {
                        const i = function(t, e) {
                                let i;
                                return i = "noop" === t ? new vc : ("zone.js" === t ? void 0 : t) || new pc({
                                    enableLongStackTrace: Ec(),
                                    shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing),
                                    shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing)
                                }), i
                            }(e ? e.ngZone : void 0, {
                                ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1,
                                ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1
                            }),
                            n = [{
                                provide: pc,
                                useValue: i
                            }];
                        return i.run(() => {
                            const e = Er.create({
                                    providers: n,
                                    parent: this.injector,
                                    name: t.moduleType.name
                                }),
                                s = t.create(e),
                                r = s.injector.get(kn, null);
                            if (!r) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                            return i.runOutsideAngular(() => {
                                    const t = i.onError.subscribe({
                                        next: t => {
                                            r.handleError(t)
                                        }
                                    });
                                    s.onDestroy(() => {
                                        Fc(this._modules, s), t.unsubscribe()
                                    })
                                }),
                                function(t, e, i) {
                                    try {
                                        const n = i();
                                        return na(n) ? n.catch(i => {
                                            throw e.runOutsideAngular(() => t.handleError(i)), i
                                        }) : n
                                    } catch (n) {
                                        throw e.runOutsideAngular(() => t.handleError(n)), n
                                    }
                                }(r, i, () => {
                                    const t = s.injector.get(Gl);
                                    return t.runInitializers(), t.donePromise.then(() => (eo(s.injector.get(ec, "en-US") || "en-US"), this._moduleDoBootstrap(s), s))
                                })
                        })
                    }
                    bootstrapModule(t, e = []) {
                        const i = Rc({}, e);
                        return function(t, e, i) {
                            const n = new ml(i);
                            return Promise.resolve(n)
                        }(0, 0, t).then(t => this.bootstrapModuleFactory(t, i))
                    }
                    _moduleDoBootstrap(t) {
                        const e = t.injector.get(jc);
                        if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t));
                        else {
                            if (!t.instance.ngDoBootstrap) throw new Error(`The module ${h(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
                            t.instance.ngDoBootstrap(e)
                        }
                        this._modules.push(t)
                    }
                    onDestroy(t) {
                        this._destroyListeners.push(t)
                    }
                    get injector() {
                        return this._injector
                    }
                    destroy() {
                        if (this._destroyed) throw new Error("The platform has already been destroyed!");
                        this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0
                    }
                    get destroyed() {
                        return this._destroyed
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_i(Er))
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function Rc(t, e) {
                return Array.isArray(e) ? e.reduce(Rc, t) : Object.assign(Object.assign({}, t), e)
            }
            let jc = (() => {
                class t {
                    constructor(t, e, i, n, s) {
                        this._zone = t, this._injector = e, this._exceptionHandler = i, this._componentFactoryResolver = n, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                            next: () => {
                                this._zone.run(() => {
                                    this.tick()
                                })
                            }
                        });
                        const l = new r.a(t => {
                                this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => {
                                    t.next(this._stable), t.complete()
                                })
                            }),
                            c = new r.a(t => {
                                let e;
                                this._zone.runOutsideAngular(() => {
                                    e = this._zone.onStable.subscribe(() => {
                                        pc.assertNotInAngularZone(), dc(() => {
                                            this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0))
                                        })
                                    })
                                });
                                const i = this._zone.onUnstable.subscribe(() => {
                                    pc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                        t.next(!1)
                                    }))
                                });
                                return () => {
                                    e.unsubscribe(), i.unsubscribe()
                                }
                            });
                        this.isStable = Object(a.a)(l, c.pipe(Object(o.a)()))
                    }
                    bootstrap(t, e) {
                        if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                        let i;
                        i = t instanceof ho ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(i.componentType);
                        const n = i.isBoundToModule ? void 0 : this._injector.get(Jo),
                            s = i.create(Er.NULL, [], e || i.selector, n),
                            r = s.location.nativeElement,
                            a = s.injector.get(xc, null),
                            o = a && s.injector.get(_c);
                        return a && o && o.registerApplication(r, a), s.onDestroy(() => {
                            this.detachView(s.hostView), Fc(this.components, s), o && o.unregisterApplication(r)
                        }), this._loadComponent(s), s
                    }
                    tick() {
                        if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                        try {
                            this._runningTick = !0;
                            for (let t of this._views) t.detectChanges()
                        } catch (t) {
                            this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t))
                        } finally {
                            this._runningTick = !1
                        }
                    }
                    attachView(t) {
                        const e = t;
                        this._views.push(e), e.attachToAppRef(this)
                    }
                    detachView(t) {
                        const e = t;
                        Fc(this._views, e), e.detachFromAppRef()
                    }
                    _loadComponent(t) {
                        this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Jl, []).concat(this._bootstrapListeners).forEach(e => e(t))
                    }
                    ngOnDestroy() {
                        this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe()
                    }
                    get viewCount() {
                        return this._views.length
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_i(pc), _i(Er), _i(kn), _i(po), _i(Gl))
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function Fc(t, e) {
                const i = t.indexOf(e);
                i > -1 && t.splice(i, 1)
            }
            class Nc {}
            class zc {}
            const Vc = {
                factoryPathPrefix: "",
                factoryPathSuffix: ".ngfactory"
            };
            let Bc = (() => {
                class t {
                    constructor(t, e) {
                        this._compiler = t, this._config = e || Vc
                    }
                    load(t) {
                        return this.loadAndCompile(t)
                    }
                    loadAndCompile(t) {
                        let [e, n] = t.split("#");
                        return void 0 === n && (n = "default"), i("zn8P")(e).then(t => t[n]).then(t => Hc(t, e, n)).then(t => this._compiler.compileModuleAsync(t))
                    }
                    loadFactory(t) {
                        let [e, n] = t.split("#"), s = "NgFactory";
                        return void 0 === n && (n = "default", s = ""), i("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[n + s]).then(t => Hc(t, e, n))
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_i(hc), _i(zc, 8))
                }, t.\u0275prov = x({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function Hc(t, e, i) {
                if (!t) throw new Error(`Cannot find '${i}' in '${e}'`);
                return t
            }
            class Uc extends Uo {}
            class Xc extends Uc {}
            const Wc = function(t) {
                    return null
                },
                Yc = Ic(null, "core", [{
                    provide: Kl,
                    useValue: "unknown"
                }, {
                    provide: Lc,
                    deps: [Er]
                }, {
                    provide: _c,
                    deps: []
                }, {
                    provide: tc,
                    deps: []
                }]),
                Gc = [{
                    provide: jc,
                    useClass: jc,
                    deps: [pc, Er, kn, po, Gl]
                }, {
                    provide: ul,
                    deps: [pc],
                    useFactory: function(t) {
                        let e = [];
                        return t.onStable.subscribe(() => {
                                for (; e.length;) e.pop()()
                            }),
                            function(t) {
                                e.push(t)
                            }
                    }
                }, {
                    provide: Gl,
                    useClass: Gl,
                    deps: [
                        [new Ai, Yl]
                    ]
                }, {
                    provide: hc,
                    useClass: hc,
                    deps: []
                }, Zl, {
                    provide: jo,
                    useFactory: function() {
                        return Yo
                    },
                    deps: []
                }, {
                    provide: No,
                    useFactory: function() {
                        return Go
                    },
                    deps: []
                }, {
                    provide: ec,
                    useFactory: function(t) {
                        return eo(t = t || "undefined" != typeof $localize && $localize.locale || "en-US"), t
                    },
                    deps: [
                        [new Si(ec), new Ai, new Ei]
                    ]
                }, {
                    provide: ic,
                    useValue: "USD"
                }];
            let qc = (() => {
                class t {
                    constructor(t) {}
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(_i(jc))
                }, t.\u0275mod = it({
                    type: t
                }), t.\u0275inj = _({
                    providers: Gc
                }), t
            })()
        },
        ffME: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("CZFc"),
                s = i("Qd51");

            function r(t, e, i) {
                var r, a;
                let o, l = !1;
                return t && "object" == typeof t ? (o = null !== (r = t.bufferSize) && void 0 !== r ? r : 1 / 0, e = null !== (a = t.windowTime) && void 0 !== a ? a : 1 / 0, l = !!t.refCount, i = t.scheduler) : o = null != t ? t : 1 / 0, Object(s.a)({
                    connector: () => new n.a(o, e, i),
                    resetOnError: !0,
                    resetOnComplete: !1,
                    resetOnRefCountZero: l
                })
            }
        },
        foWl: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            }), i.d(e, "b", function() {
                return a
            });
            var n = i("4krO"),
                s = i("fXoL");
            let r = (() => {
                    class t {
                        login() {
                            localStorage.setItem("token", "token")
                        }
                        sign() {
                            localStorage.setItem("token", "token")
                        }
                        signOut() {
                            localStorage.removeItem("token")
                        }
                        getUser() {
                            return Object(n.a)({
                                name: "John",
                                lastName: "Smith"
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })(),
                a = (() => {
                    class t {
                        loadEmails() {
                            return Object(n.a)([{
                                name: "Jane Hew",
                                time: "9:32",
                                message: "Hey! How is it going?"
                            }, {
                                name: "Lloyd Brown",
                                time: "9:18",
                                message: "Check out my new Dashboard"
                            }, {
                                name: "Mark Winstein",
                                time: "9:15",
                                message: "I want rearrange the appointment"
                            }, {
                                name: "Liana Dutti",
                                time: "9:09",
                                message: "Good news from sale department"
                            }])
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac,
                        providedIn: "root"
                    }), t
                })()
        },
        "g+Sw": function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("tmVS"),
                s = i("vfWG"),
                r = i("1lu8");

            function a(...t) {
                return Object(n.a)(1)(Object(s.a)(t, Object(r.c)(t)))
            }
        },
        "g/MW": function(t, e, i) {
            "use strict";

            function n(t) {
                return this instanceof n ? (this.v = t, this) : new n(t)
            }

            function s(t, e, i) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var s, r = i.apply(t, e || []),
                    a = [];
                return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
                    return this
                }, s;

                function o(t) {
                    r[t] && (s[t] = function(e) {
                        return new Promise(function(i, n) {
                            a.push([t, e, i, n]) > 1 || l(t, e)
                        })
                    })
                }

                function l(t, e) {
                    try {
                        (i = r[t](e)).value instanceof n ? Promise.resolve(i.value.v).then(c, h) : u(a[0][2], i)
                    } catch (s) {
                        u(a[0][3], s)
                    }
                    var i
                }

                function c(t) {
                    l("next", t)
                }

                function h(t) {
                    l("throw", t)
                }

                function u(t, e) {
                    t(e), a.shift(), a.length && l(a[0][0], a[0][1])
                }
            }
            i.d(e, "a", function() {
                return _
            }), i.d(e, "c", function() {
                return w
            }), i.d(e, "b", function() {
                return C
            });
            var r = i("O0iu"),
                a = i("2QHy");

            function o(t) {
                return Object(a.a)(null == t ? void 0 : t.then)
            }
            var l = i("5CXX"),
                c = i("SIQg"),
                h = i("jqqC"),
                u = i("v1EJ");
            const d = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";

            function p(t, e) {
                if (!t) throw new Error("Iterable cannot be null");
                return new c.a(i => {
                    const n = new h.b;
                    return n.add(e.schedule(() => {
                        const s = t[Symbol.asyncIterator]();
                        n.add(e.schedule(function() {
                            s.next().then(t => {
                                t.done ? i.complete() : (i.next(t.value), this.schedule())
                            })
                        }))
                    })), n
                })
            }

            function f(t) {
                return Object(a.a)(t[l.a])
            }

            function g(t) {
                return Object(a.a)(null == t ? void 0 : t[d])
            }

            function m(t) {
                return Symbol.asyncIterator && Object(a.a)(null == t ? void 0 : t[Symbol.asyncIterator])
            }

            function b(t) {
                return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
            }

            function y(t) {
                return s(this, arguments, function*() {
                    const e = t.getReader();
                    try {
                        for (;;) {
                            const {
                                value: t,
                                done: i
                            } = yield n(e.read());
                            if (i) return yield n(void 0);
                            yield yield n(t)
                        }
                    } finally {
                        e.releaseLock()
                    }
                })
            }

            function v(t) {
                return Object(a.a)(null == t ? void 0 : t.getReader)
            }
            var x = i("+qId");

            function _(t, e) {
                return e ? function(t, e) {
                    if (null != t) {
                        if (f(t)) return function(t, e) {
                            return new c.a(i => {
                                const n = new h.b;
                                return n.add(e.schedule(() => {
                                    const s = t[l.a]();
                                    n.add(s.subscribe({
                                        next(t) {
                                            n.add(e.schedule(() => i.next(t)))
                                        },
                                        error(t) {
                                            n.add(e.schedule(() => i.error(t)))
                                        },
                                        complete() {
                                            n.add(e.schedule(() => i.complete()))
                                        }
                                    }))
                                })), n
                            })
                        }(t, e);
                        if (Object(r.a)(t)) return Object(u.a)(t, e);
                        if (o(t)) return function(t, e) {
                            return new c.a(i => e.schedule(() => t.then(t => {
                                i.add(e.schedule(() => {
                                    i.next(t), i.add(e.schedule(() => i.complete()))
                                }))
                            }, t => {
                                i.add(e.schedule(() => i.error(t)))
                            })))
                        }(t, e);
                        if (m(t)) return p(t, e);
                        if (g(t)) return function(t, e) {
                            return new c.a(i => {
                                let n;
                                return i.add(e.schedule(() => {
                                    n = t[d](),
                                        function(t, e, i, n = 0) {
                                            const s = e.schedule(function() {
                                                try {
                                                    i.call(this)
                                                } catch (e) {
                                                    t.error(e)
                                                }
                                            }, n);
                                            t.add(s)
                                        }(i, e, function() {
                                            const {
                                                value: t,
                                                done: e
                                            } = n.next();
                                            e ? i.complete() : (i.next(t), this.schedule())
                                        })
                                })), () => Object(a.a)(null == n ? void 0 : n.return) && n.return()
                            })
                        }(t, e);
                        if (v(t)) return function(t, e) {
                            return p(y(t), e)
                        }(t, e)
                    }
                    throw b(t)
                }(t, e) : w(t)
            }

            function w(t) {
                if (t instanceof c.a) return t;
                if (null != t) {
                    if (f(t)) return n = t, new c.a(t => {
                        const e = n[l.a]();
                        if (Object(a.a)(e.subscribe)) return e.subscribe(t);
                        throw new TypeError("Provided object does not correctly implement Symbol.observable")
                    });
                    if (Object(r.a)(t)) return C(t);
                    if (o(t)) return i = t, new c.a(t => {
                        i.then(e => {
                            t.closed || (t.next(e), t.complete())
                        }, e => t.error(e)).then(null, x.a)
                    });
                    if (m(t)) return k(t);
                    if (g(t)) return e = t, new c.a(t => {
                        for (const i of e)
                            if (t.next(i), t.closed) return;
                        t.complete()
                    });
                    if (v(t)) return k(y(t))
                }
                var e, i, n;
                throw b(t)
            }

            function C(t) {
                return new c.a(e => {
                    for (let i = 0; i < t.length && !e.closed; i++) e.next(t[i]);
                    e.complete()
                })
            }

            function k(t) {
                return new c.a(e => {
                    (function(t, e) {
                        var i, n, s, r, a, o, l;
                        return a = this, void 0, l = function*() {
                            try {
                                for (i = function(t) {
                                        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                                        var e, i = t[Symbol.asyncIterator];
                                        return i ? i.call(t) : (t = function(t) {
                                            var e = "function" == typeof Symbol && Symbol.iterator,
                                                i = e && t[e],
                                                n = 0;
                                            if (i) return i.call(t);
                                            if (t && "number" == typeof t.length) return {
                                                next: function() {
                                                    return t && n >= t.length && (t = void 0), {
                                                        value: t && t[n++],
                                                        done: !t
                                                    }
                                                }
                                            };
                                            throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                                        }(t), e = {}, n("next"), n("throw"), n("return"), e[Symbol.asyncIterator] = function() {
                                            return this
                                        }, e);

                                        function n(i) {
                                            e[i] = t[i] && function(e) {
                                                return new Promise(function(n, s) {
                                                    ! function(t, e, i, n) {
                                                        Promise.resolve(n).then(function(e) {
                                                            t({
                                                                value: e,
                                                                done: i
                                                            })
                                                        }, e)
                                                    }(n, s, (e = t[i](e)).done, e.value)
                                                })
                                            }
                                        }
                                    }(t); !(n = yield i.next()).done;)
                                    if (e.next(n.value), e.closed) return
                            } catch (a) {
                                s = {
                                    error: a
                                }
                            } finally {
                                try {
                                    n && !n.done && (r = i.return) && (yield r.call(i))
                                } finally {
                                    if (s) throw s.error
                                }
                            }
                            e.complete()
                        }, new((o = void 0) || (o = Promise))(function(t, e) {
                            function i(t) {
                                try {
                                    s(l.next(t))
                                } catch (i) {
                                    e(i)
                                }
                            }

                            function n(t) {
                                try {
                                    s(l.throw(t))
                                } catch (i) {
                                    e(i)
                                }
                            }

                            function s(e) {
                                var s;
                                e.done ? t(e.value) : (s = e.value, s instanceof o ? s : new o(function(t) {
                                    t(s)
                                })).then(i, n)
                            }
                            s((l = l.apply(a, [])).next())
                        })
                    })(t, e).catch(t => e.error(t))
                })
            }
        },
        iu6b: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return n
            });
            const n = {
                now: () => (n.delegate || Date).now(),
                delegate: void 0
            }
        },
        jQpT: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("fXoL"),
                s = i("bTqV"),
                r = i("NFeN");
            let a = (() => {
                class t {
                    constructor() {
                        this.flatlogic = "https://flatlogic.com/", this.flatlogicAbout = "https://flatlogic.com/about", this.flatlogicBlog = "https://flatlogic.com/blog"
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = n.Jb({
                    type: t,
                    selectors: [
                        ["app-footer"]
                    ],
                    decls: 15,
                    vars: 3,
                    consts: [
                        [1, "footer"],
                        [1, "footer__link"],
                        [1, "footer__link-item", 3, "href"],
                        [1, "footer__icon"],
                        ["mat-mini-fab", ""],
                        ["fontSet", "fa fa-fs", "fontIcon", "fa-facebook-square"],
                        ["fontSet", "fa fa-fs", "fontIcon", "fa-twitter-square"],
                        ["fontSet", "fa fa-fs", "fontIcon", "fa-github-square"]
                    ],
                    template: function(t, e) {
                        1 & t && (n.Vb(0, "div", 0), n.Vb(1, "div", 1), n.Vb(2, "a", 2), n.Cc(3, "Flatlogic"), n.Ub(), n.Vb(4, "a", 2), n.Cc(5, "About Us"), n.Ub(), n.Vb(6, "a", 2), n.Cc(7, "Blog"), n.Ub(), n.Ub(), n.Vb(8, "div", 3), n.Vb(9, "button", 4), n.Qb(10, "mat-icon", 5), n.Ub(), n.Vb(11, "button", 4), n.Qb(12, "mat-icon", 6), n.Ub(), n.Vb(13, "button", 4), n.Qb(14, "mat-icon", 7), n.Ub(), n.Ub(), n.Ub()), 2 & t && (n.Db(2), n.lc("href", e.flatlogic, n.wc), n.Db(2), n.lc("href", e.flatlogicAbout, n.wc), n.Db(2), n.lc("href", e.flatlogicBlog, n.wc))
                    },
                    directives: [s.b, r.a],
                    styles: [".footer[_ngcontent-%COMP%]{height:48px;margin-top:40px;width:calc(100% - 48px);display:flex;justify-content:space-between;padding:0 24px 24px}@media (max-width:576px){.footer[_ngcontent-%COMP%]{flex-direction:column;align-items:start}}.footer__link[_ngcontent-%COMP%]{display:flex;align-items:center}@media (max-width:576px){.footer__link[_ngcontent-%COMP%]{margin-bottom:8px}.footer__icon[_ngcontent-%COMP%]{margin:0 0 8px -14px}}.footer__link-item[_ngcontent-%COMP%]{margin-right:16px;color:#536dfe;text-decoration:none}.footer__link-item[_ngcontent-%COMP%]:hover{text-decoration:underline}.mat-mini-fab[_ngcontent-%COMP%]{box-shadow:none;background-color:inherit;width:46px;height:46px}.mat-mini-fab[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.08)}.mat-icon[_ngcontent-%COMP%]{color:hsla(0,0%,43.1%,.6);padding:3px 0 0}"]
                }), t
            })()
        },
        jhN1: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return F
            }), i.d(e, "b", function() {
                return D
            }), i.d(e, "c", function() {
                return R
            }), i.d(e, "d", function() {
                return _
            });
            var n = i("ofXK"),
                s = i("fXoL");
            class r extends n.v {
                constructor() {
                    super()
                }
                supportsDOMEvents() {
                    return !0
                }
            }
            class a extends r {
                static makeCurrent() {
                    Object(n.z)(new a)
                }
                getProperty(t, e) {
                    return t[e]
                }
                log(t) {
                    window.console && window.console.log && window.console.log(t)
                }
                logGroup(t) {
                    window.console && window.console.group && window.console.group(t)
                }
                logGroupEnd() {
                    window.console && window.console.groupEnd && window.console.groupEnd()
                }
                onAndCancel(t, e, i) {
                    return t.addEventListener(e, i, !1), () => {
                        t.removeEventListener(e, i, !1)
                    }
                }
                dispatchEvent(t, e) {
                    t.dispatchEvent(e)
                }
                remove(t) {
                    return t.parentNode && t.parentNode.removeChild(t), t
                }
                getValue(t) {
                    return t.value
                }
                createElement(t, e) {
                    return (e = e || this.getDefaultDocument()).createElement(t)
                }
                createHtmlDocument() {
                    return document.implementation.createHTMLDocument("fakeTitle")
                }
                getDefaultDocument() {
                    return document
                }
                isElementNode(t) {
                    return t.nodeType === Node.ELEMENT_NODE
                }
                isShadowRoot(t) {
                    return t instanceof DocumentFragment
                }
                getGlobalEventTarget(t, e) {
                    return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null
                }
                getHistory() {
                    return window.history
                }
                getLocation() {
                    return window.location
                }
                getBaseHref(t) {
                    const e = l || (l = document.querySelector("base"), l) ? l.getAttribute("href") : null;
                    return null == e ? null : (i = e, o || (o = document.createElement("a")), o.setAttribute("href", i), "/" === o.pathname.charAt(0) ? o.pathname : "/" + o.pathname);
                    var i
                }
                resetBaseElement() {
                    l = null
                }
                getUserAgent() {
                    return window.navigator.userAgent
                }
                performanceNow() {
                    return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime()
                }
                supportsCookies() {
                    return !0
                }
                getCookie(t) {
                    return Object(n.y)(document.cookie, t)
                }
            }
            let o, l = null;
            const c = new s.s("TRANSITION_ID"),
                h = [{
                    provide: s.d,
                    useFactory: function(t, e, i) {
                        return () => {
                            i.get(s.e).donePromise.then(() => {
                                const i = Object(n.x)();
                                Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => i.remove(t))
                            })
                        }
                    },
                    deps: [c, n.d, s.t],
                    multi: !0
                }];
            class u {
                static init() {
                    Object(s.ab)(new u)
                }
                addToWindow(t) {
                    s.rb.getAngularTestability = (e, i = !0) => {
                        const n = t.findTestabilityInTree(e, i);
                        if (null == n) throw new Error("Could not find testability for element.");
                        return n
                    }, s.rb.getAllAngularTestabilities = () => t.getAllTestabilities(), s.rb.getAllAngularRootElements = () => t.getAllRootElements(), s.rb.frameworkStabilizers || (s.rb.frameworkStabilizers = []), s.rb.frameworkStabilizers.push(t => {
                        const e = s.rb.getAllAngularTestabilities();
                        let i = e.length,
                            n = !1;
                        const r = function(e) {
                            n = n || e, i--, 0 == i && t(n)
                        };
                        e.forEach(function(t) {
                            t.whenStable(r)
                        })
                    })
                }
                findTestabilityInTree(t, e, i) {
                    if (null == e) return null;
                    const s = t.getTestability(e);
                    return null != s ? s : i ? Object(n.x)().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null
                }
            }
            const d = new s.s("EventManagerPlugins");
            let p = (() => {
                class t {
                    constructor(t, e) {
                        this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse()
                    }
                    addEventListener(t, e, i) {
                        return this._findPluginFor(e).addEventListener(t, e, i)
                    }
                    addGlobalEventListener(t, e, i) {
                        return this._findPluginFor(e).addGlobalEventListener(t, e, i)
                    }
                    getZone() {
                        return this._zone
                    }
                    _findPluginFor(t) {
                        const e = this._eventNameToPlugin.get(t);
                        if (e) return e;
                        const i = this._plugins;
                        for (let n = 0; n < i.length; n++) {
                            const e = i[n];
                            if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e
                        }
                        throw new Error(`No event manager plugin found for event ${t}`)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(d), s.Zb(s.B))
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class f {
                constructor(t) {
                    this._doc = t
                }
                addGlobalEventListener(t, e, i) {
                    const s = Object(n.x)().getGlobalEventTarget(this._doc, t);
                    if (!s) throw new Error(`Unsupported event target ${s} for event ${e}`);
                    return this.addEventListener(s, e, i)
                }
            }
            let g = (() => {
                    class t {
                        constructor() {
                            this._stylesSet = new Set
                        }
                        addStyles(t) {
                            const e = new Set;
                            t.forEach(t => {
                                this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t))
                            }), this.onStylesAdded(e)
                        }
                        onStylesAdded(t) {}
                        getAllStyles() {
                            return Array.from(this._stylesSet)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                m = (() => {
                    class t extends g {
                        constructor(t) {
                            super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head)
                        }
                        _addStylesToHost(t, e) {
                            t.forEach(t => {
                                const i = this._doc.createElement("style");
                                i.textContent = t, this._styleNodes.add(e.appendChild(i))
                            })
                        }
                        addHost(t) {
                            this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t)
                        }
                        removeHost(t) {
                            this._hostNodes.delete(t)
                        }
                        onStylesAdded(t) {
                            this._hostNodes.forEach(e => this._addStylesToHost(t, e))
                        }
                        ngOnDestroy() {
                            this._styleNodes.forEach(t => Object(n.x)().remove(t))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(n.d))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })();
            const b = {
                    svg: "http://www.w3.org/2000/svg",
                    xhtml: "http://www.w3.org/1999/xhtml",
                    xlink: "http://www.w3.org/1999/xlink",
                    xml: "http://www.w3.org/XML/1998/namespace",
                    xmlns: "http://www.w3.org/2000/xmlns/"
                },
                y = /%COMP%/g;

            function v(t, e, i) {
                for (let n = 0; n < e.length; n++) {
                    let s = e[n];
                    Array.isArray(s) ? v(t, s, i) : (s = s.replace(y, t), i.push(s))
                }
                return i
            }

            function x(t) {
                return e => {
                    if ("__ngUnwrap__" === e) return t;
                    !1 === t(e) && (e.preventDefault(), e.returnValue = !1)
                }
            }
            let _ = (() => {
                class t {
                    constructor(t, e, i) {
                        this.eventManager = t, this.sharedStylesHost = e, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new w(t)
                    }
                    createRenderer(t, e) {
                        if (!t || !e) return this.defaultRenderer;
                        switch (e.encapsulation) {
                            case s.T.Emulated: {
                                let i = this.rendererByCompId.get(e.id);
                                return i || (i = new C(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, i)), i.applyToHost(t), i
                            }
                            case 1:
                            case s.T.ShadowDom:
                                return new k(this.eventManager, this.sharedStylesHost, t, e);
                            default:
                                if (!this.rendererByCompId.has(e.id)) {
                                    const t = v(e.id, e.styles, []);
                                    this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer)
                                }
                                return this.defaultRenderer
                        }
                    }
                    begin() {}
                    end() {}
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(p), s.Zb(m), s.Zb(s.c))
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            class w {
                constructor(t) {
                    this.eventManager = t, this.data = Object.create(null)
                }
                destroy() {}
                createElement(t, e) {
                    return e ? document.createElementNS(b[e] || e, t) : document.createElement(t)
                }
                createComment(t) {
                    return document.createComment(t)
                }
                createText(t) {
                    return document.createTextNode(t)
                }
                appendChild(t, e) {
                    t.appendChild(e)
                }
                insertBefore(t, e, i) {
                    t && t.insertBefore(e, i)
                }
                removeChild(t, e) {
                    t && t.removeChild(e)
                }
                selectRootElement(t, e) {
                    let i = "string" == typeof t ? document.querySelector(t) : t;
                    if (!i) throw new Error(`The selector "${t}" did not match any elements`);
                    return e || (i.textContent = ""), i
                }
                parentNode(t) {
                    return t.parentNode
                }
                nextSibling(t) {
                    return t.nextSibling
                }
                setAttribute(t, e, i, n) {
                    if (n) {
                        e = n + ":" + e;
                        const s = b[n];
                        s ? t.setAttributeNS(s, e, i) : t.setAttribute(e, i)
                    } else t.setAttribute(e, i)
                }
                removeAttribute(t, e, i) {
                    if (i) {
                        const n = b[i];
                        n ? t.removeAttributeNS(n, e) : t.removeAttribute(`${i}:${e}`)
                    } else t.removeAttribute(e)
                }
                addClass(t, e) {
                    t.classList.add(e)
                }
                removeClass(t, e) {
                    t.classList.remove(e)
                }
                setStyle(t, e, i, n) {
                    n & (s.I.DashCase | s.I.Important) ? t.style.setProperty(e, i, n & s.I.Important ? "important" : "") : t.style[e] = i
                }
                removeStyle(t, e, i) {
                    i & s.I.DashCase ? t.style.removeProperty(e) : t.style[e] = ""
                }
                setProperty(t, e, i) {
                    t[e] = i
                }
                setValue(t, e) {
                    t.nodeValue = e
                }
                listen(t, e, i) {
                    return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, x(i)) : this.eventManager.addEventListener(t, e, x(i))
                }
            }
            class C extends w {
                constructor(t, e, i, n) {
                    super(t), this.component = i;
                    const s = v(n + "-" + i.id, i.styles, []);
                    e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(y, n + "-" + i.id), this.hostAttr = "_nghost-%COMP%".replace(y, n + "-" + i.id)
                }
                applyToHost(t) {
                    super.setAttribute(t, this.hostAttr, "")
                }
                createElement(t, e) {
                    const i = super.createElement(t, e);
                    return super.setAttribute(i, this.contentAttr, ""), i
                }
            }
            class k extends w {
                constructor(t, e, i, n) {
                    super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({
                        mode: "open"
                    }), this.sharedStylesHost.addHost(this.shadowRoot);
                    const s = v(n.id, n.styles, []);
                    for (let r = 0; r < s.length; r++) {
                        const t = document.createElement("style");
                        t.textContent = s[r], this.shadowRoot.appendChild(t)
                    }
                }
                nodeOrShadowRoot(t) {
                    return t === this.hostEl ? this.shadowRoot : t
                }
                destroy() {
                    this.sharedStylesHost.removeHost(this.shadowRoot)
                }
                appendChild(t, e) {
                    return super.appendChild(this.nodeOrShadowRoot(t), e)
                }
                insertBefore(t, e, i) {
                    return super.insertBefore(this.nodeOrShadowRoot(t), e, i)
                }
                removeChild(t, e) {
                    return super.removeChild(this.nodeOrShadowRoot(t), e)
                }
                parentNode(t) {
                    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))
                }
            }
            let S = (() => {
                class t extends f {
                    constructor(t) {
                        super(t)
                    }
                    supports(t) {
                        return !0
                    }
                    addEventListener(t, e, i) {
                        return t.addEventListener(e, i, !1), () => this.removeEventListener(t, e, i)
                    }
                    removeEventListener(t, e, i) {
                        return t.removeEventListener(e, i)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(n.d))
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();
            const A = ["alt", "control", "meta", "shift"],
                O = {
                    "\b": "Backspace",
                    "\t": "Tab",
                    "\x7f": "Delete",
                    "\x1b": "Escape",
                    Del: "Delete",
                    Esc: "Escape",
                    Left: "ArrowLeft",
                    Right: "ArrowRight",
                    Up: "ArrowUp",
                    Down: "ArrowDown",
                    Menu: "ContextMenu",
                    Scroll: "ScrollLock",
                    Win: "OS"
                },
                E = {
                    A: "1",
                    B: "2",
                    C: "3",
                    D: "4",
                    E: "5",
                    F: "6",
                    G: "7",
                    H: "8",
                    I: "9",
                    J: "*",
                    K: "+",
                    M: "-",
                    N: ".",
                    O: "/",
                    "`": "0",
                    "\x90": "NumLock"
                },
                P = {
                    alt: t => t.altKey,
                    control: t => t.ctrlKey,
                    meta: t => t.metaKey,
                    shift: t => t.shiftKey
                };
            let T = (() => {
                    class t extends f {
                        constructor(t) {
                            super(t)
                        }
                        supports(e) {
                            return null != t.parseEventName(e)
                        }
                        addEventListener(e, i, s) {
                            const r = t.parseEventName(i),
                                a = t.eventCallback(r.fullKey, s, this.manager.getZone());
                            return this.manager.getZone().runOutsideAngular(() => Object(n.x)().onAndCancel(e, r.domEventName, a))
                        }
                        static parseEventName(e) {
                            const i = e.toLowerCase().split("."),
                                n = i.shift();
                            if (0 === i.length || "keydown" !== n && "keyup" !== n) return null;
                            const s = t._normalizeKey(i.pop());
                            let r = "";
                            if (A.forEach(t => {
                                    const e = i.indexOf(t);
                                    e > -1 && (i.splice(e, 1), r += t + ".")
                                }), r += s, 0 != i.length || 0 === s.length) return null;
                            const a = {};
                            return a.domEventName = n, a.fullKey = r, a
                        }
                        static getEventFullKey(t) {
                            let e = "",
                                i = function(t) {
                                    let e = t.key;
                                    if (null == e) {
                                        if (e = t.keyIdentifier, null == e) return "Unidentified";
                                        e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && E.hasOwnProperty(e) && (e = E[e]))
                                    }
                                    return O[e] || e
                                }(t);
                            return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), A.forEach(n => {
                                n != i && (0, P[n])(t) && (e += n + ".")
                            }), e += i, e
                        }
                        static eventCallback(e, i, n) {
                            return s => {
                                t.getEventFullKey(s) === e && n.runGuarded(() => i(s))
                            }
                        }
                        static _normalizeKey(t) {
                            switch (t) {
                                case "esc":
                                    return "escape";
                                default:
                                    return t
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(n.d))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                D = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return Object(s.Zb)(M)
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })();

            function I(t) {
                return new M(t.get(n.d))
            }
            let M = (() => {
                class t extends D {
                    constructor(t) {
                        super(), this._doc = t
                    }
                    sanitize(t, e) {
                        if (null == e) return null;
                        switch (t) {
                            case s.K.NONE:
                                return e;
                            case s.K.HTML:
                                return Object(s.gb)(e, "HTML") ? Object(s.zb)(e) : Object(s.eb)(this._doc, String(e)).toString();
                            case s.K.STYLE:
                                return Object(s.gb)(e, "Style") ? Object(s.zb)(e) : e;
                            case s.K.SCRIPT:
                                if (Object(s.gb)(e, "Script")) return Object(s.zb)(e);
                                throw new Error("unsafe value used in a script context");
                            case s.K.URL:
                                return Object(s.qb)(e), Object(s.gb)(e, "URL") ? Object(s.zb)(e) : Object(s.fb)(String(e));
                            case s.K.RESOURCE_URL:
                                if (Object(s.gb)(e, "ResourceURL")) return Object(s.zb)(e);
                                throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
                            default:
                                throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)
                        }
                    }
                    bypassSecurityTrustHtml(t) {
                        return Object(s.hb)(t)
                    }
                    bypassSecurityTrustStyle(t) {
                        return Object(s.kb)(t)
                    }
                    bypassSecurityTrustScript(t) {
                        return Object(s.jb)(t)
                    }
                    bypassSecurityTrustUrl(t) {
                        return Object(s.lb)(t)
                    }
                    bypassSecurityTrustResourceUrl(t) {
                        return Object(s.ib)(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(n.d))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return I(Object(s.Zb)(s.p))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            const L = [{
                    provide: s.D,
                    useValue: n.w
                }, {
                    provide: s.E,
                    useValue: function() {
                        a.makeCurrent(), u.init()
                    },
                    multi: !0
                }, {
                    provide: n.d,
                    useFactory: function() {
                        return Object(s.xb)(document), document
                    },
                    deps: []
                }],
                R = Object(s.U)(s.Z, "browser", L),
                j = [
                    [], {
                        provide: s.cb,
                        useValue: "root"
                    }, {
                        provide: s.n,
                        useFactory: function() {
                            return new s.n
                        },
                        deps: []
                    }, {
                        provide: d,
                        useClass: S,
                        multi: !0,
                        deps: [n.d, s.B, s.D]
                    }, {
                        provide: d,
                        useClass: T,
                        multi: !0,
                        deps: [n.d]
                    },
                    [], {
                        provide: _,
                        useClass: _,
                        deps: [p, m, s.c]
                    }, {
                        provide: s.H,
                        useExisting: _
                    }, {
                        provide: g,
                        useExisting: m
                    }, {
                        provide: m,
                        useClass: m,
                        deps: [n.d]
                    }, {
                        provide: s.P,
                        useClass: s.P,
                        deps: [s.B]
                    }, {
                        provide: p,
                        useClass: p,
                        deps: [d, s.B]
                    },
                    []
                ];
            let F = (() => {
                class t {
                    constructor(t) {
                        if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")
                    }
                    static withServerTransition(e) {
                        return {
                            ngModule: t,
                            providers: [{
                                provide: s.c,
                                useValue: e.appId
                            }, {
                                provide: c,
                                useExisting: s.c
                            }, h]
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(t, 12))
                }, t.\u0275mod = s.Nb({
                    type: t
                }), t.\u0275inj = s.Mb({
                    providers: j,
                    imports: [n.c, s.f]
                }), t
            })();
            "undefined" != typeof window && window
        },
        jqqC: function(t, e, i) {
            "use strict";
            i.d(e, "b", function() {
                return o
            }), i.d(e, "a", function() {
                return l
            }), i.d(e, "c", function() {
                return c
            });
            var n = i("2QHy"),
                s = i("GRmh");
            const r = Object(s.a)(t => function(e) {
                t(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e
            });
            var a = i("vRMS");
            class o {
                constructor(t) {
                    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._teardowns = null
                }
                unsubscribe() {
                    let t;
                    if (!this.closed) {
                        this.closed = !0;
                        const {
                            _parentage: s
                        } = this;
                        if (Array.isArray(s))
                            for (const t of s) t.remove(this);
                        else null == s || s.remove(this);
                        const {
                            initialTeardown: a
                        } = this;
                        if (Object(n.a)(a)) try {
                            a()
                        } catch (e) {
                            t = e instanceof r ? e.errors : [e]
                        }
                        const {
                            _teardowns: o
                        } = this;
                        if (o) {
                            this._teardowns = null;
                            for (const e of o) try {
                                h(e)
                            } catch (i) {
                                t = null != t ? t : [], i instanceof r ? t = [...t, ...i.errors] : t.push(i)
                            }
                        }
                        if (t) throw new r(t)
                    }
                }
                add(t) {
                    var e;
                    if (t && t !== this)
                        if (this.closed) h(t);
                        else {
                            if (t instanceof o) {
                                if (t.closed || t._hasParent(this)) return;
                                t._addParent(this)
                            }(this._teardowns = null !== (e = this._teardowns) && void 0 !== e ? e : []).push(t)
                        }
                }
                _hasParent(t) {
                    const {
                        _parentage: e
                    } = this;
                    return e === t || Array.isArray(e) && e.includes(t)
                }
                _addParent(t) {
                    const {
                        _parentage: e
                    } = this;
                    this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t
                }
                _removeParent(t) {
                    const {
                        _parentage: e
                    } = this;
                    e === t ? this._parentage = null : Array.isArray(e) && Object(a.a)(e, t)
                }
                remove(t) {
                    const {
                        _teardowns: e
                    } = this;
                    e && Object(a.a)(e, t), t instanceof o && t._removeParent(this)
                }
            }
            o.EMPTY = (() => {
                const t = new o;
                return t.closed = !0, t
            })();
            const l = o.EMPTY;

            function c(t) {
                return t instanceof o || t && "closed" in t && Object(n.a)(t.remove) && Object(n.a)(t.add) && Object(n.a)(t.unsubscribe)
            }

            function h(t) {
                Object(n.a)(t) ? t() : t.unsubscribe()
            }
        },
        kmnG: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return G
            }), i.d(e, "b", function() {
                return q
            }), i.d(e, "c", function() {
                return F
            }), i.d(e, "d", function() {
                return Z
            });
            var n = i("GU7r"),
                s = i("ofXK"),
                r = i("fXoL"),
                a = i("FKr1"),
                o = i("8LU1"),
                l = i("oXA7"),
                c = i("2btn"),
                h = i("KOvq"),
                u = i("zzs5"),
                d = i("bk9D"),
                p = i("nnEh"),
                f = i("R0Ic"),
                g = i("R1ws"),
                m = i("cH1L"),
                b = i("nLfN");
            const y = ["underline"],
                v = ["connectionContainer"],
                x = ["inputContainer"],
                _ = ["label"];

            function w(t, e) {
                1 & t && (r.Tb(0), r.Vb(1, "div", 14), r.Qb(2, "div", 15), r.Qb(3, "div", 16), r.Qb(4, "div", 17), r.Ub(), r.Vb(5, "div", 18), r.Qb(6, "div", 15), r.Qb(7, "div", 16), r.Qb(8, "div", 17), r.Ub(), r.Sb())
            }

            function C(t, e) {
                1 & t && (r.Vb(0, "div", 19), r.jc(1, 1), r.Ub())
            }

            function k(t, e) {
                if (1 & t && (r.Tb(0), r.jc(1, 2), r.Vb(2, "span"), r.Cc(3), r.Ub(), r.Sb()), 2 & t) {
                    const t = r.gc(2);
                    r.Db(3), r.Dc(t._control.placeholder)
                }
            }

            function S(t, e) {
                1 & t && r.jc(0, 3, ["*ngSwitchCase", "true"])
            }

            function A(t, e) {
                1 & t && (r.Vb(0, "span", 23), r.Cc(1, " *"), r.Ub())
            }

            function O(t, e) {
                if (1 & t) {
                    const t = r.Wb();
                    r.Vb(0, "label", 20, 21), r.cc("cdkObserveContent", function() {
                        return r.uc(t), r.gc().updateOutlineGap()
                    }), r.Bc(2, k, 4, 1, "ng-container", 12), r.Bc(3, S, 1, 0, "ng-content", 12), r.Bc(4, A, 2, 0, "span", 22), r.Ub()
                }
                if (2 & t) {
                    const t = r.gc();
                    r.Hb("mat-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-form-field-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color), r.lc("cdkObserveContentDisabled", "outline" != t.appearance)("id", t._labelId)("ngSwitch", t._hasLabel()), r.Eb("for", t._control.id)("aria-owns", t._control.id), r.Db(2), r.lc("ngSwitchCase", !1), r.Db(1), r.lc("ngSwitchCase", !0), r.Db(1), r.lc("ngIf", !t.hideRequiredMarker && t._control.required && !t._control.disabled)
                }
            }

            function E(t, e) {
                1 & t && (r.Vb(0, "div", 24), r.jc(1, 4), r.Ub())
            }

            function P(t, e) {
                if (1 & t && (r.Vb(0, "div", 25, 26), r.Qb(2, "span", 27), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.Db(2), r.Hb("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color)
                }
            }

            function T(t, e) {
                if (1 & t && (r.Vb(0, "div"), r.jc(1, 5), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.lc("@transitionMessages", t._subscriptAnimationState)
                }
            }

            function D(t, e) {
                if (1 & t && (r.Vb(0, "div", 31), r.Cc(1), r.Ub()), 2 & t) {
                    const t = r.gc(2);
                    r.lc("id", t._hintLabelId), r.Db(1), r.Dc(t.hintLabel)
                }
            }

            function I(t, e) {
                if (1 & t && (r.Vb(0, "div", 28), r.Bc(1, D, 2, 2, "div", 29), r.jc(2, 6), r.Qb(3, "div", 30), r.jc(4, 7), r.Ub()), 2 & t) {
                    const t = r.gc();
                    r.lc("@transitionMessages", t._subscriptAnimationState), r.Db(1), r.lc("ngIf", t.hintLabel)
                }
            }
            const M = ["*", [
                        ["", "matPrefix", ""]
                    ],
                    [
                        ["mat-placeholder"]
                    ],
                    [
                        ["mat-label"]
                    ],
                    [
                        ["", "matSuffix", ""]
                    ],
                    [
                        ["mat-error"]
                    ],
                    [
                        ["mat-hint", 3, "align", "end"]
                    ],
                    [
                        ["mat-hint", "align", "end"]
                    ]
                ],
                L = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"],
                R = new r.s("MatError"),
                j = {
                    transitionMessages: Object(f.m)("transitionMessages", [Object(f.j)("enter", Object(f.k)({
                        opacity: 1,
                        transform: "translateY(0%)"
                    })), Object(f.l)("void => enter", [Object(f.k)({
                        opacity: 0,
                        transform: "translateY(-5px)"
                    }), Object(f.e)("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])
                };
            let F = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275dir = r.Kb({
                    type: t
                }), t
            })();
            const N = new r.s("MatHint");
            let z = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-label"]
                        ]
                    }), t
                })(),
                V = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = r.Kb({
                        type: t,
                        selectors: [
                            ["mat-placeholder"]
                        ]
                    }), t
                })();
            const B = new r.s("MatPrefix"),
                H = new r.s("MatSuffix");
            let U = 0;
            class X {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const W = Object(a.q)(X, "primary"),
                Y = new r.s("MAT_FORM_FIELD_DEFAULT_OPTIONS"),
                G = new r.s("MatFormField");
            let q = (() => {
                    class t extends W {
                        constructor(t, e, i, n, s, r, a, o) {
                            super(t), this._elementRef = t, this._changeDetectorRef = e, this._dir = n, this._defaults = s, this._platform = r, this._ngZone = a, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new l.a, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + U++, this._labelId = "mat-form-field-label-" + U++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== o, this.appearance = s && s.appearance ? s.appearance : "legacy", this._hideRequiredMarker = !(!s || null == s.hideRequiredMarker) && s.hideRequiredMarker
                        }
                        get appearance() {
                            return this._appearance
                        }
                        set appearance(t) {
                            const e = this._appearance;
                            this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0)
                        }
                        get hideRequiredMarker() {
                            return this._hideRequiredMarker
                        }
                        set hideRequiredMarker(t) {
                            this._hideRequiredMarker = Object(o.c)(t)
                        }
                        _shouldAlwaysFloat() {
                            return "always" === this.floatLabel && !this._showAlwaysAnimate
                        }
                        _canLabelFloat() {
                            return "never" !== this.floatLabel
                        }
                        get hintLabel() {
                            return this._hintLabel
                        }
                        set hintLabel(t) {
                            this._hintLabel = t, this._processHints()
                        }
                        get floatLabel() {
                            return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel
                        }
                        set floatLabel(t) {
                            t !== this._floatLabel && (this._floatLabel = t || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck())
                        }
                        get _control() {
                            return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic
                        }
                        set _control(t) {
                            this._explicitFormFieldControl = t
                        }
                        getLabelId() {
                            return this._hasFloatingLabel() ? this._labelId : null
                        }
                        getConnectedOverlayOrigin() {
                            return this._connectionContainerRef || this._elementRef
                        }
                        ngAfterContentInit() {
                            this._validateControlChild();
                            const t = this._control;
                            t.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`), t.stateChanges.pipe(Object(u.a)(null)).subscribe(() => {
                                this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck()
                            }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(Object(d.a)(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => {
                                this._ngZone.onStable.pipe(Object(d.a)(this._destroyed)).subscribe(() => {
                                    this._outlineGapCalculationNeededOnStable && this.updateOutlineGap()
                                })
                            }), Object(c.a)(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {
                                this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck()
                            }), this._hintChildren.changes.pipe(Object(u.a)(null)).subscribe(() => {
                                this._processHints(), this._changeDetectorRef.markForCheck()
                            }), this._errorChildren.changes.pipe(Object(u.a)(null)).subscribe(() => {
                                this._syncDescribedByIds(), this._changeDetectorRef.markForCheck()
                            }), this._dir && this._dir.change.pipe(Object(d.a)(this._destroyed)).subscribe(() => {
                                "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => {
                                    requestAnimationFrame(() => this.updateOutlineGap())
                                }) : this.updateOutlineGap()
                            })
                        }
                        ngAfterContentChecked() {
                            this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap()
                        }
                        ngAfterViewInit() {
                            this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges()
                        }
                        ngOnDestroy() {
                            this._destroyed.next(), this._destroyed.complete()
                        }
                        _shouldForward(t) {
                            const e = this._control ? this._control.ngControl : null;
                            return e && e[t]
                        }
                        _hasPlaceholder() {
                            return !!(this._control && this._control.placeholder || this._placeholderChild)
                        }
                        _hasLabel() {
                            return !(!this._labelChildNonStatic && !this._labelChildStatic)
                        }
                        _shouldLabelFloat() {
                            return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat())
                        }
                        _hideControlPlaceholder() {
                            return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat()
                        }
                        _hasFloatingLabel() {
                            return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder()
                        }
                        _getDisplayedMessages() {
                            return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint"
                        }
                        _animateAndLockLabel() {
                            this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Object(h.a)(this._label.nativeElement, "transitionend").pipe(Object(p.a)(1)).subscribe(() => {
                                this._showAlwaysAnimate = !1
                            })), this.floatLabel = "always", this._changeDetectorRef.markForCheck())
                        }
                        _validatePlaceholders() {}
                        _processHints() {
                            this._validateHints(), this._syncDescribedByIds()
                        }
                        _validateHints() {}
                        _getDefaultFloatLabelState() {
                            return this._defaults && this._defaults.floatLabel || "auto"
                        }
                        _syncDescribedByIds() {
                            if (this._control) {
                                let t = [];
                                if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && t.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) {
                                    const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null,
                                        i = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null;
                                    e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), i && t.push(i.id)
                                } else this._errorChildren && t.push(...this._errorChildren.map(t => t.id));
                                this._control.setDescribedByIds(t)
                            }
                        }
                        _validateControlChild() {}
                        updateOutlineGap() {
                            const t = this._label ? this._label.nativeElement : null;
                            if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return;
                            if (!this._platform.isBrowser) return;
                            if (!this._isAttachedToDOM()) return void(this._outlineGapCalculationNeededImmediately = !0);
                            let e = 0,
                                i = 0;
                            const n = this._connectionContainerRef.nativeElement,
                                s = n.querySelectorAll(".mat-form-field-outline-start"),
                                r = n.querySelectorAll(".mat-form-field-outline-gap");
                            if (this._label && this._label.nativeElement.children.length) {
                                const s = n.getBoundingClientRect();
                                if (0 === s.width && 0 === s.height) return this._outlineGapCalculationNeededOnStable = !0, void(this._outlineGapCalculationNeededImmediately = !1);
                                const r = this._getStartEnd(s),
                                    a = t.children,
                                    o = this._getStartEnd(a[0].getBoundingClientRect());
                                let l = 0;
                                for (let t = 0; t < a.length; t++) l += a[t].offsetWidth;
                                e = Math.abs(o - r) - 5, i = l > 0 ? .75 * l + 10 : 0
                            }
                            for (let a = 0; a < s.length; a++) s[a].style.width = `${e}px`;
                            for (let a = 0; a < r.length; a++) r[a].style.width = `${i}px`;
                            this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1
                        }
                        _getStartEnd(t) {
                            return this._dir && "rtl" === this._dir.value ? t.right : t.left
                        }
                        _isAttachedToDOM() {
                            const t = this._elementRef.nativeElement;
                            if (t.getRootNode) {
                                const e = t.getRootNode();
                                return e && e !== t
                            }
                            return document.documentElement.contains(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(r.Pb(r.l), r.Pb(r.h), r.Pb(r.l), r.Pb(m.b, 8), r.Pb(Y, 8), r.Pb(b.a), r.Pb(r.B), r.Pb(g.a, 8))
                    }, t.\u0275cmp = r.Jb({
                        type: t,
                        selectors: [
                            ["mat-form-field"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (r.Ib(i, F, 1), r.Ib(i, F, 3), r.Ib(i, z, 1), r.Ib(i, z, 3), r.Ib(i, V, 1), r.Ib(i, R, 1), r.Ib(i, N, 1), r.Ib(i, B, 1), r.Ib(i, H, 1)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e._controlNonStatic = t.first), r.rc(t = r.dc()) && (e._controlStatic = t.first), r.rc(t = r.dc()) && (e._labelChildNonStatic = t.first), r.rc(t = r.dc()) && (e._labelChildStatic = t.first), r.rc(t = r.dc()) && (e._placeholderChild = t.first), r.rc(t = r.dc()) && (e._errorChildren = t), r.rc(t = r.dc()) && (e._hintChildren = t), r.rc(t = r.dc()) && (e._prefixChildren = t), r.rc(t = r.dc()) && (e._suffixChildren = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && (r.Hc(y, 1), r.Hc(v, 3), r.Hc(x, 1), r.Hc(_, 1)), 2 & t) {
                                let t;
                                r.rc(t = r.dc()) && (e.underlineRef = t.first), r.rc(t = r.dc()) && (e._connectionContainerRef = t.first), r.rc(t = r.dc()) && (e._inputContainerRef = t.first), r.rc(t = r.dc()) && (e._label = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-form-field"],
                        hostVars: 40,
                        hostBindings: function(t, e) {
                            2 & t && r.Hb("mat-form-field-appearance-standard", "standard" == e.appearance)("mat-form-field-appearance-fill", "fill" == e.appearance)("mat-form-field-appearance-outline", "outline" == e.appearance)("mat-form-field-appearance-legacy", "legacy" == e.appearance)("mat-form-field-invalid", e._control.errorState)("mat-form-field-can-float", e._canLabelFloat())("mat-form-field-should-float", e._shouldLabelFloat())("mat-form-field-has-label", e._hasFloatingLabel())("mat-form-field-hide-placeholder", e._hideControlPlaceholder())("mat-form-field-disabled", e._control.disabled)("mat-form-field-autofilled", e._control.autofilled)("mat-focused", e._control.focused)("ng-untouched", e._shouldForward("untouched"))("ng-touched", e._shouldForward("touched"))("ng-pristine", e._shouldForward("pristine"))("ng-dirty", e._shouldForward("dirty"))("ng-valid", e._shouldForward("valid"))("ng-invalid", e._shouldForward("invalid"))("ng-pending", e._shouldForward("pending"))("_mat-animation-noopable", !e._animationsEnabled)
                        },
                        inputs: {
                            color: "color",
                            floatLabel: "floatLabel",
                            appearance: "appearance",
                            hideRequiredMarker: "hideRequiredMarker",
                            hintLabel: "hintLabel"
                        },
                        exportAs: ["matFormField"],
                        features: [r.Cb([{
                            provide: G,
                            useExisting: t
                        }]), r.Ab],
                        ngContentSelectors: L,
                        decls: 15,
                        vars: 8,
                        consts: [
                            [1, "mat-form-field-wrapper"],
                            [1, "mat-form-field-flex", 3, "click"],
                            ["connectionContainer", ""],
                            [4, "ngIf"],
                            ["class", "mat-form-field-prefix", 4, "ngIf"],
                            [1, "mat-form-field-infix"],
                            ["inputContainer", ""],
                            [1, "mat-form-field-label-wrapper"],
                            ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"],
                            ["class", "mat-form-field-suffix", 4, "ngIf"],
                            ["class", "mat-form-field-underline", 4, "ngIf"],
                            [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"],
                            [4, "ngSwitchCase"],
                            ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"],
                            [1, "mat-form-field-outline"],
                            [1, "mat-form-field-outline-start"],
                            [1, "mat-form-field-outline-gap"],
                            [1, "mat-form-field-outline-end"],
                            [1, "mat-form-field-outline", "mat-form-field-outline-thick"],
                            [1, "mat-form-field-prefix"],
                            [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"],
                            ["label", ""],
                            ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"],
                            ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"],
                            [1, "mat-form-field-suffix"],
                            [1, "mat-form-field-underline"],
                            ["underline", ""],
                            [1, "mat-form-field-ripple"],
                            [1, "mat-form-field-hint-wrapper"],
                            ["class", "mat-hint", 3, "id", 4, "ngIf"],
                            [1, "mat-form-field-hint-spacer"],
                            [1, "mat-hint", 3, "id"]
                        ],
                        template: function(t, e) {
                            1 & t && (r.kc(M), r.Vb(0, "div", 0), r.Vb(1, "div", 1, 2), r.cc("click", function(t) {
                                return e._control.onContainerClick && e._control.onContainerClick(t)
                            }), r.Bc(3, w, 9, 0, "ng-container", 3), r.Bc(4, C, 2, 0, "div", 4), r.Vb(5, "div", 5, 6), r.jc(7), r.Vb(8, "span", 7), r.Bc(9, O, 5, 16, "label", 8), r.Ub(), r.Ub(), r.Bc(10, E, 2, 0, "div", 9), r.Ub(), r.Bc(11, P, 3, 4, "div", 10), r.Vb(12, "div", 11), r.Bc(13, T, 2, 1, "div", 12), r.Bc(14, I, 5, 2, "div", 13), r.Ub(), r.Ub()), 2 & t && (r.Db(3), r.lc("ngIf", "outline" == e.appearance), r.Db(1), r.lc("ngIf", e._prefixChildren.length), r.Db(5), r.lc("ngIf", e._hasFloatingLabel()), r.Db(1), r.lc("ngIf", e._suffixChildren.length), r.Db(1), r.lc("ngIf", "outline" != e.appearance), r.Db(1), r.lc("ngSwitch", e._getDisplayedMessages()), r.Db(1), r.lc("ngSwitchCase", "error"), r.Db(1), r.lc("ngSwitchCase", "hint"))
                        },
                        directives: [s.l, s.n, s.o, n.a],
                        styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"],
                        encapsulation: 2,
                        data: {
                            animation: [j.transitionMessages]
                        },
                        changeDetection: 0
                    }), t
                })(),
                Z = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = r.Nb({
                        type: t
                    }), t.\u0275inj = r.Mb({
                        imports: [
                            [s.c, a.e, n.c], a.e
                        ]
                    }), t
                })()
        },
        lBUW: function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, "AuthModule", function() {
                return x
            });
            var n = i("ofXK"),
                s = i("wZkO"),
                r = i("bTqV"),
                a = i("qFsG"),
                o = i("3Pt+"),
                l = i("tyNb"),
                c = i("v/4h"),
                h = i("fXoL"),
                u = i("foWl"),
                d = i("kmnG");
            let p = (() => {
                    class t {
                        constructor() {
                            this.sendLoginForm = new h.o, this.flatlogicEmail = "admin@flatlogic.com", this.flatlogicPassword = "admin"
                        }
                        ngOnInit() {
                            this.form = new o.e({
                                email: new o.c(this.flatlogicEmail, [o.p.required, o.p.email]),
                                password: new o.c(this.flatlogicPassword, [o.p.required])
                            })
                        }
                        login() {
                            this.form.valid && this.sendLoginForm.emit()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = h.Jb({
                        type: t,
                        selectors: [
                            ["app-login-form"]
                        ],
                        outputs: {
                            sendLoginForm: "sendLoginForm"
                        },
                        decls: 10,
                        vars: 1,
                        consts: [
                            [1, "form", 3, "formGroup", "ngSubmit"],
                            [1, "form__input"],
                            ["matInput", "", "placeholder", "Email Address", "type", "email", "formControlName", "email"],
                            ["matInput", "", "placeholder", "Password", "type", "password", "formControlName", "password"],
                            [1, "form-actions"],
                            ["mat-raised-button", "", "color", "primary", "type", "submit", 1, "form-actions__login"],
                            ["mat-button", "", 1, "form-actions__forget"]
                        ],
                        template: function(t, e) {
                            1 & t && (h.Vb(0, "form", 0), h.cc("ngSubmit", function() {
                                return e.login()
                            }), h.Vb(1, "mat-form-field", 1), h.Qb(2, "input", 2), h.Ub(), h.Vb(3, "mat-form-field", 1), h.Qb(4, "input", 3), h.Ub(), h.Vb(5, "div", 4), h.Vb(6, "button", 5), h.Cc(7, "Login"), h.Ub(), h.Vb(8, "button", 6), h.Cc(9, "Forget password"), h.Ub(), h.Ub(), h.Ub()), 2 & t && h.lc("formGroup", e.form)
                        },
                        directives: [o.q, o.l, o.f, d.b, a.a, o.b, o.k, o.d, r.b],
                        styles: [".form[_ngcontent-%COMP%]{width:100%}.form__input[_ngcontent-%COMP%]{width:100%;margin-top:6px}.form-actions[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center}.form-actions__login[_ngcontent-%COMP%]{margin-right:10px}.form-actions__forget[_ngcontent-%COMP%]{font-size:12px;font-weight:400;color:#536dfe}"]
                    }), t
                })(),
                f = (() => {
                    class t {
                        constructor() {
                            this.sendSignForm = new h.o
                        }
                        ngOnInit() {
                            this.form = new o.e({
                                name: new o.c("", [o.p.required]),
                                email: new o.c("", [o.p.required, o.p.email]),
                                password: new o.c("", [o.p.required])
                            })
                        }
                        sign() {
                            this.form.valid && this.sendSignForm.emit()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = h.Jb({
                        type: t,
                        selectors: [
                            ["app-sign-form"]
                        ],
                        outputs: {
                            sendSignForm: "sendSignForm"
                        },
                        decls: 10,
                        vars: 1,
                        consts: [
                            [1, "form", 3, "formGroup", "ngSubmit"],
                            [1, "form__input"],
                            ["matInput", "", "placeholder", "Full name", "formControlName", "name"],
                            ["matInput", "", "placeholder", "Email Address", "type", "email", "formControlName", "email"],
                            ["matInput", "", "placeholder", "Password", "type", "password", "formControlName", "password"],
                            [1, "form-actions"],
                            ["mat-raised-button", "", "color", "primary", "type", "submit", 1, "form-actions__create"]
                        ],
                        template: function(t, e) {
                            1 & t && (h.Vb(0, "form", 0), h.cc("ngSubmit", function() {
                                return e.sign()
                            }), h.Vb(1, "mat-form-field", 1), h.Qb(2, "input", 2), h.Ub(), h.Vb(3, "mat-form-field", 1), h.Qb(4, "input", 3), h.Ub(), h.Vb(5, "mat-form-field", 1), h.Qb(6, "input", 4), h.Ub(), h.Vb(7, "div", 5), h.Vb(8, "button", 6), h.Cc(9, "Create your account"), h.Ub(), h.Ub(), h.Ub()), 2 & t && h.lc("formGroup", e.form)
                        },
                        directives: [o.q, o.l, o.f, d.b, a.a, o.b, o.k, o.d, r.b],
                        styles: [".form[_ngcontent-%COMP%]{width:100%}.form__input[_ngcontent-%COMP%]{width:100%;margin-top:-15px}.form-actions[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;margin-top:5px}.form-actions__create[_ngcontent-%COMP%]{margin:0;width:95%;box-shadow:0 0 11px 0 #e8eafc,0 0 0 -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549)}"]
                    }), t
                })(),
                g = (() => {
                    class t extends n.e {
                        transform(t) {
                            return super.transform(t, "y")
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return m(e || t)
                    }, t.\u0275pipe = h.Ob({
                        name: "year",
                        type: t,
                        pure: !0
                    }), t
                })();
            const m = h.Xb(g),
                b = [{
                    path: "",
                    component: (() => {
                        class t {
                            constructor(t, e) {
                                this.service = t, this.router = e, this.todayDate = new Date, this.routers = c.b
                            }
                            sendLoginForm() {
                                this.service.login(), this.router.navigate([this.routers.DASHBOARD]).then()
                            }
                            sendSignForm() {
                                this.service.sign(), this.router.navigate([this.routers.DASHBOARD]).then()
                            }
                        }
                        return t.\u0275fac = function(e) {
                            return new(e || t)(h.Pb(u.a), h.Pb(l.b))
                        }, t.\u0275cmp = h.Jb({
                            type: t,
                            selectors: [
                                ["app-auth-page"]
                            ],
                            decls: 43,
                            vars: 3,
                            consts: [
                                [1, "auth-page"],
                                [1, "auth-page__content-block"],
                                [1, "auth-page__content-wrapper"],
                                [1, "auth-page__group"],
                                ["label", "Login"],
                                [1, "auth-page__group-title"],
                                [1, "auth-page__google-button-wrapper"],
                                ["mat-raised-button", "", 1, "auth-page__google-button"],
                                ["src", "/flat/static/tte/assets/auth/google.svg", "alt", "google", 1, "auth-page__google-button-icon"],
                                [1, "auth-page__border-wrapper"],
                                [1, "auth-page__border-line"],
                                [1, "auth-page__border-title"],
                                [3, "sendLoginForm"],
                                ["label", "New User"],
                                [1, "auth-page__group-sub-title"],
                                [3, "sendSignForm"],
                                [1, "auth-page__footer-title"],
                                ["href", "https://flatlogic.com/"],
                                [1, "auth-page__logo"],
                                [1, "auth-page__logo-wrapper"],
                                ["src", "/flat/static/tte/assets/auth/logo.svg", "alt", "logo", 1, "auth-page__logo-img"],
                                [1, "auth-page__logo-title"]
                            ],
                            template: function(t, e) {
                                1 & t && (h.Vb(0, "div", 0), h.Vb(1, "div", 1), h.Vb(2, "div", 2), h.Vb(3, "mat-tab-group", 3), h.Vb(4, "mat-tab", 4), h.Vb(5, "h4", 5), h.Cc(6, "Good Morning, User"), h.Ub(), h.Vb(7, "div", 6), h.Vb(8, "button", 7), h.Qb(9, "img", 8), h.Cc(10, "Sign in with Google "), h.Ub(), h.Ub(), h.Vb(11, "div", 9), h.Qb(12, "div", 10), h.Vb(13, "p", 11), h.Cc(14, "or"), h.Ub(), h.Qb(15, "div", 10), h.Ub(), h.Vb(16, "app-login-form", 12), h.cc("sendLoginForm", function() {
                                    return e.sendLoginForm()
                                }), h.Ub(), h.Ub(), h.Vb(17, "mat-tab", 13), h.Vb(18, "h4", 5), h.Cc(19, "Welcome!"), h.Ub(), h.Vb(20, "p", 14), h.Cc(21, "Create you account"), h.Ub(), h.Vb(22, "app-sign-form", 15), h.cc("sendSignForm", function() {
                                    return e.sendSignForm()
                                }), h.Ub(), h.Vb(23, "div", 9), h.Qb(24, "div", 10), h.Vb(25, "p", 11), h.Cc(26, "or"), h.Ub(), h.Qb(27, "div", 10), h.Ub(), h.Vb(28, "div", 6), h.Vb(29, "button", 7), h.Qb(30, "img", 8), h.Cc(31, "Sign in with Google "), h.Ub(), h.Ub(), h.Ub(), h.Ub(), h.Vb(32, "p", 16), h.Cc(33), h.hc(34, "year"), h.Vb(35, "a", 17), h.Cc(36, "Flatlogic"), h.Ub(), h.Cc(37, ", LLC. All rights reserved."), h.Ub(), h.Ub(), h.Ub(), h.Vb(38, "div", 18), h.Vb(39, "div", 19), h.Qb(40, "img", 20), h.Vb(41, "h6", 21), h.Cc(42, "Material Admin"), h.Ub(), h.Ub(), h.Ub(), h.Ub()), 2 & t && (h.Db(33), h.Ec("\xa9 2014-", h.ic(34, 1, e.todayDate), " "))
                            },
                            directives: [s.b, s.a, r.b, p, f],
                            pipes: [g],
                            styles: [".auth-page[_ngcontent-%COMP%]{width:100%;height:100%;display:flex}@media (max-width:768px){.auth-page[_ngcontent-%COMP%]{flex-direction:column}}.auth-page__content-block[_ngcontent-%COMP%]{width:37%;height:100%;background-color:#fff;display:flex;align-items:center;flex-direction:column}@media (max-width:768px){.auth-page__content-block[_ngcontent-%COMP%]{width:100%}}.auth-page__content-wrapper[_ngcontent-%COMP%]{width:45%;height:100%;padding:16px;display:flex;justify-content:space-between;flex-direction:column}@media (max-width:576px){.auth-page__content-wrapper[_ngcontent-%COMP%]{width:70%}}@media (min-width:768px) and (max-width:992px){.auth-page__content-wrapper[_ngcontent-%COMP%]{width:45%}}.auth-page__group[_ngcontent-%COMP%]{margin-top:28px}.auth-page__group-title[_ngcontent-%COMP%]{font-size:32px;font-weight:500;margin-top:37px;letter-spacing:-.7px;text-align:center;line-height:37px;color:#4a4a4a}.auth-page__group-sub-title[_ngcontent-%COMP%]{font-size:24px;font-weight:500;margin-bottom:60px;letter-spacing:-.5px;text-align:center;line-height:24px;color:#4a4a4a}.auth-page__google-button-wrapper[_ngcontent-%COMP%]{margin-top:32px;margin-bottom:10px;width:100%;display:flex;flex-direction:column;align-items:center}.auth-page__google-button[_ngcontent-%COMP%]{width:95%;padding:0;box-shadow:0 0 11px 0 #e8eafc,0 0 0 -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549)}.auth-page__google-button-icon[_ngcontent-%COMP%]{width:20px;margin-right:16px}.auth-page__border-wrapper[_ngcontent-%COMP%]{align-items:center;display:flex;justify-content:center;margin:32px 0}.auth-page__border-line[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#b9b9b9;opacity:.3}.auth-page__border-title[_ngcontent-%COMP%]{font-size:11.2px;padding:0 16px;margin:0;color:#4a4a4a}.auth-page__logo[_ngcontent-%COMP%]{width:63%;height:100%;background-color:#536dfe;display:flex;align-items:center}@media (max-width:768px){.auth-page__logo[_ngcontent-%COMP%]{display:none}}.auth-page__logo-wrapper[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:center;flex-direction:column;align-items:center}.auth-page__logo-img[_ngcontent-%COMP%]{margin-bottom:50px}.auth-page__logo-title[_ngcontent-%COMP%]{font-size:62px;color:#fff;font-weight:500;letter-spacing:-1.5px;line-height:62px}.auth-page__footer-title[_ngcontent-%COMP%]{color:#536dfe;font-size:10px;opacity:.7}.auth-page__footer-title[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;color:#536dfe}"]
                        }), t
                    })()
                }];
            let y = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = h.Nb({
                    type: t
                }), t.\u0275inj = h.Mb({
                    imports: [
                        [l.e.forChild(b)], l.e
                    ]
                }), t
            })();
            var v = i("0fNd");
            let x = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = h.Nb({
                    type: t
                }), t.\u0275inj = h.Mb({
                    providers: [u.a, u.b, v.a],
                    imports: [
                        [n.c, y, s.c, r.c, a.b, o.o, o.g]
                    ]
                }), t
            })()
        },
        lhB6: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("SIQg"),
                s = i("2QHy");

            function r(t, e) {
                const i = Object(s.a)(t) ? t : () => t,
                    r = t => t.error(i());
                return new n.a(e ? t => e.schedule(r, 0, t) : r)
            }
        },
        mASl: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return u
            });
            var n = i("SIQg"),
                s = i("wb3g"),
                r = i("g/MW"),
                a = i("TYm1"),
                o = i("CLjF"),
                l = i("1lu8"),
                c = i("rFin"),
                h = i("xt23");

            function u(...t) {
                const e = Object(l.c)(t),
                    i = Object(l.b)(t),
                    {
                        args: u,
                        keys: p
                    } = Object(s.a)(t);
                if (0 === u.length) return Object(r.a)([], e);
                const f = new n.a(function(t, e, i = a.a) {
                    return n => {
                        d(e, () => {
                            const {
                                length: s
                            } = t, a = new Array(s);
                            let o = s,
                                l = s;
                            for (let c = 0; c < s; c++) d(e, () => {
                                const s = Object(r.a)(t[c], e);
                                let u = !1;
                                s.subscribe(new h.a(n, t => {
                                    a[c] = t, u || (u = !0, l--), l || n.next(i(a.slice()))
                                }, () => {
                                    --o || n.complete()
                                }))
                            }, n)
                        }, n)
                    }
                }(u, e, p ? t => Object(c.a)(p, t) : a.a));
                return i ? f.pipe(Object(o.a)(i)) : f
            }

            function d(t, e, i) {
                t ? i.add(t.schedule(e)) : e()
            }
        },
        nLfN: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            }), i.d(e, "b", function() {
                return l
            }), i.d(e, "c", function() {
                return y
            }), i.d(e, "d", function() {
                return b
            }), i.d(e, "e", function() {
                return h
            }), i.d(e, "f", function() {
                return g
            }), i.d(e, "g", function() {
                return m
            });
            var n = i("fXoL"),
                s = i("ofXK");
            let r;
            try {
                r = "undefined" != typeof Intl && Intl.v8BreakIterator
            } catch (v) {
                r = !1
            }
            let a, o = (() => {
                    class t {
                        constructor(t) {
                            this._platformId = t, this.isBrowser = this._platformId ? Object(s.t)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !r) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(n.D))
                    }, t.\u0275prov = Object(n.Lb)({
                        factory: function() {
                            return new t(Object(n.Zb)(n.D))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                l = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({}), t
                })();
            const c = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"];

            function h() {
                if (a) return a;
                if ("object" != typeof document || !document) return a = new Set(c), a;
                let t = document.createElement("input");
                return a = new Set(c.filter(e => (t.setAttribute("type", e), t.type === e))), a
            }
            let u, d, p, f;

            function g(t) {
                return function() {
                    if (null == u && "undefined" != typeof window) try {
                        window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                            get: () => u = !0
                        }))
                    } finally {
                        u = u || !1
                    }
                    return u
                }() ? t : !!t.capture
            }

            function m() {
                if (null == p) {
                    if ("object" != typeof document || !document || "function" != typeof Element || !Element) return p = !1, p;
                    if ("scrollBehavior" in document.documentElement.style) p = !0;
                    else {
                        const t = Element.prototype.scrollTo;
                        p = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString())
                    }
                }
                return p
            }

            function b() {
                if ("object" != typeof document || !document) return 0;
                if (null == d) {
                    const t = document.createElement("div"),
                        e = t.style;
                    t.dir = "rtl", e.width = "1px", e.overflow = "auto", e.visibility = "hidden", e.pointerEvents = "none", e.position = "absolute";
                    const i = document.createElement("div"),
                        n = i.style;
                    n.width = "2px", n.height = "1px", t.appendChild(i), document.body.appendChild(t), d = 0, 0 === t.scrollLeft && (t.scrollLeft = 1, d = 0 === t.scrollLeft ? 1 : 2), t.parentNode.removeChild(t)
                }
                return d
            }

            function y(t) {
                if (function() {
                        if (null == f) {
                            const t = "undefined" != typeof document ? document.head : null;
                            f = !(!t || !t.createShadowRoot && !t.attachShadow)
                        }
                        return f
                    }()) {
                    const e = t.getRootNode ? t.getRootNode() : null;
                    if ("undefined" != typeof ShadowRoot && ShadowRoot && e instanceof ShadowRoot) return e
                }
                return null
            }
        },
        nnEh: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("eX4W"),
                s = i("EPzc"),
                r = i("xt23");

            function a(t) {
                return t <= 0 ? () => n.a : Object(s.b)((e, i) => {
                    let n = 0;
                    e.subscribe(new r.a(i, e => {
                        ++n <= t && (i.next(e), t <= n && i.complete())
                    }))
                })
            }
        },
        oXA7: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return l
            });
            var n = i("SIQg"),
                s = i("jqqC"),
                r = i("GRmh");
            const a = Object(r.a)(t => function() {
                t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
            });
            var o = i("vRMS");
            class l extends n.a {
                constructor() {
                    super(), this.closed = !1, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null
                }
                lift(t) {
                    const e = new c(this, this);
                    return e.operator = t, e
                }
                _throwIfClosed() {
                    if (this.closed) throw new a
                }
                next(t) {
                    if (this._throwIfClosed(), !this.isStopped) {
                        const e = this.observers.slice();
                        for (const i of e) i.next(t)
                    }
                }
                error(t) {
                    if (this._throwIfClosed(), !this.isStopped) {
                        this.hasError = this.isStopped = !0, this.thrownError = t;
                        const {
                            observers: e
                        } = this;
                        for (; e.length;) e.shift().error(t)
                    }
                }
                complete() {
                    if (this._throwIfClosed(), !this.isStopped) {
                        this.isStopped = !0;
                        const {
                            observers: t
                        } = this;
                        for (; t.length;) t.shift().complete()
                    }
                }
                unsubscribe() {
                    this.isStopped = this.closed = !0, this.observers = null
                }
                _trySubscribe(t) {
                    return this._throwIfClosed(), super._trySubscribe(t)
                }
                _subscribe(t) {
                    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t)
                }
                _innerSubscribe(t) {
                    const {
                        hasError: e,
                        isStopped: i,
                        observers: n
                    } = this;
                    return e || i ? s.a : (n.push(t), new s.b(() => Object(o.a)(n, t)))
                }
                _checkFinalizedStatuses(t) {
                    const {
                        hasError: e,
                        thrownError: i,
                        isStopped: n
                    } = this;
                    e ? t.error(i) : n && t.complete()
                }
                asObservable() {
                    const t = new n.a;
                    return t.source = this, t
                }
            }
            l.create = (t, e) => new c(t, e);
            class c extends l {
                constructor(t, e) {
                    super(), this.destination = t, this.source = e
                }
                next(t) {
                    var e, i;
                    null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, t)
                }
                error(t) {
                    var e, i;
                    null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, t)
                }
                complete() {
                    var t, e;
                    null === (e = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === e || e.call(t)
                }
                _subscribe(t) {
                    var e, i;
                    return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)) && void 0 !== i ? i : s.a
                }
            }
        },
        ofXK: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return x
            }), i.d(e, "b", function() {
                return St
            }), i.d(e, "c", function() {
                return Ot
            }), i.d(e, "d", function() {
                return l
            }), i.d(e, "e", function() {
                return At
            }), i.d(e, "f", function() {
                return w
            }), i.d(e, "g", function() {
                return u
            }), i.d(e, "h", function() {
                return C
            }), i.d(e, "i", function() {
                return y
            }), i.d(e, "j", function() {
                return lt
            }), i.d(e, "k", function() {
                return ht
            }), i.d(e, "l", function() {
                return dt
            }), i.d(e, "m", function() {
                return vt
            }), i.d(e, "n", function() {
                return mt
            }), i.d(e, "o", function() {
                return bt
            }), i.d(e, "p", function() {
                return yt
            }), i.d(e, "q", function() {
                return _
            }), i.d(e, "r", function() {
                return c
            }), i.d(e, "s", function() {
                return Dt
            }), i.d(e, "t", function() {
                return Pt
            }), i.d(e, "u", function() {
                return Tt
            }), i.d(e, "v", function() {
                return o
            }), i.d(e, "w", function() {
                return Et
            }), i.d(e, "x", function() {
                return r
            }), i.d(e, "y", function() {
                return ot
            }), i.d(e, "z", function() {
                return a
            });
            var n = i("fXoL");
            let s = null;

            function r() {
                return s
            }

            function a(t) {
                s || (s = t)
            }
            class o {}
            const l = new n.s("DocumentToken");
            let c = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = Object(n.Lb)({
                    factory: h,
                    token: t,
                    providedIn: "platform"
                }), t
            })();

            function h() {
                return Object(n.Zb)(d)
            }
            const u = new n.s("Location Initialized");
            let d = (() => {
                class t extends c {
                    constructor(t) {
                        super(), this._doc = t, this._init()
                    }
                    _init() {
                        this.location = r().getLocation(), this._history = r().getHistory()
                    }
                    getBaseHrefFromDOM() {
                        return r().getBaseHref(this._doc)
                    }
                    onPopState(t) {
                        r().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1)
                    }
                    onHashChange(t) {
                        r().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1)
                    }
                    get href() {
                        return this.location.href
                    }
                    get protocol() {
                        return this.location.protocol
                    }
                    get hostname() {
                        return this.location.hostname
                    }
                    get port() {
                        return this.location.port
                    }
                    get pathname() {
                        return this.location.pathname
                    }
                    get search() {
                        return this.location.search
                    }
                    get hash() {
                        return this.location.hash
                    }
                    set pathname(t) {
                        this.location.pathname = t
                    }
                    pushState(t, e, i) {
                        p() ? this._history.pushState(t, e, i) : this.location.hash = i
                    }
                    replaceState(t, e, i) {
                        p() ? this._history.replaceState(t, e, i) : this.location.hash = i
                    }
                    forward() {
                        this._history.forward()
                    }
                    back() {
                        this._history.back()
                    }
                    getState() {
                        return this._history.state
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(l))
                }, t.\u0275prov = Object(n.Lb)({
                    factory: f,
                    token: t,
                    providedIn: "platform"
                }), t
            })();

            function p() {
                return !!window.history.pushState
            }

            function f() {
                return new d(Object(n.Zb)(l))
            }

            function g(t, e) {
                if (0 == t.length) return e;
                if (0 == e.length) return t;
                let i = 0;
                return t.endsWith("/") && i++, e.startsWith("/") && i++, 2 == i ? t + e.substring(1) : 1 == i ? t + e : t + "/" + e
            }

            function m(t) {
                const e = t.match(/#|\?|$/),
                    i = e && e.index || t.length;
                return t.slice(0, i - ("/" === t[i - 1] ? 1 : 0)) + t.slice(i)
            }

            function b(t) {
                return t && "?" !== t[0] ? "?" + t : t
            }
            let y = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275prov = Object(n.Lb)({
                    factory: v,
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function v(t) {
                const e = Object(n.Zb)(l).location;
                return new _(Object(n.Zb)(c), e && e.origin || "")
            }
            const x = new n.s("appBaseHref");
            let _ = (() => {
                    class t extends y {
                        constructor(t, e) {
                            if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                            this._baseHref = e
                        }
                        onPopState(t) {
                            this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)
                        }
                        getBaseHref() {
                            return this._baseHref
                        }
                        prepareExternalUrl(t) {
                            return g(this._baseHref, t)
                        }
                        path(t = !1) {
                            const e = this._platformLocation.pathname + b(this._platformLocation.search),
                                i = this._platformLocation.hash;
                            return i && t ? `${e}${i}` : e
                        }
                        pushState(t, e, i, n) {
                            const s = this.prepareExternalUrl(i + b(n));
                            this._platformLocation.pushState(t, e, s)
                        }
                        replaceState(t, e, i, n) {
                            const s = this.prepareExternalUrl(i + b(n));
                            this._platformLocation.replaceState(t, e, s)
                        }
                        forward() {
                            this._platformLocation.forward()
                        }
                        back() {
                            this._platformLocation.back()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(c), n.Zb(x, 8))
                    }, t.\u0275prov = n.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                w = (() => {
                    class t extends y {
                        constructor(t, e) {
                            super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e)
                        }
                        onPopState(t) {
                            this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)
                        }
                        getBaseHref() {
                            return this._baseHref
                        }
                        path(t = !1) {
                            let e = this._platformLocation.hash;
                            return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e
                        }
                        prepareExternalUrl(t) {
                            const e = g(this._baseHref, t);
                            return e.length > 0 ? "#" + e : e
                        }
                        pushState(t, e, i, n) {
                            let s = this.prepareExternalUrl(i + b(n));
                            0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s)
                        }
                        replaceState(t, e, i, n) {
                            let s = this.prepareExternalUrl(i + b(n));
                            0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s)
                        }
                        forward() {
                            this._platformLocation.forward()
                        }
                        back() {
                            this._platformLocation.back()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(c), n.Zb(x, 8))
                    }, t.\u0275prov = n.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                C = (() => {
                    class t {
                        constructor(t, e) {
                            this._subject = new n.o, this._urlChangeListeners = [], this._platformStrategy = t;
                            const i = this._platformStrategy.getBaseHref();
                            this._platformLocation = e, this._baseHref = m(S(i)), this._platformStrategy.onPopState(t => {
                                this._subject.emit({
                                    url: this.path(!0),
                                    pop: !0,
                                    state: t.state,
                                    type: t.type
                                })
                            })
                        }
                        path(t = !1) {
                            return this.normalize(this._platformStrategy.path(t))
                        }
                        getState() {
                            return this._platformLocation.getState()
                        }
                        isCurrentPathEqualTo(t, e = "") {
                            return this.path() == this.normalize(t + b(e))
                        }
                        normalize(e) {
                            return t.stripTrailingSlash(function(t, e) {
                                return t && e.startsWith(t) ? e.substring(t.length) : e
                            }(this._baseHref, S(e)))
                        }
                        prepareExternalUrl(t) {
                            return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t)
                        }
                        go(t, e = "", i = null) {
                            this._platformStrategy.pushState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + b(e)), i)
                        }
                        replaceState(t, e = "", i = null) {
                            this._platformStrategy.replaceState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + b(e)), i)
                        }
                        forward() {
                            this._platformStrategy.forward()
                        }
                        back() {
                            this._platformStrategy.back()
                        }
                        onUrlChange(t) {
                            this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => {
                                this._notifyUrlChangeListeners(t.url, t.state)
                            }))
                        }
                        _notifyUrlChangeListeners(t = "", e) {
                            this._urlChangeListeners.forEach(i => i(t, e))
                        }
                        subscribe(t, e, i) {
                            return this._subject.subscribe({
                                next: t,
                                error: e,
                                complete: i
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Zb(y), n.Zb(c))
                    }, t.normalizeQueryParams = b, t.joinWithSlash = g, t.stripTrailingSlash = m, t.\u0275prov = Object(n.Lb)({
                        factory: k,
                        token: t,
                        providedIn: "root"
                    }), t
                })();

            function k() {
                return new C(Object(n.Zb)(y), Object(n.Zb)(c))
            }

            function S(t) {
                return t.replace(/\/index.html$/, "")
            }
            var A = function(t) {
                    return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t
                }({}),
                O = function(t) {
                    return t[t.Format = 0] = "Format", t[t.Standalone = 1] = "Standalone", t
                }({}),
                E = function(t) {
                    return t[t.Narrow = 0] = "Narrow", t[t.Abbreviated = 1] = "Abbreviated", t[t.Wide = 2] = "Wide", t[t.Short = 3] = "Short", t
                }({}),
                P = function(t) {
                    return t[t.Short = 0] = "Short", t[t.Medium = 1] = "Medium", t[t.Long = 2] = "Long", t[t.Full = 3] = "Full", t
                }({}),
                T = function(t) {
                    return t[t.Decimal = 0] = "Decimal", t[t.Group = 1] = "Group", t[t.List = 2] = "List", t[t.PercentSign = 3] = "PercentSign", t[t.PlusSign = 4] = "PlusSign", t[t.MinusSign = 5] = "MinusSign", t[t.Exponential = 6] = "Exponential", t[t.SuperscriptingExponent = 7] = "SuperscriptingExponent", t[t.PerMille = 8] = "PerMille", t[t[1 / 0] = 9] = "Infinity", t[t.NaN = 10] = "NaN", t[t.TimeSeparator = 11] = "TimeSeparator", t[t.CurrencyDecimal = 12] = "CurrencyDecimal", t[t.CurrencyGroup = 13] = "CurrencyGroup", t
                }({});

            function D(t, e) {
                return F(Object(n.mb)(t)[n.db.DateFormat], e)
            }

            function I(t, e) {
                return F(Object(n.mb)(t)[n.db.TimeFormat], e)
            }

            function M(t, e) {
                return F(Object(n.mb)(t)[n.db.DateTimeFormat], e)
            }

            function L(t, e) {
                const i = Object(n.mb)(t),
                    s = i[n.db.NumberSymbols][e];
                if (void 0 === s) {
                    if (e === T.CurrencyDecimal) return i[n.db.NumberSymbols][T.Decimal];
                    if (e === T.CurrencyGroup) return i[n.db.NumberSymbols][T.Group]
                }
                return s
            }
            const R = n.pb;

            function j(t) {
                if (!t[n.db.ExtraData]) throw new Error(`Missing extra locale data for the locale "${t[n.db.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`)
            }

            function F(t, e) {
                for (let i = e; i > -1; i--)
                    if (void 0 !== t[i]) return t[i];
                throw new Error("Locale data API: locale data undefined")
            }

            function N(t) {
                const [e, i] = t.split(":");
                return {
                    hours: +e,
                    minutes: +i
                }
            }
            const z = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
                V = {},
                B = /((?:[^GyYMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
            var H = function(t) {
                    return t[t.Short = 0] = "Short", t[t.ShortGMT = 1] = "ShortGMT", t[t.Long = 2] = "Long", t[t.Extended = 3] = "Extended", t
                }({}),
                U = function(t) {
                    return t[t.FullYear = 0] = "FullYear", t[t.Month = 1] = "Month", t[t.Date = 2] = "Date", t[t.Hours = 3] = "Hours", t[t.Minutes = 4] = "Minutes", t[t.Seconds = 5] = "Seconds", t[t.FractionalSeconds = 6] = "FractionalSeconds", t[t.Day = 7] = "Day", t
                }({}),
                X = function(t) {
                    return t[t.DayPeriods = 0] = "DayPeriods", t[t.Days = 1] = "Days", t[t.Months = 2] = "Months", t[t.Eras = 3] = "Eras", t
                }({});

            function W(t, e, i, n) {
                let s = function(t) {
                    if (st(t)) return t;
                    if ("number" == typeof t && !isNaN(t)) return new Date(t);
                    if ("string" == typeof t) {
                        if (t = t.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(t)) {
                            const [e, i = 1, n = 1] = t.split("-").map(t => +t);
                            return Y(e, i - 1, n)
                        }
                        const e = parseFloat(t);
                        if (!isNaN(t - e)) return new Date(e);
                        let i;
                        if (i = t.match(z)) return function(t) {
                            const e = new Date(0);
                            let i = 0,
                                n = 0;
                            const s = t[8] ? e.setUTCFullYear : e.setFullYear,
                                r = t[8] ? e.setUTCHours : e.setHours;
                            t[9] && (i = Number(t[9] + t[10]), n = Number(t[9] + t[11])), s.call(e, Number(t[1]), Number(t[2]) - 1, Number(t[3]));
                            const a = Number(t[4] || 0) - i,
                                o = Number(t[5] || 0) - n,
                                l = Number(t[6] || 0),
                                c = Math.floor(1e3 * parseFloat("0." + (t[7] || 0)));
                            return r.call(e, a, o, l, c), e
                        }(i)
                    }
                    const e = new Date(t);
                    if (!st(e)) throw new Error(`Unable to convert "${t}" into a date`);
                    return e
                }(t);
                e = G(i, e) || e;
                let r, a = [];
                for (; e;) {
                    if (r = B.exec(e), !r) {
                        a.push(e);
                        break
                    } {
                        a = a.concat(r.slice(1));
                        const t = a.pop();
                        if (!t) break;
                        e = t
                    }
                }
                let o = s.getTimezoneOffset();
                n && (o = nt(n, o), s = function(t, e, i) {
                    const n = t.getTimezoneOffset();
                    return function(t, e) {
                        return (t = new Date(t.getTime())).setMinutes(t.getMinutes() + e), t
                    }(t, -1 * (nt(e, n) - n))
                }(s, n));
                let l = "";
                return a.forEach(t => {
                    const e = function(t) {
                        if (it[t]) return it[t];
                        let e;
                        switch (t) {
                            case "G":
                            case "GG":
                            case "GGG":
                                e = Q(X.Eras, E.Abbreviated);
                                break;
                            case "GGGG":
                                e = Q(X.Eras, E.Wide);
                                break;
                            case "GGGGG":
                                e = Q(X.Eras, E.Narrow);
                                break;
                            case "y":
                                e = $(U.FullYear, 1, 0, !1, !0);
                                break;
                            case "yy":
                                e = $(U.FullYear, 2, 0, !0, !0);
                                break;
                            case "yyy":
                                e = $(U.FullYear, 3, 0, !1, !0);
                                break;
                            case "yyyy":
                                e = $(U.FullYear, 4, 0, !1, !0);
                                break;
                            case "Y":
                                e = et(1);
                                break;
                            case "YY":
                                e = et(2, !0);
                                break;
                            case "YYY":
                                e = et(3);
                                break;
                            case "YYYY":
                                e = et(4);
                                break;
                            case "M":
                            case "L":
                                e = $(U.Month, 1, 1);
                                break;
                            case "MM":
                            case "LL":
                                e = $(U.Month, 2, 1);
                                break;
                            case "MMM":
                                e = Q(X.Months, E.Abbreviated);
                                break;
                            case "MMMM":
                                e = Q(X.Months, E.Wide);
                                break;
                            case "MMMMM":
                                e = Q(X.Months, E.Narrow);
                                break;
                            case "LLL":
                                e = Q(X.Months, E.Abbreviated, O.Standalone);
                                break;
                            case "LLLL":
                                e = Q(X.Months, E.Wide, O.Standalone);
                                break;
                            case "LLLLL":
                                e = Q(X.Months, E.Narrow, O.Standalone);
                                break;
                            case "w":
                                e = tt(1);
                                break;
                            case "ww":
                                e = tt(2);
                                break;
                            case "W":
                                e = tt(1, !0);
                                break;
                            case "d":
                                e = $(U.Date, 1);
                                break;
                            case "dd":
                                e = $(U.Date, 2);
                                break;
                            case "E":
                            case "EE":
                            case "EEE":
                                e = Q(X.Days, E.Abbreviated);
                                break;
                            case "EEEE":
                                e = Q(X.Days, E.Wide);
                                break;
                            case "EEEEE":
                                e = Q(X.Days, E.Narrow);
                                break;
                            case "EEEEEE":
                                e = Q(X.Days, E.Short);
                                break;
                            case "a":
                            case "aa":
                            case "aaa":
                                e = Q(X.DayPeriods, E.Abbreviated);
                                break;
                            case "aaaa":
                                e = Q(X.DayPeriods, E.Wide);
                                break;
                            case "aaaaa":
                                e = Q(X.DayPeriods, E.Narrow);
                                break;
                            case "b":
                            case "bb":
                            case "bbb":
                                e = Q(X.DayPeriods, E.Abbreviated, O.Standalone, !0);
                                break;
                            case "bbbb":
                                e = Q(X.DayPeriods, E.Wide, O.Standalone, !0);
                                break;
                            case "bbbbb":
                                e = Q(X.DayPeriods, E.Narrow, O.Standalone, !0);
                                break;
                            case "B":
                            case "BB":
                            case "BBB":
                                e = Q(X.DayPeriods, E.Abbreviated, O.Format, !0);
                                break;
                            case "BBBB":
                                e = Q(X.DayPeriods, E.Wide, O.Format, !0);
                                break;
                            case "BBBBB":
                                e = Q(X.DayPeriods, E.Narrow, O.Format, !0);
                                break;
                            case "h":
                                e = $(U.Hours, 1, -12);
                                break;
                            case "hh":
                                e = $(U.Hours, 2, -12);
                                break;
                            case "H":
                                e = $(U.Hours, 1);
                                break;
                            case "HH":
                                e = $(U.Hours, 2);
                                break;
                            case "m":
                                e = $(U.Minutes, 1);
                                break;
                            case "mm":
                                e = $(U.Minutes, 2);
                                break;
                            case "s":
                                e = $(U.Seconds, 1);
                                break;
                            case "ss":
                                e = $(U.Seconds, 2);
                                break;
                            case "S":
                                e = $(U.FractionalSeconds, 1);
                                break;
                            case "SS":
                                e = $(U.FractionalSeconds, 2);
                                break;
                            case "SSS":
                                e = $(U.FractionalSeconds, 3);
                                break;
                            case "Z":
                            case "ZZ":
                            case "ZZZ":
                                e = K(H.Short);
                                break;
                            case "ZZZZZ":
                                e = K(H.Extended);
                                break;
                            case "O":
                            case "OO":
                            case "OOO":
                            case "z":
                            case "zz":
                            case "zzz":
                                e = K(H.ShortGMT);
                                break;
                            case "OOOO":
                            case "ZZZZ":
                            case "zzzz":
                                e = K(H.Long);
                                break;
                            default:
                                return null
                        }
                        return it[t] = e, e
                    }(t);
                    l += e ? e(s, i, o) : "''" === t ? "'" : t.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), l
            }

            function Y(t, e, i) {
                const n = new Date(0);
                return n.setFullYear(t, e, i), n.setHours(0, 0, 0), n
            }

            function G(t, e) {
                const i = function(t) {
                    return Object(n.mb)(t)[n.db.LocaleId]
                }(t);
                if (V[i] = V[i] || {}, V[i][e]) return V[i][e];
                let s = "";
                switch (e) {
                    case "shortDate":
                        s = D(t, P.Short);
                        break;
                    case "mediumDate":
                        s = D(t, P.Medium);
                        break;
                    case "longDate":
                        s = D(t, P.Long);
                        break;
                    case "fullDate":
                        s = D(t, P.Full);
                        break;
                    case "shortTime":
                        s = I(t, P.Short);
                        break;
                    case "mediumTime":
                        s = I(t, P.Medium);
                        break;
                    case "longTime":
                        s = I(t, P.Long);
                        break;
                    case "fullTime":
                        s = I(t, P.Full);
                        break;
                    case "short":
                        const e = G(t, "shortTime"),
                            i = G(t, "shortDate");
                        s = q(M(t, P.Short), [e, i]);
                        break;
                    case "medium":
                        const n = G(t, "mediumTime"),
                            r = G(t, "mediumDate");
                        s = q(M(t, P.Medium), [n, r]);
                        break;
                    case "long":
                        const a = G(t, "longTime"),
                            o = G(t, "longDate");
                        s = q(M(t, P.Long), [a, o]);
                        break;
                    case "full":
                        const l = G(t, "fullTime"),
                            c = G(t, "fullDate");
                        s = q(M(t, P.Full), [l, c])
                }
                return s && (V[i][e] = s), s
            }

            function q(t, e) {
                return e && (t = t.replace(/\{([^}]+)}/g, function(t, i) {
                    return null != e && i in e ? e[i] : t
                })), t
            }

            function Z(t, e, i = "-", n, s) {
                let r = "";
                (t < 0 || s && t <= 0) && (s ? t = 1 - t : (t = -t, r = i));
                let a = String(t);
                for (; a.length < e;) a = "0" + a;
                return n && (a = a.substr(a.length - e)), r + a
            }

            function $(t, e, i = 0, n = !1, s = !1) {
                return function(r, a) {
                    let o = function(t, e) {
                        switch (t) {
                            case U.FullYear:
                                return e.getFullYear();
                            case U.Month:
                                return e.getMonth();
                            case U.Date:
                                return e.getDate();
                            case U.Hours:
                                return e.getHours();
                            case U.Minutes:
                                return e.getMinutes();
                            case U.Seconds:
                                return e.getSeconds();
                            case U.FractionalSeconds:
                                return e.getMilliseconds();
                            case U.Day:
                                return e.getDay();
                            default:
                                throw new Error(`Unknown DateType value "${t}".`)
                        }
                    }(t, r);
                    if ((i > 0 || o > -i) && (o += i), t === U.Hours) 0 === o && -12 === i && (o = 12);
                    else if (t === U.FractionalSeconds) return l = e, Z(o, 3).substr(0, l);
                    var l;
                    const c = L(a, T.MinusSign);
                    return Z(o, e, c, n, s)
                }
            }

            function Q(t, e, i = O.Format, s = !1) {
                return function(r, a) {
                    return function(t, e, i, s, r, a) {
                        switch (i) {
                            case X.Months:
                                return function(t, e, i) {
                                    const s = Object(n.mb)(t),
                                        r = F([s[n.db.MonthsFormat], s[n.db.MonthsStandalone]], e);
                                    return F(r, i)
                                }(e, r, s)[t.getMonth()];
                            case X.Days:
                                return function(t, e, i) {
                                    const s = Object(n.mb)(t),
                                        r = F([s[n.db.DaysFormat], s[n.db.DaysStandalone]], e);
                                    return F(r, i)
                                }(e, r, s)[t.getDay()];
                            case X.DayPeriods:
                                const o = t.getHours(),
                                    l = t.getMinutes();
                                if (a) {
                                    const t = function(t) {
                                            const e = Object(n.mb)(t);
                                            return j(e), (e[n.db.ExtraData][2] || []).map(t => "string" == typeof t ? N(t) : [N(t[0]), N(t[1])])
                                        }(e),
                                        i = function(t, e, i) {
                                            const s = Object(n.mb)(t);
                                            j(s);
                                            const r = F([s[n.db.ExtraData][0], s[n.db.ExtraData][1]], e) || [];
                                            return F(r, i) || []
                                        }(e, r, s),
                                        a = t.findIndex(t => {
                                            if (Array.isArray(t)) {
                                                const [e, i] = t, n = o >= e.hours && l >= e.minutes, s = o < i.hours || o === i.hours && l < i.minutes;
                                                if (e.hours < i.hours) {
                                                    if (n && s) return !0
                                                } else if (n || s) return !0
                                            } else if (t.hours === o && t.minutes === l) return !0;
                                            return !1
                                        });
                                    if (-1 !== a) return i[a]
                                }
                                return function(t, e, i) {
                                    const s = Object(n.mb)(t),
                                        r = F([s[n.db.DayPeriodsFormat], s[n.db.DayPeriodsStandalone]], e);
                                    return F(r, i)
                                }(e, r, s)[o < 12 ? 0 : 1];
                            case X.Eras:
                                return function(t, e) {
                                    return F(Object(n.mb)(t)[n.db.Eras], e)
                                }(e, s)[t.getFullYear() <= 0 ? 0 : 1];
                            default:
                                throw new Error(`unexpected translation type ${i}`)
                        }
                    }(r, a, t, e, i, s)
                }
            }

            function K(t) {
                return function(e, i, n) {
                    const s = -1 * n,
                        r = L(i, T.MinusSign),
                        a = s > 0 ? Math.floor(s / 60) : Math.ceil(s / 60);
                    switch (t) {
                        case H.Short:
                            return (s >= 0 ? "+" : "") + Z(a, 2, r) + Z(Math.abs(s % 60), 2, r);
                        case H.ShortGMT:
                            return "GMT" + (s >= 0 ? "+" : "") + Z(a, 1, r);
                        case H.Long:
                            return "GMT" + (s >= 0 ? "+" : "") + Z(a, 2, r) + ":" + Z(Math.abs(s % 60), 2, r);
                        case H.Extended:
                            return 0 === n ? "Z" : (s >= 0 ? "+" : "") + Z(a, 2, r) + ":" + Z(Math.abs(s % 60), 2, r);
                        default:
                            throw new Error(`Unknown zone width "${t}"`)
                    }
                }
            }

            function J(t) {
                return Y(t.getFullYear(), t.getMonth(), t.getDate() + (4 - t.getDay()))
            }

            function tt(t, e = !1) {
                return function(i, n) {
                    let s;
                    if (e) {
                        const t = new Date(i.getFullYear(), i.getMonth(), 1).getDay() - 1,
                            e = i.getDate();
                        s = 1 + Math.floor((e + t) / 7)
                    } else {
                        const t = J(i),
                            e = function(t) {
                                const e = Y(t, 0, 1).getDay();
                                return Y(t, 0, 1 + (e <= 4 ? 4 : 11) - e)
                            }(t.getFullYear()),
                            n = t.getTime() - e.getTime();
                        s = 1 + Math.round(n / 6048e5)
                    }
                    return Z(s, t, L(n, T.MinusSign))
                }
            }

            function et(t, e = !1) {
                return function(i, n) {
                    return Z(J(i).getFullYear(), t, L(n, T.MinusSign), e)
                }
            }
            const it = {};

            function nt(t, e) {
                t = t.replace(/:/g, "");
                const i = Date.parse("Jan 01, 1970 00:00:00 " + t) / 6e4;
                return isNaN(i) ? e : i
            }

            function st(t) {
                return t instanceof Date && !isNaN(t.valueOf())
            }
            class rt {}
            let at = (() => {
                class t extends rt {
                    constructor(t) {
                        super(), this.locale = t
                    }
                    getPluralCategory(t, e) {
                        switch (R(e || this.locale)(t)) {
                            case A.Zero:
                                return "zero";
                            case A.One:
                                return "one";
                            case A.Two:
                                return "two";
                            case A.Few:
                                return "few";
                            case A.Many:
                                return "many";
                            default:
                                return "other"
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Zb(n.w))
                }, t.\u0275prov = n.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function ot(t, e) {
                e = encodeURIComponent(e);
                for (const i of t.split(";")) {
                    const t = i.indexOf("="),
                        [n, s] = -1 == t ? [i, ""] : [i.slice(0, t), i.slice(t + 1)];
                    if (n.trim() === e) return decodeURIComponent(s)
                }
                return null
            }
            let lt = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = i, this._renderer = n, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null
                    }
                    set klass(t) {
                        this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass)
                    }
                    set ngClass(t) {
                        this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (Object(n.sb)(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create())
                    }
                    ngDoCheck() {
                        if (this._iterableDiffer) {
                            const t = this._iterableDiffer.diff(this._rawClass);
                            t && this._applyIterableChanges(t)
                        } else if (this._keyValueDiffer) {
                            const t = this._keyValueDiffer.diff(this._rawClass);
                            t && this._applyKeyValueChanges(t)
                        }
                    }
                    _applyKeyValueChanges(t) {
                        t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => {
                            t.previousValue && this._toggleClass(t.key, !1)
                        })
                    }
                    _applyIterableChanges(t) {
                        t.forEachAddedItem(t => {
                            if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Object(n.yb)(t.item)}`);
                            this._toggleClass(t.item, !0)
                        }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1))
                    }
                    _applyClasses(t) {
                        t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e])))
                    }
                    _removeClasses(t) {
                        t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1)))
                    }
                    _toggleClass(t, e) {
                        (t = t.trim()) && t.split(/\s+/g).forEach(t => {
                            e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t)
                        })
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(n.u), n.Pb(n.v), n.Pb(n.l), n.Pb(n.G))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["", "ngClass", ""]
                    ],
                    inputs: {
                        klass: ["class", "klass"],
                        ngClass: "ngClass"
                    }
                }), t
            })();
            class ct {
                constructor(t, e, i, n) {
                    this.$implicit = t, this.ngForOf = e, this.index = i, this.count = n
                }
                get first() {
                    return 0 === this.index
                }
                get last() {
                    return this.index === this.count - 1
                }
                get even() {
                    return this.index % 2 == 0
                }
                get odd() {
                    return !this.even
                }
            }
            let ht = (() => {
                class t {
                    constructor(t, e, i) {
                        this._viewContainer = t, this._template = e, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
                    }
                    set ngForOf(t) {
                        this._ngForOf = t, this._ngForOfDirty = !0
                    }
                    set ngForTrackBy(t) {
                        this._trackByFn = t
                    }
                    get ngForTrackBy() {
                        return this._trackByFn
                    }
                    set ngForTemplate(t) {
                        t && (this._template = t)
                    }
                    ngDoCheck() {
                        if (this._ngForOfDirty) {
                            this._ngForOfDirty = !1;
                            const i = this._ngForOf;
                            if (!this._differ && i) try {
                                this._differ = this._differs.find(i).create(this.ngForTrackBy)
                            } catch (e) {
                                throw new Error(`Cannot find a differ supporting object '${i}' of type '${t=i,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`)
                            }
                        }
                        var t;
                        if (this._differ) {
                            const t = this._differ.diff(this._ngForOf);
                            t && this._applyChanges(t)
                        }
                    }
                    _applyChanges(t) {
                        const e = [];
                        t.forEachOperation((t, i, n) => {
                            if (null == t.previousIndex) {
                                const i = this._viewContainer.createEmbeddedView(this._template, new ct(null, this._ngForOf, -1, -1), null === n ? void 0 : n),
                                    s = new ut(t, i);
                                e.push(s)
                            } else if (null == n) this._viewContainer.remove(null === i ? void 0 : i);
                            else if (null !== i) {
                                const s = this._viewContainer.get(i);
                                this._viewContainer.move(s, n);
                                const r = new ut(t, s);
                                e.push(r)
                            }
                        });
                        for (let i = 0; i < e.length; i++) this._perViewChange(e[i].view, e[i].record);
                        for (let i = 0, n = this._viewContainer.length; i < n; i++) {
                            const t = this._viewContainer.get(i);
                            t.context.index = i, t.context.count = n, t.context.ngForOf = this._ngForOf
                        }
                        t.forEachIdentityChange(t => {
                            this._viewContainer.get(t.currentIndex).context.$implicit = t.item
                        })
                    }
                    _perViewChange(t, e) {
                        t.context.$implicit = e.item
                    }
                    static ngTemplateContextGuard(t, e) {
                        return !0
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(n.S), n.Pb(n.O), n.Pb(n.u))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["", "ngFor", "", "ngForOf", ""]
                    ],
                    inputs: {
                        ngForOf: "ngForOf",
                        ngForTrackBy: "ngForTrackBy",
                        ngForTemplate: "ngForTemplate"
                    }
                }), t
            })();
            class ut {
                constructor(t, e) {
                    this.record = t, this.view = e
                }
            }
            let dt = (() => {
                class t {
                    constructor(t, e) {
                        this._viewContainer = t, this._context = new pt, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e
                    }
                    set ngIf(t) {
                        this._context.$implicit = this._context.ngIf = t, this._updateView()
                    }
                    set ngIfThen(t) {
                        ft("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView()
                    }
                    set ngIfElse(t) {
                        ft("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView()
                    }
                    _updateView() {
                        this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
                    }
                    static ngTemplateContextGuard(t, e) {
                        return !0
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(n.Pb(n.S), n.Pb(n.O))
                }, t.\u0275dir = n.Kb({
                    type: t,
                    selectors: [
                        ["", "ngIf", ""]
                    ],
                    inputs: {
                        ngIf: "ngIf",
                        ngIfThen: "ngIfThen",
                        ngIfElse: "ngIfElse"
                    }
                }), t
            })();
            class pt {
                constructor() {
                    this.$implicit = null, this.ngIf = null
                }
            }

            function ft(t, e) {
                if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${Object(n.yb)(e)}'.`)
            }
            class gt {
                constructor(t, e) {
                    this._viewContainerRef = t, this._templateRef = e, this._created = !1
                }
                create() {
                    this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef)
                }
                destroy() {
                    this._created = !1, this._viewContainerRef.clear()
                }
                enforceState(t) {
                    t && !this._created ? this.create() : !t && this._created && this.destroy()
                }
            }
            let mt = (() => {
                    class t {
                        constructor() {
                            this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1
                        }
                        set ngSwitch(t) {
                            this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0)
                        }
                        _addCase() {
                            return this._caseCount++
                        }
                        _addDefault(t) {
                            this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t)
                        }
                        _matchCase(t) {
                            const e = t == this._ngSwitch;
                            return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e
                        }
                        _updateDefaultCases(t) {
                            if (this._defaultViews && t !== this._defaultUsed) {
                                this._defaultUsed = t;
                                for (let e = 0; e < this._defaultViews.length; e++) this._defaultViews[e].enforceState(t)
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "ngSwitch", ""]
                        ],
                        inputs: {
                            ngSwitch: "ngSwitch"
                        }
                    }), t
                })(),
                bt = (() => {
                    class t {
                        constructor(t, e, i) {
                            this.ngSwitch = i, i._addCase(), this._view = new gt(t, e)
                        }
                        ngDoCheck() {
                            this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.S), n.Pb(n.O), n.Pb(mt, 1))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "ngSwitchCase", ""]
                        ],
                        inputs: {
                            ngSwitchCase: "ngSwitchCase"
                        }
                    }), t
                })(),
                yt = (() => {
                    class t {
                        constructor(t, e, i) {
                            i._addDefault(new gt(t, e))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.S), n.Pb(n.O), n.Pb(mt, 1))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "ngSwitchDefault", ""]
                        ]
                    }), t
                })(),
                vt = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._ngEl = t, this._differs = e, this._renderer = i, this._ngStyle = null, this._differ = null
                        }
                        set ngStyle(t) {
                            this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create())
                        }
                        ngDoCheck() {
                            if (this._differ) {
                                const t = this._differ.diff(this._ngStyle);
                                t && this._applyChanges(t)
                            }
                        }
                        _setStyle(t, e) {
                            const [i, n] = t.split(".");
                            null != (e = null != e && n ? `${e}${n}` : e) ? this._renderer.setStyle(this._ngEl.nativeElement, i, e) : this._renderer.removeStyle(this._ngEl.nativeElement, i)
                        }
                        _applyChanges(t) {
                            t.forEachRemovedItem(t => this._setStyle(t.key, null)), t.forEachAddedItem(t => this._setStyle(t.key, t.currentValue)), t.forEachChangedItem(t => this._setStyle(t.key, t.currentValue))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.l), n.Pb(n.v), n.Pb(n.G))
                    }, t.\u0275dir = n.Kb({
                        type: t,
                        selectors: [
                            ["", "ngStyle", ""]
                        ],
                        inputs: {
                            ngStyle: "ngStyle"
                        }
                    }), t
                })();

            function xt(t, e) {
                return Error(`InvalidPipeArgument: '${e}' for pipe '${Object(n.yb)(t)}'`)
            }
            class _t {
                createSubscription(t, e) {
                    return t.subscribe({
                        next: e,
                        error: t => {
                            throw t
                        }
                    })
                }
                dispose(t) {
                    t.unsubscribe()
                }
                onDestroy(t) {
                    t.unsubscribe()
                }
            }
            class wt {
                createSubscription(t, e) {
                    return t.then(e, t => {
                        throw t
                    })
                }
                dispose(t) {}
                onDestroy(t) {}
            }
            const Ct = new wt,
                kt = new _t;
            let St = (() => {
                    class t {
                        constructor(t) {
                            this._ref = t, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null
                        }
                        ngOnDestroy() {
                            this._subscription && this._dispose()
                        }
                        transform(t) {
                            return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue)
                        }
                        _subscribe(t) {
                            this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e))
                        }
                        _selectStrategy(e) {
                            if (Object(n.ub)(e)) return Ct;
                            if (Object(n.vb)(e)) return kt;
                            throw xt(t, e)
                        }
                        _dispose() {
                            this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null
                        }
                        _updateLatestValue(t, e) {
                            t === this._obj && (this._latestValue = e, this._ref.markForCheck())
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.bc())
                    }, t.\u0275pipe = n.Ob({
                        name: "async",
                        type: t,
                        pure: !1
                    }), t
                })(),
                At = (() => {
                    class t {
                        constructor(t) {
                            this.locale = t
                        }
                        transform(e, i = "mediumDate", n, s) {
                            if (null == e || "" === e || e != e) return null;
                            try {
                                return W(e, i, s || this.locale, n)
                            } catch (r) {
                                throw xt(t, r.message)
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(n.Pb(n.w))
                    }, t.\u0275pipe = n.Ob({
                        name: "date",
                        type: t,
                        pure: !0
                    }), t
                })(),
                Ot = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = n.Nb({
                        type: t
                    }), t.\u0275inj = n.Mb({
                        providers: [{
                            provide: rt,
                            useClass: at
                        }]
                    }), t
                })();
            const Et = "browser";

            function Pt(t) {
                return t === Et
            }

            function Tt(t) {
                return "server" === t
            }
            let Dt = (() => {
                class t {}
                return t.\u0275prov = Object(n.Lb)({
                    token: t,
                    providedIn: "root",
                    factory: () => new It(Object(n.Zb)(l), window)
                }), t
            })();
            class It {
                constructor(t, e) {
                    this.document = t, this.window = e, this.offset = () => [0, 0]
                }
                setOffset(t) {
                    this.offset = Array.isArray(t) ? () => t : t
                }
                getScrollPosition() {
                    return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
                }
                scrollToPosition(t) {
                    this.supportsScrolling() && this.window.scrollTo(t[0], t[1])
                }
                scrollToAnchor(t) {
                    if (!this.supportsScrolling()) return;
                    const e = function(t, e) {
                        const i = t.getElementById(e) || t.getElementsByName(e)[0];
                        if (i) return i;
                        if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) {
                            const i = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT);
                            let n = i.currentNode;
                            for (; n;) {
                                const t = n.shadowRoot;
                                if (t) {
                                    const i = t.getElementById(e) || t.querySelector(`[name="${e}"]`);
                                    if (i) return i
                                }
                                n = i.nextNode()
                            }
                        }
                        return null
                    }(this.document, t);
                    e && (this.scrollToElement(e), this.attemptFocus(e))
                }
                setHistoryScrollRestoration(t) {
                    if (this.supportScrollRestoration()) {
                        const e = this.window.history;
                        e && e.scrollRestoration && (e.scrollRestoration = t)
                    }
                }
                scrollToElement(t) {
                    const e = t.getBoundingClientRect(),
                        i = e.left + this.window.pageXOffset,
                        n = e.top + this.window.pageYOffset,
                        s = this.offset();
                    this.window.scrollTo(i - s[0], n - s[1])
                }
                attemptFocus(t) {
                    return t.focus(), this.document.activeElement === t
                }
                supportScrollRestoration() {
                    try {
                        if (!this.supportsScrolling()) return !1;
                        const t = Mt(this.window.history) || Mt(Object.getPrototypeOf(this.window.history));
                        return !(!t || !t.writable && !t.set)
                    } catch (t) {
                        return !1
                    }
                }
                supportsScrolling() {
                    try {
                        return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
                    } catch (t) {
                        return !1
                    }
                }
            }

            function Mt(t) {
                return Object.getOwnPropertyDescriptor(t, "scrollRestoration")
            }
        },
        qFsG: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return v
            }), i.d(e, "b", function() {
                return x
            });
            var n = i("nLfN"),
                s = i("fXoL"),
                r = i("8LU1"),
                a = i("eX4W"),
                o = i("oXA7");
            i("KOvq"), i("8iEs"), i("bk9D"), i("ofXK");
            const l = Object(n.f)({
                passive: !0
            });
            let c = (() => {
                    class t {
                        constructor(t, e) {
                            this._platform = t, this._ngZone = e, this._monitoredElements = new Map
                        }
                        monitor(t) {
                            if (!this._platform.isBrowser) return a.a;
                            const e = Object(r.e)(t),
                                i = this._monitoredElements.get(e);
                            if (i) return i.subject;
                            const n = new o.a,
                                s = "cdk-text-field-autofilled",
                                c = t => {
                                    "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(s) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(s) && (e.classList.remove(s), this._ngZone.run(() => n.next({
                                        target: t.target,
                                        isAutofilled: !1
                                    }))) : (e.classList.add(s), this._ngZone.run(() => n.next({
                                        target: t.target,
                                        isAutofilled: !0
                                    })))
                                };
                            return this._ngZone.runOutsideAngular(() => {
                                e.addEventListener("animationstart", c, l), e.classList.add("cdk-text-field-autofill-monitored")
                            }), this._monitoredElements.set(e, {
                                subject: n,
                                unlisten: () => {
                                    e.removeEventListener("animationstart", c, l)
                                }
                            }), n
                        }
                        stopMonitoring(t) {
                            const e = Object(r.e)(t),
                                i = this._monitoredElements.get(e);
                            i && (i.unlisten(), i.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e))
                        }
                        ngOnDestroy() {
                            this._monitoredElements.forEach((t, e) => this.stopMonitoring(e))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(n.a), s.Zb(s.B))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(n.a), Object(s.Zb)(s.B))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                h = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        imports: [
                            [n.b]
                        ]
                    }), t
                })();
            var u = i("FKr1"),
                d = i("kmnG"),
                p = i("3Pt+");
            const f = new s.s("MAT_INPUT_VALUE_ACCESSOR"),
                g = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"];
            let m = 0;
            class b {
                constructor(t, e, i, n) {
                    this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = i, this.ngControl = n
                }
            }
            const y = Object(u.t)(b);
            let v = (() => {
                    class t extends y {
                        constructor(t, e, i, s, r, a, l, c, h, u) {
                            super(a, s, r, i), this._elementRef = t, this._platform = e, this.ngControl = i, this._autofillMonitor = c, this._formField = u, this._uid = "mat-input-" + m++, this.focused = !1, this.stateChanges = new o.a, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => Object(n.e)().has(t));
                            const d = this._elementRef.nativeElement,
                                p = d.nodeName.toLowerCase();
                            this._inputValueAccessor = l || d, this._previousNativeValue = this.value, this.id = this.id, e.IOS && h.runOutsideAngular(() => {
                                t.nativeElement.addEventListener("keyup", t => {
                                    let e = t.target;
                                    e.value || e.selectionStart || e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0))
                                })
                            }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === p, this._isTextarea = "textarea" === p, this._isNativeSelect && (this.controlType = d.multiple ? "mat-native-select-multiple" : "mat-native-select")
                        }
                        get disabled() {
                            return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled
                        }
                        set disabled(t) {
                            this._disabled = Object(r.c)(t), this.focused && (this.focused = !1, this.stateChanges.next())
                        }
                        get id() {
                            return this._id
                        }
                        set id(t) {
                            this._id = t || this._uid
                        }
                        get required() {
                            return this._required
                        }
                        set required(t) {
                            this._required = Object(r.c)(t)
                        }
                        get type() {
                            return this._type
                        }
                        set type(t) {
                            this._type = t || "text", this._validateType(), !this._isTextarea && Object(n.e)().has(this._type) && (this._elementRef.nativeElement.type = this._type)
                        }
                        get value() {
                            return this._inputValueAccessor.value
                        }
                        set value(t) {
                            t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next())
                        }
                        get readonly() {
                            return this._readonly
                        }
                        set readonly(t) {
                            this._readonly = Object(r.c)(t)
                        }
                        ngAfterViewInit() {
                            this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => {
                                this.autofilled = t.isAutofilled, this.stateChanges.next()
                            })
                        }
                        ngOnChanges() {
                            this.stateChanges.next()
                        }
                        ngOnDestroy() {
                            this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement)
                        }
                        ngDoCheck() {
                            this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder()
                        }
                        focus(t) {
                            this._elementRef.nativeElement.focus(t)
                        }
                        _focusChanged(t) {
                            t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next())
                        }
                        _onInput() {}
                        _dirtyCheckPlaceholder() {
                            var t, e;
                            const i = (null === (e = null === (t = this._formField) || void 0 === t ? void 0 : t._hideControlPlaceholder) || void 0 === e ? void 0 : e.call(t)) ? null : this.placeholder;
                            if (i !== this._previousPlaceholder) {
                                const t = this._elementRef.nativeElement;
                                this._previousPlaceholder = i, i ? t.setAttribute("placeholder", i) : t.removeAttribute("placeholder")
                            }
                        }
                        _dirtyCheckNativeValue() {
                            const t = this._elementRef.nativeElement.value;
                            this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next())
                        }
                        _validateType() {
                            g.indexOf(this._type)
                        }
                        _isNeverEmpty() {
                            return this._neverEmptyInputTypes.indexOf(this._type) > -1
                        }
                        _isBadInput() {
                            let t = this._elementRef.nativeElement.validity;
                            return t && t.badInput
                        }
                        get empty() {
                            return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled)
                        }
                        get shouldLabelFloat() {
                            if (this._isNativeSelect) {
                                const t = this._elementRef.nativeElement,
                                    e = t.options[0];
                                return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label)
                            }
                            return this.focused || !this.empty
                        }
                        setDescribedByIds(t) {
                            t.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", t.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby")
                        }
                        onContainerClick() {
                            this.focused || this.focus()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l), s.Pb(n.a), s.Pb(p.j, 10), s.Pb(p.m, 8), s.Pb(p.f, 8), s.Pb(u.a), s.Pb(f, 10), s.Pb(c), s.Pb(s.B), s.Pb(d.a, 8))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["input", "matInput", ""],
                            ["textarea", "matInput", ""],
                            ["select", "matNativeControl", ""],
                            ["input", "matNativeControl", ""],
                            ["textarea", "matNativeControl", ""]
                        ],
                        hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"],
                        hostVars: 9,
                        hostBindings: function(t, e) {
                            1 & t && s.cc("focus", function() {
                                return e._focusChanged(!0)
                            })("blur", function() {
                                return e._focusChanged(!1)
                            })("input", function() {
                                return e._onInput()
                            }), 2 & t && (s.Yb("disabled", e.disabled)("required", e.required), s.Eb("id", e.id)("data-placeholder", e.placeholder)("readonly", e.readonly && !e._isNativeSelect || null)("aria-invalid", e.errorState && !e.empty)("aria-required", e.required), s.Hb("mat-input-server", e._isServer))
                        },
                        inputs: {
                            id: "id",
                            disabled: "disabled",
                            required: "required",
                            type: "type",
                            value: "value",
                            readonly: "readonly",
                            placeholder: "placeholder",
                            errorStateMatcher: "errorStateMatcher",
                            userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"]
                        },
                        exportAs: ["matInput"],
                        features: [s.Cb([{
                            provide: d.c,
                            useExisting: t
                        }]), s.Ab, s.Bb]
                    }), t
                })(),
                x = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        providers: [u.a],
                        imports: [
                            [h, d.d, u.e], h, d.d
                        ]
                    }), t
                })()
        },
        r9Bt: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("dLTe");

            function s(t) {
                return Object(n.a)((e, i) => t <= i)
            }
        },
        "rB/T": function(t, e, i) {
            "use strict";

            function n(t) {
                for (var i in t) e.hasOwnProperty(i) || (e[i] = t[i])
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), n(i("LbVS")), n(i("vauT")), n(i("PsNa"))
        },
        rDax: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return q
            }), i.d(e, "b", function() {
                return G
            }), i.d(e, "c", function() {
                return X
            }), i.d(e, "d", function() {
                return A
            }), i.d(e, "e", function() {
                return $
            });
            var n = i("vxfF"),
                s = i("fXoL"),
                r = i("nLfN"),
                a = i("cH1L"),
                o = i("ofXK"),
                l = i("8LU1"),
                c = i("+rOU"),
                h = i("oXA7"),
                u = i("jqqC"),
                d = i("2btn"),
                p = i("nnEh"),
                f = i("bk9D"),
                g = i("EPzc"),
                m = i("xt23"),
                b = i("FtGj");
            const y = Object(r.g)();
            class v {
                constructor(t, e) {
                    this._viewportRuler = t, this._previousHTMLStyles = {
                        top: "",
                        left: ""
                    }, this._isEnabled = !1, this._document = e
                }
                attach() {}
                enable() {
                    if (this._canBeEnabled()) {
                        const t = this._document.documentElement;
                        this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = Object(l.d)(-this._previousScrollPosition.left), t.style.top = Object(l.d)(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0
                    }
                }
                disable() {
                    if (this._isEnabled) {
                        const t = this._document.documentElement,
                            e = t.style,
                            i = this._document.body.style,
                            n = e.scrollBehavior || "",
                            s = i.scrollBehavior || "";
                        this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), y && (e.scrollBehavior = i.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), y && (e.scrollBehavior = n, i.scrollBehavior = s)
                    }
                }
                _canBeEnabled() {
                    if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1;
                    const t = this._document.body,
                        e = this._viewportRuler.getViewportSize();
                    return t.scrollHeight > e.height || t.scrollWidth > e.width
                }
            }
            class x {
                constructor(t, e, i, n) {
                    this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i, this._config = n, this._scrollSubscription = null, this._detach = () => {
                        this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach())
                    }
                }
                attach(t) {
                    this._overlayRef = t
                }
                enable() {
                    if (this._scrollSubscription) return;
                    const t = this._scrollDispatcher.scrolled(0);
                    this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => {
                        const t = this._viewportRuler.getViewportScrollPosition().top;
                        Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition()
                    })) : this._scrollSubscription = t.subscribe(this._detach)
                }
                disable() {
                    this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null)
                }
                detach() {
                    this.disable(), this._overlayRef = null
                }
            }
            class _ {
                enable() {}
                disable() {}
                attach() {}
            }

            function w(t, e) {
                return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right)
            }

            function C(t, e) {
                return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right)
            }
            class k {
                constructor(t, e, i, n) {
                    this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this._config = n, this._scrollSubscription = null
                }
                attach(t) {
                    this._overlayRef = t
                }
                enable() {
                    this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => {
                        if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) {
                            const t = this._overlayRef.overlayElement.getBoundingClientRect(),
                                {
                                    width: e,
                                    height: i
                                } = this._viewportRuler.getViewportSize();
                            w(t, [{
                                width: e,
                                height: i,
                                bottom: i,
                                right: e,
                                top: 0,
                                left: 0
                            }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach()))
                        }
                    }))
                }
                disable() {
                    this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null)
                }
                detach() {
                    this.disable(), this._overlayRef = null
                }
            }
            let S = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this.noop = () => new _, this.close = t => new x(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new v(this._viewportRuler, this._document), this.reposition = t => new k(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = n
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(n.c), s.Zb(n.e), s.Zb(s.B), s.Zb(o.d))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(n.c), Object(s.Zb)(n.e), Object(s.Zb)(s.B), Object(s.Zb)(o.d))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            class A {
                constructor(t) {
                    if (this.scrollStrategy = new _, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) {
                        const e = Object.keys(t);
                        for (const i of e) void 0 !== t[i] && (this[i] = t[i])
                    }
                }
            }
            class O {
                constructor(t, e, i, n, s) {
                    this.offsetX = i, this.offsetY = n, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY
                }
            }
            class E {
                constructor(t, e) {
                    this.connectionPair = t, this.scrollableViewProperties = e
                }
            }
            let P = (() => {
                    class t {
                        constructor(t) {
                            this._attachedOverlays = [], this._document = t
                        }
                        ngOnDestroy() {
                            this.detach()
                        }
                        add(t) {
                            this.remove(t), this._attachedOverlays.push(t)
                        }
                        remove(t) {
                            const e = this._attachedOverlays.indexOf(t);
                            e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this.detach()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(o.d))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(o.d))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                T = (() => {
                    class t extends P {
                        constructor(t) {
                            super(t), this._keydownListener = t => {
                                const e = this._attachedOverlays;
                                for (let i = e.length - 1; i > -1; i--)
                                    if (e[i]._keydownEvents.observers.length > 0) {
                                        e[i]._keydownEvents.next(t);
                                        break
                                    }
                            }
                        }
                        add(t) {
                            super.add(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0)
                        }
                        detach() {
                            this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(o.d))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(o.d))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                D = (() => {
                    class t extends P {
                        constructor(t, e) {
                            super(t), this._platform = e, this._cursorStyleIsSet = !1, this._clickListener = t => {
                                const e = t.composedPath ? t.composedPath()[0] : t.target,
                                    i = this._attachedOverlays.slice();
                                for (let n = i.length - 1; n > -1; n--) {
                                    const s = i[n];
                                    if (!(s._outsidePointerEvents.observers.length < 1) && s.hasAttached()) {
                                        if (s.overlayElement.contains(e)) break;
                                        s._outsidePointerEvents.next(t)
                                    }
                                }
                            }
                        }
                        add(t) {
                            super.add(t), this._isAttached || (this._document.body.addEventListener("click", this._clickListener, !0), this._document.body.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = this._document.body.style.cursor, this._document.body.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0)
                        }
                        detach() {
                            this._isAttached && (this._document.body.removeEventListener("click", this._clickListener, !0), this._document.body.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (this._document.body.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(o.d), s.Zb(r.a))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(o.d), Object(s.Zb)(r.a))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })();
            const I = !("undefined" == typeof window || !window || !window.__karma__ && !window.jasmine);
            let M = (() => {
                class t {
                    constructor(t, e) {
                        this._platform = e, this._document = t
                    }
                    ngOnDestroy() {
                        const t = this._containerElement;
                        t && t.parentNode && t.parentNode.removeChild(t)
                    }
                    getContainerElement() {
                        return this._containerElement || this._createContainer(), this._containerElement
                    }
                    _createContainer() {
                        if (this._platform.isBrowser || I) {
                            const t = this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]');
                            for (let e = 0; e < t.length; e++) t[e].parentNode.removeChild(t[e])
                        }
                        const t = this._document.createElement("div");
                        t.classList.add("cdk-overlay-container"), I ? t.setAttribute("platform", "test") : this._platform.isBrowser || t.setAttribute("platform", "server"), this._document.body.appendChild(t), this._containerElement = t
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(o.d), s.Zb(r.a))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(o.d), Object(s.Zb)(r.a))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            class L {
                constructor(t, e, i, n, s, r, a, o, l) {
                    this._portalOutlet = t, this._host = e, this._pane = i, this._config = n, this._ngZone = s, this._keyboardDispatcher = r, this._document = a, this._location = o, this._outsideClickDispatcher = l, this._backdropElement = null, this._backdropClick = new h.a, this._attachments = new h.a, this._detachments = new h.a, this._locationChanges = u.b.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEvents = new h.a, this._outsidePointerEvents = new h.a, n.scrollStrategy && (this._scrollStrategy = n.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = n.positionStrategy
                }
                get overlayElement() {
                    return this._pane
                }
                get backdropElement() {
                    return this._backdropElement
                }
                get hostElement() {
                    return this._host
                }
                attach(t) {
                    let e = this._portalOutlet.attach(t);
                    return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(Object(p.a)(1)).subscribe(() => {
                        this.hasAttached() && this.updatePosition()
                    }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e
                }
                detach() {
                    if (!this.hasAttached()) return;
                    this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable();
                    const t = this._portalOutlet.detach();
                    return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t
                }
                dispose() {
                    const t = this.hasAttached();
                    this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete()
                }
                hasAttached() {
                    return this._portalOutlet.hasAttached()
                }
                backdropClick() {
                    return this._backdropClick
                }
                attachments() {
                    return this._attachments
                }
                detachments() {
                    return this._detachments
                }
                keydownEvents() {
                    return this._keydownEvents
                }
                outsidePointerEvents() {
                    return this._outsidePointerEvents
                }
                getConfig() {
                    return this._config
                }
                updatePosition() {
                    this._positionStrategy && this._positionStrategy.apply()
                }
                updatePositionStrategy(t) {
                    t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition()))
                }
                updateSize(t) {
                    this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize()
                }
                setDirection(t) {
                    this._config = Object.assign(Object.assign({}, this._config), {
                        direction: t
                    }), this._updateElementDirection()
                }
                addPanelClass(t) {
                    this._pane && this._toggleClasses(this._pane, t, !0)
                }
                removePanelClass(t) {
                    this._pane && this._toggleClasses(this._pane, t, !1)
                }
                getDirection() {
                    const t = this._config.direction;
                    return t ? "string" == typeof t ? t : t.value : "ltr"
                }
                updateScrollStrategy(t) {
                    t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable()))
                }
                _updateElementDirection() {
                    this._host.setAttribute("dir", this.getDirection())
                }
                _updateElementSize() {
                    if (!this._pane) return;
                    const t = this._pane.style;
                    t.width = Object(l.d)(this._config.width), t.height = Object(l.d)(this._config.height), t.minWidth = Object(l.d)(this._config.minWidth), t.minHeight = Object(l.d)(this._config.minHeight), t.maxWidth = Object(l.d)(this._config.maxWidth), t.maxHeight = Object(l.d)(this._config.maxHeight)
                }
                _togglePointerEvents(t) {
                    this._pane.style.pointerEvents = t ? "" : "none"
                }
                _attachBackdrop() {
                    this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => {
                        requestAnimationFrame(() => {
                            this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing")
                        })
                    }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing")
                }
                _updateStackingOrder() {
                    this._host.nextSibling && this._host.parentNode.appendChild(this._host)
                }
                detachBackdrop() {
                    let t, e = this._backdropElement;
                    if (!e) return;
                    let i = () => {
                        e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", i), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t)
                    };
                    e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => {
                        e.addEventListener("transitionend", i)
                    }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(i, 500))
                }
                _toggleClasses(t, e, i) {
                    const n = t.classList;
                    Object(l.b)(e).forEach(t => {
                        t && (i ? n.add(t) : n.remove(t))
                    })
                }
                _detachContentWhenStable() {
                    this._ngZone.runOutsideAngular(() => {
                        const t = this._ngZone.onStable.pipe(Object(f.a)(Object(d.a)(this._attachments, this._detachments))).subscribe(() => {
                            this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe())
                        })
                    })
                }
                _disposeScrollStrategy() {
                    const t = this._scrollStrategy;
                    t && (t.disable(), t.detach && t.detach())
                }
            }
            const R = /([A-Za-z%]+)$/;
            class j {
                constructor(t, e, i, n, s) {
                    this._viewportRuler = e, this._document = i, this._platform = n, this._overlayContainer = s, this._lastBoundingBoxSize = {
                        width: 0,
                        height: 0
                    }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new h.a, this._resizeSubscription = u.b.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t)
                }
                get positions() {
                    return this._preferredPositions
                }
                attach(t) {
                    this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
                        this._isInitialRender = !0, this.apply()
                    })
                }
                apply() {
                    if (this._isDisposed || !this._platform.isBrowser) return;
                    if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition();
                    this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect();
                    const t = this._originRect,
                        e = this._overlayRect,
                        i = this._viewportRect,
                        n = [];
                    let s;
                    for (let r of this._preferredPositions) {
                        let a = this._getOriginPoint(t, r),
                            o = this._getOverlayPoint(a, e, r),
                            l = this._getOverlayFit(o, e, i, r);
                        if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(r, a);
                        this._canFitWithFlexibleDimensions(l, o, i) ? n.push({
                            position: r,
                            origin: a,
                            overlayRect: e,
                            boundingBoxRect: this._calculateBoundingBoxRect(a, r)
                        }) : (!s || s.overlayFit.visibleArea < l.visibleArea) && (s = {
                            overlayFit: l,
                            overlayPoint: o,
                            originPoint: a,
                            position: r,
                            overlayRect: e
                        })
                    }
                    if (n.length) {
                        let t = null,
                            e = -1;
                        for (const i of n) {
                            const n = i.boundingBoxRect.width * i.boundingBoxRect.height * (i.position.weight || 1);
                            n > e && (e = n, t = i)
                        }
                        return this._isPushed = !1, void this._applyPosition(t.position, t.origin)
                    }
                    if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint);
                    this._applyPosition(s.position, s.originPoint)
                }
                detach() {
                    this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe()
                }
                dispose() {
                    this._isDisposed || (this._boundingBox && F(this._boundingBox.style, {
                        top: "",
                        left: "",
                        right: "",
                        bottom: "",
                        height: "",
                        width: "",
                        alignItems: "",
                        justifyContent: ""
                    }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0)
                }
                reapplyLastPosition() {
                    if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
                        this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect();
                        const t = this._lastPosition || this._preferredPositions[0],
                            e = this._getOriginPoint(this._originRect, t);
                        this._applyPosition(t, e)
                    }
                }
                withScrollableContainers(t) {
                    return this._scrollables = t, this
                }
                withPositions(t) {
                    return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this
                }
                withViewportMargin(t) {
                    return this._viewportMargin = t, this
                }
                withFlexibleDimensions(t = !0) {
                    return this._hasFlexibleDimensions = t, this
                }
                withGrowAfterOpen(t = !0) {
                    return this._growAfterOpen = t, this
                }
                withPush(t = !0) {
                    return this._canPush = t, this
                }
                withLockedPosition(t = !0) {
                    return this._positionLocked = t, this
                }
                setOrigin(t) {
                    return this._origin = t, this
                }
                withDefaultOffsetX(t) {
                    return this._offsetX = t, this
                }
                withDefaultOffsetY(t) {
                    return this._offsetY = t, this
                }
                withTransformOriginOn(t) {
                    return this._transformOriginSelector = t, this
                }
                _getOriginPoint(t, e) {
                    let i, n;
                    if ("center" == e.originX) i = t.left + t.width / 2;
                    else {
                        const n = this._isRtl() ? t.right : t.left,
                            s = this._isRtl() ? t.left : t.right;
                        i = "start" == e.originX ? n : s
                    }
                    return n = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, {
                        x: i,
                        y: n
                    }
                }
                _getOverlayPoint(t, e, i) {
                    let n, s;
                    return n = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, {
                        x: t.x + n,
                        y: t.y + s
                    }
                }
                _getOverlayFit(t, e, i, n) {
                    const s = z(e);
                    let {
                        x: r,
                        y: a
                    } = t, o = this._getOffset(n, "x"), l = this._getOffset(n, "y");
                    o && (r += o), l && (a += l);
                    let c = 0 - a,
                        h = a + s.height - i.height,
                        u = this._subtractOverflows(s.width, 0 - r, r + s.width - i.width),
                        d = this._subtractOverflows(s.height, c, h),
                        p = u * d;
                    return {
                        visibleArea: p,
                        isCompletelyWithinViewport: s.width * s.height === p,
                        fitsInViewportVertically: d === s.height,
                        fitsInViewportHorizontally: u == s.width
                    }
                }
                _canFitWithFlexibleDimensions(t, e, i) {
                    if (this._hasFlexibleDimensions) {
                        const n = i.bottom - e.y,
                            s = i.right - e.x,
                            r = N(this._overlayRef.getConfig().minHeight),
                            a = N(this._overlayRef.getConfig().minWidth),
                            o = t.fitsInViewportHorizontally || null != a && a <= s;
                        return (t.fitsInViewportVertically || null != r && r <= n) && o
                    }
                    return !1
                }
                _pushOverlayOnScreen(t, e, i) {
                    if (this._previousPushAmount && this._positionLocked) return {
                        x: t.x + this._previousPushAmount.x,
                        y: t.y + this._previousPushAmount.y
                    };
                    const n = z(e),
                        s = this._viewportRect,
                        r = Math.max(t.x + n.width - s.width, 0),
                        a = Math.max(t.y + n.height - s.height, 0),
                        o = Math.max(s.top - i.top - t.y, 0),
                        l = Math.max(s.left - i.left - t.x, 0);
                    let c = 0,
                        h = 0;
                    return c = n.width <= s.width ? l || -r : t.x < this._viewportMargin ? s.left - i.left - t.x : 0, h = n.height <= s.height ? o || -a : t.y < this._viewportMargin ? s.top - i.top - t.y : 0, this._previousPushAmount = {
                        x: c,
                        y: h
                    }, {
                        x: t.x + c,
                        y: t.y + h
                    }
                }
                _applyPosition(t, e) {
                    if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) {
                        const e = this._getScrollVisibility(),
                            i = new E(t, e);
                        this._positionChanges.next(i)
                    }
                    this._isInitialRender = !1
                }
                _setTransformOrigin(t) {
                    if (!this._transformOriginSelector) return;
                    const e = this._boundingBox.querySelectorAll(this._transformOriginSelector);
                    let i, n = t.overlayY;
                    i = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right";
                    for (let s = 0; s < e.length; s++) e[s].style.transformOrigin = `${i} ${n}`
                }
                _calculateBoundingBoxRect(t, e) {
                    const i = this._viewportRect,
                        n = this._isRtl();
                    let s, r, a, o, l, c;
                    if ("top" === e.overlayY) r = t.y, s = i.height - r + this._viewportMargin;
                    else if ("bottom" === e.overlayY) a = i.height - t.y + 2 * this._viewportMargin, s = i.height - a + this._viewportMargin;
                    else {
                        const e = Math.min(i.bottom - t.y + i.top, t.y),
                            n = this._lastBoundingBoxSize.height;
                        s = 2 * e, r = t.y - e, s > n && !this._isInitialRender && !this._growAfterOpen && (r = t.y - n / 2)
                    }
                    if ("end" === e.overlayX && !n || "start" === e.overlayX && n) c = i.width - t.x + this._viewportMargin, o = t.x - this._viewportMargin;
                    else if ("start" === e.overlayX && !n || "end" === e.overlayX && n) l = t.x, o = i.right - t.x;
                    else {
                        const e = Math.min(i.right - t.x + i.left, t.x),
                            n = this._lastBoundingBoxSize.width;
                        o = 2 * e, l = t.x - e, o > n && !this._isInitialRender && !this._growAfterOpen && (l = t.x - n / 2)
                    }
                    return {
                        top: r,
                        left: l,
                        bottom: a,
                        right: c,
                        width: o,
                        height: s
                    }
                }
                _setBoundingBoxStyles(t, e) {
                    const i = this._calculateBoundingBoxRect(t, e);
                    this._isInitialRender || this._growAfterOpen || (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width));
                    const n = {};
                    if (this._hasExactPosition()) n.top = n.left = "0", n.bottom = n.right = n.maxHeight = n.maxWidth = "", n.width = n.height = "100%";
                    else {
                        const t = this._overlayRef.getConfig().maxHeight,
                            s = this._overlayRef.getConfig().maxWidth;
                        n.height = Object(l.d)(i.height), n.top = Object(l.d)(i.top), n.bottom = Object(l.d)(i.bottom), n.width = Object(l.d)(i.width), n.left = Object(l.d)(i.left), n.right = Object(l.d)(i.right), n.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", n.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (n.maxHeight = Object(l.d)(t)), s && (n.maxWidth = Object(l.d)(s))
                    }
                    this._lastBoundingBoxSize = i, F(this._boundingBox.style, n)
                }
                _resetBoundingBoxStyles() {
                    F(this._boundingBox.style, {
                        top: "0",
                        left: "0",
                        right: "0",
                        bottom: "0",
                        height: "",
                        width: "",
                        alignItems: "",
                        justifyContent: ""
                    })
                }
                _resetOverlayElementStyles() {
                    F(this._pane.style, {
                        top: "",
                        left: "",
                        bottom: "",
                        right: "",
                        position: "",
                        transform: ""
                    })
                }
                _setOverlayElementStyles(t, e) {
                    const i = {},
                        n = this._hasExactPosition(),
                        s = this._hasFlexibleDimensions,
                        r = this._overlayRef.getConfig();
                    if (n) {
                        const n = this._viewportRuler.getViewportScrollPosition();
                        F(i, this._getExactOverlayY(e, t, n)), F(i, this._getExactOverlayX(e, t, n))
                    } else i.position = "static";
                    let a = "",
                        o = this._getOffset(e, "x"),
                        c = this._getOffset(e, "y");
                    o && (a += `translateX(${o}px) `), c && (a += `translateY(${c}px)`), i.transform = a.trim(), r.maxHeight && (n ? i.maxHeight = Object(l.d)(r.maxHeight) : s && (i.maxHeight = "")), r.maxWidth && (n ? i.maxWidth = Object(l.d)(r.maxWidth) : s && (i.maxWidth = "")), F(this._pane.style, i)
                }
                _getExactOverlayY(t, e, i) {
                    let n = {
                            top: "",
                            bottom: ""
                        },
                        s = this._getOverlayPoint(e, this._overlayRect, t);
                    this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, i));
                    let r = this._overlayContainer.getContainerElement().getBoundingClientRect().top;
                    return s.y -= r, "bottom" === t.overlayY ? n.bottom = this._document.documentElement.clientHeight - (s.y + this._overlayRect.height) + "px" : n.top = Object(l.d)(s.y), n
                }
                _getExactOverlayX(t, e, i) {
                    let n, s = {
                            left: "",
                            right: ""
                        },
                        r = this._getOverlayPoint(e, this._overlayRect, t);
                    return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, i)), n = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === n ? s.right = this._document.documentElement.clientWidth - (r.x + this._overlayRect.width) + "px" : s.left = Object(l.d)(r.x), s
                }
                _getScrollVisibility() {
                    const t = this._getOriginRect(),
                        e = this._pane.getBoundingClientRect(),
                        i = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect());
                    return {
                        isOriginClipped: C(t, i),
                        isOriginOutsideView: w(t, i),
                        isOverlayClipped: C(e, i),
                        isOverlayOutsideView: w(e, i)
                    }
                }
                _subtractOverflows(t, ...e) {
                    return e.reduce((t, e) => t - Math.max(e, 0), t)
                }
                _getNarrowedViewportRect() {
                    const t = this._document.documentElement.clientWidth,
                        e = this._document.documentElement.clientHeight,
                        i = this._viewportRuler.getViewportScrollPosition();
                    return {
                        top: i.top + this._viewportMargin,
                        left: i.left + this._viewportMargin,
                        right: i.left + t - this._viewportMargin,
                        bottom: i.top + e - this._viewportMargin,
                        width: t - 2 * this._viewportMargin,
                        height: e - 2 * this._viewportMargin
                    }
                }
                _isRtl() {
                    return "rtl" === this._overlayRef.getDirection()
                }
                _hasExactPosition() {
                    return !this._hasFlexibleDimensions || this._isPushed
                }
                _getOffset(t, e) {
                    return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY
                }
                _validatePositions() {}
                _addPanelClasses(t) {
                    this._pane && Object(l.b)(t).forEach(t => {
                        "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t))
                    })
                }
                _clearPanelClasses() {
                    this._pane && (this._appliedPanelClasses.forEach(t => {
                        this._pane.classList.remove(t)
                    }), this._appliedPanelClasses = [])
                }
                _getOriginRect() {
                    const t = this._origin;
                    if (t instanceof s.l) return t.nativeElement.getBoundingClientRect();
                    if (t instanceof Element) return t.getBoundingClientRect();
                    const e = t.width || 0,
                        i = t.height || 0;
                    return {
                        top: t.y,
                        bottom: t.y + i,
                        left: t.x,
                        right: t.x + e,
                        height: i,
                        width: e
                    }
                }
            }

            function F(t, e) {
                for (let i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
                return t
            }

            function N(t) {
                if ("number" != typeof t && null != t) {
                    const [e, i] = t.split(R);
                    return i && "px" !== i ? null : parseFloat(e)
                }
                return t || null
            }

            function z(t) {
                return {
                    top: Math.floor(t.top),
                    right: Math.floor(t.right),
                    bottom: Math.floor(t.bottom),
                    left: Math.floor(t.left),
                    width: Math.floor(t.width),
                    height: Math.floor(t.height)
                }
            }
            class V {
                constructor(t, e, i, n, s, r, a) {
                    this._preferredPositions = [], this._positionStrategy = new j(i, n, s, r, a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges
                }
                get positions() {
                    return this._preferredPositions
                }
                attach(t) {
                    this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null)
                }
                dispose() {
                    this._positionStrategy.dispose()
                }
                detach() {
                    this._positionStrategy.detach()
                }
                apply() {
                    this._positionStrategy.apply()
                }
                recalculateLastPosition() {
                    this._positionStrategy.reapplyLastPosition()
                }
                withScrollableContainers(t) {
                    this._positionStrategy.withScrollableContainers(t)
                }
                withFallbackPosition(t, e, i, n) {
                    const s = new O(t, e, i, n);
                    return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this
                }
                withDirection(t) {
                    return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this
                }
                withOffsetX(t) {
                    return this._positionStrategy.withDefaultOffsetX(t), this
                }
                withOffsetY(t) {
                    return this._positionStrategy.withDefaultOffsetY(t), this
                }
                withLockedPosition(t) {
                    return this._positionStrategy.withLockedPosition(t), this
                }
                withPositions(t) {
                    return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this
                }
                setOrigin(t) {
                    return this._positionStrategy.setOrigin(t), this
                }
            }
            class B {
                constructor() {
                    this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = ""
                }
                attach(t) {
                    const e = t.getConfig();
                    this._overlayRef = t, this._width && !e.width && t.updateSize({
                        width: this._width
                    }), this._height && !e.height && t.updateSize({
                        height: this._height
                    }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1
                }
                top(t = "") {
                    return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this
                }
                left(t = "") {
                    return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this
                }
                bottom(t = "") {
                    return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this
                }
                right(t = "") {
                    return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this
                }
                width(t = "") {
                    return this._overlayRef ? this._overlayRef.updateSize({
                        width: t
                    }) : this._width = t, this
                }
                height(t = "") {
                    return this._overlayRef ? this._overlayRef.updateSize({
                        height: t
                    }) : this._height = t, this
                }
                centerHorizontally(t = "") {
                    return this.left(t), this._justifyContent = "center", this
                }
                centerVertically(t = "") {
                    return this.top(t), this._alignItems = "center", this
                }
                apply() {
                    if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
                    const t = this._overlayRef.overlayElement.style,
                        e = this._overlayRef.hostElement.style,
                        i = this._overlayRef.getConfig(),
                        {
                            width: n,
                            height: s,
                            maxWidth: r,
                            maxHeight: a
                        } = i,
                        o = !("100%" !== n && "100vw" !== n || r && "100%" !== r && "100vw" !== r),
                        l = !("100%" !== s && "100vh" !== s || a && "100%" !== a && "100vh" !== a);
                    t.position = this._cssPosition, t.marginLeft = o ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, o ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems
                }
                dispose() {
                    if (this._isDisposed || !this._overlayRef) return;
                    const t = this._overlayRef.overlayElement.style,
                        e = this._overlayRef.hostElement,
                        i = e.style;
                    e.classList.remove("cdk-global-overlay-wrapper"), i.justifyContent = i.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0
                }
            }
            let H = (() => {
                    class t {
                        constructor(t, e, i, n) {
                            this._viewportRuler = t, this._document = e, this._platform = i, this._overlayContainer = n
                        }
                        global() {
                            return new B
                        }
                        connectedTo(t, e, i) {
                            return new V(e, i, t, this._viewportRuler, this._document, this._platform, this._overlayContainer)
                        }
                        flexibleConnectedTo(t) {
                            return new j(t, this._viewportRuler, this._document, this._platform, this._overlayContainer)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(n.e), s.Zb(o.d), s.Zb(r.a), s.Zb(M))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(n.e), Object(s.Zb)(o.d), Object(s.Zb)(r.a), Object(s.Zb)(M))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                U = 0,
                X = (() => {
                    class t {
                        constructor(t, e, i, n, s, r, a, o, l, c, h) {
                            this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = i, this._positionBuilder = n, this._keyboardDispatcher = s, this._injector = r, this._ngZone = a, this._document = o, this._directionality = l, this._location = c, this._outsideClickDispatcher = h
                        }
                        create(t) {
                            const e = this._createHostElement(),
                                i = this._createPaneElement(e),
                                n = this._createPortalOutlet(i),
                                s = new A(t);
                            return s.direction = s.direction || this._directionality.value, new L(n, e, i, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher)
                        }
                        position() {
                            return this._positionBuilder
                        }
                        _createPaneElement(t) {
                            const e = this._document.createElement("div");
                            return e.id = "cdk-overlay-" + U++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e
                        }
                        _createHostElement() {
                            const t = this._document.createElement("div");
                            return this._overlayContainer.getContainerElement().appendChild(t), t
                        }
                        _createPortalOutlet(t) {
                            return this._appRef || (this._appRef = this._injector.get(s.g)), new c.d(t, this._componentFactoryResolver, this._appRef, this._injector, this._document)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(S), s.Zb(M), s.Zb(s.j), s.Zb(H), s.Zb(T), s.Zb(s.t), s.Zb(s.B), s.Zb(o.d), s.Zb(a.b), s.Zb(o.h), s.Zb(D))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })();
            const W = [{
                    originX: "start",
                    originY: "bottom",
                    overlayX: "start",
                    overlayY: "top"
                }, {
                    originX: "start",
                    originY: "top",
                    overlayX: "start",
                    overlayY: "bottom"
                }, {
                    originX: "end",
                    originY: "top",
                    overlayX: "end",
                    overlayY: "bottom"
                }, {
                    originX: "end",
                    originY: "bottom",
                    overlayX: "end",
                    overlayY: "top"
                }],
                Y = new s.s("cdk-connected-overlay-scroll-strategy");
            let G = (() => {
                    class t {
                        constructor(t) {
                            this.elementRef = t
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "cdk-overlay-origin", ""],
                            ["", "overlay-origin", ""],
                            ["", "cdkOverlayOrigin", ""]
                        ],
                        exportAs: ["cdkOverlayOrigin"]
                    }), t
                })(),
                q = (() => {
                    class t {
                        constructor(t, e, i, n, r) {
                            this._overlay = t, this._dir = r, this._hasBackdrop = !1, this._lockPosition = !1, this._growAfterOpen = !1, this._flexibleDimensions = !1, this._push = !1, this._backdropSubscription = u.b.EMPTY, this._attachSubscription = u.b.EMPTY, this._detachSubscription = u.b.EMPTY, this._positionSubscription = u.b.EMPTY, this.viewportMargin = 0, this.open = !1, this.disableClose = !1, this.backdropClick = new s.o, this.positionChange = new s.o, this.attach = new s.o, this.detach = new s.o, this.overlayKeydown = new s.o, this.overlayOutsideClick = new s.o, this._templatePortal = new c.f(e, i), this._scrollStrategyFactory = n, this.scrollStrategy = this._scrollStrategyFactory()
                        }
                        get offsetX() {
                            return this._offsetX
                        }
                        set offsetX(t) {
                            this._offsetX = t, this._position && this._updatePositionStrategy(this._position)
                        }
                        get offsetY() {
                            return this._offsetY
                        }
                        set offsetY(t) {
                            this._offsetY = t, this._position && this._updatePositionStrategy(this._position)
                        }
                        get hasBackdrop() {
                            return this._hasBackdrop
                        }
                        set hasBackdrop(t) {
                            this._hasBackdrop = Object(l.c)(t)
                        }
                        get lockPosition() {
                            return this._lockPosition
                        }
                        set lockPosition(t) {
                            this._lockPosition = Object(l.c)(t)
                        }
                        get flexibleDimensions() {
                            return this._flexibleDimensions
                        }
                        set flexibleDimensions(t) {
                            this._flexibleDimensions = Object(l.c)(t)
                        }
                        get growAfterOpen() {
                            return this._growAfterOpen
                        }
                        set growAfterOpen(t) {
                            this._growAfterOpen = Object(l.c)(t)
                        }
                        get push() {
                            return this._push
                        }
                        set push(t) {
                            this._push = Object(l.c)(t)
                        }
                        get overlayRef() {
                            return this._overlayRef
                        }
                        get dir() {
                            return this._dir ? this._dir.value : "ltr"
                        }
                        ngOnDestroy() {
                            this._attachSubscription.unsubscribe(), this._detachSubscription.unsubscribe(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this._overlayRef && this._overlayRef.dispose()
                        }
                        ngOnChanges(t) {
                            this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({
                                width: this.width,
                                minWidth: this.minWidth,
                                height: this.height,
                                minHeight: this.minHeight
                            }), t.origin && this.open && this._position.apply()), t.open && (this.open ? this._attachOverlay() : this._detachOverlay())
                        }
                        _createOverlay() {
                            this.positions && this.positions.length || (this.positions = W);
                            const t = this._overlayRef = this._overlay.create(this._buildConfig());
                            this._attachSubscription = t.attachments().subscribe(() => this.attach.emit()), this._detachSubscription = t.detachments().subscribe(() => this.detach.emit()), t.keydownEvents().subscribe(t => {
                                this.overlayKeydown.next(t), t.keyCode !== b.e || this.disableClose || Object(b.o)(t) || (t.preventDefault(), this._detachOverlay())
                            }), this._overlayRef.outsidePointerEvents().subscribe(t => {
                                this.overlayOutsideClick.next(t)
                            })
                        }
                        _buildConfig() {
                            const t = this._position = this.positionStrategy || this._createPositionStrategy(),
                                e = new A({
                                    direction: this._dir,
                                    positionStrategy: t,
                                    scrollStrategy: this.scrollStrategy,
                                    hasBackdrop: this.hasBackdrop
                                });
                            return (this.width || 0 === this.width) && (e.width = this.width), (this.height || 0 === this.height) && (e.height = this.height), (this.minWidth || 0 === this.minWidth) && (e.minWidth = this.minWidth), (this.minHeight || 0 === this.minHeight) && (e.minHeight = this.minHeight), this.backdropClass && (e.backdropClass = this.backdropClass), this.panelClass && (e.panelClass = this.panelClass), e
                        }
                        _updatePositionStrategy(t) {
                            const e = this.positions.map(t => ({
                                originX: t.originX,
                                originY: t.originY,
                                overlayX: t.overlayX,
                                overlayY: t.overlayY,
                                offsetX: t.offsetX || this.offsetX,
                                offsetY: t.offsetY || this.offsetY,
                                panelClass: t.panelClass || void 0
                            }));
                            return t.setOrigin(this.origin.elementRef).withPositions(e).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)
                        }
                        _createPositionStrategy() {
                            const t = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);
                            return this._updatePositionStrategy(t), t
                        }
                        _attachOverlay() {
                            this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || this._overlayRef.attach(this._templatePortal), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe(t => {
                                this.backdropClick.emit(t)
                            }) : this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this.positionChange.observers.length > 0 && (this._positionSubscription = this._position.positionChanges.pipe(function(t, e = !1) {
                                return Object(g.b)((i, n) => {
                                    let s = 0;
                                    i.subscribe(new m.a(n, i => {
                                        const r = t(i, s++);
                                        (r || e) && n.next(i), !r && n.complete()
                                    }))
                                })
                            }(() => this.positionChange.observers.length > 0)).subscribe(t => {
                                this.positionChange.emit(t), 0 === this.positionChange.observers.length && this._positionSubscription.unsubscribe()
                            }))
                        }
                        _detachOverlay() {
                            this._overlayRef && this._overlayRef.detach(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(X), s.Pb(s.O), s.Pb(s.S), s.Pb(Y), s.Pb(a.b, 8))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "cdk-connected-overlay", ""],
                            ["", "connected-overlay", ""],
                            ["", "cdkConnectedOverlay", ""]
                        ],
                        inputs: {
                            viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"],
                            open: ["cdkConnectedOverlayOpen", "open"],
                            disableClose: ["cdkConnectedOverlayDisableClose", "disableClose"],
                            scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
                            offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"],
                            offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"],
                            hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"],
                            lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"],
                            flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"],
                            growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"],
                            push: ["cdkConnectedOverlayPush", "push"],
                            positions: ["cdkConnectedOverlayPositions", "positions"],
                            origin: ["cdkConnectedOverlayOrigin", "origin"],
                            positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"],
                            width: ["cdkConnectedOverlayWidth", "width"],
                            height: ["cdkConnectedOverlayHeight", "height"],
                            minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"],
                            minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"],
                            backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"],
                            panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"],
                            transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"]
                        },
                        outputs: {
                            backdropClick: "backdropClick",
                            positionChange: "positionChange",
                            attach: "attach",
                            detach: "detach",
                            overlayKeydown: "overlayKeydown",
                            overlayOutsideClick: "overlayOutsideClick"
                        },
                        exportAs: ["cdkConnectedOverlay"],
                        features: [s.Bb]
                    }), t
                })();
            const Z = {
                provide: Y,
                deps: [X],
                useFactory: function(t) {
                    return () => t.scrollStrategies.reposition()
                }
            };
            let $ = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = s.Nb({
                    type: t
                }), t.\u0275inj = s.Mb({
                    providers: [X, Z],
                    imports: [
                        [a.a, c.e, n.d], n.d
                    ]
                }), t
            })()
        },
        rFin: function(t, e, i) {
            "use strict";

            function n(t, e) {
                return t.reduce((t, i, n) => (t[i] = e[n], t), {})
            }
            i.d(e, "a", function() {
                return n
            })
        },
        rdQv: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("EPzc"),
                s = i("xt23");

            function r(t, e) {
                return Object(n.b)((i, n) => {
                    let r = 0;
                    i.subscribe(new s.a(n, i => {
                        n.next(t.call(e, i, r++))
                    }))
                })
            }
        },
        sIyT: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("EPzc"),
                s = i("xt23");

            function r(t) {
                return Object(n.b)((e, i) => {
                    e.subscribe(new s.a(i, () => i.next(t)))
                })
            }
        },
        sj3c: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("Jlqm"),
                s = i("EPzc"),
                r = i("xt23");

            function a(t, e = n.b) {
                return Object(s.b)((i, n) => {
                    let s = null,
                        a = null,
                        o = null;
                    const l = () => {
                        if (s) {
                            s.unsubscribe(), s = null;
                            const t = a;
                            a = null, n.next(t)
                        }
                    };

                    function c() {
                        const i = o + t,
                            n = e.now();
                        n < i ? s = this.schedule(void 0, i - n) : l()
                    }
                    i.subscribe(new r.a(n, i => {
                        a = i, o = e.now(), s || (s = e.schedule(c, t))
                    }, () => {
                        l(), n.complete()
                    }, void 0, () => {
                        a = s = null
                    }))
                })
            }
        },
        sj7R: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            var n = i("2QHy"),
                s = i("EPzc"),
                r = i("xt23"),
                a = i("TYm1");

            function o(t, e, i) {
                const o = Object(n.a)(t) || e || i ? {
                    next: t,
                    error: e,
                    complete: i
                } : t;
                return o ? Object(s.b)((t, e) => {
                    t.subscribe(new r.a(e, t => {
                        var i;
                        null === (i = o.next) || void 0 === i || i.call(o, t), e.next(t)
                    }, () => {
                        var t;
                        null === (t = o.complete) || void 0 === t || t.call(o), e.complete()
                    }, t => {
                        var i;
                        null === (i = o.error) || void 0 === i || i.call(o, t), e.error(t)
                    }))
                }) : a.a
            }
        },
        tmVS: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("1M4b"),
                s = i("TYm1");

            function r(t = 1 / 0) {
                return Object(n.a)(s.a, t)
            }
        },
        tyNb: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return bi
            }), i.d(e, "b", function() {
                return ci
            }), i.d(e, "c", function() {
                return hi
            }), i.d(e, "d", function() {
                return pi
            }), i.d(e, "e", function() {
                return Si
            }), i.d(e, "f", function() {
                return fi
            });
            var n = i("ofXK"),
                s = i("fXoL"),
                r = i("g/MW"),
                a = i("4krO"),
                o = i("X/DG"),
                l = i("mASl"),
                c = i("SIQg"),
                h = i("GRmh");
            const u = Object(h.a)(t => function() {
                t(this), this.name = "EmptyError", this.message = "no elements in sequence"
            });
            var d = i("g+Sw"),
                p = i("PV23"),
                f = i("eX4W"),
                g = i("ZXg6"),
                m = i("oXA7"),
                b = i("rdQv"),
                y = i("1q39"),
                v = i("nnEh"),
                x = i("zzs5"),
                _ = i("EPzc"),
                w = i("xt23");

            function C(t, e, i, n, s) {
                return (r, a) => {
                    let o = i,
                        l = e,
                        c = 0;
                    r.subscribe(new w.a(a, e => {
                        const i = c++;
                        l = o ? t(l, e, i) : (o = !0, e), n && a.next(l)
                    }, s && (() => {
                        o && a.next(l), a.complete()
                    })))
                }
            }

            function k(t, e) {
                return Object(_.b)(C(t, e, arguments.length >= 2, !0))
            }
            var S = i("dLTe"),
                A = i("VZwH"),
                O = i("BWBv");

            function E(t) {
                return t <= 0 ? () => f.a : Object(_.b)((e, i) => {
                    let n = [];
                    e.subscribe(new w.a(i, e => {
                        n.push(e), t < n.length && n.shift()
                    }, () => {
                        for (const t of n) i.next(t);
                        i.complete()
                    }, void 0, () => {
                        n = null
                    }))
                })
            }

            function P(t = T) {
                return Object(_.b)((e, i) => {
                    let n = !1;
                    e.subscribe(new w.a(i, t => {
                        n = !0, i.next(t)
                    }, () => n ? i.complete() : i.error(t())))
                })
            }

            function T() {
                return new u
            }

            function D(t) {
                return Object(_.b)((e, i) => {
                    let n = !1;
                    e.subscribe(new w.a(i, t => {
                        n = !0, i.next(t)
                    }, () => {
                        n || i.next(t), i.complete()
                    }))
                })
            }
            var I = i("TYm1");

            function M(t, e) {
                const i = arguments.length >= 2;
                return n => n.pipe(t ? Object(S.a)((e, i) => t(e, i, n)) : I.a, Object(v.a)(1), i ? D(e) : P(() => new u))
            }
            var L = i("1M4b"),
                R = i("sj7R"),
                j = i("42oE"),
                F = i("BjsQ"),
                N = i("tmVS");
            class z {
                constructor(t, e) {
                    this.id = t, this.url = e
                }
            }
            class V extends z {
                constructor(t, e, i = "imperative", n = null) {
                    super(t, e), this.navigationTrigger = i, this.restoredState = n
                }
                toString() {
                    return `NavigationStart(id: ${this.id}, url: '${this.url}')`
                }
            }
            class B extends z {
                constructor(t, e, i) {
                    super(t, e), this.urlAfterRedirects = i
                }
                toString() {
                    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
                }
            }
            class H extends z {
                constructor(t, e, i) {
                    super(t, e), this.reason = i
                }
                toString() {
                    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
                }
            }
            class U extends z {
                constructor(t, e, i) {
                    super(t, e), this.error = i
                }
                toString() {
                    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
                }
            }
            class X extends z {
                constructor(t, e, i, n) {
                    super(t, e), this.urlAfterRedirects = i, this.state = n
                }
                toString() {
                    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class W extends z {
                constructor(t, e, i, n) {
                    super(t, e), this.urlAfterRedirects = i, this.state = n
                }
                toString() {
                    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class Y extends z {
                constructor(t, e, i, n, s) {
                    super(t, e), this.urlAfterRedirects = i, this.state = n, this.shouldActivate = s
                }
                toString() {
                    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
                }
            }
            class G extends z {
                constructor(t, e, i, n) {
                    super(t, e), this.urlAfterRedirects = i, this.state = n
                }
                toString() {
                    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class q extends z {
                constructor(t, e, i, n) {
                    super(t, e), this.urlAfterRedirects = i, this.state = n
                }
                toString() {
                    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
                }
            }
            class Z {
                constructor(t) {
                    this.route = t
                }
                toString() {
                    return `RouteConfigLoadStart(path: ${this.route.path})`
                }
            }
            class $ {
                constructor(t) {
                    this.route = t
                }
                toString() {
                    return `RouteConfigLoadEnd(path: ${this.route.path})`
                }
            }
            class Q {
                constructor(t) {
                    this.snapshot = t
                }
                toString() {
                    return `ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class K {
                constructor(t) {
                    this.snapshot = t
                }
                toString() {
                    return `ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class J {
                constructor(t) {
                    this.snapshot = t
                }
                toString() {
                    return `ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class tt {
                constructor(t) {
                    this.snapshot = t
                }
                toString() {
                    return `ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
                }
            }
            class et {
                constructor(t, e, i) {
                    this.routerEvent = t, this.position = e, this.anchor = i
                }
                toString() {
                    return `Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`
                }
            }
            class it {
                constructor(t) {
                    this.params = t || {}
                }
                has(t) {
                    return Object.prototype.hasOwnProperty.call(this.params, t)
                }
                get(t) {
                    if (this.has(t)) {
                        const e = this.params[t];
                        return Array.isArray(e) ? e[0] : e
                    }
                    return null
                }
                getAll(t) {
                    if (this.has(t)) {
                        const e = this.params[t];
                        return Array.isArray(e) ? e : [e]
                    }
                    return []
                }
                get keys() {
                    return Object.keys(this.params)
                }
            }

            function nt(t) {
                return new it(t)
            }

            function st(t) {
                const e = Error("NavigationCancelingError: " + t);
                return e.ngNavigationCancelingError = !0, e
            }

            function rt(t, e, i) {
                const n = i.path.split("/");
                if (n.length > t.length) return null;
                if ("full" === i.pathMatch && (e.hasChildren() || n.length < t.length)) return null;
                const s = {};
                for (let r = 0; r < n.length; r++) {
                    const e = n[r],
                        i = t[r];
                    if (e.startsWith(":")) s[e.substring(1)] = i;
                    else if (e !== i.path) return null
                }
                return {
                    consumed: t.slice(0, n.length),
                    posParams: s
                }
            }

            function at(t, e) {
                const i = t ? Object.keys(t) : void 0,
                    n = e ? Object.keys(e) : void 0;
                if (!i || !n || i.length != n.length) return !1;
                let s;
                for (let r = 0; r < i.length; r++)
                    if (s = i[r], !ot(t[s], e[s])) return !1;
                return !0
            }

            function ot(t, e) {
                if (Array.isArray(t) && Array.isArray(e)) {
                    if (t.length !== e.length) return !1;
                    const i = [...t].sort(),
                        n = [...e].sort();
                    return i.every((t, e) => n[e] === t)
                }
                return t === e
            }

            function lt(t) {
                return Array.prototype.concat.apply([], t)
            }

            function ct(t) {
                return t.length > 0 ? t[t.length - 1] : null
            }

            function ht(t, e) {
                for (const i in t) t.hasOwnProperty(i) && e(t[i], i)
            }

            function ut(t) {
                return Object(s.tb)(t) ? t : Object(s.ub)(t) ? Object(r.a)(Promise.resolve(t)) : Object(a.a)(t)
            }

            function dt(t, e, i) {
                return i ? function(t, e) {
                    return at(t, e)
                }(t.queryParams, e.queryParams) && pt(t.root, e.root) : function(t, e) {
                    return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(i => ot(t[i], e[i]))
                }(t.queryParams, e.queryParams) && ft(t.root, e.root)
            }

            function pt(t, e) {
                if (!vt(t.segments, e.segments)) return !1;
                if (t.numberOfChildren !== e.numberOfChildren) return !1;
                for (const i in e.children) {
                    if (!t.children[i]) return !1;
                    if (!pt(t.children[i], e.children[i])) return !1
                }
                return !0
            }

            function ft(t, e) {
                return gt(t, e, e.segments)
            }

            function gt(t, e, i) {
                if (t.segments.length > i.length) return !!vt(t.segments.slice(0, i.length), i) && !e.hasChildren();
                if (t.segments.length === i.length) {
                    if (!vt(t.segments, i)) return !1;
                    for (const i in e.children) {
                        if (!t.children[i]) return !1;
                        if (!ft(t.children[i], e.children[i])) return !1
                    }
                    return !0
                } {
                    const n = i.slice(0, t.segments.length),
                        s = i.slice(t.segments.length);
                    return !!vt(t.segments, n) && !!t.children.primary && gt(t.children.primary, e, s)
                }
            }
            class mt {
                constructor(t, e, i) {
                    this.root = t, this.queryParams = e, this.fragment = i
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = nt(this.queryParams)), this._queryParamMap
                }
                toString() {
                    return wt.serialize(this)
                }
            }
            class bt {
                constructor(t, e) {
                    this.segments = t, this.children = e, this.parent = null, ht(e, (t, e) => t.parent = this)
                }
                hasChildren() {
                    return this.numberOfChildren > 0
                }
                get numberOfChildren() {
                    return Object.keys(this.children).length
                }
                toString() {
                    return Ct(this)
                }
            }
            class yt {
                constructor(t, e) {
                    this.path = t, this.parameters = e
                }
                get parameterMap() {
                    return this._parameterMap || (this._parameterMap = nt(this.parameters)), this._parameterMap
                }
                toString() {
                    return Tt(this)
                }
            }

            function vt(t, e) {
                return t.length === e.length && t.every((t, i) => t.path === e[i].path)
            }
            class xt {}
            class _t {
                parse(t) {
                    const e = new Rt(t);
                    return new mt(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment())
                }
                serialize(t) {
                    var e;
                    return `/${kt(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const i=t[e];return Array.isArray(i)?i.map(t=>`${At(e)}=${At(t)}`).join("&"):`${At(e)}=${At(i)}`});return e.length?` ? $ {
                        e.join("&")
                    }
                    `:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`
                }
            }
            const wt = new _t;

            function Ct(t) {
                return t.segments.map(t => Tt(t)).join("/")
            }

            function kt(t, e) {
                if (!t.hasChildren()) return Ct(t);
                if (e) {
                    const e = t.children.primary ? kt(t.children.primary, !1) : "",
                        i = [];
                    return ht(t.children, (t, e) => {
                        "primary" !== e && i.push(`${e}:${kt(t,!1)}`)
                    }), i.length > 0 ? `${e}(${i.join("//")})` : e
                } {
                    const e = function(t, e) {
                        let i = [];
                        return ht(t.children, (t, n) => {
                            "primary" === n && (i = i.concat(e(t, n)))
                        }), ht(t.children, (t, n) => {
                            "primary" !== n && (i = i.concat(e(t, n)))
                        }), i
                    }(t, (e, i) => "primary" === i ? [kt(t.children.primary, !1)] : [`${i}:${kt(e,!1)}`]);
                    return 1 === Object.keys(t.children).length && null != t.children.primary ? `${Ct(t)}/${e[0]}` : `${Ct(t)}/(${e.join("//")})`
                }
            }

            function St(t) {
                return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
            }

            function At(t) {
                return St(t).replace(/%3B/gi, ";")
            }

            function Ot(t) {
                return St(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
            }

            function Et(t) {
                return decodeURIComponent(t)
            }

            function Pt(t) {
                return Et(t.replace(/\+/g, "%20"))
            }

            function Tt(t) {
                return `${Ot(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Ot(t)}=${Ot(e[t])}`).join("")}`;
                var e
            }
            const Dt = /^[^\/()?;=#]+/;

            function It(t) {
                const e = t.match(Dt);
                return e ? e[0] : ""
            }
            const Mt = /^[^=?&#]+/,
                Lt = /^[^?&#]+/;
            class Rt {
                constructor(t) {
                    this.url = t, this.remaining = t
                }
                parseRootSegment() {
                    return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new bt([], {}) : new bt([], this.parseChildren())
                }
                parseQueryParams() {
                    const t = {};
                    if (this.consumeOptional("?"))
                        do {
                            this.parseQueryParam(t)
                        } while (this.consumeOptional("&"));
                    return t
                }
                parseFragment() {
                    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
                }
                parseChildren() {
                    if ("" === this.remaining) return {};
                    this.consumeOptional("/");
                    const t = [];
                    for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), t.push(this.parseSegment());
                    let e = {};
                    this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0));
                    let i = {};
                    return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i.primary = new bt(t, e)), i
                }
                parseSegment() {
                    const t = It(this.remaining);
                    if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);
                    return this.capture(t), new yt(Et(t), this.parseMatrixParams())
                }
                parseMatrixParams() {
                    const t = {};
                    for (; this.consumeOptional(";");) this.parseParam(t);
                    return t
                }
                parseParam(t) {
                    const e = It(this.remaining);
                    if (!e) return;
                    this.capture(e);
                    let i = "";
                    if (this.consumeOptional("=")) {
                        const t = It(this.remaining);
                        t && (i = t, this.capture(i))
                    }
                    t[Et(e)] = Et(i)
                }
                parseQueryParam(t) {
                    const e = function(t) {
                        const e = t.match(Mt);
                        return e ? e[0] : ""
                    }(this.remaining);
                    if (!e) return;
                    this.capture(e);
                    let i = "";
                    if (this.consumeOptional("=")) {
                        const t = function(t) {
                            const e = t.match(Lt);
                            return e ? e[0] : ""
                        }(this.remaining);
                        t && (i = t, this.capture(i))
                    }
                    const n = Pt(e),
                        s = Pt(i);
                    if (t.hasOwnProperty(n)) {
                        let e = t[n];
                        Array.isArray(e) || (e = [e], t[n] = e), e.push(s)
                    } else t[n] = s
                }
                parseParens(t) {
                    const e = {};
                    for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
                        const i = It(this.remaining),
                            n = this.remaining[i.length];
                        if ("/" !== n && ")" !== n && ";" !== n) throw new Error(`Cannot parse url '${this.url}'`);
                        let s;
                        i.indexOf(":") > -1 ? (s = i.substr(0, i.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = "primary");
                        const r = this.parseChildren();
                        e[s] = 1 === Object.keys(r).length ? r.primary : new bt([], r), this.consumeOptional("//")
                    }
                    return e
                }
                peekStartsWith(t) {
                    return this.remaining.startsWith(t)
                }
                consumeOptional(t) {
                    return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0)
                }
                capture(t) {
                    if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`)
                }
            }
            class jt {
                constructor(t) {
                    this._root = t
                }
                get root() {
                    return this._root.value
                }
                parent(t) {
                    const e = this.pathFromRoot(t);
                    return e.length > 1 ? e[e.length - 2] : null
                }
                children(t) {
                    const e = Ft(t, this._root);
                    return e ? e.children.map(t => t.value) : []
                }
                firstChild(t) {
                    const e = Ft(t, this._root);
                    return e && e.children.length > 0 ? e.children[0].value : null
                }
                siblings(t) {
                    const e = Nt(t, this._root);
                    return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t)
                }
                pathFromRoot(t) {
                    return Nt(t, this._root).map(t => t.value)
                }
            }

            function Ft(t, e) {
                if (t === e.value) return e;
                for (const i of e.children) {
                    const e = Ft(t, i);
                    if (e) return e
                }
                return null
            }

            function Nt(t, e) {
                if (t === e.value) return [e];
                for (const i of e.children) {
                    const n = Nt(t, i);
                    if (n.length) return n.unshift(e), n
                }
                return []
            }
            class zt {
                constructor(t, e) {
                    this.value = t, this.children = e
                }
                toString() {
                    return `TreeNode(${this.value})`
                }
            }

            function Vt(t) {
                const e = {};
                return t && t.children.forEach(t => e[t.value.outlet] = t), e
            }
            class Bt extends jt {
                constructor(t, e) {
                    super(t), this.snapshot = e, Gt(this, t)
                }
                toString() {
                    return this.snapshot.toString()
                }
            }

            function Ht(t, e) {
                const i = function(t, e) {
                        const i = new Wt([], {}, {}, "", {}, "primary", e, null, t.root, -1, {});
                        return new Yt("", new zt(i, []))
                    }(t, e),
                    n = new o.a([new yt("", {})]),
                    s = new o.a({}),
                    r = new o.a({}),
                    a = new o.a({}),
                    l = new o.a(""),
                    c = new Ut(n, s, a, l, r, "primary", e, i.root);
                return c.snapshot = i.root, new Bt(new zt(c, []), i)
            }
            class Ut {
                constructor(t, e, i, n, s, r, a, o) {
                    this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = a, this._futureSnapshot = o
                }
                get routeConfig() {
                    return this._futureSnapshot.routeConfig
                }
                get root() {
                    return this._routerState.root
                }
                get parent() {
                    return this._routerState.parent(this)
                }
                get firstChild() {
                    return this._routerState.firstChild(this)
                }
                get children() {
                    return this._routerState.children(this)
                }
                get pathFromRoot() {
                    return this._routerState.pathFromRoot(this)
                }
                get paramMap() {
                    return this._paramMap || (this._paramMap = this.params.pipe(Object(b.a)(t => nt(t)))), this._paramMap
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(Object(b.a)(t => nt(t)))), this._queryParamMap
                }
                toString() {
                    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
                }
            }

            function Xt(t, e = "emptyOnly") {
                const i = t.pathFromRoot;
                let n = 0;
                if ("always" !== e)
                    for (n = i.length - 1; n >= 1;) {
                        const t = i[n],
                            e = i[n - 1];
                        if (t.routeConfig && "" === t.routeConfig.path) n--;
                        else {
                            if (e.component) break;
                            n--
                        }
                    }
                return function(t) {
                    return t.reduce((t, e) => ({
                        params: Object.assign(Object.assign({}, t.params), e.params),
                        data: Object.assign(Object.assign({}, t.data), e.data),
                        resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData)
                    }), {
                        params: {},
                        data: {},
                        resolve: {}
                    })
                }(i.slice(n))
            }
            class Wt {
                constructor(t, e, i, n, s, r, a, o, l, c, h) {
                    this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = a, this.routeConfig = o, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h
                }
                get root() {
                    return this._routerState.root
                }
                get parent() {
                    return this._routerState.parent(this)
                }
                get firstChild() {
                    return this._routerState.firstChild(this)
                }
                get children() {
                    return this._routerState.children(this)
                }
                get pathFromRoot() {
                    return this._routerState.pathFromRoot(this)
                }
                get paramMap() {
                    return this._paramMap || (this._paramMap = nt(this.params)), this._paramMap
                }
                get queryParamMap() {
                    return this._queryParamMap || (this._queryParamMap = nt(this.queryParams)), this._queryParamMap
                }
                toString() {
                    return `Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`
                }
            }
            class Yt extends jt {
                constructor(t, e) {
                    super(e), this.url = t, Gt(this, e)
                }
                toString() {
                    return qt(this._root)
                }
            }

            function Gt(t, e) {
                e.value._routerState = t, e.children.forEach(e => Gt(t, e))
            }

            function qt(t) {
                const e = t.children.length > 0 ? ` { ${t.children.map(qt).join(", ")} } ` : "";
                return `${t.value}${e}`
            }

            function Zt(t) {
                if (t.snapshot) {
                    const e = t.snapshot,
                        i = t._futureSnapshot;
                    t.snapshot = i, at(e.queryParams, i.queryParams) || t.queryParams.next(i.queryParams), e.fragment !== i.fragment && t.fragment.next(i.fragment), at(e.params, i.params) || t.params.next(i.params),
                        function(t, e) {
                            if (t.length !== e.length) return !1;
                            for (let i = 0; i < t.length; ++i)
                                if (!at(t[i], e[i])) return !1;
                            return !0
                        }(e.url, i.url) || t.url.next(i.url), at(e.data, i.data) || t.data.next(i.data)
                } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data)
            }

            function $t(t, e) {
                var i, n;
                return at(t.params, e.params) && vt(i = t.url, n = e.url) && i.every((t, e) => at(t.parameters, n[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || $t(t.parent, e.parent))
            }

            function Qt(t, e, i) {
                if (i && t.shouldReuseRoute(e.value, i.value.snapshot)) {
                    const n = i.value;
                    n._futureSnapshot = e.value;
                    const s = function(t, e, i) {
                        return e.children.map(e => {
                            for (const n of i.children)
                                if (t.shouldReuseRoute(e.value, n.value.snapshot)) return Qt(t, e, n);
                            return Qt(t, e)
                        })
                    }(t, e, i);
                    return new zt(n, s)
                } {
                    if (t.shouldAttach(e.value)) {
                        const i = t.retrieve(e.value);
                        if (null !== i) {
                            const t = i.route;
                            return Kt(e, t), t
                        }
                    }
                    const i = new Ut(new o.a((n = e.value).url), new o.a(n.params), new o.a(n.queryParams), new o.a(n.fragment), new o.a(n.data), n.outlet, n.component, n),
                        s = e.children.map(e => Qt(t, e));
                    return new zt(i, s)
                }
                var n
            }

            function Kt(t, e) {
                if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");
                if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");
                e.value._futureSnapshot = t.value;
                for (let i = 0; i < t.children.length; ++i) Kt(t.children[i], e.children[i])
            }

            function Jt(t) {
                return "object" == typeof t && null != t && !t.outlets && !t.segmentPath
            }

            function te(t) {
                return "object" == typeof t && null != t && t.outlets
            }

            function ee(t, e, i, n, s) {
                let r = {};
                return n && ht(n, (t, e) => {
                    r[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}`
                }), new mt(i.root === t ? e : ie(i.root, t, e), r, s)
            }

            function ie(t, e, i) {
                const n = {};
                return ht(t.children, (t, s) => {
                    n[s] = t === e ? i : ie(t, e, i)
                }), new bt(t.segments, n)
            }
            class ne {
                constructor(t, e, i) {
                    if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && Jt(i[0])) throw new Error("Root segment cannot have matrix parameters");
                    const n = i.find(te);
                    if (n && n !== ct(i)) throw new Error("{outlets:{}} has to be the last command")
                }
                toRoot() {
                    return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0]
                }
            }
            class se {
                constructor(t, e, i) {
                    this.segmentGroup = t, this.processChildren = e, this.index = i
                }
            }

            function re(t, e, i) {
                if (t || (t = new bt([], {})), 0 === t.segments.length && t.hasChildren()) return ae(t, e, i);
                const n = function(t, e, i) {
                        let n = 0,
                            s = e;
                        const r = {
                            match: !1,
                            pathIndex: 0,
                            commandIndex: 0
                        };
                        for (; s < t.segments.length;) {
                            if (n >= i.length) return r;
                            const e = t.segments[s],
                                a = i[n];
                            if (te(a)) break;
                            const o = `${a}`,
                                l = n < i.length - 1 ? i[n + 1] : null;
                            if (s > 0 && void 0 === o) break;
                            if (o && l && "object" == typeof l && void 0 === l.outlets) {
                                if (!he(o, l, e)) return r;
                                n += 2
                            } else {
                                if (!he(o, {}, e)) return r;
                                n++
                            }
                            s++
                        }
                        return {
                            match: !0,
                            pathIndex: s,
                            commandIndex: n
                        }
                    }(t, e, i),
                    s = i.slice(n.commandIndex);
                if (n.match && n.pathIndex < t.segments.length) {
                    const e = new bt(t.segments.slice(0, n.pathIndex), {});
                    return e.children.primary = new bt(t.segments.slice(n.pathIndex), t.children), ae(e, 0, s)
                }
                return n.match && 0 === s.length ? new bt(t.segments, {}) : n.match && !t.hasChildren() ? oe(t, e, i) : n.match ? ae(t, 0, s) : oe(t, e, i)
            }

            function ae(t, e, i) {
                if (0 === i.length) return new bt(t.segments, {}); {
                    const n = function(t) {
                            return te(t[0]) ? t[0].outlets : {
                                primary: t
                            }
                        }(i),
                        s = {};
                    return ht(n, (i, n) => {
                        "string" == typeof i && (i = [i]), null !== i && (s[n] = re(t.children[n], e, i))
                    }), ht(t.children, (t, e) => {
                        void 0 === n[e] && (s[e] = t)
                    }), new bt(t.segments, s)
                }
            }

            function oe(t, e, i) {
                const n = t.segments.slice(0, e);
                let s = 0;
                for (; s < i.length;) {
                    const r = i[s];
                    if (te(r)) {
                        const t = le(r.outlets);
                        return new bt(n, t)
                    }
                    if (0 === s && Jt(i[0])) {
                        n.push(new yt(t.segments[e].path, ce(i[0]))), s++;
                        continue
                    }
                    const a = te(r) ? r.outlets.primary : `${r}`,
                        o = s < i.length - 1 ? i[s + 1] : null;
                    a && o && Jt(o) ? (n.push(new yt(a, ce(o))), s += 2) : (n.push(new yt(a, {})), s++)
                }
                return new bt(n, {})
            }

            function le(t) {
                const e = {};
                return ht(t, (t, i) => {
                    "string" == typeof t && (t = [t]), null !== t && (e[i] = oe(new bt([], {}), 0, t))
                }), e
            }

            function ce(t) {
                const e = {};
                return ht(t, (t, i) => e[i] = `${t}`), e
            }

            function he(t, e, i) {
                return t == i.path && at(e, i.parameters)
            }
            class ue {
                constructor(t, e, i, n) {
                    this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = n
                }
                activate(t) {
                    const e = this.futureState._root,
                        i = this.currState ? this.currState._root : null;
                    this.deactivateChildRoutes(e, i, t), Zt(this.futureState.root), this.activateChildRoutes(e, i, t)
                }
                deactivateChildRoutes(t, e, i) {
                    const n = Vt(e);
                    t.children.forEach(t => {
                        const e = t.value.outlet;
                        this.deactivateRoutes(t, n[e], i), delete n[e]
                    }), ht(n, (t, e) => {
                        this.deactivateRouteAndItsChildren(t, i)
                    })
                }
                deactivateRoutes(t, e, i) {
                    const n = t.value,
                        s = e ? e.value : null;
                    if (n === s)
                        if (n.component) {
                            const s = i.getContext(n.outlet);
                            s && this.deactivateChildRoutes(t, e, s.children)
                        } else this.deactivateChildRoutes(t, e, i);
                    else s && this.deactivateRouteAndItsChildren(e, i)
                }
                deactivateRouteAndItsChildren(t, e) {
                    this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e)
                }
                detachAndStoreRouteSubtree(t, e) {
                    const i = e.getContext(t.value.outlet);
                    if (i && i.outlet) {
                        const e = i.outlet.detach(),
                            n = i.children.onOutletDeactivated();
                        this.routeReuseStrategy.store(t.value.snapshot, {
                            componentRef: e,
                            route: t,
                            contexts: n
                        })
                    }
                }
                deactivateRouteAndOutlet(t, e) {
                    const i = e.getContext(t.value.outlet),
                        n = i && t.value.component ? i.children : e,
                        s = Vt(t);
                    for (const r of Object.keys(s)) this.deactivateRouteAndItsChildren(s[r], n);
                    i && i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated(), i.attachRef = null, i.resolver = null, i.route = null)
                }
                activateChildRoutes(t, e, i) {
                    const n = Vt(e);
                    t.children.forEach(t => {
                        this.activateRoutes(t, n[t.value.outlet], i), this.forwardEvent(new tt(t.value.snapshot))
                    }), t.children.length && this.forwardEvent(new K(t.value.snapshot))
                }
                activateRoutes(t, e, i) {
                    const n = t.value,
                        s = e ? e.value : null;
                    if (Zt(n), n === s)
                        if (n.component) {
                            const s = i.getOrCreateContext(n.outlet);
                            this.activateChildRoutes(t, e, s.children)
                        } else this.activateChildRoutes(t, e, i);
                    else if (n.component) {
                        const e = i.getOrCreateContext(n.outlet);
                        if (this.routeReuseStrategy.shouldAttach(n.snapshot)) {
                            const t = this.routeReuseStrategy.retrieve(n.snapshot);
                            this.routeReuseStrategy.store(n.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), de(t.route)
                        } else {
                            const i = function(t) {
                                    for (let e = t.parent; e; e = e.parent) {
                                        const t = e.routeConfig;
                                        if (t && t._loadedConfig) return t._loadedConfig;
                                        if (t && t.component) return null
                                    }
                                    return null
                                }(n.snapshot),
                                s = i ? i.module.componentFactoryResolver : null;
                            e.attachRef = null, e.route = n, e.resolver = s, e.outlet && e.outlet.activateWith(n, s), this.activateChildRoutes(t, null, e.children)
                        }
                    } else this.activateChildRoutes(t, null, i)
                }
            }

            function de(t) {
                Zt(t.value), t.children.forEach(de)
            }
            class pe {
                constructor(t, e) {
                    this.routes = t, this.module = e
                }
            }

            function fe(t) {
                return "function" == typeof t
            }

            function ge(t) {
                return t instanceof mt
            }
            const me = Symbol("INITIAL_VALUE");

            function be() {
                return Object(y.a)(t => Object(l.a)(t.map(t => t.pipe(Object(v.a)(1), Object(x.a)(me)))).pipe(k((t, e) => {
                    let i = !1;
                    return e.reduce((t, n, s) => {
                        if (t !== me) return t;
                        if (n === me && (i = !0), !i) {
                            if (!1 === n) return n;
                            if (s === e.length - 1 || ge(n)) return n
                        }
                        return t
                    }, t)
                }, me), Object(S.a)(t => t !== me), Object(b.a)(t => ge(t) ? t : !0 === t), Object(v.a)(1)))
            }
            let ye = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["ng-component"]
                    ],
                    decls: 1,
                    vars: 0,
                    template: function(t, e) {
                        1 & t && s.Qb(0, "router-outlet")
                    },
                    directives: function() {
                        return [fi]
                    },
                    encapsulation: 2
                }), t
            })();

            function ve(t, e = "") {
                for (let i = 0; i < t.length; i++) {
                    const n = t[i];
                    xe(n, _e(e, n))
                }
            }

            function xe(t, e) {
                t.children && ve(t.children, e)
            }

            function _e(t, e) {
                return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t
            }

            function we(t) {
                const e = t.children && t.children.map(we),
                    i = e ? Object.assign(Object.assign({}, t), {
                        children: e
                    }) : Object.assign({}, t);
                return !i.component && (e || i.loadChildren) && i.outlet && "primary" !== i.outlet && (i.component = ye), i
            }

            function Ce(t) {
                return t.outlet || "primary"
            }

            function ke(t, e) {
                const i = t.filter(t => Ce(t) === e);
                return i.push(...t.filter(t => Ce(t) !== e)), i
            }
            const Se = {
                matched: !1,
                consumedSegments: [],
                lastChild: 0,
                parameters: {},
                positionalParamSegments: {}
            };

            function Ae(t, e, i) {
                var n;
                if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || i.length > 0) ? Object.assign({}, Se) : {
                    matched: !0,
                    consumedSegments: [],
                    lastChild: 0,
                    parameters: {},
                    positionalParamSegments: {}
                };
                const s = (e.matcher || rt)(i, t, e);
                if (!s) return Object.assign({}, Se);
                const r = {};
                ht(s.posParams, (t, e) => {
                    r[e] = t.path
                });
                const a = s.consumed.length > 0 ? Object.assign(Object.assign({}, r), s.consumed[s.consumed.length - 1].parameters) : r;
                return {
                    matched: !0,
                    consumedSegments: s.consumed,
                    lastChild: s.consumed.length,
                    parameters: a,
                    positionalParamSegments: null !== (n = s.posParams) && void 0 !== n ? n : {}
                }
            }

            function Oe(t, e, i, n, s = "corrected") {
                if (i.length > 0 && function(t, e, i) {
                        return i.some(i => Ee(t, e, i) && "primary" !== Ce(i))
                    }(t, i, n)) {
                    const s = new bt(e, function(t, e, i, n) {
                        const s = {};
                        s.primary = n, n._sourceSegment = t, n._segmentIndexShift = e.length;
                        for (const r of i)
                            if ("" === r.path && "primary" !== Ce(r)) {
                                const i = new bt([], {});
                                i._sourceSegment = t, i._segmentIndexShift = e.length, s[Ce(r)] = i
                            } return s
                    }(t, e, n, new bt(i, t.children)));
                    return s._sourceSegment = t, s._segmentIndexShift = e.length, {
                        segmentGroup: s,
                        slicedSegments: []
                    }
                }
                if (0 === i.length && function(t, e, i) {
                        return i.some(i => Ee(t, e, i))
                    }(t, i, n)) {
                    const r = new bt(t.segments, function(t, e, i, n, s, r) {
                        const a = {};
                        for (const o of n)
                            if (Ee(t, i, o) && !s[Ce(o)]) {
                                const i = new bt([], {});
                                i._sourceSegment = t, i._segmentIndexShift = "legacy" === r ? t.segments.length : e.length, a[Ce(o)] = i
                            } return Object.assign(Object.assign({}, s), a)
                    }(t, e, i, n, t.children, s));
                    return r._sourceSegment = t, r._segmentIndexShift = e.length, {
                        segmentGroup: r,
                        slicedSegments: i
                    }
                }
                const r = new bt(t.segments, t.children);
                return r._sourceSegment = t, r._segmentIndexShift = e.length, {
                    segmentGroup: r,
                    slicedSegments: i
                }
            }

            function Ee(t, e, i) {
                return (!(t.hasChildren() || e.length > 0) || "full" !== i.pathMatch) && "" === i.path
            }

            function Pe(t, e, i, n) {
                return !!(Ce(t) === n || "primary" !== n && Ee(e, i, t)) && ("**" === t.path || Ae(e, t, i).matched)
            }

            function Te(t, e, i) {
                return 0 === e.length && !t.children[i]
            }
            class De {
                constructor(t) {
                    this.segmentGroup = t || null
                }
            }
            class Ie {
                constructor(t) {
                    this.urlTree = t
                }
            }

            function Me(t) {
                return new c.a(e => e.error(new De(t)))
            }

            function Le(t) {
                return new c.a(e => e.error(new Ie(t)))
            }

            function Re(t) {
                return new c.a(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))
            }
            class je {
                constructor(t, e, i, n, r) {
                    this.configLoader = e, this.urlSerializer = i, this.urlTree = n, this.config = r, this.allowRedirects = !0, this.ngModule = t.get(s.z)
                }
                apply() {
                    const t = Oe(this.urlTree.root, [], [], this.config).segmentGroup,
                        e = new bt(t.segments, t.children);
                    return this.expandSegmentGroup(this.ngModule, this.config, e, "primary").pipe(Object(b.a)(t => this.createUrlTree(Fe(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe(Object(A.a)(t => {
                        if (t instanceof Ie) return this.allowRedirects = !1, this.match(t.urlTree);
                        if (t instanceof De) throw this.noMatchError(t);
                        throw t
                    }))
                }
                match(t) {
                    return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(Object(b.a)(e => this.createUrlTree(Fe(e), t.queryParams, t.fragment))).pipe(Object(A.a)(t => {
                        if (t instanceof De) throw this.noMatchError(t);
                        throw t
                    }))
                }
                noMatchError(t) {
                    return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)
                }
                createUrlTree(t, e, i) {
                    const n = t.segments.length > 0 ? new bt([], {
                        primary: t
                    }) : t;
                    return new mt(n, e, i)
                }
                expandSegmentGroup(t, e, i, n) {
                    return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(Object(b.a)(t => new bt([], t))) : this.expandSegment(t, i, e, i.segments, n, !0)
                }
                expandChildren(t, e, i) {
                    const n = [];
                    for (const s of Object.keys(i.children)) "primary" === s ? n.unshift(s) : n.push(s);
                    return Object(r.a)(n).pipe(Object(O.a)(n => {
                        const s = i.children[n],
                            r = ke(e, n);
                        return this.expandSegmentGroup(t, r, s, n).pipe(Object(b.a)(t => ({
                            segment: t,
                            outlet: n
                        })))
                    }), k((t, e) => (t[e.outlet] = e.segment, t), {}), function(t, e) {
                        const i = arguments.length >= 2;
                        return n => n.pipe(t ? Object(S.a)((e, i) => t(e, i, n)) : I.a, E(1), i ? D(e) : P(() => new u))
                    }())
                }
                expandSegment(t, e, i, n, s, o) {
                    return Object(r.a)(i).pipe(Object(O.a)(r => this.expandSegmentAgainstRoute(t, e, i, r, n, s, o).pipe(Object(A.a)(t => {
                        if (t instanceof De) return Object(a.a)(null);
                        throw t
                    }))), M(t => !!t), Object(A.a)((t, i) => {
                        if (t instanceof u || "EmptyError" === t.name) {
                            if (Te(e, n, s)) return Object(a.a)(new bt([], {}));
                            throw new De(e)
                        }
                        throw t
                    }))
                }
                expandSegmentAgainstRoute(t, e, i, n, s, r, a) {
                    return Pe(n, e, s, r) ? void 0 === n.redirectTo ? this.matchSegmentAgainstRoute(t, e, n, s, r) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) : Me(e) : Me(e)
                }
                expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) {
                    return "**" === n.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, n, r) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r)
                }
                expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, n) {
                    const s = this.applyRedirectCommands([], i.redirectTo, {});
                    return i.redirectTo.startsWith("/") ? Le(s) : this.lineralizeSegments(i, s).pipe(Object(L.a)(i => {
                        const s = new bt(i, {});
                        return this.expandSegment(t, s, e, i, n, !1)
                    }))
                }
                expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) {
                    const {
                        matched: a,
                        consumedSegments: o,
                        lastChild: l,
                        positionalParamSegments: c
                    } = Ae(e, n, s);
                    if (!a) return Me(e);
                    const h = this.applyRedirectCommands(o, n.redirectTo, c);
                    return n.redirectTo.startsWith("/") ? Le(h) : this.lineralizeSegments(n, h).pipe(Object(L.a)(n => this.expandSegment(t, e, i, n.concat(s.slice(l)), r, !1)))
                }
                matchSegmentAgainstRoute(t, e, i, n, s) {
                    if ("**" === i.path) return i.loadChildren ? (i._loadedConfig ? Object(a.a)(i._loadedConfig) : this.configLoader.load(t.injector, i)).pipe(Object(b.a)(t => (i._loadedConfig = t, new bt(n, {})))) : Object(a.a)(new bt(n, {}));
                    const {
                        matched: r,
                        consumedSegments: o,
                        lastChild: l
                    } = Ae(e, i, n);
                    if (!r) return Me(e);
                    const c = n.slice(l);
                    return this.getChildConfig(t, i, n).pipe(Object(L.a)(t => {
                        const n = t.module,
                            r = t.routes,
                            {
                                segmentGroup: l,
                                slicedSegments: h
                            } = Oe(e, o, c, r),
                            u = new bt(l.segments, l.children);
                        if (0 === h.length && u.hasChildren()) return this.expandChildren(n, r, u).pipe(Object(b.a)(t => new bt(o, t)));
                        if (0 === r.length && 0 === h.length) return Object(a.a)(new bt(o, {}));
                        const d = Ce(i) === s;
                        return this.expandSegment(n, u, r, h, d ? "primary" : s, !0).pipe(Object(b.a)(t => new bt(o.concat(t.segments), t.children)))
                    }))
                }
                getChildConfig(t, e, i) {
                    return e.children ? Object(a.a)(new pe(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Object(a.a)(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, i).pipe(Object(L.a)(i => i ? this.configLoader.load(t.injector, e).pipe(Object(b.a)(t => (e._loadedConfig = t, t))) : function(t) {
                        return new c.a(e => e.error(st(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))
                    }(e))) : Object(a.a)(new pe([], t))
                }
                runCanLoadGuards(t, e, i) {
                    const n = e.canLoad;
                    if (!n || 0 === n.length) return Object(a.a)(!0);
                    const s = n.map(n => {
                        const s = t.get(n);
                        let r;
                        if (function(t) {
                                return t && fe(t.canLoad)
                            }(s)) r = s.canLoad(e, i);
                        else {
                            if (!fe(s)) throw new Error("Invalid CanLoad guard");
                            r = s(e, i)
                        }
                        return ut(r)
                    });
                    return Object(a.a)(s).pipe(be(), Object(R.a)(t => {
                        if (!ge(t)) return;
                        const e = st(`Redirecting to "${this.urlSerializer.serialize(t)}"`);
                        throw e.url = t, e
                    }), Object(b.a)(t => !0 === t))
                }
                lineralizeSegments(t, e) {
                    let i = [],
                        n = e.root;
                    for (;;) {
                        if (i = i.concat(n.segments), 0 === n.numberOfChildren) return Object(a.a)(i);
                        if (n.numberOfChildren > 1 || !n.children.primary) return Re(t.redirectTo);
                        n = n.children.primary
                    }
                }
                applyRedirectCommands(t, e, i) {
                    return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i)
                }
                applyRedirectCreatreUrlTree(t, e, i, n) {
                    const s = this.createSegmentGroup(t, e.root, i, n);
                    return new mt(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment)
                }
                createQueryParams(t, e) {
                    const i = {};
                    return ht(t, (t, n) => {
                        if ("string" == typeof t && t.startsWith(":")) {
                            const s = t.substring(1);
                            i[n] = e[s]
                        } else i[n] = t
                    }), i
                }
                createSegmentGroup(t, e, i, n) {
                    const s = this.createSegments(t, e.segments, i, n);
                    let r = {};
                    return ht(e.children, (e, s) => {
                        r[s] = this.createSegmentGroup(t, e, i, n)
                    }), new bt(s, r)
                }
                createSegments(t, e, i, n) {
                    return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, n) : this.findOrReturn(e, i))
                }
                findPosParam(t, e, i) {
                    const n = i[e.path.substring(1)];
                    if (!n) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);
                    return n
                }
                findOrReturn(t, e) {
                    let i = 0;
                    for (const n of e) {
                        if (n.path === t.path) return e.splice(i), n;
                        i++
                    }
                    return t
                }
            }

            function Fe(t) {
                const e = {};
                for (const i of Object.keys(t.children)) {
                    const n = Fe(t.children[i]);
                    (n.segments.length > 0 || n.hasChildren()) && (e[i] = n)
                }
                return function(t) {
                    if (1 === t.numberOfChildren && t.children.primary) {
                        const e = t.children.primary;
                        return new bt(t.segments.concat(e.segments), e.children)
                    }
                    return t
                }(new bt(t.segments, e))
            }
            class Ne {
                constructor(t) {
                    this.path = t, this.route = this.path[this.path.length - 1]
                }
            }
            class ze {
                constructor(t, e) {
                    this.component = t, this.route = e
                }
            }

            function Ve(t, e, i) {
                const n = t._root;
                return He(n, e ? e._root : null, i, [n.value])
            }

            function Be(t, e, i) {
                const n = function(t) {
                    if (!t) return null;
                    for (let e = t.parent; e; e = e.parent) {
                        const t = e.routeConfig;
                        if (t && t._loadedConfig) return t._loadedConfig
                    }
                    return null
                }(e);
                return (n ? n.module.injector : i).get(t)
            }

            function He(t, e, i, n, s = {
                canDeactivateChecks: [],
                canActivateChecks: []
            }) {
                const r = Vt(e);
                return t.children.forEach(t => {
                    ! function(t, e, i, n, s = {
                        canDeactivateChecks: [],
                        canActivateChecks: []
                    }) {
                        const r = t.value,
                            a = e ? e.value : null,
                            o = i ? i.getContext(t.value.outlet) : null;
                        if (a && r.routeConfig === a.routeConfig) {
                            const l = function(t, e, i) {
                                if ("function" == typeof i) return i(t, e);
                                switch (i) {
                                    case "pathParamsChange":
                                        return !vt(t.url, e.url);
                                    case "pathParamsOrQueryParamsChange":
                                        return !vt(t.url, e.url) || !at(t.queryParams, e.queryParams);
                                    case "always":
                                        return !0;
                                    case "paramsOrQueryParamsChange":
                                        return !$t(t, e) || !at(t.queryParams, e.queryParams);
                                    case "paramsChange":
                                    default:
                                        return !$t(t, e)
                                }
                            }(a, r, r.routeConfig.runGuardsAndResolvers);
                            l ? s.canActivateChecks.push(new Ne(n)) : (r.data = a.data, r._resolvedData = a._resolvedData), He(t, e, r.component ? o ? o.children : null : i, n, s), l && o && o.outlet && o.outlet.isActivated && s.canDeactivateChecks.push(new ze(o.outlet.component, a))
                        } else a && Ue(e, o, s), s.canActivateChecks.push(new Ne(n)), He(t, null, r.component ? o ? o.children : null : i, n, s)
                    }(t, r[t.value.outlet], i, n.concat([t.value]), s), delete r[t.value.outlet]
                }), ht(r, (t, e) => Ue(t, i.getContext(e), s)), s
            }

            function Ue(t, e, i) {
                const n = Vt(t),
                    s = t.value;
                ht(n, (t, n) => {
                    Ue(t, s.component ? e ? e.children.getContext(n) : null : e, i)
                }), i.canDeactivateChecks.push(new ze(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s))
            }
            class Xe {}

            function We(t) {
                return new c.a(e => e.error(t))
            }
            class Ye {
                constructor(t, e, i, n, s, r) {
                    this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = n, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = r
                }
                recognize() {
                    const t = Oe(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup,
                        e = this.processSegmentGroup(this.config, t, "primary");
                    if (null === e) return null;
                    const i = new Wt([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}),
                        n = new zt(i, e),
                        s = new Yt(this.url, n);
                    return this.inheritParamsAndData(s._root), s
                }
                inheritParamsAndData(t) {
                    const e = t.value,
                        i = Xt(e, this.paramsInheritanceStrategy);
                    e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(t => this.inheritParamsAndData(t))
                }
                processSegmentGroup(t, e, i) {
                    return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i)
                }
                processChildren(t, e) {
                    const i = [];
                    for (const s of Object.keys(e.children)) {
                        const n = e.children[s],
                            r = ke(t, s),
                            a = this.processSegmentGroup(r, n, s);
                        if (null === a) return null;
                        i.push(...a)
                    }
                    const n = qe(i);
                    return n.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n
                }
                processSegment(t, e, i, n) {
                    for (const s of t) {
                        const t = this.processSegmentAgainstRoute(s, e, i, n);
                        if (null !== t) return t
                    }
                    return Te(e, i, n) ? [] : null
                }
                processSegmentAgainstRoute(t, e, i, n) {
                    if (t.redirectTo || !Pe(t, e, i, n)) return null;
                    let s, r = [],
                        a = [];
                    if ("**" === t.path) {
                        const n = i.length > 0 ? ct(i).parameters : {};
                        s = new Wt(i, n, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Qe(t), Ce(t), t.component, t, Ze(e), $e(e) + i.length, Ke(t))
                    } else {
                        const n = Ae(e, t, i);
                        if (!n.matched) return null;
                        r = n.consumedSegments, a = i.slice(n.lastChild), s = new Wt(r, n.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Qe(t), Ce(t), t.component, t, Ze(e), $e(e) + r.length, Ke(t))
                    }
                    const o = function(t) {
                            return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : []
                        }(t),
                        {
                            segmentGroup: l,
                            slicedSegments: c
                        } = Oe(e, r, a, o.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution);
                    if (0 === c.length && l.hasChildren()) {
                        const t = this.processChildren(o, l);
                        return null === t ? null : [new zt(s, t)]
                    }
                    if (0 === o.length && 0 === c.length) return [new zt(s, [])];
                    const h = Ce(t) === n,
                        u = this.processSegment(o, l, c, h ? "primary" : n);
                    return null === u ? null : [new zt(s, u)]
                }
            }

            function Ge(t) {
                const e = t.value.routeConfig;
                return e && "" === e.path && void 0 === e.redirectTo
            }

            function qe(t) {
                const e = [],
                    i = new Set;
                for (const n of t) {
                    if (!Ge(n)) {
                        e.push(n);
                        continue
                    }
                    const t = e.find(t => n.value.routeConfig === t.value.routeConfig);
                    void 0 !== t ? (t.children.push(...n.children), i.add(t)) : e.push(n)
                }
                for (const n of i) {
                    const t = qe(n.children);
                    e.push(new zt(n.value, t))
                }
                return e.filter(t => !i.has(t))
            }

            function Ze(t) {
                let e = t;
                for (; e._sourceSegment;) e = e._sourceSegment;
                return e
            }

            function $e(t) {
                let e = t,
                    i = e._segmentIndexShift ? e._segmentIndexShift : 0;
                for (; e._sourceSegment;) e = e._sourceSegment, i += e._segmentIndexShift ? e._segmentIndexShift : 0;
                return i - 1
            }

            function Qe(t) {
                return t.data || {}
            }

            function Ke(t) {
                return t.resolve || {}
            }

            function Je(t) {
                return Object(y.a)(e => {
                    const i = t(e);
                    return i ? Object(r.a)(i).pipe(Object(b.a)(() => e)) : Object(a.a)(e)
                })
            }
            class ti extends class {
                shouldDetach(t) {
                    return !1
                }
                store(t, e) {}
                shouldAttach(t) {
                    return !1
                }
                retrieve(t) {
                    return null
                }
                shouldReuseRoute(t, e) {
                    return t.routeConfig === e.routeConfig
                }
            } {}
            const ei = new s.s("ROUTES");
            class ii {
                constructor(t, e, i, n) {
                    this.loader = t, this.compiler = e, this.onLoadStartListener = i, this.onLoadEndListener = n
                }
                load(t, e) {
                    if (e._loader$) return e._loader$;
                    this.onLoadStartListener && this.onLoadStartListener(e);
                    const i = this.loadModuleFactory(e.loadChildren).pipe(Object(b.a)(i => {
                        this.onLoadEndListener && this.onLoadEndListener(e);
                        const n = i.create(t);
                        return new pe(lt(n.injector.get(ei, void 0, s.r.Self | s.r.Optional)).map(we), n)
                    }), Object(A.a)(t => {
                        throw e._loader$ = void 0, t
                    }));
                    return e._loader$ = new g.a(i, () => new m.a).pipe(Object(j.a)()), e._loader$
                }
                loadModuleFactory(t) {
                    return "string" == typeof t ? Object(r.a)(this.loader.load(t)) : ut(t()).pipe(Object(L.a)(t => t instanceof s.x ? Object(a.a)(t) : Object(r.a)(this.compiler.compileModuleAsync(t))))
                }
            }
            class ni {
                constructor() {
                    this.outlet = null, this.route = null, this.resolver = null, this.children = new si, this.attachRef = null
                }
            }
            class si {
                constructor() {
                    this.contexts = new Map
                }
                onChildOutletCreated(t, e) {
                    const i = this.getOrCreateContext(t);
                    i.outlet = e, this.contexts.set(t, i)
                }
                onChildOutletDestroyed(t) {
                    const e = this.getContext(t);
                    e && (e.outlet = null)
                }
                onOutletDeactivated() {
                    const t = this.contexts;
                    return this.contexts = new Map, t
                }
                onOutletReAttached(t) {
                    this.contexts = t
                }
                getOrCreateContext(t) {
                    let e = this.getContext(t);
                    return e || (e = new ni, this.contexts.set(t, e)), e
                }
                getContext(t) {
                    return this.contexts.get(t) || null
                }
            }
            class ri {
                shouldProcessUrl(t) {
                    return !0
                }
                extract(t) {
                    return t
                }
                merge(t, e) {
                    return t
                }
            }

            function ai(t) {
                throw t
            }

            function oi(t, e, i) {
                return e.parse("/")
            }

            function li(t, e) {
                return Object(a.a)(null)
            }
            let ci = (() => {
                    class t {
                        constructor(t, e, i, n, r, a, l, c) {
                            this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = i, this.location = n, this.config = c, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new m.a, this.errorHandler = ai, this.malformedUriErrorHandler = oi, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = {
                                beforePreactivation: li,
                                afterPreactivation: li
                            }, this.urlHandlingStrategy = new ri, this.routeReuseStrategy = new ti, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.ngModule = r.get(s.z), this.console = r.get(s.bb);
                            const h = r.get(s.B);
                            this.isNgZoneEnabled = h instanceof s.B && s.B.isInAngularZone(), this.resetConfig(c), this.currentUrlTree = new mt(new bt([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new ii(a, l, t => this.triggerEvent(new Z(t)), t => this.triggerEvent(new $(t))), this.routerState = Ht(this.currentUrlTree, this.rootComponentType), this.transitions = new o.a({
                                id: 0,
                                currentUrlTree: this.currentUrlTree,
                                currentRawUrl: this.currentUrlTree,
                                extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
                                urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
                                rawUrl: this.currentUrlTree,
                                extras: {},
                                resolve: null,
                                reject: null,
                                promise: Promise.resolve(!0),
                                source: "imperative",
                                restoredState: null,
                                currentSnapshot: this.routerState.snapshot,
                                targetSnapshot: null,
                                currentRouterState: this.routerState,
                                targetRouterState: null,
                                guards: {
                                    canActivateChecks: [],
                                    canDeactivateChecks: []
                                },
                                guardsResult: null
                            }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations()
                        }
                        setupNavigations(t) {
                            const e = this.events;
                            return t.pipe(Object(S.a)(t => 0 !== t.id), Object(b.a)(t => Object.assign(Object.assign({}, t), {
                                extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)
                            })), Object(y.a)(t => {
                                let i = !1,
                                    n = !1;
                                return Object(a.a)(t).pipe(Object(R.a)(t => {
                                    this.currentNavigation = {
                                        id: t.id,
                                        initialUrl: t.currentRawUrl,
                                        extractedUrl: t.extractedUrl,
                                        trigger: t.source,
                                        extras: t.extras,
                                        previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), {
                                            previousNavigation: null
                                        }) : null
                                    }
                                }), Object(y.a)(t => {
                                    const i = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString();
                                    if (("reload" === this.onSameUrlNavigation || i) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Object(a.a)(t).pipe(Object(y.a)(t => {
                                        const i = this.transitions.getValue();
                                        return e.next(new V(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), i !== this.transitions.getValue() ? f.a : Promise.resolve(t)
                                    }), (n = this.ngModule.injector, s = this.configLoader, r = this.urlSerializer, o = this.config, Object(y.a)(t => function(t, e, i, n, s) {
                                        return new je(t, e, i, n, s).apply()
                                    }(n, s, r, t.extractedUrl, o).pipe(Object(b.a)(e => Object.assign(Object.assign({}, t), {
                                        urlAfterRedirects: e
                                    }))))), Object(R.a)(t => {
                                        this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), {
                                            finalUrl: t.urlAfterRedirects
                                        })
                                    }), function(t, e, i, n, s) {
                                        return Object(L.a)(r => function(t, e, i, n, s = "emptyOnly", r = "legacy") {
                                            try {
                                                const o = new Ye(t, e, i, n, s, r).recognize();
                                                return null === o ? We(new Xe) : Object(a.a)(o)
                                            } catch (o) {
                                                return We(o)
                                            }
                                        }(t, e, r.urlAfterRedirects, i(r.urlAfterRedirects), n, s).pipe(Object(b.a)(t => Object.assign(Object.assign({}, r), {
                                            targetSnapshot: t
                                        }))))
                                    }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Object(R.a)(t => {
                                        "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects);
                                        const i = new X(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                                        e.next(i)
                                    }));
                                    var n, s, r, o;
                                    if (i && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
                                        const {
                                            id: i,
                                            extractedUrl: n,
                                            source: s,
                                            restoredState: r,
                                            extras: o
                                        } = t, l = new V(i, this.serializeUrl(n), s, r);
                                        e.next(l);
                                        const c = Ht(n, this.rootComponentType).snapshot;
                                        return Object(a.a)(Object.assign(Object.assign({}, t), {
                                            targetSnapshot: c,
                                            urlAfterRedirects: n,
                                            extras: Object.assign(Object.assign({}, o), {
                                                skipLocationChange: !1,
                                                replaceUrl: !1
                                            })
                                        }))
                                    }
                                    return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), f.a
                                }), Je(t => {
                                    const {
                                        targetSnapshot: e,
                                        id: i,
                                        extractedUrl: n,
                                        rawUrl: s,
                                        extras: {
                                            skipLocationChange: r,
                                            replaceUrl: a
                                        }
                                    } = t;
                                    return this.hooks.beforePreactivation(e, {
                                        navigationId: i,
                                        appliedUrlTree: n,
                                        rawUrlTree: s,
                                        skipLocationChange: !!r,
                                        replaceUrl: !!a
                                    })
                                }), Object(R.a)(t => {
                                    const e = new W(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                                    this.triggerEvent(e)
                                }), Object(b.a)(t => Object.assign(Object.assign({}, t), {
                                    guards: Ve(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
                                })), function(t, e) {
                                    return Object(L.a)(i => {
                                        const {
                                            targetSnapshot: n,
                                            currentSnapshot: s,
                                            guards: {
                                                canActivateChecks: o,
                                                canDeactivateChecks: l
                                            }
                                        } = i;
                                        return 0 === l.length && 0 === o.length ? Object(a.a)(Object.assign(Object.assign({}, i), {
                                            guardsResult: !0
                                        })) : function(t, e, i, n) {
                                            return Object(r.a)(t).pipe(Object(L.a)(t => function(t, e, i, n, s) {
                                                const r = e && e.routeConfig ? e.routeConfig.canDeactivate : null;
                                                if (!r || 0 === r.length) return Object(a.a)(!0);
                                                const o = r.map(r => {
                                                    const a = Be(r, e, s);
                                                    let o;
                                                    if (function(t) {
                                                            return t && fe(t.canDeactivate)
                                                        }(a)) o = ut(a.canDeactivate(t, e, i, n));
                                                    else {
                                                        if (!fe(a)) throw new Error("Invalid CanDeactivate guard");
                                                        o = ut(a(t, e, i, n))
                                                    }
                                                    return o.pipe(M())
                                                });
                                                return Object(a.a)(o).pipe(be())
                                            }(t.component, t.route, i, e, n)), M(t => !0 !== t, !0))
                                        }(l, n, s, t).pipe(Object(L.a)(i => i && "boolean" == typeof i ? function(t, e, i, n) {
                                            return Object(r.a)(e).pipe(Object(O.a)(e => Object(d.a)(function(t, e) {
                                                return null !== t && e && e(new Q(t)), Object(a.a)(!0)
                                            }(e.route.parent, n), function(t, e) {
                                                return null !== t && e && e(new J(t)), Object(a.a)(!0)
                                            }(e.route, n), function(t, e, i) {
                                                const n = e[e.length - 1],
                                                    s = e.slice(0, e.length - 1).reverse().map(t => function(t) {
                                                        const e = t.routeConfig ? t.routeConfig.canActivateChild : null;
                                                        return e && 0 !== e.length ? {
                                                            node: t,
                                                            guards: e
                                                        } : null
                                                    }(t)).filter(t => null !== t).map(e => Object(p.a)(() => {
                                                        const s = e.guards.map(s => {
                                                            const r = Be(s, e.node, i);
                                                            let a;
                                                            if (function(t) {
                                                                    return t && fe(t.canActivateChild)
                                                                }(r)) a = ut(r.canActivateChild(n, t));
                                                            else {
                                                                if (!fe(r)) throw new Error("Invalid CanActivateChild guard");
                                                                a = ut(r(n, t))
                                                            }
                                                            return a.pipe(M())
                                                        });
                                                        return Object(a.a)(s).pipe(be())
                                                    }));
                                                return Object(a.a)(s).pipe(be())
                                            }(t, e.path, i), function(t, e, i) {
                                                const n = e.routeConfig ? e.routeConfig.canActivate : null;
                                                if (!n || 0 === n.length) return Object(a.a)(!0);
                                                const s = n.map(n => Object(p.a)(() => {
                                                    const s = Be(n, e, i);
                                                    let r;
                                                    if (function(t) {
                                                            return t && fe(t.canActivate)
                                                        }(s)) r = ut(s.canActivate(e, t));
                                                    else {
                                                        if (!fe(s)) throw new Error("Invalid CanActivate guard");
                                                        r = ut(s(e, t))
                                                    }
                                                    return r.pipe(M())
                                                }));
                                                return Object(a.a)(s).pipe(be())
                                            }(t, e.route, i))), M(t => !0 !== t, !0))
                                        }(n, o, t, e) : Object(a.a)(i)), Object(b.a)(t => Object.assign(Object.assign({}, i), {
                                            guardsResult: t
                                        })))
                                    })
                                }(this.ngModule.injector, t => this.triggerEvent(t)), Object(R.a)(t => {
                                    if (ge(t.guardsResult)) {
                                        const e = st(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);
                                        throw e.url = t.guardsResult, e
                                    }
                                    const e = new Y(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                                    this.triggerEvent(e)
                                }), Object(S.a)(t => {
                                    if (!t.guardsResult) {
                                        this.resetUrlToCurrentUrlTree();
                                        const i = new H(t.id, this.serializeUrl(t.extractedUrl), "");
                                        return e.next(i), t.resolve(!1), !1
                                    }
                                    return !0
                                }), Je(t => {
                                    if (t.guards.canActivateChecks.length) return Object(a.a)(t).pipe(Object(R.a)(t => {
                                        const e = new G(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                                        this.triggerEvent(e)
                                    }), Object(y.a)(t => {
                                        let i = !1;
                                        return Object(a.a)(t).pipe((n = this.paramsInheritanceStrategy, s = this.ngModule.injector, Object(L.a)(t => {
                                            const {
                                                targetSnapshot: e,
                                                guards: {
                                                    canActivateChecks: i
                                                }
                                            } = t;
                                            if (!i.length) return Object(a.a)(t);
                                            let o = 0;
                                            return Object(r.a)(i).pipe(Object(O.a)(t => function(t, e, i, n) {
                                                return function(t, e, i, n) {
                                                    const s = Object.keys(t);
                                                    if (0 === s.length) return Object(a.a)({});
                                                    const o = {};
                                                    return Object(r.a)(s).pipe(Object(L.a)(s => function(t, e, i, n) {
                                                        const s = Be(t, e, n);
                                                        return ut(s.resolve ? s.resolve(e, i) : s(e, i))
                                                    }(t[s], e, i, n).pipe(Object(R.a)(t => {
                                                        o[s] = t
                                                    }))), E(1), Object(L.a)(() => Object.keys(o).length === s.length ? Object(a.a)(o) : f.a))
                                                }(t._resolve, t, e, n).pipe(Object(b.a)(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Xt(t, i).resolve), null)))
                                            }(t.route, e, n, s)), Object(R.a)(() => o++), E(1), Object(L.a)(e => o === i.length ? Object(a.a)(t) : f.a))
                                        })), Object(R.a)({
                                            next: () => i = !0,
                                            complete: () => {
                                                if (!i) {
                                                    const i = new H(t.id, this.serializeUrl(t.extractedUrl), "At least one route resolver didn't emit any value.");
                                                    e.next(i), t.resolve(!1)
                                                }
                                            }
                                        }));
                                        var n, s
                                    }), Object(R.a)(t => {
                                        const e = new q(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                                        this.triggerEvent(e)
                                    }))
                                }), Je(t => {
                                    const {
                                        targetSnapshot: e,
                                        id: i,
                                        extractedUrl: n,
                                        rawUrl: s,
                                        extras: {
                                            skipLocationChange: r,
                                            replaceUrl: a
                                        }
                                    } = t;
                                    return this.hooks.afterPreactivation(e, {
                                        navigationId: i,
                                        appliedUrlTree: n,
                                        rawUrlTree: s,
                                        skipLocationChange: !!r,
                                        replaceUrl: !!a
                                    })
                                }), Object(b.a)(t => {
                                    const e = function(t, e, i) {
                                        const n = Qt(t, e._root, i ? i._root : void 0);
                                        return new Bt(n, e)
                                    }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
                                    return Object.assign(Object.assign({}, t), {
                                        targetRouterState: e
                                    })
                                }), Object(R.a)(t => {
                                    this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects)
                                }), (s = this.rootContexts, o = this.routeReuseStrategy, l = t => this.triggerEvent(t), Object(b.a)(t => (new ue(o, t.targetRouterState, t.currentRouterState, l).activate(s), t))), Object(R.a)({
                                    next() {
                                        i = !0
                                    },
                                    complete() {
                                        i = !0
                                    }
                                }), Object(F.a)(() => {
                                    if (!i && !n) {
                                        this.resetUrlToCurrentUrlTree();
                                        const i = new H(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);
                                        e.next(i), t.resolve(!1)
                                    }
                                    this.currentNavigation = null
                                }), Object(A.a)(i => {
                                    if (n = !0, (s = i) && s.ngNavigationCancelingError) {
                                        const n = ge(i.url);
                                        n || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl));
                                        const s = new H(t.id, this.serializeUrl(t.extractedUrl), i.message);
                                        e.next(s), n ? setTimeout(() => {
                                            const e = this.urlHandlingStrategy.merge(i.url, this.rawUrlTree);
                                            this.scheduleNavigation(e, "imperative", null, {
                                                skipLocationChange: t.extras.skipLocationChange,
                                                replaceUrl: "eager" === this.urlUpdateStrategy
                                            }, {
                                                resolve: t.resolve,
                                                reject: t.reject,
                                                promise: t.promise
                                            })
                                        }, 0) : t.resolve(!1)
                                    } else {
                                        this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                                        const n = new U(t.id, this.serializeUrl(t.extractedUrl), i);
                                        e.next(n);
                                        try {
                                            t.resolve(this.errorHandler(i))
                                        } catch (r) {
                                            t.reject(r)
                                        }
                                    }
                                    var s;
                                    return f.a
                                }));
                                var s, o, l
                            }))
                        }
                        resetRootComponentType(t) {
                            this.rootComponentType = t, this.routerState.root.component = this.rootComponentType
                        }
                        getTransition() {
                            const t = this.transitions.value;
                            return t.urlAfterRedirects = this.browserUrlTree, t
                        }
                        setTransition(t) {
                            this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t))
                        }
                        initialNavigation() {
                            this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), {
                                replaceUrl: !0
                            })
                        }
                        setUpLocationChangeListener() {
                            this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => {
                                const e = this.extractLocationChangeInfoFromEvent(t);
                                this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => {
                                    const {
                                        source: t,
                                        state: i,
                                        urlTree: n
                                    } = e, s = {
                                        replaceUrl: !0
                                    };
                                    if (i) {
                                        const t = Object.assign({}, i);
                                        delete t.navigationId, 0 !== Object.keys(t).length && (s.state = t)
                                    }
                                    this.scheduleNavigation(n, t, i, s)
                                }, 0), this.lastLocationChangeInfo = e
                            }))
                        }
                        extractLocationChangeInfoFromEvent(t) {
                            var e;
                            return {
                                source: "popstate" === t.type ? "popstate" : "hashchange",
                                urlTree: this.parseUrl(t.url),
                                state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null,
                                transitionId: this.getTransition().id
                            }
                        }
                        shouldScheduleNavigation(t, e) {
                            if (!t) return !0;
                            const i = e.urlTree.toString() === t.urlTree.toString();
                            return !(e.transitionId === t.transitionId && i && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source))
                        }
                        get url() {
                            return this.serializeUrl(this.currentUrlTree)
                        }
                        getCurrentNavigation() {
                            return this.currentNavigation
                        }
                        triggerEvent(t) {
                            this.events.next(t)
                        }
                        resetConfig(t) {
                            ve(t), this.config = t.map(we), this.navigated = !1, this.lastSuccessfulId = -1
                        }
                        ngOnDestroy() {
                            this.dispose()
                        }
                        dispose() {
                            this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0
                        }
                        createUrlTree(t, e = {}) {
                            const {
                                relativeTo: i,
                                queryParams: n,
                                fragment: s,
                                queryParamsHandling: r,
                                preserveFragment: a
                            } = e, o = i || this.routerState.root, l = a ? this.currentUrlTree.fragment : s;
                            let c = null;
                            switch (r) {
                                case "merge":
                                    c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), n);
                                    break;
                                case "preserve":
                                    c = this.currentUrlTree.queryParams;
                                    break;
                                default:
                                    c = n || null
                            }
                            return null !== c && (c = this.removeEmptyProps(c)),
                                function(t, e, i, n, s) {
                                    if (0 === i.length) return ee(e.root, e.root, e, n, s);
                                    const r = function(t) {
                                        if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new ne(!0, 0, t);
                                        let e = 0,
                                            i = !1;
                                        const n = t.reduce((t, n, s) => {
                                            if ("object" == typeof n && null != n) {
                                                if (n.outlets) {
                                                    const e = {};
                                                    return ht(n.outlets, (t, i) => {
                                                        e[i] = "string" == typeof t ? t.split("/") : t
                                                    }), [...t, {
                                                        outlets: e
                                                    }]
                                                }
                                                if (n.segmentPath) return [...t, n.segmentPath]
                                            }
                                            return "string" != typeof n ? [...t, n] : 0 === s ? (n.split("/").forEach((n, s) => {
                                                0 == s && "." === n || (0 == s && "" === n ? i = !0 : ".." === n ? e++ : "" != n && t.push(n))
                                            }), t) : [...t, n]
                                        }, []);
                                        return new ne(i, e, n)
                                    }(i);
                                    if (r.toRoot()) return ee(e.root, new bt([], {}), e, n, s);
                                    const a = function(t, e, i) {
                                            if (t.isAbsolute) return new se(e.root, !0, 0);
                                            if (-1 === i.snapshot._lastPathIndex) {
                                                const t = i.snapshot._urlSegment;
                                                return new se(t, t === e.root, 0)
                                            }
                                            const n = Jt(t.commands[0]) ? 0 : 1;
                                            return function(t, e, i) {
                                                let n = t,
                                                    s = e,
                                                    r = i;
                                                for (; r > s;) {
                                                    if (r -= s, n = n.parent, !n) throw new Error("Invalid number of '../'");
                                                    s = n.segments.length
                                                }
                                                return new se(n, !1, s - r)
                                            }(i.snapshot._urlSegment, i.snapshot._lastPathIndex + n, t.numberOfDoubleDots)
                                        }(r, e, t),
                                        o = a.processChildren ? ae(a.segmentGroup, a.index, r.commands) : re(a.segmentGroup, a.index, r.commands);
                                    return ee(a.segmentGroup, o, e, n, s)
                                }(o, this.currentUrlTree, t, c, l)
                        }
                        navigateByUrl(t, e = {
                            skipLocationChange: !1
                        }) {
                            const i = ge(t) ? t : this.parseUrl(t),
                                n = this.urlHandlingStrategy.merge(i, this.rawUrlTree);
                            return this.scheduleNavigation(n, "imperative", null, e)
                        }
                        navigate(t, e = {
                            skipLocationChange: !1
                        }) {
                            return function(t) {
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e];
                                    if (null == i) throw new Error(`The requested path contains ${i} segment at index ${e}`)
                                }
                            }(t), this.navigateByUrl(this.createUrlTree(t, e), e)
                        }
                        serializeUrl(t) {
                            return this.urlSerializer.serialize(t)
                        }
                        parseUrl(t) {
                            let e;
                            try {
                                e = this.urlSerializer.parse(t)
                            } catch (i) {
                                e = this.malformedUriErrorHandler(i, this.urlSerializer, t)
                            }
                            return e
                        }
                        isActive(t, e) {
                            if (ge(t)) return dt(this.currentUrlTree, t, e);
                            const i = this.parseUrl(t);
                            return dt(this.currentUrlTree, i, e)
                        }
                        removeEmptyProps(t) {
                            return Object.keys(t).reduce((e, i) => {
                                const n = t[i];
                                return null != n && (e[i] = n), e
                            }, {})
                        }
                        processNavigations() {
                            this.navigations.subscribe(t => {
                                this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new B(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0)
                            }, t => {
                                this.console.warn("Unhandled Navigation Error: ")
                            })
                        }
                        scheduleNavigation(t, e, i, n, s) {
                            if (this.disposed) return Promise.resolve(!1);
                            const r = this.getTransition(),
                                a = "imperative" !== e && "imperative" === (null == r ? void 0 : r.source),
                                o = (this.lastSuccessfulId === r.id || this.currentNavigation ? r.rawUrl : r.urlAfterRedirects).toString() === t.toString();
                            if (a && o) return Promise.resolve(!0);
                            let l, c, h;
                            s ? (l = s.resolve, c = s.reject, h = s.promise) : h = new Promise((t, e) => {
                                l = t, c = e
                            });
                            const u = ++this.navigationId;
                            return this.setTransition({
                                id: u,
                                source: e,
                                restoredState: i,
                                currentUrlTree: this.currentUrlTree,
                                currentRawUrl: this.rawUrlTree,
                                rawUrl: t,
                                extras: n,
                                resolve: l,
                                reject: c,
                                promise: h,
                                currentSnapshot: this.routerState.snapshot,
                                currentRouterState: this.routerState
                            }), h.catch(t => Promise.reject(t))
                        }
                        setBrowserUrl(t, e, i, n) {
                            const s = this.urlSerializer.serialize(t);
                            n = n || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign(Object.assign({}, n), {
                                navigationId: i
                            })) : this.location.go(s, "", Object.assign(Object.assign({}, n), {
                                navigationId: i
                            }))
                        }
                        resetStateAndUrl(t, e, i) {
                            this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, i), this.resetUrlToCurrentUrlTree()
                        }
                        resetUrlToCurrentUrlTree() {
                            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", {
                                navigationId: this.lastSuccessfulId
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(s.Q), s.Zb(xt), s.Zb(si), s.Zb(n.h), s.Zb(s.t), s.Zb(s.y), s.Zb(s.i), s.Zb(void 0))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                hi = (() => {
                    class t {
                        constructor(t, e, i, n, s) {
                            this.router = t, this.route = e, this.commands = [], this.onChanges = new m.a, null == i && n.setAttribute(s.nativeElement, "tabindex", "0")
                        }
                        ngOnChanges(t) {
                            this.onChanges.next(this)
                        }
                        set routerLink(t) {
                            this.commands = null != t ? Array.isArray(t) ? t : [t] : []
                        }
                        onClick() {
                            const t = {
                                skipLocationChange: di(this.skipLocationChange),
                                replaceUrl: di(this.replaceUrl),
                                state: this.state
                            };
                            return this.router.navigateByUrl(this.urlTree, t), !0
                        }
                        get urlTree() {
                            return this.router.createUrlTree(this.commands, {
                                relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route,
                                queryParams: this.queryParams,
                                fragment: this.fragment,
                                queryParamsHandling: this.queryParamsHandling,
                                preserveFragment: di(this.preserveFragment)
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(ci), s.Pb(Ut), s.ac("tabindex"), s.Pb(s.G), s.Pb(s.l))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "routerLink", "", 5, "a", 5, "area"]
                        ],
                        hostBindings: function(t, e) {
                            1 & t && s.cc("click", function() {
                                return e.onClick()
                            })
                        },
                        inputs: {
                            routerLink: "routerLink",
                            queryParams: "queryParams",
                            fragment: "fragment",
                            queryParamsHandling: "queryParamsHandling",
                            preserveFragment: "preserveFragment",
                            skipLocationChange: "skipLocationChange",
                            replaceUrl: "replaceUrl",
                            state: "state",
                            relativeTo: "relativeTo"
                        },
                        features: [s.Bb]
                    }), t
                })(),
                ui = (() => {
                    class t {
                        constructor(t, e, i) {
                            this.router = t, this.route = e, this.locationStrategy = i, this.commands = [], this.onChanges = new m.a, this.subscription = t.events.subscribe(t => {
                                t instanceof B && this.updateTargetUrlAndHref()
                            })
                        }
                        set routerLink(t) {
                            this.commands = null != t ? Array.isArray(t) ? t : [t] : []
                        }
                        ngOnChanges(t) {
                            this.updateTargetUrlAndHref(), this.onChanges.next(this)
                        }
                        ngOnDestroy() {
                            this.subscription.unsubscribe()
                        }
                        onClick(t, e, i, n, s) {
                            if (0 !== t || e || i || n || s) return !0;
                            if ("string" == typeof this.target && "_self" != this.target) return !0;
                            const r = {
                                skipLocationChange: di(this.skipLocationChange),
                                replaceUrl: di(this.replaceUrl),
                                state: this.state
                            };
                            return this.router.navigateByUrl(this.urlTree, r), !1
                        }
                        updateTargetUrlAndHref() {
                            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree))
                        }
                        get urlTree() {
                            return this.router.createUrlTree(this.commands, {
                                relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route,
                                queryParams: this.queryParams,
                                fragment: this.fragment,
                                queryParamsHandling: this.queryParamsHandling,
                                preserveFragment: di(this.preserveFragment)
                            })
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(ci), s.Pb(Ut), s.Pb(n.i))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["a", "routerLink", ""],
                            ["area", "routerLink", ""]
                        ],
                        hostVars: 2,
                        hostBindings: function(t, e) {
                            1 & t && s.cc("click", function(t) {
                                return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey)
                            }), 2 & t && (s.Yb("href", e.href, s.wc), s.Eb("target", e.target))
                        },
                        inputs: {
                            routerLink: "routerLink",
                            target: "target",
                            queryParams: "queryParams",
                            fragment: "fragment",
                            queryParamsHandling: "queryParamsHandling",
                            preserveFragment: "preserveFragment",
                            skipLocationChange: "skipLocationChange",
                            replaceUrl: "replaceUrl",
                            state: "state",
                            relativeTo: "relativeTo"
                        },
                        features: [s.Bb]
                    }), t
                })();

            function di(t) {
                return "" === t || !!t
            }
            let pi = (() => {
                    class t {
                        constructor(t, e, i, n, s, r) {
                            this.router = t, this.element = e, this.renderer = i, this.cdr = n, this.link = s, this.linkWithHref = r, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = {
                                exact: !1
                            }, this.routerEventsSubscription = t.events.subscribe(t => {
                                t instanceof B && this.update()
                            })
                        }
                        ngAfterContentInit() {
                            Object(a.a)(this.links.changes, this.linksWithHrefs.changes, Object(a.a)(null)).pipe(Object(N.a)()).subscribe(t => {
                                this.update(), this.subscribeToEachLinkOnChanges()
                            })
                        }
                        subscribeToEachLinkOnChanges() {
                            var t;
                            null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe();
                            const e = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter(t => !!t).map(t => t.onChanges);
                            this.linkInputChangesSubscription = Object(r.a)(e).pipe(Object(N.a)()).subscribe(t => {
                                this.isActive !== this.isLinkActive(this.router)(t) && this.update()
                            })
                        }
                        set routerLinkActive(t) {
                            const e = Array.isArray(t) ? t : t.split(" ");
                            this.classes = e.filter(t => !!t)
                        }
                        ngOnChanges(t) {
                            this.update()
                        }
                        ngOnDestroy() {
                            var t;
                            this.routerEventsSubscription.unsubscribe(), null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe()
                        }
                        update() {
                            this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => {
                                const t = this.hasActiveLinks();
                                this.isActive !== t && (this.isActive = t, this.cdr.markForCheck(), this.classes.forEach(e => {
                                    t ? this.renderer.addClass(this.element.nativeElement, e) : this.renderer.removeClass(this.element.nativeElement, e)
                                }))
                            })
                        }
                        isLinkActive(t) {
                            return e => t.isActive(e.urlTree, this.routerLinkActiveOptions.exact)
                        }
                        hasActiveLinks() {
                            const t = this.isLinkActive(this.router);
                            return this.link && t(this.link) || this.linkWithHref && t(this.linkWithHref) || this.links.some(t) || this.linksWithHrefs.some(t)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(ci), s.Pb(s.l), s.Pb(s.G), s.Pb(s.h), s.Pb(hi, 8), s.Pb(ui, 8))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "routerLinkActive", ""]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && (s.Ib(i, hi, 1), s.Ib(i, ui, 1)), 2 & t) {
                                let t;
                                s.rc(t = s.dc()) && (e.links = t), s.rc(t = s.dc()) && (e.linksWithHrefs = t)
                            }
                        },
                        inputs: {
                            routerLinkActiveOptions: "routerLinkActiveOptions",
                            routerLinkActive: "routerLinkActive"
                        },
                        exportAs: ["routerLinkActive"],
                        features: [s.Bb]
                    }), t
                })(),
                fi = (() => {
                    class t {
                        constructor(t, e, i, n, r) {
                            this.parentContexts = t, this.location = e, this.resolver = i, this.changeDetector = r, this.activated = null, this._activatedRoute = null, this.activateEvents = new s.o, this.deactivateEvents = new s.o, this.name = n || "primary", t.onChildOutletCreated(this.name, this)
                        }
                        ngOnDestroy() {
                            this.parentContexts.onChildOutletDestroyed(this.name)
                        }
                        ngOnInit() {
                            if (!this.activated) {
                                const t = this.parentContexts.getContext(this.name);
                                t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null))
                            }
                        }
                        get isActivated() {
                            return !!this.activated
                        }
                        get component() {
                            if (!this.activated) throw new Error("Outlet is not activated");
                            return this.activated.instance
                        }
                        get activatedRoute() {
                            if (!this.activated) throw new Error("Outlet is not activated");
                            return this._activatedRoute
                        }
                        get activatedRouteData() {
                            return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
                        }
                        detach() {
                            if (!this.activated) throw new Error("Outlet is not activated");
                            this.location.detach();
                            const t = this.activated;
                            return this.activated = null, this._activatedRoute = null, t
                        }
                        attach(t, e) {
                            this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView)
                        }
                        deactivate() {
                            if (this.activated) {
                                const t = this.component;
                                this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t)
                            }
                        }
                        activateWith(t, e) {
                            if (this.isActivated) throw new Error("Cannot activate an already activated outlet");
                            this._activatedRoute = t;
                            const i = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),
                                n = this.parentContexts.getOrCreateContext(this.name).children,
                                s = new gi(t, n, this.location.injector);
                            this.activated = this.location.createComponent(i, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(si), s.Pb(s.S), s.Pb(s.j), s.ac("name"), s.Pb(s.h))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["router-outlet"]
                        ],
                        outputs: {
                            activateEvents: "activate",
                            deactivateEvents: "deactivate"
                        },
                        exportAs: ["outlet"]
                    }), t
                })();
            class gi {
                constructor(t, e, i) {
                    this.route = t, this.childContexts = e, this.parent = i
                }
                get(t, e) {
                    return t === Ut ? this.route : t === si ? this.childContexts : this.parent.get(t, e)
                }
            }
            class mi {}
            class bi {
                preload(t, e) {
                    return e().pipe(Object(A.a)(() => Object(a.a)(null)))
                }
            }
            class yi {
                preload(t, e) {
                    return Object(a.a)(null)
                }
            }
            let vi = (() => {
                    class t {
                        constructor(t, e, i, n, s) {
                            this.router = t, this.injector = n, this.preloadingStrategy = s, this.loader = new ii(e, i, e => t.triggerEvent(new Z(e)), e => t.triggerEvent(new $(e)))
                        }
                        setUpPreloading() {
                            this.subscription = this.router.events.pipe(Object(S.a)(t => t instanceof B), Object(O.a)(() => this.preload())).subscribe(() => {})
                        }
                        preload() {
                            const t = this.injector.get(s.z);
                            return this.processRoutes(t, this.router.config)
                        }
                        ngOnDestroy() {
                            this.subscription && this.subscription.unsubscribe()
                        }
                        processRoutes(t, e) {
                            const i = [];
                            for (const n of e)
                                if (n.loadChildren && !n.canLoad && n._loadedConfig) {
                                    const t = n._loadedConfig;
                                    i.push(this.processRoutes(t.module, t.routes))
                                } else n.loadChildren && !n.canLoad ? i.push(this.preloadConfig(t, n)) : n.children && i.push(this.processRoutes(t, n.children));
                            return Object(r.a)(i).pipe(Object(N.a)(), Object(b.a)(t => {}))
                        }
                        preloadConfig(t, e) {
                            return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? Object(a.a)(e._loadedConfig) : this.loader.load(t.injector, e)).pipe(Object(L.a)(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes)))))
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(ci), s.Zb(s.y), s.Zb(s.i), s.Zb(s.t), s.Zb(mi))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })(),
                xi = (() => {
                    class t {
                        constructor(t, e, i = {}) {
                            this.router = t, this.viewportScroller = e, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled"
                        }
                        init() {
                            "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents()
                        }
                        createScrollEvents() {
                            return this.router.events.subscribe(t => {
                                t instanceof V ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof B && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment))
                            })
                        }
                        consumeScrollEvents() {
                            return this.router.events.subscribe(t => {
                                t instanceof et && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0]))
                            })
                        }
                        scheduleScrollEvent(t, e) {
                            this.router.triggerEvent(new et(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e))
                        }
                        ngOnDestroy() {
                            this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(ci), s.Zb(n.s), s.Zb(void 0))
                    }, t.\u0275prov = s.Lb({
                        token: t,
                        factory: t.\u0275fac
                    }), t
                })();
            const _i = new s.s("ROUTER_CONFIGURATION"),
                wi = new s.s("ROUTER_FORROOT_GUARD"),
                Ci = [n.h, {
                    provide: xt,
                    useClass: _t
                }, {
                    provide: ci,
                    useFactory: function(t, e, i, s, r, a, o, l = {}, c, h) {
                        const u = new ci(null, t, e, i, s, r, a, lt(o));
                        if (c && (u.urlHandlingStrategy = c), h && (u.routeReuseStrategy = h), function(t, e) {
                                t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy)
                            }(l, u), l.enableTracing) {
                            const t = Object(n.x)();
                            u.events.subscribe(e => {
                                t.logGroup(`Router Event: ${e.constructor.name}`), t.log(e.toString()), t.log(e), t.logGroupEnd()
                            })
                        }
                        return u
                    },
                    deps: [xt, si, n.h, s.t, s.y, s.i, ei, _i, [class {}, new s.C],
                        [class {}, new s.C]
                    ]
                }, si, {
                    provide: Ut,
                    useFactory: function(t) {
                        return t.routerState.root
                    },
                    deps: [ci]
                }, {
                    provide: s.y,
                    useClass: s.N
                }, vi, yi, bi, {
                    provide: _i,
                    useValue: {
                        enableTracing: !1
                    }
                }];

            function ki() {
                return new s.A("Router", ci)
            }
            let Si = (() => {
                class t {
                    constructor(t, e) {}
                    static forRoot(e, i) {
                        return {
                            ngModule: t,
                            providers: [Ci, Pi(e), {
                                    provide: wi,
                                    useFactory: Ei,
                                    deps: [
                                        [ci, new s.C, new s.M]
                                    ]
                                }, {
                                    provide: _i,
                                    useValue: i || {}
                                }, {
                                    provide: n.i,
                                    useFactory: Oi,
                                    deps: [n.r, [new s.q(n.a), new s.C], _i]
                                }, {
                                    provide: xi,
                                    useFactory: Ai,
                                    deps: [ci, n.s, _i]
                                }, {
                                    provide: mi,
                                    useExisting: i && i.preloadingStrategy ? i.preloadingStrategy : yi
                                }, {
                                    provide: s.A,
                                    multi: !0,
                                    useFactory: ki
                                },
                                [Ti, {
                                    provide: s.d,
                                    multi: !0,
                                    useFactory: Di,
                                    deps: [Ti]
                                }, {
                                    provide: Mi,
                                    useFactory: Ii,
                                    deps: [Ti]
                                }, {
                                    provide: s.b,
                                    multi: !0,
                                    useExisting: Mi
                                }]
                            ]
                        }
                    }
                    static forChild(e) {
                        return {
                            ngModule: t,
                            providers: [Pi(e)]
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(wi, 8), s.Zb(ci, 8))
                }, t.\u0275mod = s.Nb({
                    type: t
                }), t.\u0275inj = s.Mb({}), t
            })();

            function Ai(t, e, i) {
                return i.scrollOffset && e.setOffset(i.scrollOffset), new xi(t, e, i)
            }

            function Oi(t, e, i = {}) {
                return i.useHash ? new n.f(t, e) : new n.q(t, e)
            }

            function Ei(t) {
                return "guarded"
            }

            function Pi(t) {
                return [{
                    provide: s.a,
                    multi: !0,
                    useValue: t
                }, {
                    provide: ei,
                    multi: !0,
                    useValue: t
                }]
            }
            let Ti = (() => {
                class t {
                    constructor(t) {
                        this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new m.a
                    }
                    appInitializer() {
                        return this.injector.get(n.g, Promise.resolve(null)).then(() => {
                            let t = null;
                            const e = new Promise(e => t = e),
                                i = this.injector.get(ci),
                                n = this.injector.get(_i);
                            return "disabled" === n.initialNavigation ? (i.setUpLocationChangeListener(), t(!0)) : "enabled" === n.initialNavigation || "enabledBlocking" === n.initialNavigation ? (i.hooks.afterPreactivation = () => this.initNavigation ? Object(a.a)(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), i.initialNavigation()) : t(!0), e
                        })
                    }
                    bootstrapListener(t) {
                        const e = this.injector.get(_i),
                            i = this.injector.get(vi),
                            n = this.injector.get(xi),
                            r = this.injector.get(ci),
                            a = this.injector.get(s.g);
                        t === a.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || r.initialNavigation(), i.setUpPreloading(), n.init(), r.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete())
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(s.t))
                }, t.\u0275prov = s.Lb({
                    token: t,
                    factory: t.\u0275fac
                }), t
            })();

            function Di(t) {
                return t.appInitializer.bind(t)
            }

            function Ii(t) {
                return t.bootstrapListener.bind(t)
            }
            const Mi = new s.s("Router Initializer")
        },
        u47x: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return U
            }), i.d(e, "b", function() {
                return S
            }), i.d(e, "c", function() {
                return _
            }), i.d(e, "d", function() {
                return B
            }), i.d(e, "e", function() {
                return A
            }), i.d(e, "f", function() {
                return z
            }), i.d(e, "g", function() {
                return D
            }), i.d(e, "h", function() {
                return H
            }), i.d(e, "i", function() {
                return L
            }), i.d(e, "j", function() {
                return R
            }), i.d(e, "k", function() {
                return j
            });
            var n = i("ofXK"),
                s = i("fXoL"),
                r = i("oXA7"),
                a = i("jqqC"),
                o = i("4krO"),
                l = i("FtGj"),
                c = i("sj7R"),
                h = i("sj3c"),
                u = i("dLTe"),
                d = i("rdQv"),
                p = i("nnEh"),
                f = i("8LU1"),
                g = i("nLfN"),
                m = i("GU7r");

            function b(t, e) {
                return (t.getAttribute(e) || "").match(/\S+/g) || []
            }
            let y = 0;
            const v = new Map;
            let x = null,
                _ = (() => {
                    class t {
                        constructor(t) {
                            this._document = t
                        }
                        describe(t, e, i) {
                            if (!this._canBeDescribed(t, e)) return;
                            const n = w(e, i);
                            "string" != typeof e ? (C(e), v.set(n, {
                                messageElement: e,
                                referenceCount: 0
                            })) : v.has(n) || this._createMessageElement(e, i), this._isElementDescribedByMessage(t, n) || this._addMessageReference(t, n)
                        }
                        removeDescription(t, e, i) {
                            if (!e || !this._isElementNode(t)) return;
                            const n = w(e, i);
                            if (this._isElementDescribedByMessage(t, n) && this._removeMessageReference(t, n), "string" == typeof e) {
                                const t = v.get(n);
                                t && 0 === t.referenceCount && this._deleteMessageElement(n)
                            }
                            x && 0 === x.childNodes.length && this._deleteMessagesContainer()
                        }
                        ngOnDestroy() {
                            const t = this._document.querySelectorAll("[cdk-describedby-host]");
                            for (let e = 0; e < t.length; e++) this._removeCdkDescribedByReferenceIds(t[e]), t[e].removeAttribute("cdk-describedby-host");
                            x && this._deleteMessagesContainer(), v.clear()
                        }
                        _createMessageElement(t, e) {
                            const i = this._document.createElement("div");
                            C(i), i.textContent = t, e && i.setAttribute("role", e), this._createMessagesContainer(), x.appendChild(i), v.set(w(t, e), {
                                messageElement: i,
                                referenceCount: 0
                            })
                        }
                        _deleteMessageElement(t) {
                            const e = v.get(t),
                                i = e && e.messageElement;
                            x && i && x.removeChild(i), v.delete(t)
                        }
                        _createMessagesContainer() {
                            if (!x) {
                                const t = this._document.getElementById("cdk-describedby-message-container");
                                t && t.parentNode && t.parentNode.removeChild(t), x = this._document.createElement("div"), x.id = "cdk-describedby-message-container", x.style.visibility = "hidden", x.classList.add("cdk-visually-hidden"), this._document.body.appendChild(x)
                            }
                        }
                        _deleteMessagesContainer() {
                            x && x.parentNode && (x.parentNode.removeChild(x), x = null)
                        }
                        _removeCdkDescribedByReferenceIds(t) {
                            const e = b(t, "aria-describedby").filter(t => 0 != t.indexOf("cdk-describedby-message"));
                            t.setAttribute("aria-describedby", e.join(" "))
                        }
                        _addMessageReference(t, e) {
                            const i = v.get(e);
                            ! function(t, e, i) {
                                const n = b(t, e);
                                n.some(t => t.trim() == i.trim()) || (n.push(i.trim()), t.setAttribute(e, n.join(" ")))
                            }(t, "aria-describedby", i.messageElement.id), t.setAttribute("cdk-describedby-host", ""), i.referenceCount++
                        }
                        _removeMessageReference(t, e) {
                            const i = v.get(e);
                            i.referenceCount--,
                                function(t, e, i) {
                                    const n = b(t, e).filter(t => t != i.trim());
                                    n.length ? t.setAttribute(e, n.join(" ")) : t.removeAttribute(e)
                                }(t, "aria-describedby", i.messageElement.id), t.removeAttribute("cdk-describedby-host")
                        }
                        _isElementDescribedByMessage(t, e) {
                            const i = b(t, "aria-describedby"),
                                n = v.get(e),
                                s = n && n.messageElement.id;
                            return !!s && -1 != i.indexOf(s)
                        }
                        _canBeDescribed(t, e) {
                            if (!this._isElementNode(t)) return !1;
                            if (e && "object" == typeof e) return !0;
                            const i = null == e ? "" : `${e}`.trim(),
                                n = t.getAttribute("aria-label");
                            return !(!i || n && n.trim() === i)
                        }
                        _isElementNode(t) {
                            return t.nodeType === this._document.ELEMENT_NODE
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(n.d))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(n.d))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })();

            function w(t, e) {
                return "string" == typeof t ? `${e||""}/${t}` : t
            }

            function C(t) {
                t.id || (t.id = "cdk-describedby-message-" + y++)
            }
            class k {
                constructor(t) {
                    this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new r.a, this._typeaheadSubscription = a.b.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._skipPredicateFn = t => t.disabled, this._pressedLetters = [], this.tabOut = new r.a, this.change = new r.a, t instanceof s.F && t.changes.subscribe(t => {
                        if (this._activeItem) {
                            const e = t.toArray().indexOf(this._activeItem);
                            e > -1 && e !== this._activeItemIndex && (this._activeItemIndex = e)
                        }
                    })
                }
                skipPredicate(t) {
                    return this._skipPredicateFn = t, this
                }
                withWrap(t = !0) {
                    return this._wrap = t, this
                }
                withVerticalOrientation(t = !0) {
                    return this._vertical = t, this
                }
                withHorizontalOrientation(t) {
                    return this._horizontal = t, this
                }
                withAllowedModifierKeys(t) {
                    return this._allowedModifierKeys = t, this
                }
                withTypeAhead(t = 200) {
                    return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(Object(c.a)(t => this._pressedLetters.push(t)), Object(h.a)(t), Object(u.a)(() => this._pressedLetters.length > 0), Object(d.a)(() => this._pressedLetters.join(""))).subscribe(t => {
                        const e = this._getItemsArray();
                        for (let i = 1; i < e.length + 1; i++) {
                            const n = (this._activeItemIndex + i) % e.length,
                                s = e[n];
                            if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(t)) {
                                this.setActiveItem(n);
                                break
                            }
                        }
                        this._pressedLetters = []
                    }), this
                }
                withHomeAndEnd(t = !0) {
                    return this._homeAndEnd = t, this
                }
                setActiveItem(t) {
                    const e = this._activeItem;
                    this.updateActiveItem(t), this._activeItem !== e && this.change.next(this._activeItemIndex)
                }
                onKeydown(t) {
                    const e = t.keyCode,
                        i = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(e => !t[e] || this._allowedModifierKeys.indexOf(e) > -1);
                    switch (e) {
                        case l.k:
                            return void this.tabOut.next();
                        case l.b:
                            if (this._vertical && i) {
                                this.setNextItemActive();
                                break
                            }
                            return;
                        case l.l:
                            if (this._vertical && i) {
                                this.setPreviousItemActive();
                                break
                            }
                            return;
                        case l.i:
                            if (this._horizontal && i) {
                                "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive();
                                break
                            }
                            return;
                        case l.g:
                            if (this._horizontal && i) {
                                "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive();
                                break
                            }
                            return;
                        case l.f:
                            if (this._homeAndEnd && i) {
                                this.setFirstItemActive();
                                break
                            }
                            return;
                        case l.c:
                            if (this._homeAndEnd && i) {
                                this.setLastItemActive();
                                break
                            }
                            return;
                        default:
                            return void((i || Object(l.o)(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= l.a && e <= l.m || e >= l.n && e <= l.h) && this._letterKeyStream.next(String.fromCharCode(e))))
                    }
                    this._pressedLetters = [], t.preventDefault()
                }
                get activeItemIndex() {
                    return this._activeItemIndex
                }
                get activeItem() {
                    return this._activeItem
                }
                isTyping() {
                    return this._pressedLetters.length > 0
                }
                setFirstItemActive() {
                    this._setActiveItemByIndex(0, 1)
                }
                setLastItemActive() {
                    this._setActiveItemByIndex(this._items.length - 1, -1)
                }
                setNextItemActive() {
                    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1)
                }
                setPreviousItemActive() {
                    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1)
                }
                updateActiveItem(t) {
                    const e = this._getItemsArray(),
                        i = "number" == typeof t ? t : e.indexOf(t),
                        n = e[i];
                    this._activeItem = null == n ? null : n, this._activeItemIndex = i
                }
                _setActiveItemByDelta(t) {
                    this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t)
                }
                _setActiveInWrapMode(t) {
                    const e = this._getItemsArray();
                    for (let i = 1; i <= e.length; i++) {
                        const n = (this._activeItemIndex + t * i + e.length) % e.length;
                        if (!this._skipPredicateFn(e[n])) return void this.setActiveItem(n)
                    }
                }
                _setActiveInDefaultMode(t) {
                    this._setActiveItemByIndex(this._activeItemIndex + t, t)
                }
                _setActiveItemByIndex(t, e) {
                    const i = this._getItemsArray();
                    if (i[t]) {
                        for (; this._skipPredicateFn(i[t]);)
                            if (!i[t += e]) return;
                        this.setActiveItem(t)
                    }
                }
                _getItemsArray() {
                    return this._items instanceof s.F ? this._items.toArray() : this._items
                }
            }
            class S extends k {
                setActiveItem(t) {
                    this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(t), this.activeItem && this.activeItem.setActiveStyles()
                }
            }
            class A extends k {
                constructor() {
                    super(...arguments), this._origin = "program"
                }
                setFocusOrigin(t) {
                    return this._origin = t, this
                }
                setActiveItem(t) {
                    super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin)
                }
            }
            let O = (() => {
                class t {
                    constructor(t) {
                        this._platform = t
                    }
                    isDisabled(t) {
                        return t.hasAttribute("disabled")
                    }
                    isVisible(t) {
                        return function(t) {
                            return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length)
                        }(t) && "visible" === getComputedStyle(t).visibility
                    }
                    isTabbable(t) {
                        if (!this._platform.isBrowser) return !1;
                        const e = function(t) {
                            try {
                                return t.frameElement
                            } catch (e) {
                                return null
                            }
                        }((i = t).ownerDocument && i.ownerDocument.defaultView || window);
                        var i;
                        if (e) {
                            if (-1 === P(e)) return !1;
                            if (!this.isVisible(e)) return !1
                        }
                        let n = t.nodeName.toLowerCase(),
                            s = P(t);
                        return t.hasAttribute("contenteditable") ? -1 !== s : "iframe" !== n && "object" !== n && !(this._platform.WEBKIT && this._platform.IOS && ! function(t) {
                            let e = t.nodeName.toLowerCase(),
                                i = "input" === e && t.type;
                            return "text" === i || "password" === i || "select" === e || "textarea" === e
                        }(t)) && ("audio" === n ? !!t.hasAttribute("controls") && -1 !== s : "video" === n ? -1 !== s && (null !== s || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0)
                    }
                    isFocusable(t, e) {
                        return function(t) {
                            return ! function(t) {
                                return function(t) {
                                    return "input" == t.nodeName.toLowerCase()
                                }(t) && "hidden" == t.type
                            }(t) && (function(t) {
                                let e = t.nodeName.toLowerCase();
                                return "input" === e || "select" === e || "button" === e || "textarea" === e
                            }(t) || function(t) {
                                return function(t) {
                                    return "a" == t.nodeName.toLowerCase()
                                }(t) && t.hasAttribute("href")
                            }(t) || t.hasAttribute("contenteditable") || E(t))
                        }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t))
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(g.a))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(g.a))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function E(t) {
                if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1;
                let e = t.getAttribute("tabindex");
                return "-32768" != e && !(!e || isNaN(parseInt(e, 10)))
            }

            function P(t) {
                if (!E(t)) return null;
                const e = parseInt(t.getAttribute("tabindex") || "", 10);
                return isNaN(e) ? -1 : e
            }
            class T {
                constructor(t, e, i, n, s = !1) {
                    this._element = t, this._checker = e, this._ngZone = i, this._document = n, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors()
                }
                get enabled() {
                    return this._enabled
                }
                set enabled(t) {
                    this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor))
                }
                destroy() {
                    const t = this._startAnchor,
                        e = this._endAnchor;
                    t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1
                }
                attachAnchors() {
                    return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => {
                        this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener))
                    }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached)
                }
                focusInitialElementWhenReady() {
                    return new Promise(t => {
                        this._executeOnStable(() => t(this.focusInitialElement()))
                    })
                }
                focusFirstTabbableElementWhenReady() {
                    return new Promise(t => {
                        this._executeOnStable(() => t(this.focusFirstTabbableElement()))
                    })
                }
                focusLastTabbableElementWhenReady() {
                    return new Promise(t => {
                        this._executeOnStable(() => t(this.focusLastTabbableElement()))
                    })
                }
                _getRegionBoundary(t) {
                    let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);
                    for (let i = 0; i < e.length; i++) e[i].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]) : e[i].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]);
                    return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element)
                }
                focusInitialElement() {
                    const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
                    if (t) {
                        if (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), !this._checker.isFocusable(t)) {
                            const e = this._getFirstTabbableElement(t);
                            return null == e || e.focus(), !!e
                        }
                        return t.focus(), !0
                    }
                    return this.focusFirstTabbableElement()
                }
                focusFirstTabbableElement() {
                    const t = this._getRegionBoundary("start");
                    return t && t.focus(), !!t
                }
                focusLastTabbableElement() {
                    const t = this._getRegionBoundary("end");
                    return t && t.focus(), !!t
                }
                hasAttached() {
                    return this._hasAttached
                }
                _getFirstTabbableElement(t) {
                    if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
                    let e = t.children || t.childNodes;
                    for (let i = 0; i < e.length; i++) {
                        let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null;
                        if (t) return t
                    }
                    return null
                }
                _getLastTabbableElement(t) {
                    if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
                    let e = t.children || t.childNodes;
                    for (let i = e.length - 1; i >= 0; i--) {
                        let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null;
                        if (t) return t
                    }
                    return null
                }
                _createAnchor() {
                    const t = this._document.createElement("div");
                    return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t
                }
                _toggleAnchorTabIndex(t, e) {
                    t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex")
                }
                toggleAnchors(t) {
                    this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor))
                }
                _executeOnStable(t) {
                    this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(Object(p.a)(1)).subscribe(t)
                }
            }
            let D = (() => {
                class t {
                    constructor(t, e, i) {
                        this._checker = t, this._ngZone = e, this._document = i
                    }
                    create(t, e = !1) {
                        return new T(t, this._checker, this._ngZone, this._document, e)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(O), s.Zb(s.B), s.Zb(n.d))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(O), Object(s.Zb)(s.B), Object(s.Zb)(n.d))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();
            "undefined" != typeof Element && Element;
            const I = new s.s("liveAnnouncerElement", {
                    providedIn: "root",
                    factory: function() {
                        return null
                    }
                }),
                M = new s.s("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
            let L = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._ngZone = e, this._defaultOptions = n, this._document = i, this._liveElement = t || this._createLiveElement()
                    }
                    announce(t, ...e) {
                        const i = this._defaultOptions;
                        let n, s;
                        return 1 === e.length && "number" == typeof e[0] ? s = e[0] : [n, s] = e, this.clear(), clearTimeout(this._previousTimeout), n || (n = i && i.politeness ? i.politeness : "polite"), null == s && i && (s = i.duration), this._liveElement.setAttribute("aria-live", n), this._ngZone.runOutsideAngular(() => new Promise(e => {
                            clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => {
                                this._liveElement.textContent = t, e(), "number" == typeof s && (this._previousTimeout = setTimeout(() => this.clear(), s))
                            }, 100)
                        }))
                    }
                    clear() {
                        this._liveElement && (this._liveElement.textContent = "")
                    }
                    ngOnDestroy() {
                        clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null)
                    }
                    _createLiveElement() {
                        const t = this._document.getElementsByClassName("cdk-live-announcer-element"),
                            e = this._document.createElement("div");
                        for (let i = 0; i < t.length; i++) t[i].parentNode.removeChild(t[i]);
                        return e.classList.add("cdk-live-announcer-element"), e.classList.add("cdk-visually-hidden"), e.setAttribute("aria-atomic", "true"), e.setAttribute("aria-live", "polite"), this._document.body.appendChild(e), e
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(I, 8), s.Zb(s.B), s.Zb(n.d), s.Zb(M, 8))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(I, 8), Object(s.Zb)(s.B), Object(s.Zb)(n.d), Object(s.Zb)(M, 8))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function R(t) {
                return 0 === t.buttons
            }

            function j(t) {
                const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0];
                return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY)
            }
            const F = new s.s("cdk-focus-monitor-default-options"),
                N = Object(g.f)({
                    passive: !0,
                    capture: !0
                });
            let z = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._ngZone = t, this._platform = e, this._origin = null, this._windowFocused = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._documentKeydownListener = () => {
                            this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard")
                        }, this._documentMousedownListener = t => {
                            if (!this._lastTouchTarget) {
                                const e = R(t) ? "keyboard" : "mouse";
                                this._setOriginForCurrentEventQueue(e)
                            }
                        }, this._documentTouchstartListener = t => {
                            j(t) ? this._lastTouchTarget || this._setOriginForCurrentEventQueue("keyboard") : (null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = V(t), this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, 650))
                        }, this._windowFocusListener = () => {
                            this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1)
                        }, this._rootNodeFocusAndBlurListener = t => {
                            const e = V(t),
                                i = "focus" === t.type ? this._onFocus : this._onBlur;
                            for (let n = e; n; n = n.parentElement) i.call(this, t, n)
                        }, this._document = i, this._detectionMode = (null == n ? void 0 : n.detectionMode) || 0
                    }
                    monitor(t, e = !1) {
                        const i = Object(f.e)(t);
                        if (!this._platform.isBrowser || 1 !== i.nodeType) return Object(o.a)(null);
                        const n = Object(g.c)(i) || this._getDocument(),
                            s = this._elementInfo.get(i);
                        if (s) return e && (s.checkChildren = !0), s.subject;
                        const a = {
                            checkChildren: e,
                            subject: new r.a,
                            rootNode: n
                        };
                        return this._elementInfo.set(i, a), this._registerGlobalListeners(a), a.subject
                    }
                    stopMonitoring(t) {
                        const e = Object(f.e)(t),
                            i = this._elementInfo.get(e);
                        i && (i.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._removeGlobalListeners(i))
                    }
                    focusVia(t, e, i) {
                        const n = Object(f.e)(t);
                        n === this._getDocument().activeElement ? this._getClosestElementsInfo(n).forEach(([t, i]) => this._originChanged(t, e, i)) : (this._setOriginForCurrentEventQueue(e), "function" == typeof n.focus && n.focus(i))
                    }
                    ngOnDestroy() {
                        this._elementInfo.forEach((t, e) => this.stopMonitoring(e))
                    }
                    _getDocument() {
                        return this._document || document
                    }
                    _getWindow() {
                        return this._getDocument().defaultView || window
                    }
                    _toggleClass(t, e, i) {
                        i ? t.classList.add(e) : t.classList.remove(e)
                    }
                    _getFocusOrigin(t) {
                        return this._origin ? this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(t) ? "touch" : "program"
                    }
                    _setClasses(t, e) {
                        this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e)
                    }
                    _setOriginForCurrentEventQueue(t) {
                        this._ngZone.runOutsideAngular(() => {
                            this._origin = t, 0 === this._detectionMode && (this._originTimeoutId = setTimeout(() => this._origin = null, 1))
                        })
                    }
                    _wasCausedByTouch(t) {
                        const e = V(t);
                        return this._lastTouchTarget instanceof Node && e instanceof Node && (e === this._lastTouchTarget || e.contains(this._lastTouchTarget))
                    }
                    _onFocus(t, e) {
                        const i = this._elementInfo.get(e);
                        i && (i.checkChildren || e === V(t)) && this._originChanged(e, this._getFocusOrigin(t), i)
                    }
                    _onBlur(t, e) {
                        const i = this._elementInfo.get(e);
                        !i || i.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(i.subject, null))
                    }
                    _emitOrigin(t, e) {
                        this._ngZone.run(() => t.next(e))
                    }
                    _registerGlobalListeners(t) {
                        if (!this._platform.isBrowser) return;
                        const e = t.rootNode,
                            i = this._rootNodeFocusListenerCount.get(e) || 0;
                        i || this._ngZone.runOutsideAngular(() => {
                            e.addEventListener("focus", this._rootNodeFocusAndBlurListener, N), e.addEventListener("blur", this._rootNodeFocusAndBlurListener, N)
                        }), this._rootNodeFocusListenerCount.set(e, i + 1), 1 == ++this._monitoredElementCount && this._ngZone.runOutsideAngular(() => {
                            const t = this._getDocument(),
                                e = this._getWindow();
                            t.addEventListener("keydown", this._documentKeydownListener, N), t.addEventListener("mousedown", this._documentMousedownListener, N), t.addEventListener("touchstart", this._documentTouchstartListener, N), e.addEventListener("focus", this._windowFocusListener)
                        })
                    }
                    _removeGlobalListeners(t) {
                        const e = t.rootNode;
                        if (this._rootNodeFocusListenerCount.has(e)) {
                            const t = this._rootNodeFocusListenerCount.get(e);
                            t > 1 ? this._rootNodeFocusListenerCount.set(e, t - 1) : (e.removeEventListener("focus", this._rootNodeFocusAndBlurListener, N), e.removeEventListener("blur", this._rootNodeFocusAndBlurListener, N), this._rootNodeFocusListenerCount.delete(e))
                        }
                        if (!--this._monitoredElementCount) {
                            const t = this._getDocument(),
                                e = this._getWindow();
                            t.removeEventListener("keydown", this._documentKeydownListener, N), t.removeEventListener("mousedown", this._documentMousedownListener, N), t.removeEventListener("touchstart", this._documentTouchstartListener, N), e.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId)
                        }
                    }
                    _originChanged(t, e, i) {
                        this._setClasses(t, e), this._emitOrigin(i.subject, e), this._lastFocusOrigin = e
                    }
                    _getClosestElementsInfo(t) {
                        const e = [];
                        return this._elementInfo.forEach((i, n) => {
                            (n === t || i.checkChildren && n.contains(t)) && e.push([n, i])
                        }), e
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(s.Zb(s.B), s.Zb(g.a), s.Zb(n.d, 8), s.Zb(F, 8))
                }, t.\u0275prov = Object(s.Lb)({
                    factory: function() {
                        return new t(Object(s.Zb)(s.B), Object(s.Zb)(g.a), Object(s.Zb)(n.d, 8), Object(s.Zb)(F, 8))
                    },
                    token: t,
                    providedIn: "root"
                }), t
            })();

            function V(t) {
                return t.composedPath ? t.composedPath()[0] : t.target
            }
            let B = (() => {
                    class t {
                        constructor(t, e) {
                            this._elementRef = t, this._focusMonitor = e, this.cdkFocusChange = new s.o
                        }
                        ngAfterViewInit() {
                            const t = this._elementRef.nativeElement;
                            this._monitorSubscription = this._focusMonitor.monitor(t, 1 === t.nodeType && t.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(t => this.cdkFocusChange.emit(t))
                        }
                        ngOnDestroy() {
                            this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription && this._monitorSubscription.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l), s.Pb(z))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "cdkMonitorElementFocus", ""],
                            ["", "cdkMonitorSubtreeFocus", ""]
                        ],
                        outputs: {
                            cdkFocusChange: "cdkFocusChange"
                        }
                    }), t
                })(),
                H = (() => {
                    class t {
                        constructor(t, e) {
                            this._platform = t, this._document = e
                        }
                        getHighContrastMode() {
                            if (!this._platform.isBrowser) return 0;
                            const t = this._document.createElement("div");
                            t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t);
                            const e = this._document.defaultView || window,
                                i = e && e.getComputedStyle ? e.getComputedStyle(t) : null,
                                n = (i && i.backgroundColor || "").replace(/ /g, "");
                            switch (this._document.body.removeChild(t), n) {
                                case "rgb(0,0,0)":
                                    return 2;
                                case "rgb(255,255,255)":
                                    return 1
                            }
                            return 0
                        }
                        _applyBodyHighContrastModeCssClasses() {
                            if (this._platform.isBrowser && this._document.body) {
                                const t = this._document.body.classList;
                                t.remove("cdk-high-contrast-active"), t.remove("cdk-high-contrast-black-on-white"), t.remove("cdk-high-contrast-white-on-black");
                                const e = this.getHighContrastMode();
                                1 === e ? (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-black-on-white")) : 2 === e && (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-white-on-black"))
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(g.a), s.Zb(n.d))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(g.a), Object(s.Zb)(n.d))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                U = (() => {
                    class t {
                        constructor(t) {
                            t._applyBodyHighContrastModeCssClasses()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(H))
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        imports: [
                            [g.b, m.c]
                        ]
                    }), t
                })()
        },
        ujAs: function(t, e, i) {
            "use strict";
            var n;

            function s(t) {
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }

            function r(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            function o(t, e, i) {
                return e && a(t.prototype, e), i && a(t, i), t
            }

            function l(t, e, i) {
                return e in t ? Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = i, t
            }

            function c(t, e) {
                var i = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(t);
                    e && (n = n.filter(function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    })), i.push.apply(i, n)
                }
                return i
            }

            function h(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? c(Object(i), !0).forEach(function(e) {
                        l(t, e, i[e])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : c(Object(i)).forEach(function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                    })
                }
                return t
            }

            function u(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && p(t, e)
            }

            function d(t) {
                return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
            }

            function p(t, e) {
                return (p = Object.setPrototypeOf || function(t, e) {
                    return t.__proto__ = e, t
                })(t, e)
            }

            function f(t, e) {
                return !e || "object" != typeof e && "function" != typeof e ? function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }(t) : e
            }

            function g(t) {
                var e = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                    } catch (t) {
                        return !1
                    }
                }();
                return function() {
                    var i, n = d(t);
                    if (e) {
                        var s = d(this).constructor;
                        i = Reflect.construct(n, arguments, s)
                    } else i = n.apply(this, arguments);
                    return f(this, i)
                }
            }

            function m(t) {
                return function(t) {
                    if (Array.isArray(t)) return b(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return b(t, e);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? b(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function b(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
                return n
            }
            var y = function() {
                    function t() {
                        r(this, t)
                    }
                    return o(t, [{
                        key: "shadeRGBColor",
                        value: function(t, e) {
                            var i = e.split(","),
                                n = t < 0 ? 0 : 255,
                                s = t < 0 ? -1 * t : t,
                                r = parseInt(i[0].slice(4), 10),
                                a = parseInt(i[1], 10),
                                o = parseInt(i[2], 10);
                            return "rgb(" + (Math.round((n - r) * s) + r) + "," + (Math.round((n - a) * s) + a) + "," + (Math.round((n - o) * s) + o) + ")"
                        }
                    }, {
                        key: "shadeHexColor",
                        value: function(t, e) {
                            var i = parseInt(e.slice(1), 16),
                                n = t < 0 ? 0 : 255,
                                s = t < 0 ? -1 * t : t,
                                r = i >> 16,
                                a = i >> 8 & 255,
                                o = 255 & i;
                            return "#" + (16777216 + 65536 * (Math.round((n - r) * s) + r) + 256 * (Math.round((n - a) * s) + a) + (Math.round((n - o) * s) + o)).toString(16).slice(1)
                        }
                    }, {
                        key: "shadeColor",
                        value: function(e, i) {
                            return t.isColorHex(i) ? this.shadeHexColor(e, i) : this.shadeRGBColor(e, i)
                        }
                    }], [{
                        key: "bind",
                        value: function(t, e) {
                            return function() {
                                return t.apply(e, arguments)
                            }
                        }
                    }, {
                        key: "isObject",
                        value: function(t) {
                            return t && "object" === s(t) && !Array.isArray(t) && null != t
                        }
                    }, {
                        key: "listToArray",
                        value: function(t) {
                            var e, i = [];
                            for (e = 0; e < t.length; e++) i[e] = t[e];
                            return i
                        }
                    }, {
                        key: "extend",
                        value: function(t, e) {
                            var i = this;
                            "function" != typeof Object.assign && (Object.assign = function(t) {
                                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                                    var n = arguments[i];
                                    if (null != n)
                                        for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s])
                                }
                                return e
                            });
                            var n = Object.assign({}, t);
                            return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(function(s) {
                                i.isObject(e[s]) && s in t ? n[s] = i.extend(t[s], e[s]) : Object.assign(n, l({}, s, e[s]))
                            }), n
                        }
                    }, {
                        key: "extendArray",
                        value: function(e, i) {
                            var n = [];
                            return e.map(function(e) {
                                n.push(t.extend(i, e))
                            }), n
                        }
                    }, {
                        key: "monthMod",
                        value: function(t) {
                            return t % 12
                        }
                    }, {
                        key: "clone",
                        value: function(t) {
                            if ("[object Array]" === Object.prototype.toString.call(t)) {
                                for (var e = [], i = 0; i < t.length; i++) e[i] = this.clone(t[i]);
                                return e
                            }
                            if ("[object Null]" === Object.prototype.toString.call(t)) return null;
                            if ("[object Date]" === Object.prototype.toString.call(t)) return t;
                            if ("object" === s(t)) {
                                var n = {};
                                for (var r in t) t.hasOwnProperty(r) && (n[r] = this.clone(t[r]));
                                return n
                            }
                            return t
                        }
                    }, {
                        key: "log10",
                        value: function(t) {
                            return Math.log(t) / Math.LN10
                        }
                    }, {
                        key: "roundToBase10",
                        value: function(t) {
                            return Math.pow(10, Math.floor(Math.log10(t)))
                        }
                    }, {
                        key: "roundToBase",
                        value: function(t, e) {
                            return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)))
                        }
                    }, {
                        key: "parseNumber",
                        value: function(t) {
                            return null === t ? t : parseFloat(t)
                        }
                    }, {
                        key: "randomId",
                        value: function() {
                            return (Math.random() + 1).toString(36).substring(4)
                        }
                    }, {
                        key: "noExponents",
                        value: function(t) {
                            var e = String(t).split(/[eE]/);
                            if (1 === e.length) return e[0];
                            var i = "",
                                n = t < 0 ? "-" : "",
                                s = e[0].replace(".", ""),
                                r = Number(e[1]) + 1;
                            if (r < 0) {
                                for (i = n + "0."; r++;) i += "0";
                                return i + s.replace(/^-/, "")
                            }
                            for (r -= s.length; r--;) i += "0";
                            return s + i
                        }
                    }, {
                        key: "getDimensions",
                        value: function(t) {
                            var e = getComputedStyle(t, null),
                                i = t.clientHeight,
                                n = t.clientWidth;
                            return i -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), [n -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i]
                        }
                    }, {
                        key: "getBoundingClientRect",
                        value: function(t) {
                            var e = t.getBoundingClientRect();
                            return {
                                top: e.top,
                                right: e.right,
                                bottom: e.bottom,
                                left: e.left,
                                width: t.clientWidth,
                                height: t.clientHeight,
                                x: e.left,
                                y: e.top
                            }
                        }
                    }, {
                        key: "getLargestStringFromArr",
                        value: function(t) {
                            return t.reduce(function(t, e) {
                                return Array.isArray(e) && (e = e.reduce(function(t, e) {
                                    return t.length > e.length ? t : e
                                })), t.length > e.length ? t : e
                            }, 0)
                        }
                    }, {
                        key: "hexToRgba",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                            "#" !== t.substring(0, 1) && (t = "#999999");
                            var i = t.replace("#", "");
                            i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
                            for (var n = 0; n < i.length; n++) i[n] = parseInt(1 === i[n].length ? i[n] + i[n] : i[n], 16);
                            return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")"
                        }
                    }, {
                        key: "getOpacityFromRGBA",
                        value: function(t) {
                            return parseFloat(t.replace(/^.*,(.+)\)/, "$1"))
                        }
                    }, {
                        key: "rgb2hex",
                        value: function(t) {
                            return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : ""
                        }
                    }, {
                        key: "isColorHex",
                        value: function(t) {
                            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)
                        }
                    }, {
                        key: "getPolygonPos",
                        value: function(t, e) {
                            for (var i = [], n = 2 * Math.PI / e, s = 0; s < e; s++) {
                                var r = {};
                                r.x = t * Math.sin(s * n), r.y = -t * Math.cos(s * n), i.push(r)
                            }
                            return i
                        }
                    }, {
                        key: "polarToCartesian",
                        value: function(t, e, i, n) {
                            var s = (n - 90) * Math.PI / 180;
                            return {
                                x: t + i * Math.cos(s),
                                y: e + i * Math.sin(s)
                            }
                        }
                    }, {
                        key: "escapeString",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x",
                                i = t.toString().slice();
                            return i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e)
                        }
                    }, {
                        key: "negToZero",
                        value: function(t) {
                            return t < 0 ? 0 : t
                        }
                    }, {
                        key: "moveIndexInArray",
                        value: function(t, e, i) {
                            if (i >= t.length)
                                for (var n = i - t.length + 1; n--;) t.push(void 0);
                            return t.splice(i, 0, t.splice(e, 1)[0]), t
                        }
                    }, {
                        key: "extractNumber",
                        value: function(t) {
                            return parseFloat(t.replace(/[^\d.]*/g, ""))
                        }
                    }, {
                        key: "findAncestor",
                        value: function(t, e) {
                            for (;
                                (t = t.parentElement) && !t.classList.contains(e););
                            return t
                        }
                    }, {
                        key: "setELstyles",
                        value: function(t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t.style.key = e[i])
                        }
                    }, {
                        key: "isNumber",
                        value: function(t) {
                            return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10))
                        }
                    }, {
                        key: "isFloat",
                        value: function(t) {
                            return Number(t) === t && t % 1 != 0
                        }
                    }, {
                        key: "isSafari",
                        value: function() {
                            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
                        }
                    }, {
                        key: "isFirefox",
                        value: function() {
                            return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
                        }
                    }, {
                        key: "isIE11",
                        value: function() {
                            if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0
                        }
                    }, {
                        key: "isIE",
                        value: function() {
                            var t = window.navigator.userAgent,
                                e = t.indexOf("MSIE ");
                            if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
                            if (t.indexOf("Trident/") > 0) {
                                var i = t.indexOf("rv:");
                                return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10)
                            }
                            var n = t.indexOf("Edge/");
                            return n > 0 && parseInt(t.substring(n + 5, t.indexOf(".", n)), 10)
                        }
                    }]), t
                }(),
                v = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.setEasingFunctions()
                    }
                    return o(t, [{
                        key: "setEasingFunctions",
                        value: function() {
                            var t;
                            if (!this.w.globals.easing) {
                                switch (this.w.config.chart.animations.easing) {
                                    case "linear":
                                        t = "-";
                                        break;
                                    case "easein":
                                        t = "<";
                                        break;
                                    case "easeout":
                                        t = ">";
                                        break;
                                    case "easeinout":
                                        t = "<>";
                                        break;
                                    case "swing":
                                        t = function(t) {
                                            var e = 1.70158;
                                            return (t -= 1) * t * ((e + 1) * t + e) + 1
                                        };
                                        break;
                                    case "bounce":
                                        t = function(t) {
                                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                                        };
                                        break;
                                    case "elastic":
                                        t = function(t) {
                                            return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * (2 * Math.PI) / .3) + 1
                                        };
                                        break;
                                    default:
                                        t = "<>"
                                }
                                this.w.globals.easing = t
                            }
                        }
                    }, {
                        key: "animateLine",
                        value: function(t, e, i, n) {
                            t.attr(e).animate(n).attr(i)
                        }
                    }, {
                        key: "animateMarker",
                        value: function(t, e, i, n, s, r) {
                            e || (e = 0), t.attr({
                                r: e,
                                width: e,
                                height: e
                            }).animate(n, s).attr({
                                r: i,
                                width: i.width,
                                height: i.height
                            }).afterAll(function() {
                                r()
                            })
                        }
                    }, {
                        key: "animateCircle",
                        value: function(t, e, i, n, s) {
                            t.attr({
                                r: e.r,
                                cx: e.cx,
                                cy: e.cy
                            }).animate(n, s).attr({
                                r: i.r,
                                cx: i.cx,
                                cy: i.cy
                            })
                        }
                    }, {
                        key: "animateRect",
                        value: function(t, e, i, n, s) {
                            t.attr(e).animate(n).attr(i).afterAll(function() {
                                return s()
                            })
                        }
                    }, {
                        key: "animatePathsGradually",
                        value: function(t) {
                            var e = this.w,
                                i = 0;
                            e.config.chart.animations.animateGradually.enabled && (i = e.config.chart.animations.animateGradually.delay), e.config.chart.animations.dynamicAnimation.enabled && e.globals.dataChanged && "bar" !== e.config.chart.type && (i = 0), this.morphSVG(t.el, t.realIndex, t.j, "line" !== e.config.chart.type || e.globals.comboCharts ? t.fill : "stroke", t.pathFrom, t.pathTo, t.speed, t.delay * i)
                        }
                    }, {
                        key: "showDelayedElements",
                        value: function() {
                            this.w.globals.delayedElements.forEach(function(t) {
                                t.el.classList.remove("apexcharts-element-hidden")
                            })
                        }
                    }, {
                        key: "animationCompleted",
                        value: function(t) {
                            var e = this.w;
                            e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
                                el: t,
                                w: e
                            }))
                        }
                    }, {
                        key: "morphSVG",
                        value: function(t, e, i, n, s, r, a, o) {
                            var l = this,
                                c = this.w;
                            s || (s = t.attr("pathFrom")), r || (r = t.attr("pathTo"));
                            var h = function(t) {
                                return "radar" === c.config.chart.type && (a = 1), "M 0 ".concat(c.globals.gridHeight)
                            };
                            (!s || s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = h()), (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = h()), c.globals.shouldAnimate || (a = 1), t.plot(s).animate(1, c.globals.easing, o).plot(s).animate(a, c.globals.easing, o).plot(r).afterAll(function() {
                                y.isNumber(i) ? i === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 && c.globals.shouldAnimate && l.animationCompleted(t) : "none" !== n && c.globals.shouldAnimate && (!c.globals.comboCharts && e === c.globals.series.length - 1 || c.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements()
                            })
                        }
                    }]), t
                }(),
                x = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "getDefaultFilter",
                        value: function(t, e) {
                            var i = this.w;
                            t.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e)
                        }
                    }, {
                        key: "addNormalFilter",
                        value: function(t, e) {
                            var i = this.w;
                            i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, e)
                        }
                    }, {
                        key: "addLightenFilter",
                        value: function(t, e, i) {
                            var n = this,
                                s = this.w,
                                r = i.intensity;
                            t.unfilter(!0), new window.SVG.Filter, t.filter(function(t) {
                                var i = s.config.chart.dropShadow;
                                (i.enabled ? n.addShadow(t, e, i) : t).componentTransfer({
                                    rgb: {
                                        type: "linear",
                                        slope: 1.5,
                                        intercept: r
                                    }
                                })
                            }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                        }
                    }, {
                        key: "addDarkenFilter",
                        value: function(t, e, i) {
                            var n = this,
                                s = this.w,
                                r = i.intensity;
                            t.unfilter(!0), new window.SVG.Filter, t.filter(function(t) {
                                var i = s.config.chart.dropShadow;
                                (i.enabled ? n.addShadow(t, e, i) : t).componentTransfer({
                                    rgb: {
                                        type: "linear",
                                        slope: r
                                    }
                                })
                            }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                        }
                    }, {
                        key: "applyFilter",
                        value: function(t, e, i) {
                            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                            switch (i) {
                                case "none":
                                    this.addNormalFilter(t, e);
                                    break;
                                case "lighten":
                                    this.addLightenFilter(t, e, {
                                        intensity: n
                                    });
                                    break;
                                case "darken":
                                    this.addDarkenFilter(t, e, {
                                        intensity: n
                                    })
                            }
                        }
                    }, {
                        key: "addShadow",
                        value: function(t, e, i) {
                            var n = i.blur,
                                s = i.top,
                                r = i.left,
                                a = i.color,
                                o = i.opacity,
                                l = t.flood(Array.isArray(a) ? a[e] : a, o).composite(t.sourceAlpha, "in").offset(r, s).gaussianBlur(n).merge(t.source);
                            return t.blend(t.source, l)
                        }
                    }, {
                        key: "dropShadow",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                n = e.top,
                                s = e.left,
                                r = e.blur,
                                a = e.color,
                                o = e.opacity,
                                l = e.noUserSpaceOnUse,
                                c = this.w;
                            return t.unfilter(!0), y.isIE() && "radialBar" === c.config.chart.type || (a = Array.isArray(a) ? a[i] : a, t.filter(function(t) {
                                var e;
                                e = y.isSafari() || y.isFirefox() || y.isIE() ? t.flood(a, o).composite(t.sourceAlpha, "in").offset(s, n).gaussianBlur(r) : t.flood(a, o).composite(t.sourceAlpha, "in").offset(s, n).gaussianBlur(r).merge(t.source), t.blend(t.source, e)
                            }), l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t
                        }
                    }, {
                        key: "setSelectionFilter",
                        value: function(t, e, i) {
                            var n = this.w;
                            if (void 0 !== n.globals.selectedDataPoints[e] && n.globals.selectedDataPoints[e].indexOf(i) > -1) {
                                t.node.setAttribute("selected", !0);
                                var s = n.config.states.active.filter;
                                "none" !== s && this.applyFilter(t, e, s.type, s.value)
                            }
                        }
                    }, {
                        key: "_scaleFilterSize",
                        value: function(t) {
                            ! function(e) {
                                for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                            }({
                                width: "200%",
                                height: "200%",
                                x: "-50%",
                                y: "-50%"
                            })
                        }
                    }]), t
                }(),
                _ = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "drawLine",
                        value: function(t, e, i, n) {
                            var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                                r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                                a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                o = this.w,
                                l = o.globals.dom.Paper.line().attr({
                                    x1: t,
                                    y1: e,
                                    x2: i,
                                    y2: n,
                                    stroke: s,
                                    "stroke-dasharray": r,
                                    "stroke-width": a
                                });
                            return l
                        }
                    }, {
                        key: "drawRect",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                                r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                                a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                                o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                                c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
                                h = this.w,
                                u = h.globals.dom.Paper.rect();
                            return u.attr({
                                x: t,
                                y: e,
                                width: i > 0 ? i : 0,
                                height: n > 0 ? n : 0,
                                rx: s,
                                ry: s,
                                opacity: a,
                                "stroke-width": null !== o ? o : 0,
                                stroke: null !== l ? l : "none",
                                "stroke-dasharray": c
                            }), u.node.setAttribute("fill", r), u
                        }
                    }, {
                        key: "drawPolygon",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none",
                                s = this.w,
                                r = s.globals.dom.Paper.polygon(t).attr({
                                    fill: n,
                                    stroke: e,
                                    "stroke-width": i
                                });
                            return r
                        }
                    }, {
                        key: "drawCircle",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                i = this.w;
                            t < 0 && (t = 0);
                            var n = i.globals.dom.Paper.circle(2 * t);
                            return null !== e && n.attr(e), n
                        }
                    }, {
                        key: "drawPath",
                        value: function(t) {
                            var e = t.d,
                                i = void 0 === e ? "" : e,
                                n = t.stroke,
                                s = void 0 === n ? "#a8a8a8" : n,
                                r = t.strokeWidth,
                                a = void 0 === r ? 1 : r,
                                o = t.fill,
                                l = t.fillOpacity,
                                c = void 0 === l ? 1 : l,
                                h = t.strokeOpacity,
                                u = void 0 === h ? 1 : h,
                                d = t.classes,
                                p = t.strokeLinecap,
                                f = void 0 === p ? null : p,
                                g = t.strokeDashArray,
                                m = void 0 === g ? 0 : g,
                                b = this.w;
                            return null === f && (f = b.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({
                                fill: o,
                                "fill-opacity": c,
                                stroke: s,
                                "stroke-opacity": u,
                                "stroke-linecap": f,
                                "stroke-width": a,
                                "stroke-dasharray": m,
                                class: d
                            })
                        }
                    }, {
                        key: "group",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                e = this.w,
                                i = e.globals.dom.Paper.group();
                            return null !== t && i.attr(t), i
                        }
                    }, {
                        key: "move",
                        value: function(t, e) {
                            return ["M", t, e].join(" ")
                        }
                    }, {
                        key: "line",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                n = null;
                            return null === i ? n = ["L", t, e].join(" ") : "H" === i ? n = ["H", t].join(" ") : "V" === i && (n = ["V", e].join(" ")), n
                        }
                    }, {
                        key: "curve",
                        value: function(t, e, i, n, s, r) {
                            return ["C", t, e, i, n, s, r].join(" ")
                        }
                    }, {
                        key: "quadraticCurve",
                        value: function(t, e, i, n) {
                            return ["Q", t, e, i, n].join(" ")
                        }
                    }, {
                        key: "arc",
                        value: function(t, e, i, n, s, r, a) {
                            var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
                                l = "A";
                            o && (l = "a");
                            var c = [l, t, e, i, n, s, r, a].join(" ");
                            return c
                        }
                    }, {
                        key: "renderPaths",
                        value: function(t) {
                            var e, i = t.j,
                                n = t.realIndex,
                                s = t.pathFrom,
                                r = t.pathTo,
                                a = t.stroke,
                                o = t.strokeWidth,
                                l = t.strokeLinecap,
                                c = t.fill,
                                u = t.animationDelay,
                                d = t.initialSpeed,
                                p = t.dataChangeSpeed,
                                f = t.className,
                                g = t.shouldClipToGrid,
                                m = void 0 === g || g,
                                b = t.bindEventsOnPaths,
                                y = void 0 === b || b,
                                _ = t.drawShadow,
                                w = void 0 === _ || _,
                                C = this.w,
                                k = new x(this.ctx),
                                S = new v(this.ctx),
                                A = this.w.config.chart.animations.enabled,
                                O = A && this.w.config.chart.animations.dynamicAnimation.enabled,
                                E = !!(A && !C.globals.resized || O && C.globals.dataChanged && C.globals.shouldAnimate);
                            E ? e = s : (e = r, C.globals.animationEnded = !0);
                            var P, T = C.config.stroke.dashArray;
                            P = Array.isArray(T) ? T[n] : C.config.stroke.dashArray;
                            var D = this.drawPath({
                                d: e,
                                stroke: a,
                                strokeWidth: o,
                                fill: c,
                                fillOpacity: 1,
                                classes: f,
                                strokeLinecap: l,
                                strokeDashArray: P
                            });
                            D.attr("index", n), m && D.attr({
                                "clip-path": "url(#gridRectMask".concat(C.globals.cuid, ")")
                            }), "none" !== C.config.states.normal.filter.type ? k.getDefaultFilter(D, n) : C.config.chart.dropShadow.enabled && w && (!C.config.chart.dropShadow.enabledOnSeries || C.config.chart.dropShadow.enabledOnSeries && -1 !== C.config.chart.dropShadow.enabledOnSeries.indexOf(n)) && k.dropShadow(D, C.config.chart.dropShadow, n), y && (D.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, D)), D.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, D)), D.node.addEventListener("mousedown", this.pathMouseDown.bind(this, D))), D.attr({
                                pathTo: r,
                                pathFrom: s
                            });
                            var I = {
                                el: D,
                                j: i,
                                realIndex: n,
                                pathFrom: s,
                                pathTo: r,
                                fill: c,
                                strokeWidth: o,
                                delay: u
                            };
                            return !A || C.globals.resized || C.globals.dataChanged ? !C.globals.resized && C.globals.dataChanged || S.showDelayedElements() : S.animatePathsGradually(h(h({}, I), {}, {
                                speed: d
                            })), C.globals.dataChanged && O && E && S.animatePathsGradually(h(h({}, I), {}, {
                                speed: p
                            })), D
                        }
                    }, {
                        key: "drawPattern",
                        value: function(t, e, i) {
                            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                                r = this.w,
                                a = r.globals.dom.Paper.pattern(e, i, function(r) {
                                    "horizontalLines" === t ? r.line(0, 0, i, 0).stroke({
                                        color: n,
                                        width: s + 1
                                    }) : "verticalLines" === t ? r.line(0, 0, 0, e).stroke({
                                        color: n,
                                        width: s + 1
                                    }) : "slantedLines" === t ? r.line(0, 0, e, i).stroke({
                                        color: n,
                                        width: s
                                    }) : "squares" === t ? r.rect(e, i).fill("none").stroke({
                                        color: n,
                                        width: s
                                    }) : "circles" === t && r.circle(e).fill("none").stroke({
                                        color: n,
                                        width: s
                                    })
                                });
                            return a
                        }
                    }, {
                        key: "drawGradient",
                        value: function(t, e, i, n, s) {
                            var r, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                                h = this.w;
                            e.length < 9 && 0 === e.indexOf("#") && (e = y.hexToRgba(e, n)), i.length < 9 && 0 === i.indexOf("#") && (i = y.hexToRgba(i, s));
                            var u = 0,
                                d = 1,
                                p = 1,
                                f = null;
                            null !== o && (u = void 0 !== o[0] ? o[0] / 100 : 0, d = void 0 !== o[1] ? o[1] / 100 : 1, p = void 0 !== o[2] ? o[2] / 100 : 1, f = void 0 !== o[3] ? o[3] / 100 : null);
                            var g = !("donut" !== h.config.chart.type && "pie" !== h.config.chart.type && "polarArea" !== h.config.chart.type && "bubble" !== h.config.chart.type);
                            if (r = h.globals.dom.Paper.gradient(g ? "radial" : "linear", null === l || 0 === l.length ? function(t) {
                                    t.at(u, e, n), t.at(d, i, s), t.at(p, i, s), null !== f && t.at(f, e, n)
                                } : function(t) {
                                    (Array.isArray(l[c]) ? l[c] : l).forEach(function(e) {
                                        t.at(e.offset / 100, e.color, e.opacity)
                                    })
                                }), g) {
                                var m = h.globals.gridWidth / 2,
                                    b = h.globals.gridHeight / 2;
                                r.attr("bubble" !== h.config.chart.type ? {
                                    gradientUnits: "userSpaceOnUse",
                                    cx: m,
                                    cy: b,
                                    r: a
                                } : {
                                    cx: .5,
                                    cy: .5,
                                    r: .8,
                                    fx: .2,
                                    fy: .2
                                })
                            } else "vertical" === t ? r.from(0, 0).to(0, 1) : "diagonal" === t ? r.from(0, 0).to(1, 1) : "horizontal" === t ? r.from(0, 1).to(1, 1) : "diagonal2" === t && r.from(1, 0).to(0, 1);
                            return r
                        }
                    }, {
                        key: "drawText",
                        value: function(t) {
                            var e, i = t.x,
                                n = t.y,
                                s = t.text,
                                r = t.textAnchor,
                                a = t.fontSize,
                                o = t.fontFamily,
                                l = t.fontWeight,
                                c = t.foreColor,
                                h = t.opacity,
                                u = t.cssClass,
                                d = void 0 === u ? "" : u,
                                p = t.isPlainText,
                                f = void 0 === p || p,
                                g = this.w;
                            return void 0 === s && (s = ""), r || (r = "start"), c && c.length || (c = g.config.chart.foreColor), o = o || g.config.chart.fontFamily, l = l || "regular", (e = Array.isArray(s) ? g.globals.dom.Paper.text(function(t) {
                                for (var e = 0; e < s.length; e++) 0 === e ? t.tspan(s[e]) : t.tspan(s[e]).newLine()
                            }) : f ? g.globals.dom.Paper.plain(s) : g.globals.dom.Paper.text(function(t) {
                                return t.tspan(s)
                            })).attr({
                                x: i,
                                y: n,
                                "text-anchor": r,
                                "dominant-baseline": "auto",
                                "font-size": a,
                                "font-family": o,
                                "font-weight": l,
                                fill: c,
                                class: "apexcharts-text " + d
                            }), e.node.style.fontFamily = o, e.node.style.opacity = h, e
                        }
                    }, {
                        key: "drawMarker",
                        value: function(t, e, i) {
                            t = t || 0;
                            var n = i.pSize || 0,
                                s = null;
                            if ("square" === i.shape || "rect" === i.shape) {
                                var r = void 0 === i.pRadius ? n / 2 : i.pRadius;
                                null !== e && n || (n = 0, r = 0);
                                var a = 1.2 * n + r,
                                    o = this.drawRect(a, a, a, a, r);
                                o.attr({
                                    x: t - a / 2,
                                    y: e - a / 2,
                                    cx: t,
                                    cy: e,
                                    class: i.class ? i.class : "",
                                    fill: i.pointFillColor,
                                    "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                    stroke: i.pointStrokeColor,
                                    "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                    "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                                }), s = o
                            } else "circle" !== i.shape && i.shape || (y.isNumber(e) || (n = 0, e = 0), s = this.drawCircle(n, {
                                cx: t,
                                cy: e,
                                class: i.class ? i.class : "",
                                stroke: i.pointStrokeColor,
                                fill: i.pointFillColor,
                                "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                            }));
                            return s
                        }
                    }, {
                        key: "pathMouseEnter",
                        value: function(t, e) {
                            var i = this.w,
                                n = new x(this.ctx),
                                s = parseInt(t.node.getAttribute("index"), 10),
                                r = parseInt(t.node.getAttribute("j"), 10);
                            if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
                                    seriesIndex: s,
                                    dataPointIndex: r,
                                    w: i
                                }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
                                    seriesIndex: s,
                                    dataPointIndex: r,
                                    w: i
                                }]), ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && "none" !== i.config.states.active.filter.type && !i.globals.isTouchDevice) {
                                var a = i.config.states.hover.filter;
                                n.applyFilter(t, s, a.type, a.value)
                            }
                        }
                    }, {
                        key: "pathMouseLeave",
                        value: function(t, e) {
                            var i = this.w,
                                n = new x(this.ctx),
                                s = parseInt(t.node.getAttribute("index"), 10),
                                r = parseInt(t.node.getAttribute("j"), 10);
                            "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
                                seriesIndex: s,
                                dataPointIndex: r,
                                w: i
                            }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
                                seriesIndex: s,
                                dataPointIndex: r,
                                w: i
                            }]), "none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && n.getDefaultFilter(t, s)
                        }
                    }, {
                        key: "pathMouseDown",
                        value: function(t, e) {
                            var i = this.w,
                                n = new x(this.ctx),
                                s = parseInt(t.node.getAttribute("index"), 10),
                                r = parseInt(t.node.getAttribute("j"), 10),
                                a = "false";
                            if ("true" === t.node.getAttribute("selected")) {
                                if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s].indexOf(r) > -1) {
                                    var o = i.globals.selectedDataPoints[s].indexOf(r);
                                    i.globals.selectedDataPoints[s].splice(o, 1)
                                }
                            } else {
                                if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
                                    i.globals.selectedDataPoints = [];
                                    var l = i.globals.dom.Paper.select(".apexcharts-series path").members,
                                        c = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                                        h = function(t) {
                                            Array.prototype.forEach.call(t, function(t) {
                                                t.node.setAttribute("selected", "false"), n.getDefaultFilter(t, s)
                                            })
                                        };
                                    h(l), h(c)
                                }
                                t.node.setAttribute("selected", "true"), a = "true", void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(r)
                            }
                            if ("true" === a) {
                                var u = i.config.states.active.filter;
                                "none" !== u && n.applyFilter(t, s, u.type, u.value)
                            } else "none" !== i.config.states.active.filter.type && n.getDefaultFilter(t, s);
                            "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, {
                                selectedDataPoints: i.globals.selectedDataPoints,
                                seriesIndex: s,
                                dataPointIndex: r,
                                w: i
                            }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
                                selectedDataPoints: i.globals.selectedDataPoints,
                                seriesIndex: s,
                                dataPointIndex: r,
                                w: i
                            }])
                        }
                    }, {
                        key: "rotateAroundCenter",
                        value: function(t) {
                            var e = t.getBBox();
                            return {
                                x: e.x + e.width / 2,
                                y: e.y + e.height / 2
                            }
                        }
                    }, {
                        key: "getTextRects",
                        value: function(t, e, i, n) {
                            var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                r = this.w,
                                a = this.drawText({
                                    x: -200,
                                    y: -200,
                                    text: t,
                                    textAnchor: "start",
                                    fontSize: e,
                                    fontFamily: i,
                                    foreColor: "#fff",
                                    opacity: 0
                                });
                            n && a.attr("transform", n), r.globals.dom.Paper.add(a);
                            var o = a.bbox();
                            return s || (o = a.node.getBoundingClientRect()), a.remove(), {
                                width: o.width,
                                height: o.height
                            }
                        }
                    }, {
                        key: "placeTextWithEllipsis",
                        value: function(t, e, i) {
                            if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
                                for (var n = e.length - 3; n > 0; n -= 3)
                                    if (t.getSubStringLength(0, n) <= i / 1.1) return void(t.textContent = e.substring(0, n) + "...");
                                t.textContent = "."
                            }
                        }
                    }], [{
                        key: "setAttrs",
                        value: function(t, e) {
                            for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                        }
                    }]), t
                }(),
                w = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.annoCtx = e
                    }
                    return o(t, [{
                        key: "setOrientations",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                i = this.w;
                            if ("vertical" === t.label.orientation) {
                                var n = null !== e ? e : 0,
                                    s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(n, "']"));
                                if (null !== s) {
                                    var r = s.getBoundingClientRect();
                                    s.setAttribute("x", parseFloat(s.getAttribute("x")) - r.height + 4), s.setAttribute("y", "top" === t.label.position ? parseFloat(s.getAttribute("y")) + r.width : parseFloat(s.getAttribute("y")) - r.width);
                                    var a = this.annoCtx.graphics.rotateAroundCenter(s),
                                        o = a.x,
                                        l = a.y;
                                    s.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"))
                                }
                            }
                        }
                    }, {
                        key: "addBackgroundToAnno",
                        value: function(t, e) {
                            var i = this.w;
                            if (!t || !e.label.text || e.label.text && !e.label.text.trim()) return null;
                            var n = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
                                s = t.getBoundingClientRect(),
                                r = e.label.style.padding.left,
                                a = e.label.style.padding.right,
                                o = e.label.style.padding.top,
                                l = e.label.style.padding.bottom;
                            "vertical" === e.label.orientation && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, a = e.label.style.padding.bottom);
                            var c = this.annoCtx.graphics.drawRect(s.left - n.left - r - i.globals.barPadForNumericAxis, s.top - n.top - o, s.width + r + a, s.height + o + l, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
                            return e.id && c.node.classList.add(e.id), c
                        }
                    }, {
                        key: "annotationsBackground",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = function(i, n, s) {
                                    var r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(n, "']"));
                                    if (r) {
                                        var a = r.parentNode,
                                            o = t.addBackgroundToAnno(r, i);
                                        o && a.insertBefore(o.node, r)
                                    }
                                };
                            e.config.annotations.xaxis.map(function(t, e) {
                                i(t, e, "xaxis")
                            }), e.config.annotations.yaxis.map(function(t, e) {
                                i(t, e, "yaxis")
                            }), e.config.annotations.points.map(function(t, e) {
                                i(t, e, "point")
                            })
                        }
                    }, {
                        key: "getStringX",
                        value: function(t) {
                            var e = this.w,
                                i = t;
                            e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
                            var n = e.globals.labels.indexOf(t),
                                s = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (n + 1) + ")");
                            return s && (i = parseFloat(s.getAttribute("x"))), i
                        }
                    }]), t
                }(),
                C = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis
                    }
                    return o(t, [{
                        key: "addXaxisAnnotation",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = this.invertAxis ? n.globals.minY : n.globals.minX,
                                r = this.invertAxis ? n.globals.maxY : n.globals.maxX,
                                a = this.invertAxis ? n.globals.yRange[0] : n.globals.xRange,
                                o = (t.x - s) / (a / n.globals.gridWidth);
                            this.annoCtx.inversedReversedAxis && (o = (r - t.x) / (a / n.globals.gridWidth));
                            var l = t.label.text;
                            "category" !== n.config.xaxis.type && !n.config.xaxis.convertedCatToNumeric || this.invertAxis || n.globals.dataFormatXNumeric || (o = this.annoCtx.helpers.getStringX(t.x));
                            var c = t.strokeDashArray;
                            if (y.isNumber(o)) {
                                if (null == t.x2) {
                                    var h = this.annoCtx.graphics.drawLine(o + t.offsetX, 0 + t.offsetY, o + t.offsetX, n.globals.gridHeight + t.offsetY, t.borderColor, c, t.borderWidth);
                                    e.appendChild(h.node), t.id && h.node.classList.add(t.id)
                                } else {
                                    var u = (t.x2 - s) / (a / n.globals.gridWidth);
                                    if (this.annoCtx.inversedReversedAxis && (u = (r - t.x2) / (a / n.globals.gridWidth)), "category" !== n.config.xaxis.type && !n.config.xaxis.convertedCatToNumeric || this.invertAxis || n.globals.dataFormatXNumeric || (u = this.annoCtx.helpers.getStringX(t.x2)), u < o) {
                                        var d = o;
                                        o = u, u = d
                                    }
                                    var p = this.annoCtx.graphics.drawRect(o + t.offsetX, 0 + t.offsetY, u - o, n.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, c);
                                    p.node.classList.add("apexcharts-annotation-rect"), p.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")")), e.appendChild(p.node), t.id && p.node.classList.add(t.id)
                                }
                                var f = "top" === t.label.position ? 4 : n.globals.gridHeight,
                                    g = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)),
                                    m = this.annoCtx.graphics.drawText({
                                        x: o + t.label.offsetX,
                                        y: f + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? g.width / 2 - 12 : -g.width / 2 : 0),
                                        text: l,
                                        textAnchor: t.label.textAnchor,
                                        fontSize: t.label.style.fontSize,
                                        fontFamily: t.label.style.fontFamily,
                                        fontWeight: t.label.style.fontWeight,
                                        foreColor: t.label.style.color,
                                        cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                    });
                                m.attr({
                                    rel: i
                                }), e.appendChild(m.node), this.annoCtx.helpers.setOrientations(t, i)
                            }
                        }
                    }, {
                        key: "drawXAxisAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-xaxis-annotations"
                                });
                            return e.config.annotations.xaxis.map(function(e, n) {
                                t.addXaxisAnnotation(e, i.node, n)
                            }), i
                        }
                    }]), t
                }(),
                k = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "getStackedSeriesTotals",
                        value: function() {
                            var t = this.w,
                                e = [];
                            if (0 === t.globals.series.length) return e;
                            for (var i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) {
                                for (var n = 0, s = 0; s < t.globals.series.length; s++) void 0 !== t.globals.series[s][i] && (n += t.globals.series[s][i]);
                                e.push(n)
                            }
                            return t.globals.stackedSeriesTotals = e, e
                        }
                    }, {
                        key: "getSeriesTotalByIndex",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            return null === t ? this.w.config.series.reduce(function(t, e) {
                                return t + e
                            }, 0) : this.w.globals.series[t].reduce(function(t, e) {
                                return t + e
                            }, 0)
                        }
                    }, {
                        key: "isSeriesNull",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            return 0 === (null === t ? this.w.config.series.filter(function(t) {
                                return null !== t
                            }) : this.w.config.series[t].data.filter(function(t) {
                                return null !== t
                            })).length
                        }
                    }, {
                        key: "seriesHaveSameValues",
                        value: function(t) {
                            return this.w.globals.series[t].every(function(t, e, i) {
                                return t === i[0]
                            })
                        }
                    }, {
                        key: "getCategoryLabels",
                        value: function(t) {
                            var e = this.w,
                                i = t.slice();
                            return e.config.xaxis.convertedCatToNumeric && (i = t.map(function(t, i) {
                                return e.config.xaxis.labels.formatter(t - e.globals.minX + 1)
                            })), i
                        }
                    }, {
                        key: "getLargestSeries",
                        value: function() {
                            var t = this.w;
                            t.globals.maxValsInArrayIndex = t.globals.series.map(function(t) {
                                return t.length
                            }).indexOf(Math.max.apply(Math, t.globals.series.map(function(t) {
                                return t.length
                            })))
                        }
                    }, {
                        key: "getLargestMarkerSize",
                        value: function() {
                            var t = this.w,
                                e = 0;
                            return t.globals.markers.size.forEach(function(t) {
                                e = Math.max(e, t)
                            }), t.globals.markers.largestSize = e, e
                        }
                    }, {
                        key: "getSeriesTotals",
                        value: function() {
                            var t = this.w;
                            t.globals.seriesTotals = t.globals.series.map(function(t, e) {
                                var i = 0;
                                if (Array.isArray(t))
                                    for (var n = 0; n < t.length; n++) i += t[n];
                                else i += t;
                                return i
                            })
                        }
                    }, {
                        key: "getSeriesTotalsXRange",
                        value: function(t, e) {
                            var i = this.w;
                            return i.globals.series.map(function(n, s) {
                                for (var r = 0, a = 0; a < n.length; a++) i.globals.seriesX[s][a] > t && i.globals.seriesX[s][a] < e && (r += n[a]);
                                return r
                            })
                        }
                    }, {
                        key: "getPercentSeries",
                        value: function() {
                            var t = this.w;
                            t.globals.seriesPercent = t.globals.series.map(function(e, i) {
                                var n = [];
                                if (Array.isArray(e))
                                    for (var s = 0; s < e.length; s++) {
                                        var r = t.globals.stackedSeriesTotals[s],
                                            a = 0;
                                        r && (a = 100 * e[s] / r), n.push(a)
                                    } else {
                                        var o = 100 * e / t.globals.seriesTotals.reduce(function(t, e) {
                                            return t + e
                                        }, 0);
                                        n.push(o)
                                    }
                                return n
                            })
                        }
                    }, {
                        key: "getCalculatedRatios",
                        value: function() {
                            var t, e, i, n, s = this.w.globals,
                                r = [],
                                a = 0,
                                o = [],
                                l = .1,
                                c = 0;
                            if (s.yRange = [], s.isMultipleYAxis)
                                for (var h = 0; h < s.minYArr.length; h++) s.yRange.push(Math.abs(s.minYArr[h] - s.maxYArr[h])), o.push(0);
                            else s.yRange.push(Math.abs(s.minY - s.maxY));
                            s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ);
                            for (var u = 0; u < s.yRange.length; u++) r.push(s.yRange[u] / s.gridHeight);
                            if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, n = s.xRange / s.gridHeight, (a = s.zRange / s.gridHeight * 16) || (a = 1), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0), s.isMultipleYAxis) {
                                o = [];
                                for (var d = 0; d < r.length; d++) o.push(-s.minYArr[d] / r[d])
                            } else o.push(-s.minY / r[0]), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (l = -s.minY / t, c = s.minX / e);
                            return {
                                yRatio: r,
                                invertedYRatio: t,
                                zRatio: a,
                                xRatio: e,
                                initialXRatio: i,
                                invertedXRatio: n,
                                baseLineInvertedY: l,
                                baseLineY: o,
                                baseLineX: c
                            }
                        }
                    }, {
                        key: "getLogSeries",
                        value: function(t) {
                            var e = this,
                                i = this.w;
                            return i.globals.seriesLog = t.map(function(t, n) {
                                return i.config.yaxis[n] && i.config.yaxis[n].logarithmic ? t.map(function(t) {
                                    return null === t ? null : e.getLogVal(t, n)
                                }) : t
                            }), i.globals.invalidLogScale ? t : i.globals.seriesLog
                        }
                    }, {
                        key: "getLogVal",
                        value: function(t, e) {
                            var i = this.w;
                            return (Math.log(t) - Math.log(i.globals.minYArr[e])) / (Math.log(i.globals.maxYArr[e]) - Math.log(i.globals.minYArr[e]))
                        }
                    }, {
                        key: "getLogYRatios",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = this.w.globals;
                            return n.yLogRatio = t.slice(), n.logYRange = n.yRange.map(function(t, s) {
                                if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) {
                                    var r, a = -Number.MAX_VALUE,
                                        o = Number.MIN_VALUE;
                                    return n.seriesLog.forEach(function(t, e) {
                                        t.forEach(function(t) {
                                            i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (a = Math.max(t, a), o = Math.min(t, o))
                                        })
                                    }), r = Math.pow(n.yRange[s], Math.abs(o - a) / n.yRange[s]), n.yLogRatio[s] = r / n.gridHeight, r
                                }
                            }), n.invalidLogScale ? t.slice() : n.yLogRatio
                        }
                    }], [{
                        key: "checkComboSeries",
                        value: function(t) {
                            var e = !1,
                                i = 0,
                                n = 0;
                            return t.length && void 0 !== t[0].type && t.forEach(function(t) {
                                "bar" !== t.type && "column" !== t.type && "candlestick" !== t.type && "boxPlot" !== t.type || i++, void 0 !== t.type && n++
                            }), n > 1 && (e = !0), {
                                comboBarCount: i,
                                comboCharts: e
                            }
                        }
                    }, {
                        key: "extendArrayProps",
                        value: function(t, e, i) {
                            return e.yaxis && (e = t.extendYAxis(e, i)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e
                        }
                    }]), t
                }(),
                S = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.annoCtx = e
                    }
                    return o(t, [{
                        key: "addYaxisAnnotation",
                        value: function(t, e, i) {
                            var n, s = this.w,
                                r = t.strokeDashArray,
                                a = this._getY1Y2("y1", t),
                                o = t.label.text;
                            if (null == t.y2) {
                                var l = this.annoCtx.graphics.drawLine(0 + t.offsetX, a + t.offsetY, this._getYAxisAnnotationWidth(t), a + t.offsetY, t.borderColor, r, t.borderWidth);
                                e.appendChild(l.node), t.id && l.node.classList.add(t.id)
                            } else {
                                if ((n = this._getY1Y2("y2", t)) > a) {
                                    var c = a;
                                    a = n, n = c
                                }
                                var h = this.annoCtx.graphics.drawRect(0 + t.offsetX, n + t.offsetY, this._getYAxisAnnotationWidth(t), a - n, 0, t.fillColor, t.opacity, 1, t.borderColor, r);
                                h.node.classList.add("apexcharts-annotation-rect"), h.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), e.appendChild(h.node), t.id && h.node.classList.add(t.id)
                            }
                            var u = this.annoCtx.graphics.drawText({
                                x: ("right" === t.label.position ? s.globals.gridWidth : 0) + t.label.offsetX,
                                y: (n || a) + t.label.offsetY - 3,
                                text: o,
                                textAnchor: t.label.textAnchor,
                                fontSize: t.label.style.fontSize,
                                fontFamily: t.label.style.fontFamily,
                                fontWeight: t.label.style.fontWeight,
                                foreColor: t.label.style.color,
                                cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                            });
                            u.attr({
                                rel: i
                            }), e.appendChild(u.node)
                        }
                    }, {
                        key: "_getY1Y2",
                        value: function(t, e) {
                            var i, n = "y1" === t ? e.y : e.y2,
                                s = this.w;
                            if (this.annoCtx.invertAxis) {
                                var r = s.globals.labels.indexOf(n);
                                s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(n));
                                var a = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
                                a && (i = parseFloat(a.getAttribute("y")))
                            } else {
                                var o;
                                o = s.config.yaxis[e.yAxisIndex].logarithmic ? (n = new k(this.annoCtx.ctx).getLogVal(n, e.yAxisIndex)) / s.globals.yLogRatio[e.yAxisIndex] : (n - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight), i = s.globals.gridHeight - o, s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = o)
                            }
                            return i
                        }
                    }, {
                        key: "_getYAxisAnnotationWidth",
                        value: function(t) {
                            var e = this.w;
                            return (t.width.indexOf("%") > -1 ? e.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX
                        }
                    }, {
                        key: "drawYAxisAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-yaxis-annotations"
                                });
                            return e.config.annotations.yaxis.map(function(e, n) {
                                t.addYaxisAnnotation(e, i.node, n)
                            }), i
                        }
                    }]), t
                }(),
                A = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.annoCtx = e
                    }
                    return o(t, [{
                        key: "addPointAnnotation",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = 0,
                                r = 0,
                                a = 0;
                            this.annoCtx.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts.");
                            var o, l = parseFloat(t.y);
                            if ("string" == typeof t.x) {
                                var c = n.globals.labels.indexOf(t.x);
                                n.config.xaxis.convertedCatToNumeric && (c = n.globals.categoryLabels.indexOf(t.x)), s = this.annoCtx.helpers.getStringX(t.x), null === t.y && (l = n.globals.series[t.seriesIndex][c])
                            } else s = (t.x - n.globals.minX) / (n.globals.xRange / n.globals.gridWidth);
                            if (o = n.config.yaxis[t.yAxisIndex].logarithmic ? (l = new k(this.annoCtx.ctx).getLogVal(l, t.yAxisIndex)) / n.globals.yLogRatio[t.yAxisIndex] : (l - n.globals.minYArr[t.yAxisIndex]) / (n.globals.yRange[t.yAxisIndex] / n.globals.gridHeight), r = n.globals.gridHeight - o - parseFloat(t.label.style.fontSize) - t.marker.size, a = n.globals.gridHeight - o, n.config.yaxis[t.yAxisIndex] && n.config.yaxis[t.yAxisIndex].reversed && (r = o + parseFloat(t.label.style.fontSize) + t.marker.size, a = o), y.isNumber(s)) {
                                var h = {
                                        pSize: t.marker.size,
                                        pointStrokeWidth: t.marker.strokeWidth,
                                        pointFillColor: t.marker.fillColor,
                                        pointStrokeColor: t.marker.strokeColor,
                                        shape: t.marker.shape,
                                        pRadius: t.marker.radius,
                                        class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
                                    },
                                    u = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, a + t.marker.offsetY, h);
                                e.appendChild(u.node);
                                var d = this.annoCtx.graphics.drawText({
                                    x: s + t.label.offsetX,
                                    y: r + t.label.offsetY,
                                    text: t.label.text ? t.label.text : "",
                                    textAnchor: t.label.textAnchor,
                                    fontSize: t.label.style.fontSize,
                                    fontFamily: t.label.style.fontFamily,
                                    fontWeight: t.label.style.fontWeight,
                                    foreColor: t.label.style.color,
                                    cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                });
                                if (d.attr({
                                        rel: i
                                    }), e.appendChild(d.node), t.customSVG.SVG) {
                                    var p = this.annoCtx.graphics.group({
                                        class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass
                                    });
                                    p.attr({
                                        transform: "translate(".concat(s + t.customSVG.offsetX, ", ").concat(r + t.customSVG.offsetY, ")")
                                    }), p.node.innerHTML = t.customSVG.SVG, e.appendChild(p.node)
                                }
                                if (t.image.path) {
                                    var f = t.image.width ? t.image.width : 20,
                                        g = t.image.height ? t.image.height : 20;
                                    this.annoCtx.addImage({
                                        x: s + t.image.offsetX - f / 2,
                                        y: r + t.image.offsetY - g / 2,
                                        width: f,
                                        height: g,
                                        path: t.image.path,
                                        appendTo: ".apexcharts-point-annotations"
                                    })
                                }
                            }
                        }
                    }, {
                        key: "drawPointAnnotations",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.annoCtx.graphics.group({
                                    class: "apexcharts-point-annotations"
                                });
                            return e.config.annotations.points.map(function(e, n) {
                                t.addPointAnnotation(e, i.node, n)
                            }), i
                        }
                    }]), t
                }(),
                O = {
                    name: "en",
                    options: {
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        toolbar: {
                            exportToSVG: "Download SVG",
                            exportToPNG: "Download PNG",
                            exportToCSV: "Download CSV",
                            menu: "Menu",
                            selection: "Selection",
                            selectionZoom: "Selection Zoom",
                            zoomIn: "Zoom In",
                            zoomOut: "Zoom Out",
                            pan: "Panning",
                            reset: "Reset Zoom"
                        }
                    }
                },
                E = function() {
                    function t() {
                        r(this, t), this.yAxis = {
                            show: !0,
                            showAlways: !1,
                            showForNullSeries: !0,
                            seriesName: void 0,
                            opposite: !1,
                            reversed: !1,
                            logarithmic: !1,
                            tickAmount: void 0,
                            forceNiceScale: !1,
                            max: void 0,
                            min: void 0,
                            floating: !1,
                            decimalsInFloat: void 0,
                            labels: {
                                show: !0,
                                minWidth: 0,
                                maxWidth: 160,
                                offsetX: 0,
                                offsetY: 0,
                                align: void 0,
                                rotate: 0,
                                padding: 20,
                                style: {
                                    colors: [],
                                    fontSize: "11px",
                                    fontWeight: 400,
                                    fontFamily: void 0,
                                    cssClass: ""
                                },
                                formatter: void 0
                            },
                            axisBorder: {
                                show: !1,
                                color: "#e0e0e0",
                                width: 1,
                                offsetX: 0,
                                offsetY: 0
                            },
                            axisTicks: {
                                show: !1,
                                color: "#e0e0e0",
                                width: 6,
                                offsetX: 0,
                                offsetY: 0
                            },
                            title: {
                                text: void 0,
                                rotate: -90,
                                offsetY: 0,
                                offsetX: 0,
                                style: {
                                    color: void 0,
                                    fontSize: "11px",
                                    fontWeight: 900,
                                    fontFamily: void 0,
                                    cssClass: ""
                                }
                            },
                            tooltip: {
                                enabled: !1,
                                offsetX: 0
                            },
                            crosshairs: {
                                show: !0,
                                position: "front",
                                stroke: {
                                    color: "#b6b6b6",
                                    width: 1,
                                    dashArray: 0
                                }
                            }
                        }, this.pointAnnotation = {
                            x: 0,
                            y: null,
                            yAxisIndex: 0,
                            seriesIndex: 0,
                            marker: {
                                size: 4,
                                fillColor: "#fff",
                                strokeWidth: 2,
                                strokeColor: "#333",
                                shape: "circle",
                                offsetX: 0,
                                offsetY: 0,
                                radius: 2,
                                cssClass: ""
                            },
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "middle",
                                offsetX: 0,
                                offsetY: 0,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            },
                            customSVG: {
                                SVG: void 0,
                                cssClass: void 0,
                                offsetX: 0,
                                offsetY: 0
                            },
                            image: {
                                path: void 0,
                                width: 20,
                                height: 20,
                                offsetX: 0,
                                offsetY: 0
                            }
                        }, this.yAxisAnnotation = {
                            y: 0,
                            y2: null,
                            strokeDashArray: 1,
                            fillColor: "#c2c2c2",
                            borderColor: "#c2c2c2",
                            borderWidth: 1,
                            opacity: .3,
                            offsetX: 0,
                            offsetY: 0,
                            width: "100%",
                            yAxisIndex: 0,
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "end",
                                position: "right",
                                offsetX: 0,
                                offsetY: -3,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            }
                        }, this.xAxisAnnotation = {
                            x: 0,
                            x2: null,
                            strokeDashArray: 1,
                            fillColor: "#c2c2c2",
                            borderColor: "#c2c2c2",
                            borderWidth: 1,
                            opacity: .3,
                            offsetX: 0,
                            offsetY: 0,
                            label: {
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                borderRadius: 2,
                                text: void 0,
                                textAnchor: "middle",
                                orientation: "vertical",
                                position: "top",
                                offsetX: 0,
                                offsetY: 0,
                                style: {
                                    background: "#fff",
                                    color: void 0,
                                    fontSize: "11px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    cssClass: "",
                                    padding: {
                                        left: 5,
                                        right: 5,
                                        top: 2,
                                        bottom: 2
                                    }
                                }
                            }
                        }, this.text = {
                            x: 0,
                            y: 0,
                            text: "",
                            textAnchor: "start",
                            foreColor: void 0,
                            fontSize: "13px",
                            fontFamily: void 0,
                            fontWeight: 400,
                            appendTo: ".apexcharts-annotations",
                            backgroundColor: "transparent",
                            borderColor: "#c2c2c2",
                            borderRadius: 0,
                            borderWidth: 0,
                            paddingLeft: 4,
                            paddingRight: 4,
                            paddingTop: 2,
                            paddingBottom: 2
                        }
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            return {
                                annotations: {
                                    position: "front",
                                    yaxis: [this.yAxisAnnotation],
                                    xaxis: [this.xAxisAnnotation],
                                    points: [this.pointAnnotation],
                                    texts: [],
                                    images: [],
                                    shapes: []
                                },
                                chart: {
                                    animations: {
                                        enabled: !0,
                                        easing: "easeinout",
                                        speed: 800,
                                        animateGradually: {
                                            delay: 150,
                                            enabled: !0
                                        },
                                        dynamicAnimation: {
                                            enabled: !0,
                                            speed: 350
                                        }
                                    },
                                    background: "transparent",
                                    locales: [O],
                                    defaultLocale: "en",
                                    dropShadow: {
                                        enabled: !1,
                                        enabledOnSeries: void 0,
                                        top: 2,
                                        left: 2,
                                        blur: 4,
                                        color: "#000",
                                        opacity: .35
                                    },
                                    events: {
                                        animationEnd: void 0,
                                        beforeMount: void 0,
                                        mounted: void 0,
                                        updated: void 0,
                                        click: void 0,
                                        mouseMove: void 0,
                                        legendClick: void 0,
                                        markerClick: void 0,
                                        selection: void 0,
                                        dataPointSelection: void 0,
                                        dataPointMouseEnter: void 0,
                                        dataPointMouseLeave: void 0,
                                        beforeZoom: void 0,
                                        beforeResetZoom: void 0,
                                        zoomed: void 0,
                                        scrolled: void 0,
                                        brushScrolled: void 0
                                    },
                                    foreColor: "#373d3f",
                                    fontFamily: "Helvetica, Arial, sans-serif",
                                    height: "auto",
                                    parentHeightOffset: 15,
                                    redrawOnParentResize: !0,
                                    redrawOnWindowResize: !0,
                                    id: void 0,
                                    group: void 0,
                                    offsetX: 0,
                                    offsetY: 0,
                                    selection: {
                                        enabled: !1,
                                        type: "x",
                                        fill: {
                                            color: "#24292e",
                                            opacity: .1
                                        },
                                        stroke: {
                                            width: 1,
                                            color: "#24292e",
                                            opacity: .4,
                                            dashArray: 3
                                        },
                                        xaxis: {
                                            min: void 0,
                                            max: void 0
                                        },
                                        yaxis: {
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    sparkline: {
                                        enabled: !1
                                    },
                                    brush: {
                                        enabled: !1,
                                        autoScaleYaxis: !0,
                                        target: void 0
                                    },
                                    stacked: !1,
                                    stackType: "normal",
                                    toolbar: {
                                        show: !0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        tools: {
                                            download: !0,
                                            selection: !0,
                                            zoom: !0,
                                            zoomin: !0,
                                            zoomout: !0,
                                            pan: !0,
                                            reset: !0,
                                            customIcons: []
                                        },
                                        export: {
                                            csv: {
                                                filename: void 0,
                                                columnDelimiter: ",",
                                                headerCategory: "category",
                                                headerValue: "value",
                                                dateFormatter: function(t) {
                                                    return new Date(t).toDateString()
                                                }
                                            },
                                            png: {
                                                filename: void 0
                                            },
                                            svg: {
                                                filename: void 0
                                            }
                                        },
                                        autoSelected: "zoom"
                                    },
                                    type: "line",
                                    width: "100%",
                                    zoom: {
                                        enabled: !0,
                                        type: "x",
                                        autoScaleYaxis: !1,
                                        zoomedArea: {
                                            fill: {
                                                color: "#90CAF9",
                                                opacity: .4
                                            },
                                            stroke: {
                                                color: "#0D47A1",
                                                opacity: .4,
                                                width: 1
                                            }
                                        }
                                    }
                                },
                                plotOptions: {
                                    area: {
                                        fillTo: "origin"
                                    },
                                    bar: {
                                        horizontal: !1,
                                        columnWidth: "70%",
                                        barHeight: "70%",
                                        distributed: !1,
                                        borderRadius: 0,
                                        rangeBarOverlap: !0,
                                        rangeBarGroupRows: !1,
                                        colors: {
                                            ranges: [],
                                            backgroundBarColors: [],
                                            backgroundBarOpacity: 1,
                                            backgroundBarRadius: 0
                                        },
                                        dataLabels: {
                                            position: "top",
                                            maxItems: 100,
                                            hideOverflowingLabels: !0,
                                            orientation: "horizontal"
                                        }
                                    },
                                    bubble: {
                                        minBubbleRadius: void 0,
                                        maxBubbleRadius: void 0
                                    },
                                    candlestick: {
                                        colors: {
                                            upward: "#00B746",
                                            downward: "#EF403C"
                                        },
                                        wick: {
                                            useFillColor: !0
                                        }
                                    },
                                    boxPlot: {
                                        colors: {
                                            upper: "#00E396",
                                            lower: "#008FFB"
                                        }
                                    },
                                    heatmap: {
                                        radius: 2,
                                        enableShades: !0,
                                        shadeIntensity: .5,
                                        reverseNegativeShade: !1,
                                        distributed: !1,
                                        useFillColorAsStroke: !1,
                                        colorScale: {
                                            inverse: !1,
                                            ranges: [],
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    treemap: {
                                        enableShades: !0,
                                        shadeIntensity: .5,
                                        distributed: !1,
                                        reverseNegativeShade: !1,
                                        useFillColorAsStroke: !1,
                                        colorScale: {
                                            inverse: !1,
                                            ranges: [],
                                            min: void 0,
                                            max: void 0
                                        }
                                    },
                                    radialBar: {
                                        inverseOrder: !1,
                                        startAngle: 0,
                                        endAngle: 360,
                                        offsetX: 0,
                                        offsetY: 0,
                                        hollow: {
                                            margin: 5,
                                            size: "50%",
                                            background: "transparent",
                                            image: void 0,
                                            imageWidth: 150,
                                            imageHeight: 150,
                                            imageOffsetX: 0,
                                            imageOffsetY: 0,
                                            imageClipped: !0,
                                            position: "front",
                                            dropShadow: {
                                                enabled: !1,
                                                top: 0,
                                                left: 0,
                                                blur: 3,
                                                color: "#000",
                                                opacity: .5
                                            }
                                        },
                                        track: {
                                            show: !0,
                                            startAngle: void 0,
                                            endAngle: void 0,
                                            background: "#f2f2f2",
                                            strokeWidth: "97%",
                                            opacity: 1,
                                            margin: 5,
                                            dropShadow: {
                                                enabled: !1,
                                                top: 0,
                                                left: 0,
                                                blur: 3,
                                                color: "#000",
                                                opacity: .5
                                            }
                                        },
                                        dataLabels: {
                                            show: !0,
                                            name: {
                                                show: !0,
                                                fontSize: "16px",
                                                fontFamily: void 0,
                                                fontWeight: 600,
                                                color: void 0,
                                                offsetY: 0,
                                                formatter: function(t) {
                                                    return t
                                                }
                                            },
                                            value: {
                                                show: !0,
                                                fontSize: "14px",
                                                fontFamily: void 0,
                                                fontWeight: 400,
                                                color: void 0,
                                                offsetY: 16,
                                                formatter: function(t) {
                                                    return t + "%"
                                                }
                                            },
                                            total: {
                                                show: !1,
                                                label: "Total",
                                                fontSize: "16px",
                                                fontWeight: 600,
                                                fontFamily: void 0,
                                                color: void 0,
                                                formatter: function(t) {
                                                    return t.globals.seriesTotals.reduce(function(t, e) {
                                                        return t + e
                                                    }, 0) / t.globals.series.length + "%"
                                                }
                                            }
                                        }
                                    },
                                    pie: {
                                        customScale: 1,
                                        offsetX: 0,
                                        offsetY: 0,
                                        startAngle: 0,
                                        endAngle: 360,
                                        expandOnClick: !0,
                                        dataLabels: {
                                            offset: 0,
                                            minAngleToShowLabel: 10
                                        },
                                        donut: {
                                            size: "65%",
                                            background: "transparent",
                                            labels: {
                                                show: !1,
                                                name: {
                                                    show: !0,
                                                    fontSize: "16px",
                                                    fontFamily: void 0,
                                                    fontWeight: 600,
                                                    color: void 0,
                                                    offsetY: -10,
                                                    formatter: function(t) {
                                                        return t
                                                    }
                                                },
                                                value: {
                                                    show: !0,
                                                    fontSize: "20px",
                                                    fontFamily: void 0,
                                                    fontWeight: 400,
                                                    color: void 0,
                                                    offsetY: 10,
                                                    formatter: function(t) {
                                                        return t
                                                    }
                                                },
                                                total: {
                                                    show: !1,
                                                    showAlways: !1,
                                                    label: "Total",
                                                    fontSize: "16px",
                                                    fontWeight: 400,
                                                    fontFamily: void 0,
                                                    color: void 0,
                                                    formatter: function(t) {
                                                        return t.globals.seriesTotals.reduce(function(t, e) {
                                                            return t + e
                                                        }, 0)
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    polarArea: {
                                        rings: {
                                            strokeWidth: 1,
                                            strokeColor: "#e8e8e8"
                                        },
                                        spokes: {
                                            strokeWidth: 1,
                                            connectorColors: "#e8e8e8"
                                        }
                                    },
                                    radar: {
                                        size: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        polygons: {
                                            strokeWidth: 1,
                                            strokeColors: "#e8e8e8",
                                            connectorColors: "#e8e8e8",
                                            fill: {
                                                colors: void 0
                                            }
                                        }
                                    }
                                },
                                colors: void 0,
                                dataLabels: {
                                    enabled: !0,
                                    enabledOnSeries: void 0,
                                    formatter: function(t) {
                                        return null !== t ? t : ""
                                    },
                                    textAnchor: "middle",
                                    distributed: !1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        fontSize: "12px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        colors: void 0
                                    },
                                    background: {
                                        enabled: !0,
                                        foreColor: "#fff",
                                        borderRadius: 2,
                                        padding: 4,
                                        opacity: .9,
                                        borderWidth: 1,
                                        borderColor: "#fff",
                                        dropShadow: {
                                            enabled: !1,
                                            top: 1,
                                            left: 1,
                                            blur: 1,
                                            color: "#000",
                                            opacity: .45
                                        }
                                    },
                                    dropShadow: {
                                        enabled: !1,
                                        top: 1,
                                        left: 1,
                                        blur: 1,
                                        color: "#000",
                                        opacity: .45
                                    }
                                },
                                fill: {
                                    type: "solid",
                                    colors: void 0,
                                    opacity: .85,
                                    gradient: {
                                        shade: "dark",
                                        type: "horizontal",
                                        shadeIntensity: .5,
                                        gradientToColors: void 0,
                                        inverseColors: !0,
                                        opacityFrom: 1,
                                        opacityTo: 1,
                                        stops: [0, 50, 100],
                                        colorStops: []
                                    },
                                    image: {
                                        src: [],
                                        width: void 0,
                                        height: void 0
                                    },
                                    pattern: {
                                        style: "squares",
                                        width: 6,
                                        height: 6,
                                        strokeWidth: 2
                                    }
                                },
                                grid: {
                                    show: !0,
                                    borderColor: "#e0e0e0",
                                    strokeDashArray: 0,
                                    position: "back",
                                    xaxis: {
                                        lines: {
                                            show: !1
                                        }
                                    },
                                    yaxis: {
                                        lines: {
                                            show: !0
                                        }
                                    },
                                    row: {
                                        colors: void 0,
                                        opacity: .5
                                    },
                                    column: {
                                        colors: void 0,
                                        opacity: .5
                                    },
                                    padding: {
                                        top: 0,
                                        right: 10,
                                        bottom: 0,
                                        left: 12
                                    }
                                },
                                labels: [],
                                legend: {
                                    show: !0,
                                    showForSingleSeries: !1,
                                    showForNullSeries: !0,
                                    showForZeroSeries: !0,
                                    floating: !1,
                                    position: "bottom",
                                    horizontalAlign: "center",
                                    inverseOrder: !1,
                                    fontSize: "12px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    width: void 0,
                                    height: void 0,
                                    formatter: void 0,
                                    tooltipHoverFormatter: void 0,
                                    offsetX: -20,
                                    offsetY: 4,
                                    labels: {
                                        colors: void 0,
                                        useSeriesColors: !1
                                    },
                                    markers: {
                                        width: 12,
                                        height: 12,
                                        strokeWidth: 0,
                                        fillColors: void 0,
                                        strokeColor: "#fff",
                                        radius: 12,
                                        customHTML: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        onClick: void 0
                                    },
                                    itemMargin: {
                                        horizontal: 5,
                                        vertical: 2
                                    },
                                    onItemClick: {
                                        toggleDataSeries: !0
                                    },
                                    onItemHover: {
                                        highlightDataSeries: !0
                                    }
                                },
                                markers: {
                                    discrete: [],
                                    size: 0,
                                    colors: void 0,
                                    strokeColors: "#fff",
                                    strokeWidth: 2,
                                    strokeOpacity: .9,
                                    strokeDashArray: 0,
                                    fillOpacity: 1,
                                    shape: "circle",
                                    width: 8,
                                    height: 8,
                                    radius: 2,
                                    offsetX: 0,
                                    offsetY: 0,
                                    onClick: void 0,
                                    onDblClick: void 0,
                                    showNullDataPoints: !0,
                                    hover: {
                                        size: void 0,
                                        sizeOffset: 3
                                    }
                                },
                                noData: {
                                    text: void 0,
                                    align: "center",
                                    verticalAlign: "middle",
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        color: void 0,
                                        fontSize: "14px",
                                        fontFamily: void 0
                                    }
                                },
                                responsive: [],
                                series: void 0,
                                states: {
                                    normal: {
                                        filter: {
                                            type: "none",
                                            value: 0
                                        }
                                    },
                                    hover: {
                                        filter: {
                                            type: "lighten",
                                            value: .1
                                        }
                                    },
                                    active: {
                                        allowMultipleDataPointsSelection: !1,
                                        filter: {
                                            type: "darken",
                                            value: .5
                                        }
                                    }
                                },
                                title: {
                                    text: void 0,
                                    align: "left",
                                    margin: 5,
                                    offsetX: 0,
                                    offsetY: 0,
                                    floating: !1,
                                    style: {
                                        fontSize: "14px",
                                        fontWeight: 900,
                                        fontFamily: void 0,
                                        color: void 0
                                    }
                                },
                                subtitle: {
                                    text: void 0,
                                    align: "left",
                                    margin: 5,
                                    offsetX: 0,
                                    offsetY: 30,
                                    floating: !1,
                                    style: {
                                        fontSize: "12px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0
                                    }
                                },
                                stroke: {
                                    show: !0,
                                    curve: "smooth",
                                    lineCap: "butt",
                                    width: 2,
                                    colors: void 0,
                                    dashArray: 0
                                },
                                tooltip: {
                                    enabled: !0,
                                    enabledOnSeries: void 0,
                                    shared: !0,
                                    followCursor: !1,
                                    intersect: !1,
                                    inverseOrder: !1,
                                    custom: void 0,
                                    fillSeriesColor: !1,
                                    theme: "light",
                                    style: {
                                        fontSize: "12px",
                                        fontFamily: void 0
                                    },
                                    onDatasetHover: {
                                        highlightDataSeries: !1
                                    },
                                    x: {
                                        show: !0,
                                        format: "dd MMM",
                                        formatter: void 0
                                    },
                                    y: {
                                        formatter: void 0,
                                        title: {
                                            formatter: function(t) {
                                                return t ? t + ": " : ""
                                            }
                                        }
                                    },
                                    z: {
                                        formatter: void 0,
                                        title: "Size: "
                                    },
                                    marker: {
                                        show: !0,
                                        fillColors: void 0
                                    },
                                    items: {
                                        display: "flex"
                                    },
                                    fixed: {
                                        enabled: !1,
                                        position: "topRight",
                                        offsetX: 0,
                                        offsetY: 0
                                    }
                                },
                                xaxis: {
                                    type: "category",
                                    categories: [],
                                    convertedCatToNumeric: !1,
                                    offsetX: 0,
                                    offsetY: 0,
                                    labels: {
                                        show: !0,
                                        rotate: -45,
                                        rotateAlways: !1,
                                        hideOverlappingLabels: !0,
                                        trim: !1,
                                        minHeight: void 0,
                                        maxHeight: 120,
                                        showDuplicates: !0,
                                        style: {
                                            colors: [],
                                            fontSize: "12px",
                                            fontWeight: 400,
                                            fontFamily: void 0,
                                            cssClass: ""
                                        },
                                        offsetX: 0,
                                        offsetY: 0,
                                        format: void 0,
                                        formatter: void 0,
                                        datetimeUTC: !0,
                                        datetimeFormatter: {
                                            year: "yyyy",
                                            month: "MMM 'yy",
                                            day: "dd MMM",
                                            hour: "HH:mm",
                                            minute: "HH:mm:ss",
                                            second: "HH:mm:ss"
                                        }
                                    },
                                    axisBorder: {
                                        show: !0,
                                        color: "#e0e0e0",
                                        width: "100%",
                                        height: 1,
                                        offsetX: 0,
                                        offsetY: 0
                                    },
                                    axisTicks: {
                                        show: !0,
                                        color: "#e0e0e0",
                                        height: 6,
                                        offsetX: 0,
                                        offsetY: 0
                                    },
                                    tickAmount: void 0,
                                    tickPlacement: "on",
                                    min: void 0,
                                    max: void 0,
                                    range: void 0,
                                    floating: !1,
                                    decimalsInFloat: void 0,
                                    position: "bottom",
                                    title: {
                                        text: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        style: {
                                            color: void 0,
                                            fontSize: "12px",
                                            fontWeight: 900,
                                            fontFamily: void 0,
                                            cssClass: ""
                                        }
                                    },
                                    crosshairs: {
                                        show: !0,
                                        width: 1,
                                        position: "back",
                                        opacity: .9,
                                        stroke: {
                                            color: "#b6b6b6",
                                            width: 1,
                                            dashArray: 3
                                        },
                                        fill: {
                                            type: "solid",
                                            color: "#B1B9C4",
                                            gradient: {
                                                colorFrom: "#D8E3F0",
                                                colorTo: "#BED1E6",
                                                stops: [0, 100],
                                                opacityFrom: .4,
                                                opacityTo: .5
                                            }
                                        },
                                        dropShadow: {
                                            enabled: !1,
                                            left: 0,
                                            top: 0,
                                            blur: 1,
                                            opacity: .4
                                        }
                                    },
                                    tooltip: {
                                        enabled: !0,
                                        offsetY: 0,
                                        formatter: void 0,
                                        style: {
                                            fontSize: "12px",
                                            fontFamily: void 0
                                        }
                                    }
                                },
                                yaxis: this.yAxis,
                                theme: {
                                    mode: "light",
                                    palette: "palette1",
                                    monochrome: {
                                        enabled: !1,
                                        color: "#008FFB",
                                        shadeTo: "light",
                                        shadeIntensity: .65
                                    }
                                }
                            }
                        }
                    }]), t
                }(),
                P = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.graphics = new _(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new w(this), this.xAxisAnnotations = new C(this), this.yAxisAnnotations = new S(this), this.pointsAnnotations = new A(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
                    }
                    return o(t, [{
                        key: "drawAxesAnnotations",
                        value: function() {
                            var t = this.w;
                            if (t.globals.axisCharts) {
                                for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), n = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, r = [e, i, n], a = [i.node, e.node, n.node], o = 0; o < 3; o++) t.globals.dom.elGraphical.add(r[o]), !s || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && a[o].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
                                    el: a[o],
                                    index: 0
                                });
                                this.helpers.annotationsBackground()
                            }
                        }
                    }, {
                        key: "drawImageAnnos",
                        value: function() {
                            var t = this;
                            this.w.config.annotations.images.map(function(e, i) {
                                t.addImage(e, i)
                            })
                        }
                    }, {
                        key: "drawTextAnnos",
                        value: function() {
                            var t = this;
                            this.w.config.annotations.texts.map(function(e, i) {
                                t.addText(e, i)
                            })
                        }
                    }, {
                        key: "addXaxisAnnotation",
                        value: function(t, e, i) {
                            this.xAxisAnnotations.addXaxisAnnotation(t, e, i)
                        }
                    }, {
                        key: "addYaxisAnnotation",
                        value: function(t, e, i) {
                            this.yAxisAnnotations.addYaxisAnnotation(t, e, i)
                        }
                    }, {
                        key: "addPointAnnotation",
                        value: function(t, e, i) {
                            this.pointsAnnotations.addPointAnnotation(t, e, i)
                        }
                    }, {
                        key: "addText",
                        value: function(t, e) {
                            var i = t.text,
                                n = t.backgroundColor,
                                s = t.borderWidth,
                                r = t.strokeDashArray,
                                a = t.borderRadius,
                                o = t.borderColor,
                                l = t.appendTo,
                                c = void 0 === l ? ".apexcharts-annotations" : l,
                                h = t.paddingLeft,
                                u = void 0 === h ? 4 : h,
                                d = t.paddingRight,
                                p = void 0 === d ? 4 : d,
                                f = t.paddingBottom,
                                g = void 0 === f ? 2 : f,
                                m = t.paddingTop,
                                b = void 0 === m ? 2 : m,
                                y = this.w,
                                v = this.graphics.drawText({
                                    x: t.x,
                                    y: t.y,
                                    text: i,
                                    textAnchor: t.textAnchor || "start",
                                    fontSize: t.fontSize || "12px",
                                    fontWeight: t.fontWeight || "regular",
                                    fontFamily: t.fontFamily || y.config.chart.fontFamily,
                                    foreColor: t.foreColor || y.config.chart.foreColor,
                                    cssClass: t.cssClass
                                }),
                                x = y.globals.dom.baseEl.querySelector(c);
                            x && x.appendChild(v.node);
                            var _ = v.bbox();
                            if (i) {
                                var w = this.graphics.drawRect(_.x - u, _.y - b, _.width + u + p, _.height + g + b, a, n || "transparent", 1, s, o, r);
                                x.insertBefore(w.node, v.node)
                            }
                        }
                    }, {
                        key: "addImage",
                        value: function(t, e) {
                            var i = this.w,
                                n = t.x,
                                s = void 0 === n ? 0 : n,
                                r = t.y,
                                a = void 0 === r ? 0 : r,
                                o = t.width,
                                l = void 0 === o ? 20 : o,
                                c = t.height,
                                h = void 0 === c ? 20 : c,
                                u = t.appendTo,
                                d = void 0 === u ? ".apexcharts-annotations" : u,
                                p = i.globals.dom.Paper.image(t.path);
                            p.size(l, h).move(s, a);
                            var f = i.globals.dom.baseEl.querySelector(d);
                            f && f.appendChild(p.node)
                        }
                    }, {
                        key: "addXaxisAnnotationExternal",
                        value: function(t, e, i) {
                            return this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "xaxis",
                                contextMethod: i.addXaxisAnnotation
                            }), i
                        }
                    }, {
                        key: "addYaxisAnnotationExternal",
                        value: function(t, e, i) {
                            return this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "yaxis",
                                contextMethod: i.addYaxisAnnotation
                            }), i
                        }
                    }, {
                        key: "addPointAnnotationExternal",
                        value: function(t, e, i) {
                            return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
                                params: t,
                                pushToMemory: e,
                                context: i,
                                type: "point",
                                contextMethod: i.addPointAnnotation
                            }), i
                        }
                    }, {
                        key: "addAnnotationExternal",
                        value: function(t) {
                            var e = t.params,
                                i = t.pushToMemory,
                                n = t.context,
                                s = t.type,
                                r = t.contextMethod,
                                a = n,
                                o = a.w,
                                l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations")),
                                c = l.childNodes.length + 1,
                                h = new E,
                                u = Object.assign({}, "xaxis" === s ? h.xAxisAnnotation : "yaxis" === s ? h.yAxisAnnotation : h.pointAnnotation),
                                d = y.extend(u, e);
                            switch (s) {
                                case "xaxis":
                                    this.addXaxisAnnotation(d, l, c);
                                    break;
                                case "yaxis":
                                    this.addYaxisAnnotation(d, l, c);
                                    break;
                                case "point":
                                    this.addPointAnnotation(d, l, c)
                            }
                            var p = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(c, "']")),
                                f = this.helpers.addBackgroundToAnno(p, d);
                            return f && l.insertBefore(f.node, p), i && o.globals.memory.methodsToExec.push({
                                context: a,
                                id: d.id ? d.id : y.randomId(),
                                method: r,
                                label: "addAnnotation",
                                params: e
                            }), n
                        }
                    }, {
                        key: "clearAnnotations",
                        value: function(t) {
                            var e = t.w,
                                i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                            e.globals.memory.methodsToExec.map(function(t, i) {
                                "addText" !== t.label && "addAnnotation" !== t.label || e.globals.memory.methodsToExec.splice(i, 1)
                            }), i = y.listToArray(i), Array.prototype.forEach.call(i, function(t) {
                                for (; t.firstChild;) t.removeChild(t.firstChild)
                            })
                        }
                    }, {
                        key: "removeAnnotation",
                        value: function(t, e) {
                            var i = t.w,
                                n = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
                            n && (i.globals.memory.methodsToExec.map(function(t, n) {
                                t.id === e && i.globals.memory.methodsToExec.splice(n, 1)
                            }), Array.prototype.forEach.call(n, function(t) {
                                t.parentElement.removeChild(t)
                            }))
                        }
                    }]), t
                }(),
                T = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0
                    }
                    return o(t, [{
                        key: "clippedImgArea",
                        value: function(t) {
                            var e = this.w,
                                i = e.config,
                                n = parseInt(e.globals.gridWidth, 10),
                                s = parseInt(e.globals.gridHeight, 10),
                                r = n > s ? n : s,
                                a = t.image,
                                o = 0,
                                l = 0;
                            void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t.width, l = t.height);
                            var c = document.createElementNS(e.globals.SVGNS, "pattern");
                            _.setAttrs(c, {
                                id: t.patternID,
                                patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
                                width: o + "px",
                                height: l + "px"
                            });
                            var h = document.createElementNS(e.globals.SVGNS, "image");
                            c.appendChild(h), h.setAttributeNS(window.SVG.xlink, "href", a), _.setAttrs(h, {
                                x: 0,
                                y: 0,
                                preserveAspectRatio: "none",
                                width: o + "px",
                                height: l + "px"
                            }), h.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(c)
                        }
                    }, {
                        key: "getSeriesIndex",
                        value: function(t) {
                            var e = this.w;
                            return this.seriesIndex = ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type || "treemap" === e.config.chart.type ? t.seriesNumber : t.seriesNumber % e.globals.series.length, this.seriesIndex
                        }
                    }, {
                        key: "fillPath",
                        value: function(t) {
                            var e = this.w;
                            this.opts = t;
                            var i, n, s, r = this.w.config;
                            this.seriesIndex = this.getSeriesIndex(t);
                            var a = this.getFillColors()[this.seriesIndex];
                            void 0 !== e.globals.seriesColors[this.seriesIndex] && (a = e.globals.seriesColors[this.seriesIndex]), "function" == typeof a && (a = a({
                                seriesIndex: this.seriesIndex,
                                dataPointIndex: t.dataPointIndex,
                                value: t.value,
                                w: e
                            }));
                            var o = this.getFillType(this.seriesIndex),
                                l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
                            t.color && (a = t.color);
                            var c = a;
                            if (-1 === a.indexOf("rgb") ? a.length < 9 && (c = y.hexToRgba(a, l)) : a.indexOf("rgba") > -1 && (l = y.getOpacityFromRGBA(a)), t.opacity && (l = t.opacity), "pattern" === o && (n = this.handlePatternFill(n, a, l, c)), "gradient" === o && (s = this.handleGradientFill(a, l, this.seriesIndex)), "image" === o) {
                                var h = r.fill.image.src,
                                    u = t.patternID ? t.patternID : "";
                                this.clippedImgArea({
                                    opacity: l,
                                    image: Array.isArray(h) ? t.seriesNumber < h.length ? h[t.seriesNumber] : h[0] : h,
                                    width: t.width ? t.width : void 0,
                                    height: t.height ? t.height : void 0,
                                    patternUnits: t.patternUnits,
                                    patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(u)
                                }), i = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(u, ")")
                            } else i = "gradient" === o ? s : "pattern" === o ? n : c;
                            return t.solid && (i = c), i
                        }
                    }, {
                        key: "getFillType",
                        value: function(t) {
                            var e = this.w;
                            return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type
                        }
                    }, {
                        key: "getFillColors",
                        value: function() {
                            var t = this.w,
                                e = t.config,
                                i = this.opts,
                                n = [];
                            return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? n = t.globals.stroke.colors : n.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? n = t.globals.fill.colors : n.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? n = t.globals.stroke.colors : n.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? n = t.globals.fill.colors : n.push(t.globals.fill.colors), void 0 !== i.fillColors && (n = [], Array.isArray(i.fillColors) ? n = i.fillColors.slice() : n.push(i.fillColors)), n
                        }
                    }, {
                        key: "handlePatternFill",
                        value: function(t, e, i, n) {
                            var s = this.w.config,
                                r = this.opts,
                                a = new _(this.ctx),
                                o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth,
                                l = e;
                            return Array.isArray(s.fill.pattern.style) ? void 0 !== s.fill.pattern.style[r.seriesNumber] ? a.drawPattern(s.fill.pattern.style[r.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : n : a.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i)
                        }
                    }, {
                        key: "handleGradientFill",
                        value: function(t, e, i) {
                            var n, s = this.w.config,
                                r = this.opts,
                                a = new _(this.ctx),
                                o = new y,
                                l = s.fill.gradient.type,
                                c = t,
                                h = void 0 === s.fill.gradient.opacityFrom ? e : Array.isArray(s.fill.gradient.opacityFrom) ? s.fill.gradient.opacityFrom[i] : s.fill.gradient.opacityFrom;
                            c.indexOf("rgba") > -1 && (h = y.getOpacityFromRGBA(c));
                            var u = void 0 === s.fill.gradient.opacityTo ? e : Array.isArray(s.fill.gradient.opacityTo) ? s.fill.gradient.opacityTo[i] : s.fill.gradient.opacityTo;
                            if (void 0 === s.fill.gradient.gradientToColors || 0 === s.fill.gradient.gradientToColors.length) n = o.shadeColor("dark" === s.fill.gradient.shade ? -1 * parseFloat(s.fill.gradient.shadeIntensity) : parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? y.rgb2hex(t) : t);
                            else if (s.fill.gradient.gradientToColors[r.seriesNumber]) {
                                var d = s.fill.gradient.gradientToColors[r.seriesNumber];
                                n = d, d.indexOf("rgba") > -1 && (u = y.getOpacityFromRGBA(d))
                            } else n = t;
                            if (s.fill.gradient.inverseColors) {
                                var p = c;
                                c = n, n = p
                            }
                            return c.indexOf("rgb") > -1 && (c = y.rgb2hex(c)), n.indexOf("rgb") > -1 && (n = y.rgb2hex(n)), a.drawGradient(l, c, n, h, u, r.size, s.fill.gradient.stops, s.fill.gradient.colorStops, i)
                        }
                    }]), t
                }(),
                D = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "setGlobalMarkerSize",
                        value: function() {
                            var t = this.w;
                            if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
                                if (t.globals.markers.size.length < t.globals.series.length + 1)
                                    for (var e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0])
                            } else t.globals.markers.size = t.config.series.map(function(e) {
                                return t.config.markers.size
                            })
                        }
                    }, {
                        key: "plotChartMarkers",
                        value: function(t, e, i, n) {
                            var s, r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                                a = this.w,
                                o = e,
                                l = t,
                                c = null,
                                h = new _(this.ctx);
                            if ((a.globals.markers.size[e] > 0 || r) && (c = h.group({
                                    class: r ? "" : "apexcharts-series-markers"
                                })).attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), Array.isArray(l.x))
                                for (var u = 0; u < l.x.length; u++) {
                                    var d = i;
                                    1 === i && 0 === u && (d = 0), 1 === i && 1 === u && (d = 1);
                                    var p = "apexcharts-marker";
                                    "line" !== a.config.chart.type && "area" !== a.config.chart.type || a.globals.comboCharts || a.config.tooltip.intersect || (p += " no-pointer-events");
                                    var f = Array.isArray(a.config.markers.size) ? a.globals.markers.size[e] > 0 : a.config.markers.size > 0;
                                    if (f || r) {
                                        y.isNumber(l.y[u]) ? p += " w".concat(y.randomId()) : p = "apexcharts-nullpoint";
                                        var g = this.getMarkerConfig(p, e, d);
                                        a.config.series[o].data[d] && (a.config.series[o].data[d].fillColor && (g.pointFillColor = a.config.series[o].data[d].fillColor), a.config.series[o].data[d].strokeColor && (g.pointStrokeColor = a.config.series[o].data[d].strokeColor)), n && (g.pSize = n), (s = h.drawMarker(l.x[u], l.y[u], g)).attr("rel", d), s.attr("j", d), s.attr("index", e), s.node.setAttribute("default-marker-size", g.pSize);
                                        var m = new x(this.ctx);
                                        m.setSelectionFilter(s, e, d), this.addEvents(s), c && c.add(s)
                                    } else void 0 === a.globals.pointsArray[e] && (a.globals.pointsArray[e] = []), a.globals.pointsArray[e].push([l.x[u], l.y[u]])
                                }
                            return c
                        }
                    }, {
                        key: "getMarkerConfig",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                n = this.w,
                                s = this.getMarkerStyle(e),
                                r = n.globals.markers.size[e],
                                a = n.config.markers;
                            return null !== i && a.discrete.length && a.discrete.map(function(t) {
                                t.seriesIndex === e && t.dataPointIndex === i && (s.pointStrokeColor = t.strokeColor, s.pointFillColor = t.fillColor, r = t.size)
                            }), {
                                pSize: r,
                                pRadius: a.radius,
                                width: Array.isArray(a.width) ? a.width[e] : a.width,
                                height: Array.isArray(a.height) ? a.height[e] : a.height,
                                pointStrokeWidth: Array.isArray(a.strokeWidth) ? a.strokeWidth[e] : a.strokeWidth,
                                pointStrokeColor: s.pointStrokeColor,
                                pointFillColor: s.pointFillColor,
                                shape: Array.isArray(a.shape) ? a.shape[e] : a.shape,
                                class: t,
                                pointStrokeOpacity: Array.isArray(a.strokeOpacity) ? a.strokeOpacity[e] : a.strokeOpacity,
                                pointStrokeDashArray: Array.isArray(a.strokeDashArray) ? a.strokeDashArray[e] : a.strokeDashArray,
                                pointFillOpacity: Array.isArray(a.fillOpacity) ? a.fillOpacity[e] : a.fillOpacity,
                                seriesIndex: e
                            }
                        }
                    }, {
                        key: "addEvents",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx);
                            t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), {
                                passive: !0
                            })
                        }
                    }, {
                        key: "getMarkerStyle",
                        value: function(t) {
                            var e = this.w,
                                i = e.globals.markers.colors,
                                n = e.config.markers.strokeColor || e.config.markers.strokeColors;
                            return {
                                pointStrokeColor: Array.isArray(n) ? n[t] : n,
                                pointFillColor: Array.isArray(i) ? i[t] : i
                            }
                        }
                    }]), t
                }(),
                I = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = new _(this.ctx),
                                r = i.realIndex,
                                a = i.pointsPos,
                                o = i.zRatio,
                                l = i.elParent,
                                c = s.group({
                                    class: "apexcharts-series-markers apexcharts-series-".concat(n.config.chart.type)
                                });
                            if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")), Array.isArray(a.x))
                                for (var h = 0; h < a.x.length; h++) {
                                    var u = e + 1,
                                        d = !0;
                                    0 === e && 0 === h && (u = 0), 0 === e && 1 === h && (u = 1);
                                    var p = 0,
                                        f = n.globals.markers.size[r];
                                    if (o !== 1 / 0) {
                                        f = n.globals.seriesZ[r][u] / o;
                                        var g = n.config.plotOptions.bubble;
                                        g.minBubbleRadius && f < g.minBubbleRadius && (f = g.minBubbleRadius), g.maxBubbleRadius && f > g.maxBubbleRadius && (f = g.maxBubbleRadius)
                                    }
                                    n.config.chart.animations.enabled || (p = f);
                                    var m = a.y[h];
                                    if (p = p || 0, null !== m && void 0 !== n.globals.series[r][u] || (d = !1), d) {
                                        var b = this.drawPoint(a.x[h], m, p, f, r, u, e);
                                        c.add(b)
                                    }
                                    l.add(c)
                                }
                        }
                    }, {
                        key: "drawPoint",
                        value: function(t, e, i, n, s, r, a) {
                            var o, l = this.w,
                                c = s,
                                h = new v(this.ctx),
                                u = new x(this.ctx),
                                d = new T(this.ctx),
                                p = new D(this.ctx),
                                f = new _(this.ctx),
                                g = p.getMarkerConfig("apexcharts-marker", c),
                                m = d.fillPath({
                                    seriesNumber: s,
                                    dataPointIndex: r,
                                    patternUnits: "objectBoundingBox",
                                    value: l.globals.series[s][a]
                                });
                            if ("circle" === g.shape ? o = f.drawCircle(i) : "square" !== g.shape && "rect" !== g.shape || (o = f.drawRect(0, 0, g.width - g.pointStrokeWidth / 2, g.height - g.pointStrokeWidth / 2, g.pRadius)), l.config.series[c].data[r] && l.config.series[c].data[r].fillColor && (m = l.config.series[c].data[r].fillColor), o.attr({
                                    x: t - g.width / 2 - g.pointStrokeWidth / 2,
                                    y: e - g.height / 2 - g.pointStrokeWidth / 2,
                                    cx: t,
                                    cy: e,
                                    fill: m,
                                    "fill-opacity": g.pointFillOpacity,
                                    stroke: g.pointStrokeColor,
                                    r: n,
                                    "stroke-width": g.pointStrokeWidth,
                                    "stroke-dasharray": g.pointStrokeDashArray,
                                    "stroke-opacity": g.pointStrokeOpacity
                                }), l.config.chart.dropShadow.enabled && u.dropShadow(o, l.config.chart.dropShadow, s), !this.initialAnim || l.globals.dataChanged || l.globals.resized ? l.globals.animationEnded = !0 : h.animateMarker(o, 0, "circle" === g.shape ? n : {
                                    width: g.width,
                                    height: g.height
                                }, l.config.chart.animations.speed, l.globals.easing, function() {
                                    window.setTimeout(function() {
                                        h.animationCompleted(o)
                                    }, 100)
                                }), l.globals.dataChanged && "circle" === g.shape)
                                if (this.dynamicAnim) {
                                    var b, y, w, C, k = l.config.chart.animations.dynamicAnimation.speed;
                                    null != (C = l.globals.previousPaths[s] && l.globals.previousPaths[s][a]) && (b = C.x, y = C.y, w = void 0 !== C.r ? C.r : n);
                                    for (var S = 0; S < l.globals.collapsedSeries.length; S++) l.globals.collapsedSeries[S].index === s && (k = 1, n = 0);
                                    0 === t && 0 === e && (n = 0), h.animateCircle(o, {
                                        cx: b,
                                        cy: y,
                                        r: w
                                    }, {
                                        cx: t,
                                        cy: e,
                                        r: n
                                    }, k, l.globals.easing)
                                } else o.attr({
                                    r: n
                                });
                            return o.attr({
                                rel: r,
                                j: r,
                                index: s,
                                "default-marker-size": n
                            }), u.setSelectionFilter(o, s, r), p.addEvents(o), o.node.classList.add("apexcharts-marker"), o
                        }
                    }, {
                        key: "centerTextInBubble",
                        value: function(t) {
                            return {
                                y: t += parseInt(this.w.config.dataLabels.style.fontSize, 10) / 4
                            }
                        }
                    }]), t
                }(),
                M = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "dataLabelsCorrection",
                        value: function(t, e, i, n, s, r, a) {
                            var o = this.w,
                                l = !1,
                                c = new _(this.ctx).getTextRects(i, a),
                                h = c.width,
                                u = c.height;
                            if (e < 0 && (e = 0), e > o.globals.gridHeight + u && (e = o.globals.gridHeight + u / 2), void 0 === o.globals.dataLabelsRects[n] && (o.globals.dataLabelsRects[n] = []), o.globals.dataLabelsRects[n].push({
                                    x: t,
                                    y: e,
                                    width: h,
                                    height: u
                                }), void 0 !== o.globals.dataLabelsRects[n][o.globals.dataLabelsRects[n].length - 2]) {
                                var d = o.globals.dataLabelsRects[n][void 0 !== o.globals.lastDrawnDataLabelsIndexes[n] ? o.globals.lastDrawnDataLabelsIndexes[n][o.globals.lastDrawnDataLabelsIndexes[n].length - 1] : 0];
                                (t > d.x + d.width + 2 || e > d.y + d.height + 2 || t + h < d.x) && (l = !0)
                            }
                            return (0 === s || r) && (l = !0), {
                                x: t,
                                y: e,
                                textRects: c,
                                drawnextLabel: l
                            }
                        }
                    }, {
                        key: "drawDataLabel",
                        value: function(t, e, i) {
                            var n = this,
                                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
                                r = this.w,
                                a = new _(this.ctx),
                                o = r.config.dataLabels,
                                l = 0,
                                c = 0,
                                h = i,
                                u = null;
                            if (!o.enabled || !Array.isArray(t.x)) return u;
                            u = a.group({
                                class: "apexcharts-data-labels"
                            });
                            for (var d = 0; d < t.x.length; d++)
                                if (l = t.x[d] + o.offsetX, c = t.y[d] + o.offsetY + s, !isNaN(l)) {
                                    1 === i && 0 === d && (h = 0), 1 === i && 1 === d && (h = 1);
                                    var p = r.globals.series[e][h],
                                        f = "",
                                        g = function(t) {
                                            return r.config.dataLabels.formatter(t, {
                                                ctx: n.ctx,
                                                seriesIndex: e,
                                                dataPointIndex: h,
                                                w: r
                                            })
                                        };
                                    if ("bubble" === r.config.chart.type) {
                                        f = g(p = r.globals.seriesZ[e][h]), c = t.y[d];
                                        var m = new I(this.ctx),
                                            b = m.centerTextInBubble(c, e, h);
                                        c = b.y
                                    } else void 0 !== p && (f = g(p));
                                    this.plotDataLabelsText({
                                        x: l,
                                        y: c,
                                        text: f,
                                        i: e,
                                        j: h,
                                        parent: u,
                                        offsetCorrection: !0,
                                        dataLabelsConfig: r.config.dataLabels
                                    })
                                } return u
                        }
                    }, {
                        key: "plotDataLabelsText",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = t.x,
                                s = t.y,
                                r = t.i,
                                a = t.j,
                                o = t.text,
                                l = t.textAnchor,
                                c = t.fontSize,
                                h = t.parent,
                                u = t.dataLabelsConfig,
                                d = t.color,
                                p = t.alwaysDrawDataLabel,
                                f = t.offsetCorrection;
                            if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
                                var g = {
                                    x: n,
                                    y: s,
                                    drawnextLabel: !0
                                };
                                f && (g = this.dataLabelsCorrection(n, s, o, r, a, p, parseInt(u.style.fontSize, 10))), e.globals.zoomed || (n = g.x, s = g.y), g.textRects && (n < -10 - g.textRects.width || n > e.globals.gridWidth + g.textRects.width + 10) && (o = "");
                                var m = e.globals.dataLabels.style.colors[r];
                                (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (m = e.globals.dataLabels.style.colors[a]), "function" == typeof m && (m = m({
                                    series: e.globals.series,
                                    seriesIndex: r,
                                    dataPointIndex: a,
                                    w: e
                                })), d && (m = d);
                                var b = u.offsetX,
                                    y = u.offsetY;
                                if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (b = 0, y = 0), g.drawnextLabel) {
                                    var v = i.drawText({
                                        width: 100,
                                        height: parseInt(u.style.fontSize, 10),
                                        x: n + b,
                                        y: s + y,
                                        foreColor: m,
                                        textAnchor: l || u.textAnchor,
                                        text: o,
                                        fontSize: c || u.style.fontSize,
                                        fontFamily: u.style.fontFamily,
                                        fontWeight: u.style.fontWeight || "normal"
                                    });
                                    if (v.attr({
                                            class: "apexcharts-datalabel",
                                            cx: n,
                                            cy: s
                                        }), u.dropShadow.enabled) {
                                        var w = u.dropShadow;
                                        new x(this.ctx).dropShadow(v, w)
                                    }
                                    h.add(v), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(a)
                                }
                            }
                        }
                    }, {
                        key: "addBackgroundToDataLabel",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.config.dataLabels.background,
                                s = n.padding,
                                r = n.padding / 2,
                                a = e.width,
                                o = e.height,
                                l = new _(this.ctx).drawRect(e.x - s, e.y - r / 2, a + 2 * s, o + r, n.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, n.opacity, n.borderWidth, n.borderColor);
                            return n.dropShadow.enabled && new x(this.ctx).dropShadow(l, n.dropShadow), l
                        }
                    }, {
                        key: "dataLabelsBackground",
                        value: function() {
                            var t = this.w;
                            if ("bubble" !== t.config.chart.type)
                                for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e.length; i++) {
                                    var n = e[i],
                                        s = n.getBBox(),
                                        r = null;
                                    if (s.width && s.height && (r = this.addBackgroundToDataLabel(n, s)), r) {
                                        n.parentNode.insertBefore(r.node, n);
                                        var a = n.getAttribute("fill");
                                        !t.config.chart.animations.enabled || t.globals.resized || t.globals.dataChanged ? r.attr({
                                            fill: a
                                        }) : r.animate().attr({
                                            fill: a
                                        }), n.setAttribute("fill", t.config.dataLabels.background.foreColor)
                                    }
                                }
                        }
                    }, {
                        key: "bringForward",
                        value: function() {
                            for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), n = 0; n < e.length; n++) i && i.insertBefore(e[n], i.nextSibling)
                        }
                    }]), t
                }(),
                L = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.barCtx = e
                    }
                    return o(t, [{
                        key: "handleBarDataLabels",
                        value: function(t) {
                            var e = t.x,
                                i = t.y,
                                n = t.y1,
                                s = t.y2,
                                r = t.i,
                                a = t.j,
                                o = t.realIndex,
                                l = t.series,
                                c = t.barHeight,
                                h = t.barWidth,
                                u = t.barYPosition,
                                d = t.visibleSeries,
                                p = t.renderedPath,
                                f = this.w,
                                g = new _(this.barCtx.ctx),
                                m = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth,
                                b = e + parseFloat(h * d),
                                y = i + parseFloat(c * d);
                            f.globals.isXNumeric && !f.globals.isBarHorizontal && (b = e + parseFloat(h * (d + 1)), y = i + parseFloat(c * (d + 1)) - m);
                            var v, x = e,
                                w = i,
                                C = f.config.dataLabels,
                                k = this.barCtx.barOptions.dataLabels;
                            void 0 !== u && this.barCtx.isTimelineBar && (y = u, w = u);
                            var S = C.offsetX,
                                A = C.offsetY,
                                O = {
                                    width: 0,
                                    height: 0
                                };
                            f.config.dataLabels.enabled && (O = g.getTextRects(f.globals.yLabelFormatters[0](this.barCtx.series[r][a]), parseFloat(C.style.fontSize)));
                            var E = {
                                x: e,
                                y: i,
                                i: r,
                                j: a,
                                renderedPath: p,
                                bcx: b,
                                bcy: y,
                                barHeight: c,
                                barWidth: h,
                                textRects: O,
                                strokeWidth: m,
                                dataLabelsX: x,
                                dataLabelsY: w,
                                barDataLabelsConfig: k,
                                offX: S,
                                offY: A
                            };
                            return v = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(E) : this.calculateColumnsDataLabelsPosition(E), p.attr({
                                cy: v.bcy,
                                cx: v.bcx,
                                j: a,
                                val: l[r][a],
                                barHeight: c,
                                barWidth: h
                            }), this.drawCalculatedDataLabels({
                                x: v.dataLabelsX,
                                y: v.dataLabelsY,
                                val: this.barCtx.isTimelineBar ? [n, s] : l[r][a],
                                i: o,
                                j: a,
                                barWidth: h,
                                barHeight: c,
                                textRects: O,
                                dataLabelsConfig: C
                            })
                        }
                    }, {
                        key: "calculateColumnsDataLabelsPosition",
                        value: function(t) {
                            var e, i = this.w,
                                n = t.i,
                                s = t.j,
                                r = t.y,
                                a = t.bcx,
                                o = t.barWidth,
                                l = t.barHeight,
                                c = t.textRects,
                                h = t.dataLabelsY,
                                u = t.barDataLabelsConfig,
                                d = t.strokeWidth,
                                p = t.offX,
                                f = t.offY;
                            l = Math.abs(l);
                            var g = "vertical" === i.config.plotOptions.bar.dataLabels.orientation;
                            a -= d / 2, e = i.globals.isXNumeric ? a - o / 2 + p : a - i.globals.gridWidth / i.globals.dataPoints + o / 2 + p, g && (e = e + c.height / 2 - d / 2 - 2);
                            var m = this.barCtx.series[n][s] < 0,
                                b = r;
                            switch (this.barCtx.isReversed && (b = r - l + (m ? 2 * l : 0), r -= l), u.position) {
                                case "center":
                                    h = g ? m ? b + l / 2 + f : b + l / 2 - f : m ? b - l / 2 + c.height / 2 + f : b + l / 2 + c.height / 2 - f;
                                    break;
                                case "bottom":
                                    h = g ? m ? b + l + f : b + l - f : m ? b - l + c.height + d + f : b + l - c.height / 2 + d - f;
                                    break;
                                case "top":
                                    h = g ? m ? b + f : b - f : m ? b - c.height / 2 - f : b + c.height + f
                            }
                            return i.config.chart.stacked || (h < 0 ? h = 0 + d : h + c.height / 3 > i.globals.gridHeight && (h = i.globals.gridHeight - d)), {
                                bcx: a,
                                bcy: r,
                                dataLabelsX: e,
                                dataLabelsY: h
                            }
                        }
                    }, {
                        key: "calculateBarsDataLabelsPosition",
                        value: function(t) {
                            var e = this.w,
                                i = t.x,
                                n = t.i,
                                s = t.j,
                                r = t.bcy,
                                a = t.barHeight,
                                o = t.barWidth,
                                l = t.textRects,
                                c = t.dataLabelsX,
                                h = t.strokeWidth,
                                u = t.barDataLabelsConfig,
                                d = t.offX,
                                p = t.offY,
                                f = e.globals.gridHeight / e.globals.dataPoints;
                            o = Math.abs(o);
                            var g = r - (this.barCtx.isTimelineBar ? 0 : f) + a / 2 + l.height / 2 + p - 3,
                                m = this.barCtx.series[n][s] < 0,
                                b = i;
                            switch (this.barCtx.isReversed && (b = i + o - (m ? 2 * o : 0), i = e.globals.gridWidth - o), u.position) {
                                case "center":
                                    c = m ? b + o / 2 - d : Math.max(l.width / 2, b - o / 2) + d;
                                    break;
                                case "bottom":
                                    c = m ? b + o - h - Math.round(l.width / 2) - d : b - o + h + Math.round(l.width / 2) + d;
                                    break;
                                case "top":
                                    c = m ? b - h + Math.round(l.width / 2) - d : b - h - Math.round(l.width / 2) + d
                            }
                            return e.config.chart.stacked || (c < 0 ? c = c + l.width + h : c + l.width / 2 > e.globals.gridWidth && (c = e.globals.gridWidth - l.width - h)), {
                                bcx: i,
                                bcy: r,
                                dataLabelsX: c,
                                dataLabelsY: g
                            }
                        }
                    }, {
                        key: "drawCalculatedDataLabels",
                        value: function(t) {
                            var e = t.x,
                                i = t.y,
                                n = t.val,
                                s = t.i,
                                r = t.j,
                                a = t.textRects,
                                o = t.barHeight,
                                l = t.barWidth,
                                c = t.dataLabelsConfig,
                                u = this.w,
                                d = "rotate(0)";
                            "vertical" === u.config.plotOptions.bar.dataLabels.orientation && (d = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
                            var p = new M(this.barCtx.ctx),
                                f = new _(this.barCtx.ctx),
                                g = c.formatter,
                                m = null,
                                b = u.globals.collapsedSeriesIndices.indexOf(s) > -1;
                            if (c.enabled && !b) {
                                m = f.group({
                                    class: "apexcharts-data-labels",
                                    transform: d
                                });
                                var y = "";
                                void 0 !== n && (y = g(n, {
                                    seriesIndex: s,
                                    dataPointIndex: r,
                                    w: u
                                })), 0 === n && u.config.chart.stacked && (y = "");
                                var v = u.globals.series[s][r] <= 0,
                                    x = u.config.plotOptions.bar.dataLabels.position;
                                "vertical" === u.config.plotOptions.bar.dataLabels.orientation && ("top" === x && (c.textAnchor = v ? "end" : "start"), "center" === x && (c.textAnchor = "middle"), "bottom" === x && (c.textAnchor = v ? "end" : "start")), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && l < f.getTextRects(y, parseFloat(c.style.fontSize)).width && (y = ""), u.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? (l > 0 && a.width / 1.6 > l || l < 0 && a.width / 1.6 < l) && (y = "") : a.height / 1.6 > o && (y = ""));
                                var w = h({}, c);
                                this.barCtx.isHorizontal && n < 0 && ("start" === c.textAnchor ? w.textAnchor = "end" : "end" === c.textAnchor && (w.textAnchor = "start")), p.plotDataLabelsText({
                                    x: e,
                                    y: i,
                                    text: y,
                                    i: s,
                                    j: r,
                                    parent: m,
                                    dataLabelsConfig: w,
                                    alwaysDrawDataLabel: !0,
                                    offsetCorrection: !0
                                })
                            }
                            return m
                        }
                    }]), t
                }(),
                R = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive"
                    }
                    return o(t, [{
                        key: "getAllSeriesEls",
                        value: function() {
                            return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
                        }
                    }, {
                        key: "getSeriesByName",
                        value: function(t) {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(y.escapeString(t), "']"))
                        }
                    }, {
                        key: "isSeriesHidden",
                        value: function(t) {
                            var e = this.getSeriesByName(t),
                                i = parseInt(e.getAttribute("data:realIndex"), 10);
                            return {
                                isHidden: e.classList.contains("apexcharts-series-collapsed"),
                                realIndex: i
                            }
                        }
                    }, {
                        key: "addCollapsedClassToSeries",
                        value: function(t, e) {
                            var i = this.w;

                            function n(i) {
                                for (var n = 0; n < i.length; n++) i[n].index === e && t.node.classList.add("apexcharts-series-collapsed")
                            }
                            n(i.globals.collapsedSeries), n(i.globals.ancillaryCollapsedSeries)
                        }
                    }, {
                        key: "toggleSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden
                        }
                    }, {
                        key: "showSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0)
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            var e = this.isSeriesHidden(t);
                            e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1)
                        }
                    }, {
                        key: "resetSeries",
                        value: function() {
                            var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                n = this.w,
                                s = y.clone(n.globals.initialSeries);
                            n.globals.previousPaths = [], i ? (n.globals.collapsedSeries = [], n.globals.ancillaryCollapsedSeries = [], n.globals.collapsedSeriesIndices = [], n.globals.ancillaryCollapsedSeriesIndices = []) : s = this.emptyCollapsedSeries(s), n.config.series = s, t && (e && (n.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s, n.config.chart.animations.dynamicAnimation.enabled))
                        }
                    }, {
                        key: "emptyCollapsedSeries",
                        value: function(t) {
                            for (var e = this.w, i = 0; i < t.length; i++) e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
                            return t
                        }
                    }, {
                        key: "toggleSeriesOnHover",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                            if ("mousemove" === t.type) {
                                var s = parseInt(e.getAttribute("rel"), 10) - 1,
                                    r = null,
                                    a = null;
                                i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), a = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));
                                for (var o = 0; o < n.length; o++) n[o].classList.add(this.legendInactiveClass);
                                null !== r && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), null !== a && a.classList.remove(this.legendInactiveClass))
                            } else if ("mouseout" === t.type)
                                for (var l = 0; l < n.length; l++) n[l].classList.remove(this.legendInactiveClass)
                        }
                    }, {
                        key: "highlightRangeInSeries",
                        value: function(t, e) {
                            var i = this,
                                n = this.w,
                                s = n.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
                                r = function(t) {
                                    for (var e = 0; e < s.length; e++) s[e].classList[t](i.legendInactiveClass)
                                };
                            if ("mousemove" === t.type) {
                                var a = parseInt(e.getAttribute("rel"), 10) - 1;
                                r("add"),
                                    function(t) {
                                        for (var e = 0; e < s.length; e++) {
                                            var n = parseInt(s[e].getAttribute("val"), 10);
                                            n >= t.from && n <= t.to && s[e].classList.remove(i.legendInactiveClass)
                                        }
                                    }(n.config.plotOptions.heatmap.colorScale.ranges[a])
                            } else "mouseout" === t.type && r("remove")
                        }
                    }, {
                        key: "getActiveConfigSeriesIndex",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc",
                                i = this.w,
                                n = 0;
                            if (i.config.series.length > 1)
                                for (var s = i.config.series.map(function(e, n) {
                                        var s = !1;
                                        return t && (s = "bar" === i.config.series[n].type || "column" === i.config.series[n].type), e.data && e.data.length > 0 && !s ? n : -1
                                    }), r = "asc" === e ? 0 : s.length - 1;
                                    "asc" === e ? r < s.length : r >= 0;
                                    "asc" === e ? r++ : r--)
                                    if (-1 !== s[r]) {
                                        n = s[r];
                                        break
                                    } return n
                        }
                    }, {
                        key: "getPreviousPaths",
                        value: function() {
                            var t = this.w;

                            function e(e, i, n) {
                                for (var s = e[i].childNodes, r = {
                                        type: n,
                                        paths: [],
                                        realIndex: e[i].getAttribute("data:realIndex")
                                    }, a = 0; a < s.length; a++)
                                    if (s[a].hasAttribute("pathTo")) {
                                        var o = s[a].getAttribute("pathTo");
                                        r.paths.push({
                                            d: o
                                        })
                                    } t.globals.previousPaths.push(r)
                            }
                            t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "candlestick", "radar"].forEach(function(i) {
                                for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(i, "-series .apexcharts-series")), s = 0; s < n.length; s++) e(n, s, i)
                            }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
                            var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
                            if (i.length > 0)
                                for (var n = function(e) {
                                        for (var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e, "'] rect")), n = [], s = function(t) {
                                                var e = function(e) {
                                                        return i[t].getAttribute(e)
                                                    },
                                                    s = {
                                                        x: parseFloat(e("x")),
                                                        y: parseFloat(e("y")),
                                                        width: parseFloat(e("width")),
                                                        height: parseFloat(e("height"))
                                                    };
                                                n.push({
                                                    rect: s,
                                                    color: i[t].getAttribute("color")
                                                })
                                            }, r = 0; r < i.length; r++) s(r);
                                        t.globals.previousPaths.push(n)
                                    }, s = 0; s < i.length; s++) n(s);
                            t.globals.axisCharts || (t.globals.previousPaths = t.globals.series)
                        }
                    }, {
                        key: "handlePrevBubbleScatterPaths",
                        value: function(t) {
                            var e = this.w,
                                i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
                            if (i.length > 0)
                                for (var n = 0; n < i.length; n++) {
                                    for (var s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(n, "'] circle")), r = [], a = 0; a < s.length; a++) r.push({
                                        x: s[a].getAttribute("cx"),
                                        y: s[a].getAttribute("cy"),
                                        r: s[a].getAttribute("r")
                                    });
                                    e.globals.previousPaths.push(r)
                                }
                        }
                    }, {
                        key: "clearPreviousPaths",
                        value: function() {
                            var t = this.w;
                            t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1
                        }
                    }, {
                        key: "handleNoData",
                        value: function() {
                            var t = this.w,
                                e = t.config.noData,
                                i = new _(this.ctx),
                                n = t.globals.svgWidth / 2,
                                s = t.globals.svgHeight / 2,
                                r = "middle";
                            if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (n = 10, r = "start") : "right" === e.align && (n = t.globals.svgWidth - 10, r = "end"), "top" === e.verticalAlign ? s = 50 : "bottom" === e.verticalAlign && (s = t.globals.svgHeight - 50), n += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
                                var a = i.drawText({
                                    x: n,
                                    y: s,
                                    text: e.text,
                                    textAnchor: r,
                                    fontSize: e.style.fontSize,
                                    fontFamily: e.style.fontFamily,
                                    foreColor: e.style.color,
                                    opacity: 1,
                                    class: "apexcharts-text-nodata"
                                });
                                t.globals.dom.Paper.add(a)
                            }
                        }
                    }, {
                        key: "setNullSeriesToZeroValues",
                        value: function(t) {
                            for (var e = this.w, i = 0; i < t.length; i++)
                                if (0 === t[i].length)
                                    for (var n = 0; n < t[e.globals.maxValsInArrayIndex].length; n++) t[i].push(0);
                            return t
                        }
                    }, {
                        key: "hasAllSeriesEqualX",
                        value: function() {
                            for (var t = !0, e = this.w, i = this.filteredSeriesX(), n = 0; n < i.length - 1; n++)
                                if (i[n][0] !== i[n + 1][0]) {
                                    t = !1;
                                    break
                                } return e.globals.allSeriesHasEqualX = t, t
                        }
                    }, {
                        key: "filteredSeriesX",
                        value: function() {
                            return this.w.globals.seriesX.map(function(t) {
                                return t.length > 0 ? t : []
                            })
                        }
                    }]), t
                }(),
                j = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.barCtx = e
                    }
                    return o(t, [{
                        key: "initVariables",
                        value: function(t) {
                            var e = this.w;
                            this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
                            for (var i = 0; i < t.length; i++)
                                if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric)
                                    for (var n = 0; n < t[i].length; n++) e.globals.seriesX[i][n] > e.globals.minX && e.globals.seriesX[i][n] < e.globals.maxX && this.barCtx.visibleItems++;
                                else this.barCtx.visibleItems = e.globals.dataPoints;
                            0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], this.barCtx.radiusOnSeriesNumber = t.length - 1, e.globals.comboCharts || this.checkZeroSeries({
                                series: t
                            })
                        }
                    }, {
                        key: "initialPositions",
                        value: function() {
                            var t, e, i, n, s, r, a, o, l = this.w,
                                c = l.globals.dataPoints;
                            this.barCtx.isTimelineBar && (c = l.globals.labels.length);
                            var h = this.barCtx.seriesLen;
                            if (l.config.plotOptions.bar.rangeBarGroupRows && (h = 1), this.barCtx.isHorizontal) s = (i = l.globals.gridHeight / c) / h, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2;
                            else {
                                if (n = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (n = l.globals.gridWidth / l.globals.dataPoints), r = n / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) {
                                    var u = this.barCtx.xRatio;
                                    l.config.xaxis.convertedCatToNumeric && (u = this.barCtx.initialXRatio), l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / u > 0 && (n = l.globals.minXDiff / u), (r = n / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1)
                                }
                                a = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (n - r * this.barCtx.seriesLen) / 2
                            }
                            return {
                                x: t,
                                y: e,
                                yDivision: i,
                                xDivision: n,
                                barHeight: s,
                                barWidth: r,
                                zeroH: a,
                                zeroW: o
                            }
                        }
                    }, {
                        key: "getPathFillColor",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = new T(this.barCtx.ctx),
                                a = null,
                                o = this.barCtx.barOptions.distributed ? i : e;
                            return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(n) {
                                t[e][i] >= n.from && t[e][i] <= n.to && (a = n.color)
                            }), s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (a = s.config.series[e].data[i].fillColor), r.fillPath({
                                seriesNumber: this.barCtx.barOptions.distributed ? o : n,
                                dataPointIndex: i,
                                color: a,
                                value: t[e][i]
                            })
                        }
                    }, {
                        key: "getStrokeWidth",
                        value: function(t, e, i) {
                            var n = 0,
                                s = this.w;
                            return this.barCtx.isNullValue = null == this.barCtx.series[t][e], s.config.stroke.show && (this.barCtx.isNullValue || (n = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), n
                        }
                    }, {
                        key: "barBackground",
                        value: function(t) {
                            var e = t.j,
                                i = t.i,
                                n = t.x1,
                                s = t.x2,
                                r = t.y1,
                                a = t.y2,
                                o = t.elSeries,
                                l = this.w,
                                c = new _(this.barCtx.ctx),
                                h = new R(this.barCtx.ctx).getActiveConfigSeriesIndex();
                            if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && h === i) {
                                e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e -= this.barCtx.barOptions.colors.backgroundBarColors.length);
                                var u = c.drawRect(void 0 !== n ? n : 0, void 0 !== r ? r : 0, void 0 !== s ? s : l.globals.gridWidth, void 0 !== a ? a : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, this.barCtx.barOptions.colors.backgroundBarColors[e], this.barCtx.barOptions.colors.backgroundBarOpacity);
                                o.add(u), u.node.classList.add("apexcharts-backgroundBar")
                            }
                        }
                    }, {
                        key: "getColumnPaths",
                        value: function(t) {
                            var e = t.barWidth,
                                i = t.barXPosition,
                                n = t.yRatio,
                                s = t.y1,
                                r = t.y2,
                                a = t.strokeWidth,
                                o = t.series,
                                l = t.realIndex,
                                c = t.i,
                                h = t.j,
                                u = t.w,
                                d = new _(this.barCtx.ctx);
                            (a = Array.isArray(a) ? a[l] : a) || (a = 0);
                            var p = this.getRoundedBars(u, {
                                    barWidth: e,
                                    strokeWidth: a,
                                    yRatio: n,
                                    barXPosition: i,
                                    y1: s,
                                    y2: r
                                }, o, c, h),
                                f = i,
                                g = i + e,
                                m = d.move(f, s),
                                b = d.move(f, s),
                                y = d.line(g - a, s);
                            return u.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(l, h, !1)), m = m + d.line(f, p.y2) + p.pathWithRadius + d.line(g - a, p.y2) + y + y + "z", b = b + d.line(f, s) + y + y + y + y + y + d.line(f, s), u.config.chart.stacked && (this.barCtx.yArrj.push(p.y2), this.barCtx.yArrjF.push(Math.abs(s - p.y2)), this.barCtx.yArrjVal.push(this.barCtx.series[c][h])), {
                                pathTo: m,
                                pathFrom: b
                            }
                        }
                    }, {
                        key: "getBarpaths",
                        value: function(t) {
                            var e = t.barYPosition,
                                i = t.barHeight,
                                n = t.x1,
                                s = t.x2,
                                r = t.strokeWidth,
                                a = t.series,
                                o = t.realIndex,
                                l = t.i,
                                c = t.j,
                                h = t.w,
                                u = new _(this.barCtx.ctx);
                            (r = Array.isArray(r) ? r[o] : r) || (r = 0);
                            var d = this.getRoundedBars(h, {
                                    barHeight: i,
                                    strokeWidth: r,
                                    barYPosition: e,
                                    x2: s,
                                    x1: n
                                }, a, l, c),
                                p = u.move(n, e),
                                f = u.move(n, e);
                            h.globals.previousPaths.length > 0 && (f = this.barCtx.getPreviousPath(o, c, !1));
                            var g = e,
                                m = e + i,
                                b = u.line(n, m - r);
                            return p = p + u.line(d.x2, g) + d.pathWithRadius + u.line(d.x2, m - r) + b + b + "z", f = f + u.line(n, g) + b + b + b + b + b + u.line(n, g), h.config.chart.stacked && (this.barCtx.xArrj.push(d.x2), this.barCtx.xArrjF.push(Math.abs(n - d.x2)), this.barCtx.xArrjVal.push(this.barCtx.series[l][c])), {
                                pathTo: p,
                                pathFrom: f
                            }
                        }
                    }, {
                        key: "getRoundedBars",
                        value: function(t, e, i, n, s) {
                            var r = new _(this.barCtx.ctx),
                                a = t.config.plotOptions.bar.borderRadius;
                            if (t.config.chart.stacked && i.length > 1 && n !== this.barCtx.radiusOnSeriesNumber && (a = 0), this.barCtx.isHorizontal) {
                                var o = "",
                                    l = e.x2;
                                if (Math.abs(e.x1 - e.x2) < a && (a = Math.abs(e.x1 - e.x2)), void 0 !== i[n][s] || null !== i[n][s]) {
                                    var c = this.barCtx.isReversed ? i[n][s] > 0 : i[n][s] < 0;
                                    c && (a *= -1), o = r.quadraticCurve((l -= a) + a, e.barYPosition, l + a, e.barYPosition + (c ? -1 * a : a)) + r.line(l + a, e.barYPosition + e.barHeight - e.strokeWidth - (c ? -1 * a : a)) + r.quadraticCurve(l + a, e.barYPosition + e.barHeight - e.strokeWidth, l, e.barYPosition + e.barHeight - e.strokeWidth)
                                }
                                return {
                                    pathWithRadius: o,
                                    x2: l
                                }
                            }
                            var h = "",
                                u = e.y2;
                            if (Math.abs(e.y1 - e.y2) < a && (a = Math.abs(e.y1 - e.y2)), void 0 !== i[n][s] || null !== i[n][s]) {
                                var d = i[n][s] < 0;
                                d && (a *= -1), h = r.quadraticCurve(e.barXPosition, (u += a) - a, e.barXPosition + (d ? -1 * a : a), u - a) + r.line(e.barXPosition + e.barWidth - e.strokeWidth - (d ? -1 * a : a), u - a) + r.quadraticCurve(e.barXPosition + e.barWidth - e.strokeWidth, u - a, e.barXPosition + e.barWidth - e.strokeWidth, u)
                            }
                            return {
                                pathWithRadius: h,
                                y2: u
                            }
                        }
                    }, {
                        key: "checkZeroSeries",
                        value: function(t) {
                            for (var e = t.series, i = this.w, n = 0; n < e.length; n++) {
                                for (var s = 0, r = 0; r < e[i.globals.maxValsInArrayIndex].length; r++) s += e[n][r];
                                0 === s && this.barCtx.zeroSerieses.push(n)
                            }
                            for (var a = e.length - 1; a >= 0; a--) this.barCtx.zeroSerieses.indexOf(a) > -1 && a === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
                            for (var o = e.length - 1; o >= 0; o--) i.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1)
                        }
                    }]), t
                }(),
                F = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var n = this.w;
                        this.barOptions = n.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = n.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = "datetime" === n.config.xaxis.type && n.globals.seriesRangeBarTimeline.length, this.xyRatios = i, null !== this.xyRatios && (this.xRatio = i.xRatio, this.initialXRatio = i.initialXRatio, this.yRatio = i.yRatio, this.invertedXRatio = i.invertedXRatio, this.invertedYRatio = i.invertedYRatio, this.baseLineY = i.baseLineY, this.baseLineInvertedY = i.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new j(this)
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t, e) {
                            var i = this.w,
                                n = new _(this.ctx),
                                s = new k(this.ctx, i);
                            t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                            var r = n.group({
                                class: "apexcharts-bar-series apexcharts-plot-series"
                            });
                            i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
                            for (var a = 0, o = 0; a < t.length; a++, o++) {
                                var l, c, u, d, p = void 0,
                                    f = void 0,
                                    g = [],
                                    m = [],
                                    b = i.globals.comboCharts ? e[a] : a,
                                    v = n.group({
                                        class: "apexcharts-series",
                                        rel: a + 1,
                                        seriesName: y.escapeString(i.globals.seriesNames[b]),
                                        "data:realIndex": b
                                    });
                                this.ctx.series.addCollapsedClassToSeries(v, b), t[a].length > 0 && (this.visibleI = this.visibleI + 1);
                                var x = 0,
                                    w = 0;
                                this.yRatio.length > 1 && (this.yaxisIndex = b), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
                                var C = this.barHelpers.initialPositions();
                                f = C.y, x = C.barHeight, c = C.yDivision, d = C.zeroW, p = C.x, w = C.barWidth, l = C.xDivision, u = C.zeroH, this.horizontal || m.push(p + w / 2);
                                for (var S = n.group({
                                        class: "apexcharts-datalabels",
                                        "data:realIndex": b
                                    }), A = 0; A < i.globals.dataPoints; A++) {
                                    var O = this.barHelpers.getStrokeWidth(a, A, b),
                                        E = null,
                                        P = {
                                            indexes: {
                                                i: a,
                                                j: A,
                                                realIndex: b,
                                                bc: o
                                            },
                                            x: p,
                                            y: f,
                                            strokeWidth: O,
                                            elSeries: v
                                        };
                                    this.isHorizontal ? (E = this.drawBarPaths(h(h({}, P), {}, {
                                        barHeight: x,
                                        zeroW: d,
                                        yDivision: c
                                    })), w = this.series[a][A] / this.invertedYRatio) : (E = this.drawColumnPaths(h(h({}, P), {}, {
                                        xDivision: l,
                                        barWidth: w,
                                        zeroH: u
                                    })), x = this.series[a][A] / this.yRatio[this.yaxisIndex]), f = E.y, p = E.x, A > 0 && m.push(p + w / 2), g.push(f);
                                    var T = this.barHelpers.getPathFillColor(t, a, A, b);
                                    this.renderSeries({
                                        realIndex: b,
                                        pathFill: T,
                                        j: A,
                                        i: a,
                                        pathFrom: E.pathFrom,
                                        pathTo: E.pathTo,
                                        strokeWidth: O,
                                        elSeries: v,
                                        x: p,
                                        y: f,
                                        series: t,
                                        barHeight: x,
                                        barWidth: w,
                                        elDataLabelsWrap: S,
                                        visibleSeries: this.visibleI,
                                        type: "bar"
                                    })
                                }
                                i.globals.seriesXvalues[b] = m, i.globals.seriesYvalues[b] = g, r.add(v)
                            }
                            return r
                        }
                    }, {
                        key: "renderSeries",
                        value: function(t) {
                            var e = t.realIndex,
                                i = t.pathFill,
                                n = t.lineFill,
                                s = t.j,
                                r = t.i,
                                a = t.pathFrom,
                                o = t.pathTo,
                                l = t.strokeWidth,
                                c = t.elSeries,
                                h = t.x,
                                u = t.y,
                                d = t.y1,
                                p = t.y2,
                                f = t.series,
                                g = t.barHeight,
                                m = t.barWidth,
                                b = t.barYPosition,
                                y = t.elDataLabelsWrap,
                                v = t.visibleSeries,
                                w = t.type,
                                C = this.w,
                                k = new _(this.ctx);
                            n || (n = this.barOptions.distributed ? C.globals.stroke.colors[s] : C.globals.stroke.colors[e]), C.config.series[r].data[s] && C.config.series[r].data[s].strokeColor && (n = C.config.series[r].data[s].strokeColor), this.isNullValue && (i = "none");
                            var S = k.renderPaths({
                                i: r,
                                j: s,
                                realIndex: e,
                                pathFrom: a,
                                pathTo: o,
                                stroke: n,
                                strokeWidth: l,
                                strokeLineCap: C.config.stroke.lineCap,
                                fill: i,
                                animationDelay: s / C.config.chart.animations.animateGradually.delay * (C.config.chart.animations.speed / C.globals.dataPoints) / 2.4,
                                initialSpeed: C.config.chart.animations.speed,
                                dataChangeSpeed: C.config.chart.animations.dynamicAnimation.speed,
                                className: "apexcharts-".concat(w, "-area")
                            });
                            S.attr("clip-path", "url(#gridRectMask".concat(C.globals.cuid, ")")), void 0 !== d && void 0 !== p && (S.attr("data-range-y1", d), S.attr("data-range-y2", p)), new x(this.ctx).setSelectionFilter(S, e, s), c.add(S);
                            var A = new L(this).handleBarDataLabels({
                                x: h,
                                y: u,
                                y1: d,
                                y2: p,
                                i: r,
                                j: s,
                                series: f,
                                realIndex: e,
                                barHeight: g,
                                barWidth: m,
                                barYPosition: b,
                                renderedPath: S,
                                visibleSeries: v
                            });
                            return null !== A && y.add(A), c.add(y), c
                        }
                    }, {
                        key: "drawBarPaths",
                        value: function(t) {
                            var e, i = t.indexes,
                                n = t.barHeight,
                                s = t.zeroW,
                                r = t.y,
                                a = t.yDivision,
                                o = t.elSeries,
                                l = this.w,
                                c = i.i,
                                h = i.j;
                            l.globals.isXNumeric && (r = (l.globals.seriesX[c][h] - l.globals.minX) / this.invertedXRatio - n);
                            var u = r + n * this.visibleI,
                                d = this.barHelpers.getBarpaths({
                                    barYPosition: u,
                                    barHeight: n,
                                    x1: s,
                                    x2: e = null == this.series[c][h] ? s : s + this.series[c][h] / this.invertedYRatio - 2 * (this.isReversed ? this.series[c][h] / this.invertedYRatio : 0),
                                    strokeWidth: t.strokeWidth,
                                    series: this.series,
                                    realIndex: i.realIndex,
                                    i: c,
                                    j: h,
                                    w: l
                                });
                            return l.globals.isXNumeric || (r += a), this.barHelpers.barBackground({
                                j: h,
                                i: c,
                                y1: u - n * this.visibleI,
                                y2: n * this.seriesLen,
                                elSeries: o
                            }), {
                                pathTo: d.pathTo,
                                pathFrom: d.pathFrom,
                                x: e,
                                y: r,
                                barYPosition: u
                            }
                        }
                    }, {
                        key: "drawColumnPaths",
                        value: function(t) {
                            var e, i = t.indexes,
                                n = t.x,
                                s = t.xDivision,
                                r = t.barWidth,
                                a = t.zeroH,
                                o = t.strokeWidth,
                                l = t.elSeries,
                                c = this.w,
                                h = i.realIndex,
                                u = i.i,
                                d = i.j,
                                p = i.bc;
                            if (c.globals.isXNumeric) {
                                var f = h;
                                c.globals.seriesX[h].length || (f = c.globals.maxValsInArrayIndex), n = (c.globals.seriesX[f][d] - c.globals.minX) / this.xRatio - r * this.seriesLen / 2
                            }
                            var g = n + r * this.visibleI,
                                m = this.barHelpers.getColumnPaths({
                                    barXPosition: g,
                                    barWidth: r,
                                    y1: a,
                                    y2: e = null == this.series[u][d] ? a : a - this.series[u][d] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[u][d] / this.yRatio[this.yaxisIndex] : 0),
                                    strokeWidth: o,
                                    series: this.series,
                                    realIndex: i.realIndex,
                                    i: u,
                                    j: d,
                                    w: c
                                });
                            return c.globals.isXNumeric || (n += s), this.barHelpers.barBackground({
                                bc: p,
                                j: d,
                                i: u,
                                x1: g - o / 2 - r * this.visibleI,
                                x2: r * this.seriesLen + o / 2,
                                elSeries: l
                            }), {
                                pathTo: m.pathTo,
                                pathFrom: m.pathFrom,
                                x: n,
                                y: e,
                                barXPosition: g
                            }
                        }
                    }, {
                        key: "getPreviousPath",
                        value: function(t, e) {
                            for (var i, n = this.w, s = 0; s < n.globals.previousPaths.length; s++) {
                                var r = n.globals.previousPaths[s];
                                r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== n.globals.previousPaths[s].paths[e] && (i = n.globals.previousPaths[s].paths[e].d)
                            }
                            return i
                        }
                    }]), t
                }(),
                N = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
                    }
                    return o(t, [{
                        key: "isValidDate",
                        value: function(t) {
                            return !isNaN(this.parseDate(t))
                        }
                    }, {
                        key: "getTimeStamp",
                        value: function(t) {
                            return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t
                        }
                    }, {
                        key: "getDate",
                        value: function(t) {
                            return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t)
                        }
                    }, {
                        key: "parseDate",
                        value: function(t) {
                            var e = Date.parse(t);
                            if (!isNaN(e)) return this.getTimeStamp(t);
                            var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                            return this.getTimeStamp(i)
                        }
                    }, {
                        key: "parseDateWithTimezone",
                        value: function(t) {
                            return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
                        }
                    }, {
                        key: "formatDate",
                        value: function(t, e) {
                            var i = this.w.globals.locale,
                                n = this.w.config.xaxis.labels.datetimeUTC,
                                s = ["\0"].concat(m(i.months)),
                                r = ["\x01"].concat(m(i.shortMonths)),
                                a = ["\x02"].concat(m(i.days)),
                                o = ["\x03"].concat(m(i.shortDays));

                            function l(t, e) {
                                var i = t + "";
                                for (e = e || 2; i.length < e;) i = "0" + i;
                                return i
                            }
                            var c = n ? t.getUTCFullYear() : t.getFullYear();
                            e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
                            var h = (n ? t.getUTCMonth() : t.getMonth()) + 1;
                            e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + s[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(h))).replace(/(^|[^\\])M/g, "$1" + h);
                            var u = n ? t.getUTCDate() : t.getDate();
                            e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + a[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + l(u))).replace(/(^|[^\\])d/g, "$1" + u);
                            var d = n ? t.getUTCHours() : t.getHours(),
                                p = d > 12 ? d - 12 : 0 === d ? 12 : d;
                            e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(d))).replace(/(^|[^\\])H/g, "$1" + d)).replace(/(^|[^\\])hh+/g, "$1" + l(p))).replace(/(^|[^\\])h/g, "$1" + p);
                            var f = n ? t.getUTCMinutes() : t.getMinutes();
                            e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(f))).replace(/(^|[^\\])m/g, "$1" + f);
                            var g = n ? t.getUTCSeconds() : t.getSeconds();
                            e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(g))).replace(/(^|[^\\])s/g, "$1" + g);
                            var b = n ? t.getUTCMilliseconds() : t.getMilliseconds();
                            e = e.replace(/(^|[^\\])fff+/g, "$1" + l(b, 3)), b = Math.round(b / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + l(b)), b = Math.round(b / 10);
                            var y = d < 12 ? "AM" : "PM";
                            e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + b)).replace(/(^|[^\\])TT+/g, "$1" + y)).replace(/(^|[^\\])T/g, "$1" + y.charAt(0));
                            var v = y.toLowerCase();
                            e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + v)).replace(/(^|[^\\])t/g, "$1" + v.charAt(0));
                            var x = -t.getTimezoneOffset(),
                                _ = n || !x ? "Z" : x > 0 ? "+" : "-";
                            if (!n) {
                                var w = (x = Math.abs(x)) % 60;
                                _ += l(Math.floor(x / 60)) + ":" + l(w)
                            }
                            e = e.replace(/(^|[^\\])K/g, "$1" + _);
                            var C = (n ? t.getUTCDay() : t.getDay()) + 1;
                            return (e = (e = (e = (e = e.replace(new RegExp(a[0], "g"), a[C])).replace(new RegExp(o[0], "g"), o[C])).replace(new RegExp(s[0], "g"), s[h])).replace(new RegExp(r[0], "g"), r[h])).replace(/\\(.)/g, "$1")
                        }
                    }, {
                        key: "getTimeUnitsfromTimestamp",
                        value: function(t, e, i) {
                            var n = this.w;
                            void 0 !== n.config.xaxis.min && (t = n.config.xaxis.min), void 0 !== n.config.xaxis.max && (e = n.config.xaxis.max);
                            var s = this.getDate(t),
                                r = this.getDate(e),
                                a = this.formatDate(s, "yyyy MM dd HH mm ss fff").split(" "),
                                o = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" ");
                            return {
                                minMillisecond: parseInt(a[6], 10),
                                maxMillisecond: parseInt(o[6], 10),
                                minSecond: parseInt(a[5], 10),
                                maxSecond: parseInt(o[5], 10),
                                minMinute: parseInt(a[4], 10),
                                maxMinute: parseInt(o[4], 10),
                                minHour: parseInt(a[3], 10),
                                maxHour: parseInt(o[3], 10),
                                minDate: parseInt(a[2], 10),
                                maxDate: parseInt(o[2], 10),
                                minMonth: parseInt(a[1], 10) - 1,
                                maxMonth: parseInt(o[1], 10) - 1,
                                minYear: parseInt(a[0], 10),
                                maxYear: parseInt(o[0], 10)
                            }
                        }
                    }, {
                        key: "isLeapYear",
                        value: function(t) {
                            return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
                        }
                    }, {
                        key: "calculcateLastDaysOfMonth",
                        value: function(t, e, i) {
                            return this.determineDaysOfMonths(t, e) - i
                        }
                    }, {
                        key: "determineDaysOfYear",
                        value: function(t) {
                            var e = 365;
                            return this.isLeapYear(t) && (e = 366), e
                        }
                    }, {
                        key: "determineRemainingDaysOfYear",
                        value: function(t, e, i) {
                            var n = this.daysCntOfYear[e] + i;
                            return e > 1 && this.isLeapYear() && n++, n
                        }
                    }, {
                        key: "determineDaysOfMonths",
                        value: function(t, e) {
                            var i = 30;
                            switch (t = y.monthMod(t), !0) {
                                case this.months30.indexOf(t) > -1:
                                    2 === t && (i = this.isLeapYear(e) ? 29 : 28);
                                    break;
                                case this.months31.indexOf(t) > -1:
                                default:
                                    i = 31
                            }
                            return i
                        }
                    }]), t
                }(),
                z = function(t) {
                    u(i, F);
                    var e = g(i);

                    function i() {
                        return r(this, i), e.apply(this, arguments)
                    }
                    return o(i, [{
                        key: "draw",
                        value: function(t, e) {
                            var i = this.w,
                                n = new _(this.ctx);
                            this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t);
                            for (var s = n.group({
                                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                                }), r = 0; r < t.length; r++) {
                                var a, o, l, c = void 0,
                                    u = void 0,
                                    d = void 0,
                                    p = i.globals.comboCharts ? e[r] : r,
                                    f = n.group({
                                        class: "apexcharts-series",
                                        seriesName: y.escapeString(i.globals.seriesNames[p]),
                                        rel: r + 1,
                                        "data:realIndex": p
                                    });
                                t[r].length > 0 && (this.visibleI = this.visibleI + 1);
                                var g = 0,
                                    m = 0;
                                this.yRatio.length > 1 && (this.yaxisIndex = p);
                                var b = this.barHelpers.initialPositions();
                                u = b.y, l = b.zeroW, c = b.x, m = b.barWidth, a = b.xDivision, o = b.zeroH;
                                for (var v = n.group({
                                        class: "apexcharts-datalabels",
                                        "data:realIndex": p
                                    }), x = 0; x < i.globals.dataPoints; x++) {
                                    var w = this.barHelpers.getStrokeWidth(r, x, p),
                                        C = this.seriesRangeStart[r][x],
                                        k = this.seriesRangeEnd[r][x],
                                        S = null,
                                        A = null,
                                        O = {
                                            x: c,
                                            y: u,
                                            strokeWidth: w,
                                            elSeries: f
                                        };
                                    if (d = b.yDivision, g = b.barHeight, this.isHorizontal) {
                                        A = u + g * this.visibleI;
                                        var E = this.seriesLen;
                                        i.config.plotOptions.bar.rangeBarGroupRows && (E = 1);
                                        var P = (d - g * E) / 2;
                                        if (void 0 === i.config.series[r].data[x]) break;
                                        if (this.isTimelineBar && i.config.series[r].data[x].x) {
                                            var T = this.detectOverlappingBars({
                                                i: r,
                                                j: x,
                                                barYPosition: A,
                                                srty: P,
                                                barHeight: g,
                                                yDivision: d,
                                                initPositions: b
                                            });
                                            g = T.barHeight, A = T.barYPosition
                                        }
                                        m = (S = this.drawRangeBarPaths(h({
                                            indexes: {
                                                i: r,
                                                j: x,
                                                realIndex: p
                                            },
                                            barHeight: g,
                                            barYPosition: A,
                                            zeroW: l,
                                            yDivision: d,
                                            y1: C,
                                            y2: k
                                        }, O))).barWidth
                                    } else g = (S = this.drawRangeColumnPaths(h({
                                        indexes: {
                                            i: r,
                                            j: x,
                                            realIndex: p
                                        },
                                        zeroH: o,
                                        barWidth: m,
                                        xDivision: a
                                    }, O))).barHeight;
                                    u = S.y, c = S.x;
                                    var D = this.barHelpers.getPathFillColor(t, r, x, p);
                                    this.renderSeries({
                                        realIndex: p,
                                        pathFill: D,
                                        lineFill: i.globals.stroke.colors[p],
                                        j: x,
                                        i: r,
                                        x: c,
                                        y: u,
                                        y1: C,
                                        y2: k,
                                        pathFrom: S.pathFrom,
                                        pathTo: S.pathTo,
                                        strokeWidth: w,
                                        elSeries: f,
                                        series: t,
                                        barHeight: g,
                                        barYPosition: A,
                                        barWidth: m,
                                        elDataLabelsWrap: v,
                                        visibleSeries: this.visibleI,
                                        type: "rangebar"
                                    })
                                }
                                s.add(f)
                            }
                            return s
                        }
                    }, {
                        key: "detectOverlappingBars",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                n = t.barYPosition,
                                s = t.srty,
                                r = t.barHeight,
                                a = t.yDivision,
                                o = t.initPositions,
                                l = this.w,
                                c = [],
                                h = l.config.series[e].data[i].rangeName,
                                u = l.config.series[e].data[i].x,
                                d = l.globals.labels.indexOf(u),
                                p = l.globals.seriesRangeBarTimeline[e].findIndex(function(t) {
                                    return t.x === u && t.overlaps.length > 0
                                });
                            return n = l.config.plotOptions.bar.rangeBarGroupRows ? s + a * d : s + r * this.visibleI + a * d, p > -1 && !l.config.plotOptions.bar.rangeBarOverlap && (c = l.globals.seriesRangeBarTimeline[e][p].overlaps).indexOf(h) > -1 && (n = (r = o.barHeight / c.length) * this.visibleI + a * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + c.indexOf(h)) + a * d), {
                                barYPosition: n,
                                barHeight: r
                            }
                        }
                    }, {
                        key: "drawRangeColumnPaths",
                        value: function(t) {
                            var e = t.indexes,
                                i = t.x,
                                n = t.xDivision,
                                s = t.barWidth,
                                r = t.zeroH,
                                a = this.w,
                                o = e.i,
                                l = e.j,
                                c = this.yRatio[this.yaxisIndex],
                                h = e.realIndex,
                                u = this.getRangeValue(h, l),
                                d = Math.min(u.start, u.end),
                                p = Math.max(u.start, u.end);
                            a.globals.isXNumeric && (i = (a.globals.seriesX[o][l] - a.globals.minX) / this.xRatio - s / 2);
                            var f = i + s * this.visibleI;
                            null == this.series[o][l] ? d = r : (d = r - d / c, p = r - p / c);
                            var g = Math.abs(p - d),
                                m = this.barHelpers.getColumnPaths({
                                    barXPosition: f,
                                    barWidth: s,
                                    y1: d,
                                    y2: p,
                                    strokeWidth: this.strokeWidth,
                                    series: this.seriesRangeEnd,
                                    realIndex: e.realIndex,
                                    i: h,
                                    j: l,
                                    w: a
                                });
                            return a.globals.isXNumeric || (i += n), {
                                pathTo: m.pathTo,
                                pathFrom: m.pathFrom,
                                barHeight: g,
                                x: i,
                                y: p,
                                barXPosition: f
                            }
                        }
                    }, {
                        key: "drawRangeBarPaths",
                        value: function(t) {
                            var e = t.indexes,
                                i = t.y,
                                n = t.yDivision,
                                s = t.barHeight,
                                r = t.barYPosition,
                                a = t.zeroW,
                                o = this.w,
                                l = a + t.y1 / this.invertedYRatio,
                                c = a + t.y2 / this.invertedYRatio,
                                h = Math.abs(c - l),
                                u = this.barHelpers.getBarpaths({
                                    barYPosition: r,
                                    barHeight: s,
                                    x1: l,
                                    x2: c,
                                    strokeWidth: this.strokeWidth,
                                    series: this.seriesRangeEnd,
                                    i: e.realIndex,
                                    realIndex: e.realIndex,
                                    j: e.j,
                                    w: o
                                });
                            return o.globals.isXNumeric || (i += n), {
                                pathTo: u.pathTo,
                                pathFrom: u.pathFrom,
                                barWidth: h,
                                x: c,
                                y: i
                            }
                        }
                    }, {
                        key: "getRangeValue",
                        value: function(t, e) {
                            var i = this.w;
                            return {
                                start: i.globals.seriesRangeStart[t][e],
                                end: i.globals.seriesRangeEnd[t][e]
                            }
                        }
                    }, {
                        key: "getTooltipValues",
                        value: function(t) {
                            var e = t.ctx,
                                i = t.seriesIndex,
                                n = t.dataPointIndex,
                                s = t.y1,
                                r = t.y2,
                                a = t.w,
                                o = a.globals.seriesRangeStart[i][n],
                                l = a.globals.seriesRangeEnd[i][n],
                                c = a.globals.labels[n],
                                h = a.config.series[i].name ? a.config.series[i].name : "",
                                u = a.config.tooltip.y.formatter,
                                d = a.config.tooltip.y.title.formatter,
                                p = {
                                    w: a,
                                    seriesIndex: i,
                                    dataPointIndex: n,
                                    start: o,
                                    end: l
                                };
                            "function" == typeof d && (h = d(h, p)), Number.isFinite(s) && Number.isFinite(r) && (o = s, l = r, a.config.series[i].data[n].x && (c = a.config.series[i].data[n].x + ":"), "function" == typeof u && (c = u(c, p)));
                            var f = "",
                                g = "",
                                m = a.globals.colors[i];
                            if (void 0 === a.config.tooltip.x.formatter)
                                if ("datetime" === a.config.xaxis.type) {
                                    var b = new N(e);
                                    f = b.formatDate(b.getDate(o), a.config.tooltip.x.format), g = b.formatDate(b.getDate(l), a.config.tooltip.x.format)
                                } else f = o, g = l;
                            else f = a.config.tooltip.x.formatter(o), g = a.config.tooltip.x.formatter(l);
                            return {
                                start: o,
                                end: l,
                                startVal: f,
                                endVal: g,
                                ylabel: c,
                                color: m,
                                seriesName: h
                            }
                        }
                    }, {
                        key: "buildCustomTooltipHTML",
                        value: function(t) {
                            return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t.color + '">' + (t.seriesName || "") + '</span></div><div> <span class="category">' + t.ylabel + ' </span> <span class="value start-value">' + t.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t.end + "</span></div></div>"
                        }
                    }]), i
                }(),
                V = function() {
                    function t(e) {
                        r(this, t), this.opts = e
                    }
                    return o(t, [{
                        key: "line",
                        value: function() {
                            return {
                                chart: {
                                    animations: {
                                        easing: "swing"
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                stroke: {
                                    width: 5,
                                    curve: "straight"
                                },
                                markers: {
                                    size: 0,
                                    hover: {
                                        sizeOffset: 6
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "sparkline",
                        value: function(t) {
                            return this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0, y.extend(t, {
                                grid: {
                                    show: !1,
                                    padding: {
                                        left: 0,
                                        right: 0,
                                        top: 0,
                                        bottom: 0
                                    }
                                },
                                legend: {
                                    show: !1
                                },
                                xaxis: {
                                    labels: {
                                        show: !1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    axisBorder: {
                                        show: !1
                                    },
                                    axisTicks: {
                                        show: !1
                                    }
                                },
                                chart: {
                                    toolbar: {
                                        show: !1
                                    },
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                }
                            })
                        }
                    }, {
                        key: "bar",
                        value: function() {
                            return {
                                chart: {
                                    stacked: !1,
                                    animations: {
                                        easing: "swing"
                                    }
                                },
                                plotOptions: {
                                    bar: {
                                        dataLabels: {
                                            position: "center"
                                        }
                                    }
                                },
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    }
                                },
                                stroke: {
                                    width: 0,
                                    lineCap: "round"
                                },
                                fill: {
                                    opacity: .85
                                },
                                legend: {
                                    markers: {
                                        shape: "square",
                                        radius: 2,
                                        size: 8
                                    }
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                xaxis: {
                                    tooltip: {
                                        enabled: !1
                                    },
                                    tickPlacement: "between",
                                    crosshairs: {
                                        width: "barWidth",
                                        position: "back",
                                        fill: {
                                            type: "gradient"
                                        },
                                        dropShadow: {
                                            enabled: !1
                                        },
                                        stroke: {
                                            width: 0
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "candlestick",
                        value: function() {
                            var t = this;
                            return {
                                stroke: {
                                    width: 1,
                                    colors: ["#333"]
                                },
                                fill: {
                                    opacity: 1
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !0,
                                    custom: function(e) {
                                        return t._getBoxTooltip(e.w, e.seriesIndex, e.dataPointIndex, ["Open", "High", "", "Low", "Close"], "candlestick")
                                    }
                                },
                                states: {
                                    active: {
                                        filter: {
                                            type: "none"
                                        }
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "boxPlot",
                        value: function() {
                            var t = this;
                            return {
                                chart: {
                                    animations: {
                                        dynamicAnimation: {
                                            enabled: !1
                                        }
                                    }
                                },
                                stroke: {
                                    width: 1,
                                    colors: ["#24292e"]
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !0,
                                    custom: function(e) {
                                        return t._getBoxTooltip(e.w, e.seriesIndex, e.dataPointIndex, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                                    }
                                },
                                markers: {
                                    size: 5,
                                    strokeWidth: 1,
                                    strokeColors: "#111"
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "rangeBar",
                        value: function() {
                            return {
                                stroke: {
                                    width: 0,
                                    lineCap: "square"
                                },
                                plotOptions: {
                                    bar: {
                                        borderRadius: 0,
                                        dataLabels: {
                                            position: "center"
                                        }
                                    }
                                },
                                dataLabels: {
                                    enabled: !1,
                                    formatter: function(t, e) {
                                        var i = e.seriesIndex,
                                            n = e.dataPointIndex,
                                            s = e.w;
                                        return s.globals.seriesRangeEnd[i][n] - s.globals.seriesRangeStart[i][n]
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                tooltip: {
                                    shared: !1,
                                    followCursor: !0,
                                    custom: function(t) {
                                        return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function(t) {
                                            var e = new z(t.ctx, null),
                                                i = e.getTooltipValues(t);
                                            return e.buildCustomTooltipHTML({
                                                color: i.color,
                                                seriesName: i.seriesName,
                                                ylabel: i.ylabel,
                                                start: i.startVal,
                                                end: i.endVal
                                            })
                                        }(t) : function(t) {
                                            var e = new z(t.ctx, null),
                                                i = e.getTooltipValues(t);
                                            return e.buildCustomTooltipHTML({
                                                color: i.color,
                                                seriesName: i.seriesName,
                                                ylabel: i.ylabel,
                                                start: i.start,
                                                end: i.end
                                            })
                                        }(t)
                                    }
                                },
                                xaxis: {
                                    tickPlacement: "between",
                                    tooltip: {
                                        enabled: !1
                                    },
                                    crosshairs: {
                                        stroke: {
                                            width: 0
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "area",
                        value: function() {
                            return {
                                stroke: {
                                    width: 4
                                },
                                fill: {
                                    type: "gradient",
                                    gradient: {
                                        inverseColors: !1,
                                        shade: "light",
                                        type: "vertical",
                                        opacityFrom: .65,
                                        opacityTo: .5,
                                        stops: [0, 100, 100]
                                    }
                                },
                                markers: {
                                    size: 0,
                                    hover: {
                                        sizeOffset: 6
                                    }
                                },
                                tooltip: {
                                    followCursor: !1
                                }
                            }
                        }
                    }, {
                        key: "brush",
                        value: function(t) {
                            return y.extend(t, {
                                chart: {
                                    toolbar: {
                                        autoSelected: "selection",
                                        show: !1
                                    },
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    enabled: !1
                                },
                                stroke: {
                                    width: 1
                                },
                                tooltip: {
                                    enabled: !1
                                },
                                xaxis: {
                                    tooltip: {
                                        enabled: !1
                                    }
                                }
                            })
                        }
                    }, {
                        key: "stacked100",
                        value: function(t) {
                            t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
                            var e = t.dataLabels.formatter;
                            return t.yaxis.forEach(function(e, i) {
                                t.yaxis[i].min = 0, t.yaxis[i].max = 100
                            }), "bar" === t.chart.type && (t.dataLabels.formatter = e || function(t) {
                                return "number" == typeof t && t ? t.toFixed(0) + "%" : t
                            }), t
                        }
                    }, {
                        key: "convertCatToNumeric",
                        value: function(t) {
                            return t.xaxis.convertedCatToNumeric = !0, t
                        }
                    }, {
                        key: "convertCatToNumericXaxis",
                        value: function(t, e, i) {
                            t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(t) {
                                return y.isNumber(t) ? Math.floor(t) : t
                            };
                            var n = t.xaxis.labels.formatter,
                                s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
                            return i && i.length && (s = i.map(function(t) {
                                return Array.isArray(t) ? t : String(t)
                            })), s && s.length && (t.xaxis.labels.formatter = function(t) {
                                return y.isNumber(t) ? n(s[Math.floor(t) - 1]) : n(t)
                            }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t
                        }
                    }, {
                        key: "bubble",
                        value: function() {
                            return {
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                xaxis: {
                                    crosshairs: {
                                        width: 0
                                    }
                                },
                                fill: {
                                    type: "solid",
                                    gradient: {
                                        shade: "light",
                                        inverse: !0,
                                        shadeIntensity: .55,
                                        opacityFrom: .4,
                                        opacityTo: .8
                                    }
                                }
                            }
                        }
                    }, {
                        key: "scatter",
                        value: function() {
                            return {
                                dataLabels: {
                                    enabled: !1
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0
                                },
                                markers: {
                                    size: 6,
                                    strokeWidth: 1,
                                    hover: {
                                        sizeOffset: 2
                                    }
                                }
                            }
                        }
                    }, {
                        key: "heatmap",
                        value: function() {
                            return {
                                chart: {
                                    stacked: !1
                                },
                                fill: {
                                    opacity: 1
                                },
                                dataLabels: {
                                    style: {
                                        colors: ["#fff"]
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                tooltip: {
                                    followCursor: !0,
                                    marker: {
                                        show: !1
                                    },
                                    x: {
                                        show: !1
                                    }
                                },
                                legend: {
                                    position: "top",
                                    markers: {
                                        shape: "square",
                                        size: 10,
                                        offsetY: 2
                                    }
                                },
                                grid: {
                                    padding: {
                                        right: 20
                                    }
                                }
                            }
                        }
                    }, {
                        key: "treemap",
                        value: function() {
                            return {
                                chart: {
                                    zoom: {
                                        enabled: !1
                                    }
                                },
                                dataLabels: {
                                    style: {
                                        fontSize: 14,
                                        fontWeight: 600,
                                        colors: ["#fff"]
                                    }
                                },
                                stroke: {
                                    show: !0,
                                    width: 2,
                                    colors: ["#fff"]
                                },
                                legend: {
                                    show: !1
                                },
                                fill: {
                                    gradient: {
                                        stops: [0, 100]
                                    }
                                },
                                tooltip: {
                                    followCursor: !0,
                                    x: {
                                        show: !1
                                    }
                                },
                                grid: {
                                    padding: {
                                        left: 0,
                                        right: 0
                                    }
                                },
                                xaxis: {
                                    crosshairs: {
                                        show: !1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "pie",
                        value: function() {
                            return {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                plotOptions: {
                                    pie: {
                                        donut: {
                                            labels: {
                                                show: !1
                                            }
                                        }
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    dropShadow: {
                                        enabled: !0
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                fill: {
                                    opacity: 1,
                                    gradient: {
                                        shade: "light",
                                        stops: [0, 100]
                                    }
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "donut",
                        value: function() {
                            return {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    style: {
                                        colors: ["#fff"]
                                    },
                                    background: {
                                        enabled: !1
                                    },
                                    dropShadow: {
                                        enabled: !0
                                    }
                                },
                                stroke: {
                                    colors: ["#fff"]
                                },
                                fill: {
                                    opacity: 1,
                                    gradient: {
                                        shade: "light",
                                        shadeIntensity: .35,
                                        stops: [80, 100],
                                        opacityFrom: 1,
                                        opacityTo: 1
                                    }
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "polarArea",
                        value: function() {
                            return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
                                chart: {
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                dataLabels: {
                                    formatter: function(t) {
                                        return t.toFixed(1) + "%"
                                    },
                                    enabled: !1
                                },
                                stroke: {
                                    show: !0,
                                    width: 2
                                },
                                fill: {
                                    opacity: .7
                                },
                                tooltip: {
                                    theme: "dark",
                                    fillSeriesColor: !0
                                },
                                legend: {
                                    position: "right"
                                }
                            }
                        }
                    }, {
                        key: "radar",
                        value: function() {
                            return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
                                dataLabels: {
                                    enabled: !1,
                                    style: {
                                        fontSize: "11px"
                                    }
                                },
                                stroke: {
                                    width: 2
                                },
                                markers: {
                                    size: 3,
                                    strokeWidth: 1,
                                    strokeOpacity: 1
                                },
                                fill: {
                                    opacity: .2
                                },
                                tooltip: {
                                    shared: !1,
                                    intersect: !0,
                                    followCursor: !0
                                },
                                grid: {
                                    show: !1
                                },
                                xaxis: {
                                    labels: {
                                        formatter: function(t) {
                                            return t
                                        },
                                        style: {
                                            colors: ["#a8a8a8"],
                                            fontSize: "11px"
                                        }
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    crosshairs: {
                                        show: !1
                                    }
                                }
                            }
                        }
                    }, {
                        key: "radialBar",
                        value: function() {
                            return {
                                chart: {
                                    animations: {
                                        dynamicAnimation: {
                                            enabled: !0,
                                            speed: 800
                                        }
                                    },
                                    toolbar: {
                                        show: !1
                                    }
                                },
                                fill: {
                                    gradient: {
                                        shade: "dark",
                                        shadeIntensity: .4,
                                        inverseColors: !1,
                                        type: "diagonal2",
                                        opacityFrom: 1,
                                        opacityTo: 1,
                                        stops: [70, 98, 100]
                                    }
                                },
                                legend: {
                                    show: !1,
                                    position: "right"
                                },
                                tooltip: {
                                    enabled: !1,
                                    fillSeriesColor: !0
                                }
                            }
                        }
                    }, {
                        key: "_getBoxTooltip",
                        value: function(t, e, i, n, s) {
                            var r = t.globals.seriesCandleO[e][i],
                                a = t.globals.seriesCandleH[e][i],
                                o = t.globals.seriesCandleM[e][i],
                                l = t.globals.seriesCandleL[e][i],
                                c = t.globals.seriesCandleC[e][i];
                            return t.config.series[e].type && t.config.series[e].type !== s ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name ? t.config.series[e].name : "series-" + (e + 1), ": <strong>").concat(t.globals.series[e][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(n[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(n[1], ': <span class="value">') + a + "</span></div>" + (o ? "<div>".concat(n[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(n[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(n[4], ': <span class="value">') + c + "</span></div></div>"
                        }
                    }]), t
                }(),
                B = function() {
                    function t(e) {
                        r(this, t), this.opts = e
                    }
                    return o(t, [{
                        key: "init",
                        value: function(t) {
                            var e = t.responsiveOverride,
                                i = this.opts,
                                n = new E,
                                r = new V(i);
                            this.chartType = i.chart.type, "histogram" === this.chartType && (i.chart.type = "bar", i = y.extend({
                                plotOptions: {
                                    bar: {
                                        columnWidth: "99.99%"
                                    }
                                }
                            }, i)), i = this.extendYAxis(i), i = this.extendAnnotations(i);
                            var a = n.init(),
                                o = {};
                            if (i && "object" === s(i)) {
                                var l = {};
                                l = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? r[i.chart.type]() : r.line(), i.chart.brush && i.chart.brush.enabled && (l = r.brush(l)), i.chart.stacked && "100%" === i.chart.stackType && (i = r.stacked100(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, e || (i.xaxis.convertedCatToNumeric = !1), ((i = this.checkForCatToNumericXAxis(this.chartType, l, i)).chart.sparkline && i.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = r.sparkline(l)), o = y.extend(a, l)
                            }
                            var c = y.extend(o, window.Apex);
                            return a = y.extend(c, i), this.handleUserInputErrors(a)
                        }
                    }, {
                        key: "checkForCatToNumericXAxis",
                        value: function(t, e, i) {
                            var n = new V(i);
                            return "bar" === t && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal || "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t || !("datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type) || "between" === (i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement) || (i = n.convertCatToNumeric(i)), i
                        }
                    }, {
                        key: "extendYAxis",
                        value: function(t, e) {
                            var i = new E;
                            (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = y.extend(t.yaxis, window.Apex.yaxis)), t.yaxis = t.yaxis.constructor !== Array ? [y.extend(i.yAxis, t.yaxis)] : y.extendArray(t.yaxis, i.yAxis);
                            var n = !1;
                            t.yaxis.forEach(function(t) {
                                t.logarithmic && (n = !0)
                            });
                            var s = t.series;
                            return e && !s && (s = e.config.series), n && s.length !== t.yaxis.length && s.length && (t.yaxis = s.map(function(e, n) {
                                if (e.name || (s[n].name = "series-".concat(n + 1)), t.yaxis[n]) return t.yaxis[n].seriesName = s[n].name, t.yaxis[n];
                                var r = y.extend(i.yAxis, t.yaxis[0]);
                                return r.show = !1, r
                            })), n && s.length > 1 && s.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t
                        }
                    }, {
                        key: "extendAnnotations",
                        value: function(t) {
                            return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), this.extendPointAnnotations(t)
                        }
                    }, {
                        key: "extendYAxisAnnotations",
                        value: function(t) {
                            var e = new E;
                            return t.annotations.yaxis = y.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t
                        }
                    }, {
                        key: "extendXAxisAnnotations",
                        value: function(t) {
                            var e = new E;
                            return t.annotations.xaxis = y.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t
                        }
                    }, {
                        key: "extendPointAnnotations",
                        value: function(t) {
                            var e = new E;
                            return t.annotations.points = y.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t
                        }
                    }, {
                        key: "checkForDarkTheme",
                        value: function(t) {
                            t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"))
                        }
                    }, {
                        key: "handleUserInputErrors",
                        value: function(t) {
                            var e = t;
                            if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                            if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
                                if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                                e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1
                            }
                            return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && "barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e.chart.type && "boxPlot" !== e.chart.type || e.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")), e.yaxis[0].reversed = !1), e.chart.group && 0 === e.yaxis[0].labels.minWidth && console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."), Array.isArray(e.stroke.width) && "line" !== e.chart.type && "area" !== e.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"), e.stroke.width = e.stroke.width[0]), e
                        }
                    }]), t
                }(),
                H = function() {
                    function t() {
                        r(this, t)
                    }
                    return o(t, [{
                        key: "initGlobalVars",
                        value: function(t) {
                            t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0
                        }
                    }, {
                        key: "globalVars",
                        value: function(t) {
                            return {
                                chartID: null,
                                cuid: null,
                                events: {
                                    beforeMount: [],
                                    mounted: [],
                                    updated: [],
                                    clicked: [],
                                    selection: [],
                                    dataPointSelection: [],
                                    zoomed: [],
                                    scrolled: []
                                },
                                colors: [],
                                clientX: null,
                                clientY: null,
                                fill: {
                                    colors: []
                                },
                                stroke: {
                                    colors: []
                                },
                                dataLabels: {
                                    style: {
                                        colors: []
                                    }
                                },
                                radarPolygons: {
                                    fill: {
                                        colors: []
                                    }
                                },
                                markers: {
                                    colors: [],
                                    size: t.markers.size,
                                    largestSize: 0
                                },
                                animationEnded: !1,
                                isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                                isDirty: !1,
                                isExecCalled: !1,
                                initialConfig: null,
                                initialSeries: [],
                                lastXAxis: [],
                                lastYAxis: [],
                                columnSeries: null,
                                labels: [],
                                timescaleLabels: [],
                                noLabelsProvided: !1,
                                allSeriesCollapsed: !1,
                                collapsedSeries: [],
                                collapsedSeriesIndices: [],
                                ancillaryCollapsedSeries: [],
                                ancillaryCollapsedSeriesIndices: [],
                                risingSeries: [],
                                dataFormatXNumeric: !1,
                                capturedSeriesIndex: -1,
                                capturedDataPointIndex: -1,
                                selectedDataPoints: [],
                                goldenPadding: 35,
                                invalidLogScale: !1,
                                ignoreYAxisIndexes: [],
                                yAxisSameScaleIndices: [],
                                maxValsInArrayIndex: 0,
                                radialSize: 0,
                                selection: void 0,
                                zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
                                panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
                                selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
                                yaxis: null,
                                mousedown: !1,
                                lastClientPosition: {},
                                visibleXRange: void 0,
                                yValueDecimal: 0,
                                total: 0,
                                SVGNS: "http://www.w3.org/2000/svg",
                                svgWidth: 0,
                                svgHeight: 0,
                                noData: !1,
                                locale: {},
                                dom: {},
                                memory: {
                                    methodsToExec: []
                                },
                                shouldAnimate: !0,
                                skipLastTimelinelabel: !1,
                                skipFirstTimelinelabel: !1,
                                delayedElements: [],
                                axisCharts: !0,
                                isDataXYZ: !1,
                                resized: !1,
                                resizeTimer: null,
                                comboCharts: !1,
                                dataChanged: !1,
                                previousPaths: [],
                                allSeriesHasEqualX: !0,
                                pointsArray: [],
                                dataLabelsRects: [],
                                lastDrawnDataLabelsIndexes: [],
                                hasNullValues: !1,
                                easing: null,
                                zoomed: !1,
                                gridWidth: 0,
                                gridHeight: 0,
                                rotateXLabels: !1,
                                defaultLabels: !1,
                                xLabelFormatter: void 0,
                                yLabelFormatters: [],
                                xaxisTooltipFormatter: void 0,
                                ttKeyFormatter: void 0,
                                ttVal: void 0,
                                ttZFormatter: void 0,
                                LINE_HEIGHT_RATIO: 1.618,
                                xAxisLabelsHeight: 0,
                                xAxisLabelsWidth: 0,
                                yAxisLabelsWidth: 0,
                                scaleX: 1,
                                scaleY: 1,
                                translateX: 0,
                                translateY: 0,
                                translateYAxisX: [],
                                yAxisWidths: [],
                                translateXAxisY: 0,
                                translateXAxisX: 0,
                                tooltip: null
                            }
                        }
                    }, {
                        key: "init",
                        value: function(t) {
                            var e = this.globalVars(t);
                            return this.initGlobalVars(e), e.initialConfig = y.extend({}, t), e.initialSeries = y.clone(t.series), e.lastXAxis = y.clone(e.initialConfig.xaxis), e.lastYAxis = y.clone(e.initialConfig.yaxis), e
                        }
                    }]), t
                }(),
                U = function() {
                    function t(e) {
                        r(this, t), this.opts = e
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            var t = new B(this.opts).init({
                                responsiveOverride: !1
                            });
                            return {
                                config: t,
                                globals: (new H).init(t)
                            }
                        }
                    }]), t
                }(),
                X = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new k(this.ctx)
                    }
                    return o(t, [{
                        key: "isMultiFormat",
                        value: function() {
                            return this.isFormatXY() || this.isFormat2DArray()
                        }
                    }, {
                        key: "isFormatXY",
                        value: function() {
                            var t = this.w.config.series.slice(),
                                e = new R(this.ctx);
                            if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0
                        }
                    }, {
                        key: "isFormat2DArray",
                        value: function() {
                            var t = this.w.config.series.slice(),
                                e = new R(this.ctx);
                            if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null != t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0
                        }
                    }, {
                        key: "handleFormat2DArray",
                        value: function(t, e) {
                            for (var i = this.w.config, n = this.w.globals, s = "boxPlot" === i.chart.type || "boxPlot" === i.series[e].type, r = 0; r < t[e].data.length; r++)
                                if (void 0 !== t[e].data[r][1] && (Array.isArray(t[e].data[r][1]) && 4 === t[e].data[r][1].length && !s ? this.twoDSeries.push(y.parseNumber(t[e].data[r][1][3])) : this.twoDSeries.push(y.parseNumber(t[e].data[r].length >= 5 ? t[e].data[r][4] : t[e].data[r][1])), n.dataFormatXNumeric = !0), "datetime" === i.xaxis.type) {
                                    var a = new Date(t[e].data[r][0]);
                                    a = new Date(a).getTime(), this.twoDSeriesX.push(a)
                                } else this.twoDSeriesX.push(t[e].data[r][0]);
                            for (var o = 0; o < t[e].data.length; o++) void 0 !== t[e].data[o][2] && (this.threeDSeries.push(t[e].data[o][2]), n.isDataXYZ = !0)
                        }
                    }, {
                        key: "handleFormatXY",
                        value: function(t, e) {
                            var i = this.w.config,
                                n = this.w.globals,
                                s = new N(this.ctx),
                                r = e;
                            n.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex);
                            for (var a = 0; a < t[e].data.length; a++) void 0 !== t[e].data[a].y && (Array.isArray(t[e].data[a].y) ? this.twoDSeries.push(y.parseNumber(t[e].data[a].y[t[e].data[a].y.length - 1])) : this.twoDSeries.push(y.parseNumber(t[e].data[a].y)));
                            for (var o = 0; o < t[r].data.length; o++) {
                                var l = "string" == typeof t[r].data[o].x,
                                    c = Array.isArray(t[r].data[o].x),
                                    h = !c && !!s.isValidDate(t[r].data[o].x.toString());
                                l || h ? l || i.xaxis.convertedCatToNumeric ? "datetime" !== i.xaxis.type || n.isBarHorizontal && n.isRangeData ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[r].data[o].x)) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())) : (n.dataFormatXNumeric = !0, n.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[o].x))) : c ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : (n.isXNumeric = !0, n.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[o].x))
                            }
                            if (t[e].data[0] && void 0 !== t[e].data[0].z) {
                                for (var u = 0; u < t[e].data.length; u++) this.threeDSeries.push(t[e].data[u].z);
                                n.isDataXYZ = !0
                            }
                        }
                    }, {
                        key: "handleRangeData",
                        value: function(t, e) {
                            var i = this.w.config,
                                n = this.w.globals,
                                s = {};
                            return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", t, e)), n.seriesRangeStart.push(s.start), n.seriesRangeEnd.push(s.end), "datetime" === i.xaxis.type && n.seriesRangeBarTimeline.push(s.rangeUniques), n.seriesRangeBarTimeline.forEach(function(t, e) {
                                t && t.forEach(function(t, e) {
                                    t.y.forEach(function(e, i) {
                                        for (var n = 0; n < t.y.length; n++) i !== n && e.y1 <= t.y[n].y2 && t.y[n].y1 <= e.y2 && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[n].rangeName) < 0 && t.overlaps.push(t.y[n].rangeName))
                                    })
                                })
                            }), s
                        }
                    }, {
                        key: "handleCandleStickBoxData",
                        value: function(t, e) {
                            var i = this.w.globals,
                                n = {};
                            return this.isFormat2DArray() ? n = this.handleCandleStickBoxDataFormat("array", t, e) : this.isFormatXY() && (n = this.handleCandleStickBoxDataFormat("xy", t, e)), i.seriesCandleO[e] = n.o, i.seriesCandleH[e] = n.h, i.seriesCandleM[e] = n.m, i.seriesCandleL[e] = n.l, i.seriesCandleC[e] = n.c, n
                        }
                    }, {
                        key: "handleRangeDataFormat",
                        value: function(t, e, i) {
                            var n = [],
                                s = [],
                                r = e[i].data.filter(function(t, e, i) {
                                    return e === i.findIndex(function(e) {
                                        return e.x === t.x
                                    })
                                }).map(function(t, e) {
                                    return {
                                        x: t.x,
                                        overlaps: [],
                                        y: []
                                    }
                                }),
                                a = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",
                                o = new R(this.ctx).getActiveConfigSeriesIndex();
                            if ("array" === t) {
                                if (2 !== e[o].data[0][1].length) throw new Error(a);
                                for (var l = 0; l < e[i].data.length; l++) n.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1])
                            } else if ("xy" === t) {
                                if (2 !== e[o].data[0].y.length) throw new Error(a);
                                for (var c = function(t) {
                                        var a = y.randomId(),
                                            o = e[i].data[t].x,
                                            l = {
                                                y1: e[i].data[t].y[0],
                                                y2: e[i].data[t].y[1],
                                                rangeName: a
                                            };
                                        e[i].data[t].rangeName = a;
                                        var c = r.findIndex(function(t) {
                                            return t.x === o
                                        });
                                        r[c].y.push(l), n.push(l.y1), s.push(l.y2)
                                    }, h = 0; h < e[i].data.length; h++) c(h)
                            }
                            return {
                                start: n,
                                end: s,
                                rangeUniques: r
                            }
                        }
                    }, {
                        key: "handleCandleStickBoxDataFormat",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = "boxPlot" === n.config.chart.type || "boxPlot" === n.config.series[i].type,
                                r = [],
                                a = [],
                                o = [],
                                l = [],
                                c = [];
                            if ("array" === t)
                                if (s && 6 === e[i].data[0].length || !s && 5 === e[i].data[0].length)
                                    for (var h = 0; h < e[i].data.length; h++) r.push(e[i].data[h][1]), a.push(e[i].data[h][2]), s ? (o.push(e[i].data[h][3]), l.push(e[i].data[h][4]), c.push(e[i].data[h][5])) : (l.push(e[i].data[h][3]), c.push(e[i].data[h][4]));
                                else
                                    for (var u = 0; u < e[i].data.length; u++) Array.isArray(e[i].data[u][1]) && (r.push(e[i].data[u][1][0]), a.push(e[i].data[u][1][1]), s ? (o.push(e[i].data[u][1][2]), l.push(e[i].data[u][1][3]), c.push(e[i].data[u][1][4])) : (l.push(e[i].data[u][1][2]), c.push(e[i].data[u][1][3])));
                            else if ("xy" === t)
                                for (var d = 0; d < e[i].data.length; d++) Array.isArray(e[i].data[d].y) && (r.push(e[i].data[d].y[0]), a.push(e[i].data[d].y[1]), s ? (o.push(e[i].data[d].y[2]), l.push(e[i].data[d].y[3]), c.push(e[i].data[d].y[4])) : (l.push(e[i].data[d].y[2]), c.push(e[i].data[d].y[3])));
                            return {
                                o: r,
                                h: a,
                                m: o,
                                l,
                                c
                            }
                        }
                    }, {
                        key: "parseDataAxisCharts",
                        value: function(t) {
                            var e = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx,
                                n = this.w.config,
                                s = this.w.globals,
                                r = new N(i),
                                a = n.labels.length > 0 ? n.labels.slice() : n.xaxis.categories.slice();
                            s.isTimelineBar = "rangeBar" === n.chart.type && "datetime" === n.xaxis.type;
                            for (var o = function() {
                                    for (var t = 0; t < a.length; t++)
                                        if ("string" == typeof a[t]) {
                                            if (!r.isValidDate(a[t])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                                            e.twoDSeriesX.push(r.parseDate(a[t]))
                                        } else e.twoDSeriesX.push(a[t])
                                }, l = 0; l < t.length; l++) {
                                if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                                if ("rangeBar" !== n.chart.type && "rangeArea" !== n.chart.type && "rangeBar" !== t[l].type && "rangeArea" !== t[l].type || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), "candlestick" !== n.chart.type && "candlestick" !== t[l].type && "boxPlot" !== n.chart.type && "boxPlot" !== t[l].type || this.handleCandleStickBoxData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0);
                                else {
                                    "datetime" === n.xaxis.type ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : "numeric" === n.xaxis.type && (s.isXNumeric = !0, a.length > 0 && (this.twoDSeriesX = a, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX);
                                    var c = t[l].data.map(function(t) {
                                        return y.parseNumber(t)
                                    });
                                    s.series.push(c)
                                }
                                s.seriesZ.push(this.threeDSeries), s.seriesNames.push(void 0 !== t[l].name ? t[l].name : "series-" + parseInt(l + 1, 10)), s.seriesColors.push(void 0 !== t[l].color ? t[l].color : void 0)
                            }
                            return this.w
                        }
                    }, {
                        key: "parseDataNonAxisCharts",
                        value: function(t) {
                            var e = this.w.globals,
                                i = this.w.config;
                            e.series = t.slice(), e.seriesNames = i.labels.slice();
                            for (var n = 0; n < e.series.length; n++) void 0 === e.seriesNames[n] && e.seriesNames.push("series-" + (n + 1));
                            return this.w
                        }
                    }, {
                        key: "handleExternalLabelsData",
                        value: function(t) {
                            var e = this.w.config,
                                i = this.w.globals;
                            e.xaxis.categories.length > 0 ? i.labels = e.xaxis.categories : e.labels.length > 0 ? i.labels = e.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRangeBarTimeline.length && (i.seriesRangeBarTimeline.map(function(t) {
                                t.forEach(function(t) {
                                    i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x)
                                })
                            }), i.labels = i.labels.filter(function(t, e, i) {
                                return i.indexOf(t) === e
                            })), e.xaxis.convertedCatToNumeric && (new V(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t)
                        }
                    }, {
                        key: "_generateExternalLabels",
                        value: function(t) {
                            var e = this.w.globals,
                                i = this.w.config,
                                n = [];
                            if (e.axisCharts) {
                                if (e.series.length > 0)
                                    for (var s = 0; s < e.series[e.maxValsInArrayIndex].length; s++) n.push(s + 1);
                                e.seriesX = [];
                                for (var r = 0; r < t.length; r++) e.seriesX.push(n);
                                e.isXNumeric = !0
                            }
                            if (0 === n.length) {
                                n = e.axisCharts ? [] : e.series.map(function(t, e) {
                                    return e + 1
                                });
                                for (var a = 0; a < t.length; a++) e.seriesX.push(n)
                            }
                            e.labels = n, i.xaxis.convertedCatToNumeric && (e.categoryLabels = n.map(function(t) {
                                return i.xaxis.labels.formatter(t)
                            })), e.noLabelsProvided = !0
                        }
                    }, {
                        key: "parseData",
                        value: function(t) {
                            var e = this.w,
                                i = e.config,
                                n = e.globals;
                            if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), n.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), "bar" === i.chart.type && i.chart.stacked) {
                                var s = new R(this.ctx);
                                n.series = s.setNullSeriesToZeroValues(n.series)
                            }
                            this.coreUtils.getSeriesTotals(), n.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), n.dataFormatXNumeric || n.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t);
                            for (var r = this.coreUtils.getCategoryLabels(n.labels), a = 0; a < r.length; a++)
                                if (Array.isArray(r[a])) {
                                    n.isMultiLineX = !0;
                                    break
                                }
                        }
                    }, {
                        key: "excludeCollapsedSeriesInYAxis",
                        value: function() {
                            var t = this,
                                e = this.w;
                            e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function(i, n) {
                                if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index
                            })
                        }
                    }]), t
                }(),
                W = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM"
                    }
                    return o(t, [{
                        key: "xLabelFormat",
                        value: function(t, e, i, n) {
                            var s = this.w;
                            if ("datetime" === s.config.xaxis.type && void 0 === s.config.xaxis.labels.formatter && void 0 === s.config.tooltip.x.formatter) {
                                var r = new N(this.ctx);
                                return r.formatDate(r.getDate(e), s.config.tooltip.x.format)
                            }
                            return t(e, i, n)
                        }
                    }, {
                        key: "defaultGeneralFormatter",
                        value: function(t) {
                            return Array.isArray(t) ? t.map(function(t) {
                                return t
                            }) : t
                        }
                    }, {
                        key: "defaultYFormatter",
                        value: function(t, e, i) {
                            var n = this.w;
                            return y.isNumber(t) && (t = t.toFixed(0 !== n.globals.yValueDecimal ? void 0 !== e.decimalsInFloat ? e.decimalsInFloat : n.globals.yValueDecimal : n.globals.maxYArr[i] - n.globals.minYArr[i] < 5 ? 1 : 0)), t
                        }
                    }, {
                        key: "setLabelFormatters",
                        value: function() {
                            var t = this,
                                e = this.w;
                            return e.globals.xaxisTooltipFormatter = function(e) {
                                return t.defaultGeneralFormatter(e)
                            }, e.globals.ttKeyFormatter = function(e) {
                                return t.defaultGeneralFormatter(e)
                            }, e.globals.ttZFormatter = function(t) {
                                return t
                            }, e.globals.legendFormatter = function(e) {
                                return t.defaultGeneralFormatter(e)
                            }, e.globals.xLabelFormatter = void 0 !== e.config.xaxis.labels.formatter ? e.config.xaxis.labels.formatter : function(t) {
                                if (y.isNumber(t)) {
                                    if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type) {
                                        if (y.isNumber(e.config.xaxis.decimalsInFloat)) return t.toFixed(e.config.xaxis.decimalsInFloat);
                                        var i = e.globals.maxX - e.globals.minX;
                                        return t.toFixed(i > 0 && i < 100 ? 1 : 0)
                                    }
                                    return t.toFixed(e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4 ? 1 : 0)
                                }
                                return t
                            }, e.globals.ttKeyFormatter = "function" == typeof e.config.tooltip.x.formatter ? e.config.tooltip.x.formatter : e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(function(i, n) {
                                e.globals.yLabelFormatters[n] = void 0 !== i.labels.formatter ? i.labels.formatter : function(s) {
                                    return e.globals.xyCharts ? Array.isArray(s) ? s.map(function(e) {
                                        return t.defaultYFormatter(e, i, n)
                                    }) : t.defaultYFormatter(s, i, n) : s
                                }
                            }), e.globals
                        }
                    }, {
                        key: "heatmapLabelFormatters",
                        value: function() {
                            var t = this.w;
                            if ("heatmap" === t.config.chart.type) {
                                t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
                                var e = t.globals.seriesNames.reduce(function(t, e) {
                                    return t.length > e.length ? t : e
                                }, 0);
                                t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e
                            }
                        }
                    }]), t
                }(),
                Y = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "getLabel",
                        value: function(t, e, i, n) {
                            var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
                                r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
                                a = this.w,
                                o = void 0 === t[n] ? "" : t[n],
                                l = o,
                                c = a.globals.xLabelFormatter,
                                h = a.config.xaxis.labels.formatter,
                                u = !1,
                                d = new W(this.ctx),
                                p = o;
                            l = d.xLabelFormat(c, o, p, {
                                i: n,
                                dateFormatter: new N(this.ctx).formatDate,
                                w: a
                            }), void 0 !== h && (l = h(o, t[n], {
                                i: n,
                                dateFormatter: new N(this.ctx).formatDate,
                                w: a
                            }));
                            var f = function(t) {
                                var i = null;
                                return e.forEach(function(t) {
                                    "month" === t.unit ? i = "year" : "day" === t.unit ? i = "month" : "hour" === t.unit ? i = "day" : "minute" === t.unit && (i = "hour")
                                }), i === t
                            };
                            e.length > 0 ? (u = f(e[n].unit), i = e[n].position, l = e[n].value) : "datetime" === a.config.xaxis.type && void 0 === h && (l = ""), void 0 === l && (l = ""), l = Array.isArray(l) ? l : l.toString();
                            var g = new _(this.ctx),
                                m = {};
                            m = a.globals.rotateXLabels ? g.getTextRects(l, parseInt(r, 10), null, "rotate(".concat(a.config.xaxis.labels.rotate, " 0 0)"), !1) : g.getTextRects(l, parseInt(r, 10));
                            var b = !a.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                            return !Array.isArray(l) && (0 === l.indexOf("NaN") || 0 === l.toLowerCase().indexOf("invalid") || l.toLowerCase().indexOf("infinity") >= 0 || s.indexOf(l) >= 0 && b) && (l = ""), {
                                x: i,
                                text: l,
                                textRect: m,
                                isBold: u
                            }
                        }
                    }, {
                        key: "checkLabelBasedOnTickamount",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = n.config.xaxis.tickAmount;
                            return "dataPoints" === s && (s = Math.round(n.globals.gridWidth / 120)), s > i || t % Math.round(i / (s + 1)) == 0 || (e.text = ""), e
                        }
                    }, {
                        key: "checkForOverflowingLabels",
                        value: function(t, e, i, n, s) {
                            var r = this.w;
                            if (0 === t && r.globals.skipFirstTimelinelabel && (e.text = ""), t === i - 1 && r.globals.skipLastTimelinelabel && (e.text = ""), r.config.xaxis.labels.hideOverlappingLabels && n.length > 0) {
                                var a = s[s.length - 1];
                                e.x < a.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + a.x && (e.text = "")
                            }
                            return e
                        }
                    }, {
                        key: "checkForReversedLabels",
                        value: function(t, e) {
                            var i = this.w;
                            return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e
                        }
                    }, {
                        key: "isYAxisHidden",
                        value: function(t) {
                            var e = this.w,
                                i = new k(this.ctx);
                            return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t)
                        }
                    }, {
                        key: "getYAxisForeColor",
                        value: function(t, e) {
                            var i = this.w;
                            return Array.isArray(t) && i.globals.yAxisScale[e] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[e].result.length, !1), t
                        }
                    }, {
                        key: "drawYAxisTicks",
                        value: function(t, e, i, n, s, r, a) {
                            var o = this.w,
                                l = new _(this.ctx),
                                c = o.globals.translateY;
                            if (n.show && e > 0) {
                                !0 === o.config.yaxis[s].opposite && (t += n.width);
                                for (var h = e; h >= 0; h--) {
                                    var u = c + e / 10 + o.config.yaxis[s].labels.offsetY - 1;
                                    o.globals.isBarHorizontal && (u = r * h), "heatmap" === o.config.chart.type && (u += r / 2);
                                    var d = l.drawLine(t + i.offsetX - n.width + n.offsetX, u + n.offsetY, t + i.offsetX + n.offsetX, u + n.offsetY, n.color);
                                    a.add(d), c += r
                                }
                            }
                        }
                    }]), t
                }(),
                G = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "fixSvgStringForIe11",
                        value: function(t) {
                            if (!y.isIE11()) return t;
                            var e = 0,
                                i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t) {
                                    return 2 == ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"' : t
                                });
                            return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
                        }
                    }, {
                        key: "getSvgString",
                        value: function() {
                            var t = this.w.globals.dom.Paper.svg();
                            return this.fixSvgStringForIe11(t)
                        }
                    }, {
                        key: "cleanup",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                                i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                                n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                            Array.prototype.forEach.call(n, function(t) {
                                t.setAttribute("width", 0)
                            }), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100))
                        }
                    }, {
                        key: "svgUrl",
                        value: function() {
                            this.cleanup();
                            var t = this.getSvgString(),
                                e = new Blob([t], {
                                    type: "image/svg+xml;charset=utf-8"
                                });
                            return URL.createObjectURL(e)
                        }
                    }, {
                        key: "dataURI",
                        value: function() {
                            var t = this;
                            return new Promise(function(e) {
                                var i = t.w;
                                t.cleanup();
                                var n = document.createElement("canvas");
                                n.width = i.globals.svgWidth, n.height = parseInt(i.globals.dom.elWrap.style.height, 10);
                                var s = "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background,
                                    r = n.getContext("2d");
                                r.fillStyle = s, r.fillRect(0, 0, n.width, n.height);
                                var a = t.getSvgString();
                                if (window.canvg && y.isIE11()) {
                                    var o = window.canvg.Canvg.fromString(r, a, {
                                        ignoreClear: !0,
                                        ignoreDimensions: !0
                                    });
                                    o.start();
                                    var l = n.msToBlob();
                                    o.stop(), e({
                                        blob: l
                                    })
                                } else {
                                    var c = "data:image/svg+xml," + encodeURIComponent(a),
                                        h = new Image;
                                    h.crossOrigin = "anonymous", h.onload = function() {
                                        if (r.drawImage(h, 0, 0), n.msToBlob) {
                                            var t = n.msToBlob();
                                            e({
                                                blob: t
                                            })
                                        } else {
                                            var i = n.toDataURL("image/png");
                                            e({
                                                imgURI: i
                                            })
                                        }
                                    }, h.src = c
                                }
                            })
                        }
                    }, {
                        key: "exportToSVG",
                        value: function() {
                            this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
                        }
                    }, {
                        key: "exportToPng",
                        value: function() {
                            var t = this;
                            this.dataURI().then(function(e) {
                                var i = e.imgURI,
                                    n = e.blob;
                                n ? navigator.msSaveOrOpenBlob(n, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png")
                            })
                        }
                    }, {
                        key: "exportToCSV",
                        value: function(t) {
                            var e = this,
                                i = t.series,
                                n = t.columnDelimiter,
                                s = t.lineDelimiter,
                                r = void 0 === s ? "\n" : s,
                                a = this.w,
                                o = [],
                                l = [],
                                c = "data:text/csv;charset=utf-8,\ufeff",
                                h = new X(this.ctx),
                                u = new Y(this.ctx),
                                d = function(t) {
                                    var i = "";
                                    if (a.globals.axisCharts) {
                                        if ("category" === a.config.xaxis.type || a.config.xaxis.convertedCatToNumeric)
                                            if (a.globals.isBarHorizontal) {
                                                var s = a.globals.yLabelFormatters[0],
                                                    r = new R(e.ctx).getActiveConfigSeriesIndex();
                                                i = s(a.globals.labels[t], {
                                                    seriesIndex: r,
                                                    dataPointIndex: t,
                                                    w: a
                                                })
                                            } else i = u.getLabel(a.globals.labels, a.globals.timescaleLabels, 0, t).text;
                                        "datetime" === a.config.xaxis.type && (a.config.xaxis.categories.length ? i = a.config.xaxis.categories[t] : a.config.labels.length && (i = a.config.labels[t]))
                                    } else i = a.config.labels[t];
                                    return Array.isArray(i) && (i = i.join(" ")), y.isNumber(i) ? i : i.split(n).join("")
                                };
                            o.push(a.config.chart.toolbar.export.csv.headerCategory), i.map(function(t, e) {
                                var i = t.name ? t.name : "series-".concat(e);
                                a.globals.axisCharts && o.push(i.split(n).join("") ? i.split(n).join("") : "series-".concat(e))
                            }), a.globals.axisCharts || (o.push(a.config.chart.toolbar.export.csv.headerValue), l.push(o.join(n))), i.map(function(t, e) {
                                a.globals.axisCharts ? function(t, e) {
                                    if (o.length && 0 === e && l.push(o.join(n)), t.data && t.data.length)
                                        for (var s = 0; s < t.data.length; s++) {
                                            o = [];
                                            var r = d(s);
                                            if (r || (h.isFormatXY() ? r = i[e].data[s].x : h.isFormat2DArray() && (r = i[e].data[s] ? i[e].data[s][0] : "")), 0 === e) {
                                                o.push("datetime" === a.config.xaxis.type && String(r).length >= 10 ? a.config.chart.toolbar.export.csv.dateFormatter(r) : y.isNumber(r) ? r : r.split(n).join(""));
                                                for (var c = 0; c < a.globals.series.length; c++) o.push(a.globals.series[c][s])
                                            }("candlestick" === a.config.chart.type || t.type && "candlestick" === t.type) && (o.pop(), o.push(a.globals.seriesCandleO[e][s]), o.push(a.globals.seriesCandleH[e][s]), o.push(a.globals.seriesCandleL[e][s]), o.push(a.globals.seriesCandleC[e][s])), ("boxPlot" === a.config.chart.type || t.type && "boxPlot" === t.type) && (o.pop(), o.push(a.globals.seriesCandleO[e][s]), o.push(a.globals.seriesCandleH[e][s]), o.push(a.globals.seriesCandleM[e][s]), o.push(a.globals.seriesCandleL[e][s]), o.push(a.globals.seriesCandleC[e][s])), "rangeBar" === a.config.chart.type && (o.pop(), o.push(a.globals.seriesRangeStart[e][s]), o.push(a.globals.seriesRangeEnd[e][s])), o.length && l.push(o.join(n))
                                        }
                                }(t, e) : ((o = []).push(a.globals.labels[e].split(n).join("")), o.push(a.globals.series[e]), l.push(o.join(n)))
                            }), c += l.join(r), this.triggerDownload(encodeURI(c), a.config.chart.toolbar.export.csv.filename, ".csv")
                        }
                    }, {
                        key: "triggerDownload",
                        value: function(t, e, i) {
                            var n = document.createElement("a");
                            n.href = t, n.download = (e || this.w.globals.chartID) + i, document.body.appendChild(n), n.click(), document.body.removeChild(n)
                        }
                    }]), t
                }(),
                q = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.axesUtils = new Y(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], this.offY = "top" === i.config.xaxis.position ? 0 : i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth = this.xaxisBorderWidth.indexOf("%") > -1 ? i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0]
                    }
                    return o(t, [{
                        key: "drawXaxis",
                        value: function() {
                            var t, e = this,
                                i = this.w,
                                n = new _(this.ctx),
                                s = n.group({
                                    class: "apexcharts-xaxis",
                                    transform: "translate(".concat(i.config.xaxis.offsetX, ", ").concat(i.config.xaxis.offsetY, ")")
                                }),
                                r = n.group({
                                    class: "apexcharts-xaxis-texts-g",
                                    transform: "translate(".concat(i.globals.translateXAxisX, ", ").concat(i.globals.translateXAxisY, ")")
                                });
                            s.add(r);
                            for (var a = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++) o.push(this.xaxisLabels[l]);
                            var c = o.length;
                            a = i.globals.isXNumeric ? a + (t = i.globals.gridWidth / (c > 1 ? c - 1 : c)) / 2 + i.config.xaxis.labels.offsetX : a + (t = i.globals.gridWidth / o.length) + i.config.xaxis.labels.offsetX;
                            for (var h = function(s) {
                                    var l = a - t / 2 + i.config.xaxis.labels.offsetX;
                                    0 === s && 1 === c && t / 2 === a && 1 === i.globals.dataPoints && (l = i.globals.gridWidth / 2);
                                    var h = e.axesUtils.getLabel(o, i.globals.timescaleLabels, l, s, e.drawnLabels, e.xaxisFontSize),
                                        u = 28;
                                    if (i.globals.rotateXLabels && (u = 22), (h = void 0 !== i.config.xaxis.tickAmount && "dataPoints" !== i.config.xaxis.tickAmount && "datetime" !== i.config.xaxis.type ? e.axesUtils.checkLabelBasedOnTickamount(s, h, c) : e.axesUtils.checkForOverflowingLabels(s, h, c, e.drawnLabels, e.drawnLabelsRects)).text && i.globals.xaxisLabelsCount++, i.config.xaxis.labels.show) {
                                        var d = n.drawText({
                                            x: h.x,
                                            y: e.offY + i.config.xaxis.labels.offsetY + u - ("top" === i.config.xaxis.position ? i.globals.xAxisHeight + i.config.xaxis.axisTicks.height - 2 : 0),
                                            text: h.text,
                                            textAnchor: "middle",
                                            fontWeight: h.isBold ? 600 : i.config.xaxis.labels.style.fontWeight,
                                            fontSize: e.xaxisFontSize,
                                            fontFamily: e.xaxisFontFamily,
                                            foreColor: Array.isArray(e.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[i.globals.minX + s - 1] : e.xaxisForeColors[s] : e.xaxisForeColors,
                                            isPlainText: !1,
                                            cssClass: "apexcharts-xaxis-label " + i.config.xaxis.labels.style.cssClass
                                        });
                                        r.add(d);
                                        var p = document.createElementNS(i.globals.SVGNS, "title");
                                        p.textContent = Array.isArray(h.text) ? h.text.join(" ") : h.text, d.node.appendChild(p), "" !== h.text && (e.drawnLabels.push(h.text), e.drawnLabelsRects.push(h))
                                    }
                                    a += t
                                }, u = 0; u <= c - 1; u++) h(u);
                            if (void 0 !== i.config.xaxis.title.text) {
                                var d = n.group({
                                        class: "apexcharts-xaxis-title"
                                    }),
                                    p = n.drawText({
                                        x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX,
                                        y: this.offY + parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY,
                                        text: i.config.xaxis.title.text,
                                        textAnchor: "middle",
                                        fontSize: i.config.xaxis.title.style.fontSize,
                                        fontFamily: i.config.xaxis.title.style.fontFamily,
                                        fontWeight: i.config.xaxis.title.style.fontWeight,
                                        foreColor: i.config.xaxis.title.style.color,
                                        cssClass: "apexcharts-xaxis-title-text " + i.config.xaxis.title.style.cssClass
                                    });
                                d.add(p), s.add(d)
                            }
                            if (i.config.xaxis.axisBorder.show) {
                                var f = i.globals.barPadForNumericAxis,
                                    g = n.drawLine(i.globals.padHorizontal + i.config.xaxis.axisBorder.offsetX - f, this.offY, this.xaxisBorderWidth + f, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                                s.add(g)
                            }
                            return s
                        }
                    }, {
                        key: "drawXaxisInversed",
                        value: function(t) {
                            var e, i, n = this,
                                s = this.w,
                                r = new _(this.ctx),
                                a = s.config.yaxis[0].opposite ? s.globals.translateYAxisX[t] : 0,
                                o = r.group({
                                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                                    rel: t
                                }),
                                l = r.group({
                                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                                    transform: "translate(" + a + ", 0)"
                                });
                            o.add(l);
                            var c = [];
                            if (s.config.yaxis[t].show)
                                for (var h = 0; h < this.xaxisLabels.length; h++) c.push(this.xaxisLabels[h]);
                            i = -(e = s.globals.gridHeight / c.length) / 2.2;
                            var u = s.globals.yLabelFormatters[0],
                                d = s.config.yaxis[0].labels;
                            if (d.show)
                                for (var p = function(a) {
                                        var o = void 0 === c[a] ? "" : c[a];
                                        o = u(o, {
                                            seriesIndex: t,
                                            dataPointIndex: a,
                                            w: s
                                        });
                                        var h = n.axesUtils.getYAxisForeColor(d.style.colors, t),
                                            p = 0;
                                        Array.isArray(o) && (p = o.length / 2 * parseInt(d.style.fontSize, 10));
                                        var f = r.drawText({
                                            x: d.offsetX - 15,
                                            y: i + e + d.offsetY - p,
                                            text: o,
                                            textAnchor: n.yaxis.opposite ? "start" : "end",
                                            foreColor: Array.isArray(h) ? h[a] : h,
                                            fontSize: d.style.fontSize,
                                            fontFamily: d.style.fontFamily,
                                            fontWeight: d.style.fontWeight,
                                            isPlainText: !1,
                                            cssClass: "apexcharts-yaxis-label " + d.style.cssClass
                                        });
                                        l.add(f);
                                        var g = document.createElementNS(s.globals.SVGNS, "title");
                                        if (g.textContent = o.text, f.node.appendChild(g), 0 !== s.config.yaxis[t].labels.rotate) {
                                            var m = r.rotateAroundCenter(f.node);
                                            f.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[t].labels.rotate, " 0 ").concat(m.y, ")"))
                                        }
                                        i += e
                                    }, f = 0; f <= c.length - 1; f++) p(f);
                            if (void 0 !== s.config.yaxis[0].title.text) {
                                var g = r.group({
                                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                                        transform: "translate(" + a + ", 0)"
                                    }),
                                    m = r.drawText({
                                        x: 0,
                                        y: s.globals.gridHeight / 2,
                                        text: s.config.yaxis[0].title.text,
                                        textAnchor: "middle",
                                        foreColor: s.config.yaxis[0].title.style.color,
                                        fontSize: s.config.yaxis[0].title.style.fontSize,
                                        fontWeight: s.config.yaxis[0].title.style.fontWeight,
                                        fontFamily: s.config.yaxis[0].title.style.fontFamily,
                                        cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[0].title.style.cssClass
                                    });
                                g.add(m), o.add(g)
                            }
                            var b = 0;
                            this.isCategoryBarHorizontal && s.config.yaxis[0].opposite && (b = s.globals.gridWidth);
                            var y = s.config.xaxis.axisBorder;
                            if (y.show) {
                                var v = r.drawLine(s.globals.padHorizontal + y.offsetX + b, 1 + y.offsetY, s.globals.padHorizontal + y.offsetX + b, s.globals.gridHeight + y.offsetY, y.color, 0);
                                o.add(v)
                            }
                            return s.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b, c.length, s.config.yaxis[0].axisBorder, s.config.yaxis[0].axisTicks, 0, e, o), o
                        }
                    }, {
                        key: "drawXaxisTicks",
                        value: function(t, e) {
                            var i = this.w,
                                n = t;
                            if (!(t < 0 || t - 2 > i.globals.gridWidth)) {
                                var s = this.offY + i.config.xaxis.axisTicks.offsetY,
                                    r = s + i.config.xaxis.axisTicks.height;
                                if ("top" === i.config.xaxis.position && (r = s - i.config.xaxis.axisTicks.height), i.config.xaxis.axisTicks.show) {
                                    var a = new _(this.ctx).drawLine(t + i.config.xaxis.axisTicks.offsetX, s + i.config.xaxis.offsetY, n + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
                                    e.add(a), a.node.classList.add("apexcharts-xaxis-tick")
                                }
                            }
                        }
                    }, {
                        key: "getXAxisTicksPositions",
                        value: function() {
                            var t = this.w,
                                e = [],
                                i = this.xaxisLabels.length,
                                n = t.globals.padHorizontal;
                            if (t.globals.timescaleLabels.length > 0)
                                for (var s = 0; s < i; s++) e.push(n = this.xaxisLabels[s].position);
                            else
                                for (var r = i, a = 0; a < r; a++) {
                                    var o = r;
                                    t.globals.isXNumeric && "bar" !== t.config.chart.type && (o -= 1), e.push(n += t.globals.gridWidth / o)
                                }
                            return e
                        }
                    }, {
                        key: "xAxisLabelCorrections",
                        value: function() {
                            var t = this.w,
                                e = new _(this.ctx),
                                i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                                n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"),
                                s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                                r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                            if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
                                for (var a = 0; a < n.length; a++) {
                                    var o = e.rotateAroundCenter(n[a]);
                                    o.y = o.y - 1, o.x = o.x + 1, n[a].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), n[a].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")")), t.config.xaxis.labels.trim && Array.prototype.forEach.call(n[a].childNodes, function(i) {
                                        e.placeTextWithEllipsis(i, i.textContent, t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10))
                                    })
                                } else ! function() {
                                    for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < n.length; s++) t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(n[s].childNodes, function(t) {
                                        e.placeTextWithEllipsis(t, t.textContent, i)
                                    })
                                }();
                            if (s.length > 0) {
                                var l = s[s.length - 1].getBBox(),
                                    c = s[0].getBBox();
                                l.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), c.x + c.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]);
                                for (var h = 0; h < r.length; h++) e.placeTextWithEllipsis(r[h], r[h].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20)
                            }
                        }
                    }]), t
                }(),
                Z = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.xaxisLabels = i.globals.labels.slice(), this.axesUtils = new Y(e), this.isTimelineBar = "datetime" === i.config.xaxis.type && i.globals.seriesRangeBarTimeline.length, i.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i.globals.timescaleLabels.slice())
                    }
                    return o(t, [{
                        key: "drawGridArea",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                e = this.w,
                                i = new _(this.ctx);
                            null === t && (t = i.group({
                                class: "apexcharts-grid"
                            }));
                            var n = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
                                s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
                            return t.add(s), t.add(n), t
                        }
                    }, {
                        key: "drawGrid",
                        value: function() {
                            var t = null;
                            return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t
                        }
                    }, {
                        key: "createGridMask",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = new _(this.ctx),
                                n = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
                            if (Array.isArray(t.config.stroke.width)) {
                                var s = 0;
                                t.config.stroke.width.forEach(function(t) {
                                    s = Math.max(s, t)
                                }), n = s
                            }
                            e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid));
                            var r = t.config.chart.type,
                                a = 0,
                                o = 0;
                            ("bar" === r || "rangeBar" === r || "candlestick" === r || "boxPlot" === r || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (o = t.config.grid.padding.right, e.barPadForNumericAxis > (a = t.config.grid.padding.left) && (a = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-n / 2 - a - 2, -n / 2, e.gridWidth + n + o + a + 4, e.gridHeight + n, 0, "#fff"), new k(this).getLargestMarkerSize();
                            var l = t.globals.markers.largestSize + 1;
                            e.dom.elGridRectMarker = i.drawRect(2 * -l, 2 * -l, e.gridWidth + 4 * l, e.gridHeight + 4 * l, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
                            var c = e.dom.baseEl.querySelector("defs");
                            c.appendChild(e.dom.elGridRectMask), c.appendChild(e.dom.elGridRectMarkerMask)
                        }
                    }, {
                        key: "_drawGridLines",
                        value: function(t) {
                            var e = t.i,
                                i = t.x1,
                                n = this.w;
                            0 === e && n.globals.skipFirstTimelinelabel || e === t.xCount - 1 && n.globals.skipLastTimelinelabel && !n.config.xaxis.labels.formatter || "radar" === n.config.chart.type || (n.config.grid.xaxis.lines.show && this._drawGridLine({
                                x1: i,
                                y1: t.y1,
                                x2: t.x2,
                                y2: t.y2,
                                parent: t.parent
                            }), new q(this.ctx).drawXaxisTicks(i, this.elg))
                        }
                    }, {
                        key: "_drawGridLine",
                        value: function(t) {
                            var e = t.x1,
                                i = t.y1,
                                n = t.x2,
                                s = t.y2,
                                r = t.parent,
                                a = this.w,
                                o = r.node.classList.contains("apexcharts-gridlines-horizontal"),
                                l = a.config.grid.strokeDashArray,
                                c = a.globals.barPadForNumericAxis,
                                h = new _(this).drawLine(e - (o ? c : 0), i, n + (o ? c : 0), s, a.config.grid.borderColor, l);
                            h.node.classList.add("apexcharts-gridline"), r.add(h)
                        }
                    }, {
                        key: "_drawGridBandRect",
                        value: function(t) {
                            var e = t.c,
                                i = t.x1,
                                n = t.y1,
                                s = t.x2,
                                r = t.y2,
                                a = t.type,
                                o = this.w,
                                l = new _(this.ctx),
                                c = o.globals.barPadForNumericAxis;
                            if ("column" !== a || "datetime" !== o.config.xaxis.type) {
                                var h = l.drawRect(i - ("row" === a ? c : 0), n, s + ("row" === a ? 2 * c : 0), r, 0, o.config.grid[a].colors[e], o.config.grid[a].opacity);
                                this.elg.add(h), h.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")), h.node.classList.add("apexcharts-grid-".concat(a))
                            }
                        }
                    }, {
                        key: "_drawXYLines",
                        value: function(t) {
                            var e = this,
                                i = t.xCount,
                                n = t.tickAmount,
                                s = this.w;
                            if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
                                var r, a = s.globals.padHorizontal,
                                    o = s.globals.gridHeight;
                                s.globals.timescaleLabels.length ? function(t) {
                                    for (var n = t.xC, s = t.y1, r = t.y2, a = 0; a < n; a++) e._drawGridLines({
                                        i: a,
                                        x1: e.xaxisLabels[a].position,
                                        y1: s,
                                        x2: e.xaxisLabels[a].position,
                                        y2: r,
                                        xCount: i,
                                        parent: e.elgridLinesV
                                    })
                                }({
                                    xC: i,
                                    x1: a,
                                    y1: 0,
                                    x2: r,
                                    y2: o
                                }) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), s.config.xaxis.convertedCatToNumeric && (i = s.globals.xaxisLabelsCount), function(t) {
                                    var n = t.xC,
                                        r = t.x1,
                                        a = t.y1,
                                        o = t.x2,
                                        l = t.y2;
                                    if (void 0 !== s.config.xaxis.tickAmount && "dataPoints" !== s.config.xaxis.tickAmount) s.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach(function(t, n) {
                                        var s = t.getBBox();
                                        e._drawGridLines({
                                            i: n,
                                            x1: s.x + s.width / 2,
                                            y1: a,
                                            x2: s.x + s.width / 2,
                                            y2: l,
                                            xCount: i,
                                            parent: e.elgridLinesV
                                        })
                                    });
                                    else
                                        for (var c = 0; c < n + (s.globals.isXNumeric ? 0 : 1); c++) 0 === c && 1 === n && 1 === s.globals.dataPoints && (o = r = s.globals.gridWidth / 2), e._drawGridLines({
                                            i: c,
                                            x1: r,
                                            y1: a,
                                            x2: o,
                                            y2: l,
                                            xCount: i,
                                            parent: e.elgridLinesV
                                        }), o = r += s.globals.gridWidth / (s.globals.isXNumeric ? n - 1 : n)
                                }({
                                    xC: i,
                                    x1: a,
                                    y1: 0,
                                    x2: r,
                                    y2: o
                                }))
                            }
                            if (s.config.grid.yaxis.lines.show) {
                                var l = 0,
                                    c = 0,
                                    h = s.globals.gridWidth,
                                    u = n + 1;
                                this.isTimelineBar && (u = s.globals.labels.length);
                                for (var d = 0; d < u + (this.isTimelineBar ? 1 : 0); d++) this._drawGridLine({
                                    x1: 0,
                                    y1: l,
                                    x2: h,
                                    y2: c,
                                    parent: this.elgridLinesH
                                }), c = l += s.globals.gridHeight / (this.isTimelineBar ? u : n)
                            }
                        }
                    }, {
                        key: "_drawInvertedXYLines",
                        value: function(t) {
                            var e = t.xCount,
                                i = this.w;
                            if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                                for (var n, s = i.globals.padHorizontal, r = i.globals.gridHeight, a = 0; a < e + 1; a++) i.config.grid.xaxis.lines.show && this._drawGridLine({
                                    x1: s,
                                    y1: 0,
                                    x2: n,
                                    y2: r,
                                    parent: this.elgridLinesV
                                }), new q(this.ctx).drawXaxisTicks(s, this.elg), n = s = s + i.globals.gridWidth / e + .3;
                            if (i.config.grid.yaxis.lines.show)
                                for (var o = 0, l = 0, c = i.globals.gridWidth, h = 0; h < i.globals.dataPoints + 1; h++) this._drawGridLine({
                                    x1: 0,
                                    y1: o,
                                    x2: c,
                                    y2: l,
                                    parent: this.elgridLinesH
                                }), l = o += i.globals.gridHeight / i.globals.dataPoints
                        }
                    }, {
                        key: "renderGrid",
                        value: function() {
                            var t = this.w,
                                e = new _(this.ctx);
                            this.elg = e.group({
                                class: "apexcharts-grid"
                            }), this.elgridLinesH = e.group({
                                class: "apexcharts-gridlines-horizontal"
                            }), this.elgridLinesV = e.group({
                                class: "apexcharts-gridlines-vertical"
                            }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());
                            for (var i, n = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (n = t.globals.yAxisScale[s].result.length - 1), !(n > 2)); s++);
                            return !t.globals.isBarHorizontal || this.isTimelineBar ? (i = this.xaxisLabels.length, this.isTimelineBar && (n = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({
                                xCount: i,
                                tickAmount: n
                            })) : this._drawInvertedXYLines({
                                xCount: i = n,
                                tickAmount: n = t.globals.xTickAmount
                            }), this.drawGridBands(i, n), {
                                el: this.elg,
                                xAxisTickWidth: t.globals.gridWidth / i
                            }
                        }
                    }, {
                        key: "drawGridBands",
                        value: function(t, e) {
                            var i = this.w;
                            if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                                for (var n = 0, s = i.globals.gridHeight / e, r = i.globals.gridWidth, a = 0, o = 0; a < e; a++, o++) o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
                                    c: o,
                                    x1: 0,
                                    y1: n,
                                    x2: r,
                                    y2: s,
                                    type: "row"
                                }), n += i.globals.gridHeight / e;
                            if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                                for (var l = i.globals.isBarHorizontal || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, c = i.globals.padHorizontal, h = i.globals.padHorizontal + i.globals.gridWidth / l, u = i.globals.gridHeight, d = 0, p = 0; d < t; d++, p++) p >= i.config.grid.column.colors.length && (p = 0), this._drawGridBandRect({
                                    c: p,
                                    x1: c,
                                    y1: 0,
                                    x2: h,
                                    y2: u,
                                    type: "column"
                                }), c += i.globals.gridWidth / l
                        }
                    }]), t
                }(),
                $ = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "niceScale",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                s = arguments.length > 4 ? arguments[4] : void 0,
                                r = this.w,
                                a = Math.abs(e - t);
                            if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, n, a)) && (i = r.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !y.isNumber(t) && !y.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) {
                                var o = this.linearScale(t = 0, e = i, i);
                                return o
                            }
                            t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
                            var l = [];
                            a < 1 && s && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[n].type || "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[n].type || r.globals.isRangeData) && (e *= 1.01);
                            var c = i + 1;
                            c < 2 ? c = 2 : c > 2 && (c -= 2);
                            var h = a / c,
                                u = Math.floor(y.log10(h)),
                                d = Math.pow(10, u),
                                p = Math.round(h / d);
                            p < 1 && (p = 1);
                            var f = p * d,
                                g = f * Math.floor(t / f),
                                m = f * Math.ceil(e / f),
                                b = g;
                            if (s && a > 2) {
                                for (; l.push(b), !((b += f) > m););
                                return {
                                    result: l,
                                    niceMin: l[0],
                                    niceMax: l[l.length - 1]
                                }
                            }
                            var v = t;
                            (l = []).push(v);
                            for (var x = Math.abs(e - t) / i, _ = 0; _ <= i; _++) l.push(v += x);
                            return l[l.length - 2] >= e && l.pop(), {
                                result: l,
                                niceMin: l[0],
                                niceMax: l[l.length - 1]
                            }
                        }
                    }, {
                        key: "linearScale",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                n = arguments.length > 3 ? arguments[3] : void 0,
                                s = Math.abs(e - t);
                            "dataPoints" === (i = this._adjustTicksForSmallRange(i, n, s)) && (i = this.w.globals.dataPoints - 1);
                            var r = s / i;
                            i === Number.MAX_VALUE && (i = 10, r = 1);
                            for (var a = [], o = t; i >= 0;) a.push(o), o += r, i -= 1;
                            return {
                                result: a,
                                niceMin: a[0],
                                niceMax: a[a.length - 1]
                            }
                        }
                    }, {
                        key: "logarithmicScale",
                        value: function(t) {
                            for (var e = [], i = Math.ceil(Math.log10(t)) + 1, n = 0; n < i; n++) e.push(Math.pow(10, n));
                            return {
                                result: e,
                                niceMin: e[0],
                                niceMax: e[e.length - 1]
                            }
                        }
                    }, {
                        key: "_adjustTicksForSmallRange",
                        value: function(t, e, i) {
                            var n = t;
                            if (void 0 !== e && this.w.config.yaxis[e].labels.formatter && void 0 === this.w.config.yaxis[e].tickAmount) {
                                var s = this.w.config.yaxis[e].labels.formatter(1);
                                y.isNumber(Number(s)) && !y.isFloat(s) && (n = Math.ceil(i))
                            }
                            return n < t ? n : t
                        }
                    }, {
                        key: "setYScaleForIndex",
                        value: function(t, e, i) {
                            var n = this.w.globals,
                                s = this.w.config,
                                r = n.isBarHorizontal ? s.xaxis : s.yaxis[t];
                            void 0 === n.yAxisScale[t] && (n.yAxisScale[t] = []);
                            var a = Math.abs(i - e);
                            r.logarithmic && a <= 5 && (n.invalidLogScale = !0), r.logarithmic && a > 5 ? (n.allSeriesCollapsed = !1, n.yAxisScale[t] = this.logarithmicScale(i)) : i !== -Number.MAX_VALUE && y.isNumber(i) ? (n.allSeriesCollapsed = !1, n.yAxisScale[t] = void 0 === r.min && void 0 === r.max || r.forceNiceScale ? this.niceScale(e, i, r.tickAmount ? r.tickAmount : a < 5 && a > 1 ? a + 1 : 5, t, void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale) : this.linearScale(e, i, r.tickAmount, t)) : n.yAxisScale[t] = this.linearScale(0, 5, 5)
                        }
                    }, {
                        key: "setXScale",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.globals,
                                s = i.config.xaxis,
                                r = Math.abs(e - t);
                            return n.xAxisScale = e !== -Number.MAX_VALUE && y.isNumber(e) ? this.linearScale(t, e, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : this.linearScale(0, 5, 5), n.xAxisScale
                        }
                    }, {
                        key: "setMultipleYScales",
                        value: function() {
                            var t = this,
                                e = this.w.globals,
                                i = this.w.config,
                                n = e.minYArr.concat([]),
                                s = e.maxYArr.concat([]),
                                r = [];
                            i.yaxis.forEach(function(e, a) {
                                var o = a;
                                i.series.forEach(function(t, i) {
                                    t.name === e.seriesName && (o = i, r.push(a !== i ? {
                                        index: i,
                                        similarIndex: a,
                                        alreadyExists: !0
                                    } : {
                                        index: i
                                    }))
                                }), t.setYScaleForIndex(a, n[o], s[o])
                            }), this.sameScaleInMultipleAxes(n, s, r)
                        }
                    }, {
                        key: "sameScaleInMultipleAxes",
                        value: function(t, e, i) {
                            var n = this,
                                s = this.w.config,
                                r = this.w.globals,
                                a = [];
                            i.forEach(function(t) {
                                t.alreadyExists && (void 0 === a[t.index] && (a[t.index] = []), a[t.index].push(t.index), a[t.index].push(t.similarIndex))
                            }), r.yAxisSameScaleIndices = a, a.forEach(function(t, e) {
                                a.forEach(function(i, n) {
                                    var s, r;
                                    e !== n && (s = t, r = i, s.filter(function(t) {
                                        return -1 !== r.indexOf(t)
                                    })).length > 0 && (a[e] = a[e].concat(a[n]))
                                })
                            });
                            var o = a.map(function(t) {
                                return t.filter(function(e, i) {
                                    return t.indexOf(e) === i
                                })
                            }).map(function(t) {
                                return t.sort()
                            });
                            a = a.filter(function(t) {
                                return !!t
                            });
                            var l = o.slice(),
                                c = l.map(function(t) {
                                    return JSON.stringify(t)
                                });
                            l = l.filter(function(t, e) {
                                return c.indexOf(JSON.stringify(t)) === e
                            });
                            var h = [],
                                u = [];
                            t.forEach(function(t, i) {
                                l.forEach(function(n, s) {
                                    n.indexOf(i) > -1 && (void 0 === h[s] && (h[s] = [], u[s] = []), h[s].push({
                                        key: i,
                                        value: t
                                    }), u[s].push({
                                        key: i,
                                        value: e[i]
                                    }))
                                })
                            });
                            var d = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
                                p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                            h.forEach(function(t, e) {
                                t.forEach(function(t, i) {
                                    d[e] = Math.min(t.value, d[e])
                                })
                            }), u.forEach(function(t, e) {
                                t.forEach(function(t, i) {
                                    p[e] = Math.max(t.value, p[e])
                                })
                            }), t.forEach(function(t, e) {
                                u.forEach(function(t, i) {
                                    var a = d[i],
                                        o = p[i];
                                    s.chart.stacked && (o = 0, t.forEach(function(t, e) {
                                        t.value !== -Number.MAX_VALUE && (o += t.value), a !== Number.MIN_VALUE && (a += h[i][e].value)
                                    })), t.forEach(function(i, l) {
                                        t[l].key === e && (void 0 !== s.yaxis[e].min && (a = "function" == typeof s.yaxis[e].min ? s.yaxis[e].min(r.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = "function" == typeof s.yaxis[e].max ? s.yaxis[e].max(r.maxY) : s.yaxis[e].max), n.setYScaleForIndex(e, a, o))
                                    })
                                })
                            })
                        }
                    }, {
                        key: "autoScaleY",
                        value: function(t, e, i) {
                            t || (t = this);
                            var n = t.w;
                            if (n.globals.isMultipleYAxis || n.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
                            var s = n.globals.seriesX[0],
                                r = n.config.chart.stacked;
                            return e.forEach(function(t, a) {
                                for (var o = 0, l = 0; l < s.length; l++)
                                    if (s[l] >= i.xaxis.min) {
                                        o = l;
                                        break
                                    } var c, h, u = n.globals.minYArr[a],
                                    d = n.globals.maxYArr[a],
                                    p = n.globals.stackedSeriesTotals;
                                n.globals.series.forEach(function(a, l) {
                                    var f = a[o];
                                    r ? (c = h = f = p[o], p.forEach(function(t, e) {
                                        s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > h && null !== t && (h = t), a[e] < c && null !== a[e] && (c = a[e]))
                                    })) : (c = h = f, a.forEach(function(t, e) {
                                        if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) {
                                            var r = t,
                                                a = t;
                                            n.globals.series.forEach(function(i, n) {
                                                null !== t && (r = Math.min(i[e], r), a = Math.max(i[e], a))
                                            }), a > h && null !== a && (h = a), r < c && null !== r && (c = r)
                                        }
                                    })), void 0 === c && void 0 === h && (c = u, h = d), (h *= h < 0 ? .9 : 1.1) < 0 && h < d && (h = d), (c *= c < 0 ? 1.1 : .9) < 0 && c > u && (c = u), e.length > 1 ? (e[l].min = void 0 === t.min ? c : t.min, e[l].max = void 0 === t.max ? h : t.max) : (e[0].min = void 0 === t.min ? c : t.min, e[0].max = void 0 === t.max ? h : t.max)
                                })
                            }), e
                        }
                    }]), t
                }(),
                Q = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.scales = new $(e)
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            this.setYRange(), this.setXRange(), this.setZRange()
                        }
                    }, {
                        key: "getMinYMaxY",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                s = this.w.config,
                                r = this.w.globals,
                                a = -Number.MAX_VALUE,
                                o = Number.MIN_VALUE;
                            null === n && (n = t + 1);
                            var l = r.series,
                                c = l,
                                h = l;
                            "candlestick" === s.chart.type ? (c = r.seriesCandleL, h = r.seriesCandleH) : "boxPlot" === s.chart.type ? (c = r.seriesCandleO, h = r.seriesCandleC) : r.isRangeData && (c = r.seriesRangeStart, h = r.seriesRangeEnd);
                            for (var u = t; u < n; u++) {
                                r.dataPoints = Math.max(r.dataPoints, l[u].length);
                                for (var d = 0; d < r.series[u].length; d++) {
                                    var p = l[u][d];
                                    null !== p && y.isNumber(p) ? (void 0 !== h[u][d] && (a = Math.max(a, h[u][d])), void 0 !== c[u][d] && (e = Math.min(e, c[u][d]), i = Math.max(i, c[u][d])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || (void 0 !== r.seriesCandleC[u][d] && (a = Math.max(a, r.seriesCandleO[u][d]), a = Math.max(a, r.seriesCandleH[u][d]), a = Math.max(a, r.seriesCandleL[u][d]), a = Math.max(a, r.seriesCandleC[u][d]), "boxPlot" === this.w.config.chart.type && (a = Math.max(a, r.seriesCandleM[u][d]))), !s.series[u].type || "candlestick" === s.series[u].type && "boxPlot" === s.series[u].type || (a = Math.max(a, r.series[u][d]), e = Math.min(e, r.series[u][d])), i = a), y.isFloat(p) && (p = y.noExponents(p), r.yValueDecimal = Math.max(r.yValueDecimal, p.toString().split(".")[1].length)), o > c[u][d] && c[u][d] < 0 && (o = c[u][d])) : r.hasNullValues = !0
                                }
                            }
                            return "rangeBar" === s.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && "datetime" === s.xaxis.type && (o = e), "bar" === s.chart.type && (o < 0 && a < 0 && (a = 0), o === Number.MIN_VALUE && (o = 0)), {
                                minY: o,
                                maxY: a,
                                lowestY: e,
                                highestY: i
                            }
                        }
                    }, {
                        key: "setYRange",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
                            var i = Number.MAX_VALUE;
                            if (t.isMultipleYAxis)
                                for (var n = 0; n < t.series.length; n++) {
                                    var s = this.getMinYMaxY(n, i, null, n + 1);
                                    t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY
                                }
                            var r = this.getMinYMaxY(0, i, null, t.series.length);
                            if (t.minY = r.minY, t.maxY = r.maxY, i = r.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "boxPlot" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
                                var a = t.maxY - i;
                                (i >= 0 && i <= 10 || void 0 !== e.yaxis[0].min || void 0 !== e.yaxis[0].max) && (a = 0), t.minY = i - 5 * a / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * a / 100
                            }
                            return e.yaxis.forEach(function(e, i) {
                                void 0 !== e.max && ("number" == typeof e.max ? t.maxYArr[i] = e.max : "function" == typeof e.max && (t.maxYArr[i] = e.max(t.isMultipleYAxis ? t.maxYArr[i] : t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && ("number" == typeof e.min ? t.minYArr[i] = e.min : "function" == typeof e.min && (t.minYArr[i] = e.min(t.isMultipleYAxis ? t.minYArr[i] === Number.MIN_VALUE ? 0 : t.minYArr[i] : t.minY)), t.minY = t.minYArr[i])
                            }), t.isBarHorizontal && ["min", "max"].forEach(function(i) {
                                void 0 !== e.xaxis[i] && "number" == typeof e.xaxis[i] && ("min" === i ? t.minY = e.xaxis[i] : t.maxY = e.xaxis[i])
                            }), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function(e, i) {
                                t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax
                            })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
                                minY: t.minY,
                                maxY: t.maxY,
                                minYArr: t.minYArr,
                                maxYArr: t.maxYArr,
                                yAxisScale: t.yAxisScale
                            }
                        }
                    }, {
                        key: "setXRange",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config,
                                i = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
                            if (t.isXNumeric && function() {
                                    for (var e = 0; e < t.series.length; e++)
                                        if (t.labels[e])
                                            for (var i = 0; i < t.labels[e].length; i++) null !== t.labels[e][i] && y.isNumber(t.labels[e][i]) && (t.maxX = Math.max(t.maxX, t.labels[e][i]), t.initialMaxX = Math.max(t.maxX, t.labels[e][i]), t.minX = Math.min(t.minX, t.labels[e][i]), t.initialMinX = Math.min(t.minX, t.labels[e][i]))
                                }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
                                var n;
                                if (void 0 === e.xaxis.tickAmount ? (n = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (n = t.dataPoints - 1), n > t.dataPoints && 0 !== t.dataPoints && (n = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (n = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (n = t.maxX - t.minX - 1)) : n = e.xaxis.tickAmount, t.xTickAmount = n, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
                                    if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
                                        for (var s = [], r = t.minX - 1; r < t.maxX; r++) s.push(r + 1);
                                        t.xAxisScale = {
                                            result: s,
                                            niceMin: s[0],
                                            niceMax: s[s.length - 1]
                                        }
                                    } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
                                else t.xAxisScale = this.scales.linearScale(1, n, n), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, n - 1), t.seriesX = t.labels.slice());
                                i && (t.labels = t.xAxisScale.result.slice())
                            }
                            return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                                minX: t.minX,
                                maxX: t.maxX
                            }
                        }
                    }, {
                        key: "setZRange",
                        value: function() {
                            var t = this.w.globals;
                            if (t.isDataXYZ)
                                for (var e = 0; e < t.series.length; e++)
                                    if (void 0 !== t.seriesZ[e])
                                        for (var i = 0; i < t.seriesZ[e].length; i++) null !== t.seriesZ[e][i] && y.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i]))
                        }
                    }, {
                        key: "_handleSingleDataPoint",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            if (t.minX === t.maxX) {
                                var i = new N(this.ctx);
                                if ("datetime" === e.xaxis.type) {
                                    var n = i.getDate(t.minX);
                                    n.setUTCDate(n.getDate() - 2), t.minX = new Date(n).getTime();
                                    var s = i.getDate(t.maxX);
                                    s.setUTCDate(s.getDate() + 2), t.maxX = new Date(s).getTime()
                                } else("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX)
                            }
                        }
                    }, {
                        key: "_getMinXDiff",
                        value: function() {
                            var t = this.w.globals;
                            t.isXNumeric && t.seriesX.forEach(function(e, i) {
                                1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
                                var n = e.slice();
                                n.sort(function(t, e) {
                                    return t - e
                                }), n.forEach(function(e, i) {
                                    if (i > 0) {
                                        var s = e - n[i - 1];
                                        s > 0 && (t.minXDiff = Math.min(s, t.minXDiff))
                                    }
                                }), 1 === t.dataPoints && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = .5)
                            })
                        }
                    }, {
                        key: "_setStackedMinMax",
                        value: function() {
                            var t = this.w.globals,
                                e = [],
                                i = [];
                            if (t.series.length)
                                for (var n = 0; n < t.series[t.maxValsInArrayIndex].length; n++)
                                    for (var s = 0, r = 0, a = 0; a < t.series.length; a++) null !== t.series[a][n] && y.isNumber(t.series[a][n]) && (t.series[a][n] > 0 ? s = s + parseFloat(t.series[a][n]) + 1e-4 : r += parseFloat(t.series[a][n])), a === t.series.length - 1 && (e.push(s), i.push(r));
                            for (var o = 0; o < e.length; o++) t.maxY = Math.max(t.maxY, e[o]), t.minY = Math.min(t.minY, i[o])
                        }
                    }]), t
                }(),
                K = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Y(e)
                    }
                    return o(t, [{
                        key: "drawYaxis",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = new _(this.ctx),
                                s = i.config.yaxis[t].labels.style,
                                r = s.fontSize,
                                a = s.fontFamily,
                                o = s.fontWeight,
                                l = n.group({
                                    class: "apexcharts-yaxis",
                                    rel: t,
                                    transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)"
                                });
                            if (this.axesUtils.isYAxisHidden(t)) return l;
                            var c = n.group({
                                class: "apexcharts-yaxis-texts-g"
                            });
                            l.add(c);
                            var h = i.globals.yAxisScale[t].result.length - 1,
                                u = i.globals.gridHeight / h,
                                d = i.globals.translateY,
                                p = i.globals.yLabelFormatters[t],
                                f = i.globals.yAxisScale[t].result.slice();
                            f = this.axesUtils.checkForReversedLabels(t, f);
                            var g = "";
                            if (i.config.yaxis[t].labels.show)
                                for (var m = function(l) {
                                        var m = f[l];
                                        m = p(m, l);
                                        var b = i.config.yaxis[t].labels.padding;
                                        i.config.yaxis[t].opposite && 0 !== i.config.yaxis.length && (b *= -1);
                                        var y = e.axesUtils.getYAxisForeColor(s.colors, t),
                                            v = n.drawText({
                                                x: b,
                                                y: d + h / 10 + i.config.yaxis[t].labels.offsetY + 1,
                                                text: m,
                                                textAnchor: i.config.yaxis[t].opposite ? "start" : "end",
                                                fontSize: r,
                                                fontFamily: a,
                                                fontWeight: o,
                                                foreColor: Array.isArray(y) ? y[l] : y,
                                                isPlainText: !1,
                                                cssClass: "apexcharts-yaxis-label " + s.cssClass
                                            });
                                        if (l === h && (g = v), c.add(v), 0 !== i.config.yaxis[t].labels.rotate) {
                                            var x = n.rotateAroundCenter(g.node),
                                                _ = n.rotateAroundCenter(v.node);
                                            v.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(x.x, " ").concat(_.y, ")"))
                                        }
                                        d += u
                                    }, b = h; b >= 0; b--) m(b);
                            if (void 0 !== i.config.yaxis[t].title.text) {
                                var y = n.group({
                                        class: "apexcharts-yaxis-title"
                                    }),
                                    v = 0;
                                i.config.yaxis[t].opposite && (v = i.globals.translateYAxisX[t]);
                                var x = n.drawText({
                                    x: v,
                                    y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY,
                                    text: i.config.yaxis[t].title.text,
                                    textAnchor: "end",
                                    foreColor: i.config.yaxis[t].title.style.color,
                                    fontSize: i.config.yaxis[t].title.style.fontSize,
                                    fontWeight: i.config.yaxis[t].title.style.fontWeight,
                                    fontFamily: i.config.yaxis[t].title.style.fontFamily,
                                    cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass
                                });
                                y.add(x), l.add(y)
                            }
                            var w = i.config.yaxis[t].axisBorder,
                                C = 31 + w.offsetX;
                            if (i.config.yaxis[t].opposite && (C = -31 - w.offsetX), w.show) {
                                var k = n.drawLine(C, i.globals.translateY + w.offsetY - 2, C, i.globals.gridHeight + i.globals.translateY + w.offsetY + 2, w.color, 0, w.width);
                                l.add(k)
                            }
                            return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(C, h, w, i.config.yaxis[t].axisTicks, t, u, l), l
                        }
                    }, {
                        key: "drawYaxisInversed",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = i.group({
                                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                                }),
                                s = i.group({
                                    class: "apexcharts-xaxis-texts-g",
                                    transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                                });
                            n.add(s);
                            var r = e.globals.yAxisScale[t].result.length - 1,
                                a = e.globals.gridWidth / r + .1,
                                o = a + e.config.xaxis.labels.offsetX,
                                l = e.globals.xLabelFormatter,
                                c = e.globals.yAxisScale[t].result.slice(),
                                h = e.globals.timescaleLabels;
                            h.length > 0 && (this.xaxisLabels = h.slice(), r = (c = h.slice()).length), c = this.axesUtils.checkForReversedLabels(t, c);
                            var u = h.length;
                            if (e.config.xaxis.labels.show)
                                for (var d = u ? 0 : r; u ? d < u : d >= 0; u ? d++ : d--) {
                                    var p = c[d];
                                    p = l(p, d);
                                    var f = e.globals.gridWidth + e.globals.padHorizontal - (o - a + e.config.xaxis.labels.offsetX);
                                    if (h.length) {
                                        var g = this.axesUtils.getLabel(c, h, f, d, this.drawnLabels, this.xaxisFontSize);
                                        f = g.x, p = g.text, this.drawnLabels.push(g.text), 0 === d && e.globals.skipFirstTimelinelabel && (p = ""), d === c.length - 1 && e.globals.skipLastTimelinelabel && (p = "")
                                    }
                                    var m = i.drawText({
                                        x: f,
                                        y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
                                        text: p,
                                        textAnchor: "middle",
                                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
                                        fontSize: this.xaxisFontSize,
                                        fontFamily: this.xaxisFontFamily,
                                        fontWeight: e.config.xaxis.labels.style.fontWeight,
                                        isPlainText: !1,
                                        cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
                                    });
                                    s.add(m), m.tspan(p);
                                    var b = document.createElementNS(e.globals.SVGNS, "title");
                                    b.textContent = p, m.node.appendChild(b), o += a
                                }
                            return this.inversedYAxisTitleText(n), this.inversedYAxisBorder(n), n
                        }
                    }, {
                        key: "inversedYAxisBorder",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = e.config.xaxis.axisBorder;
                            if (n.show) {
                                var s = 0;
                                "bar" === e.config.chart.type && e.globals.isXNumeric && (s -= 15);
                                var r = i.drawLine(e.globals.padHorizontal + s + n.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, n.color, 0, n.height);
                                t.add(r)
                            }
                        }
                    }, {
                        key: "inversedYAxisTitleText",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx);
                            if (void 0 !== e.config.xaxis.title.text) {
                                var n = i.group({
                                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                                    }),
                                    s = i.drawText({
                                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
                                        text: e.config.xaxis.title.text,
                                        textAnchor: "middle",
                                        fontSize: e.config.xaxis.title.style.fontSize,
                                        fontFamily: e.config.xaxis.title.style.fontFamily,
                                        fontWeight: e.config.xaxis.title.style.fontWeight,
                                        foreColor: e.config.xaxis.title.style.color,
                                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                                    });
                                n.add(s), t.add(n)
                            }
                        }
                    }, {
                        key: "yAxisTitleRotate",
                        value: function(t, e) {
                            var i = this.w,
                                n = new _(this.ctx),
                                s = {
                                    width: 0,
                                    height: 0
                                },
                                r = {
                                    width: 0,
                                    height: 0
                                },
                                a = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
                            null !== a && (s = a.getBoundingClientRect());
                            var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
                            if (null !== o && (r = o.getBoundingClientRect()), null !== o) {
                                var l = this.xPaddingForYAxisTitle(t, s, r, e);
                                o.setAttribute("x", l.xPos - (e ? 10 : 0))
                            }
                            if (null !== o) {
                                var c = n.rotateAroundCenter(o);
                                o.setAttribute("transform", "rotate(".concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(c.x, " ").concat(c.y, ")"))
                            }
                        }
                    }, {
                        key: "xPaddingForYAxisTitle",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = 0,
                                a = 0,
                                o = 10;
                            return void 0 === s.config.yaxis[t].title.text || t < 0 ? {
                                xPos: a,
                                padd: 0
                            } : (n ? (a = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, 0 === (r += 1) && (a -= o / 2)) : (a = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (a = -1 * e.width - s.config.yaxis[t].title.offsetX - (o = 25))), {
                                xPos: a,
                                padd: o
                            })
                        }
                    }, {
                        key: "setYAxisXPosition",
                        value: function(t, e) {
                            var i = this.w,
                                n = 0,
                                s = 0,
                                r = 18,
                                a = 1;
                            i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function(o, l) {
                                var c = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t[l].width,
                                    h = t[l].width + e[l].width;
                                o.opposite ? i.globals.isBarHorizontal ? i.globals.translateYAxisX[l] = (s = i.globals.gridWidth + i.globals.translateX - 1) - o.labels.offsetX : (s = i.globals.gridWidth + i.globals.translateX + a, c || (a = a + h + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (n = i.globals.translateX - r, c || (r = r + h + 20), i.globals.translateYAxisX[l] = n + o.labels.offsetX)
                            })
                        }
                    }, {
                        key: "setYAxisTextAlignments",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                            (e = y.listToArray(e)).forEach(function(e, i) {
                                var n = t.config.yaxis[i];
                                if (n && void 0 !== n.labels.align) {
                                    var s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")),
                                        r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"));
                                    r = y.listToArray(r);
                                    var a = s.getBoundingClientRect();
                                    "left" === n.labels.align ? (r.forEach(function(t, e) {
                                        t.setAttribute("text-anchor", "start")
                                    }), n.opposite || s.setAttribute("transform", "translate(-".concat(a.width, ", 0)"))) : "center" === n.labels.align ? (r.forEach(function(t, e) {
                                        t.setAttribute("text-anchor", "middle")
                                    }), s.setAttribute("transform", "translate(".concat(a.width / 2 * (n.opposite ? 1 : -1), ", 0)"))) : "right" === n.labels.align && (r.forEach(function(t, e) {
                                        t.setAttribute("text-anchor", "end")
                                    }), n.opposite && s.setAttribute("transform", "translate(".concat(a.width, ", 0)")))
                                }
                            })
                        }
                    }]), t
                }(),
                J = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.documentEvent = y.bind(this.documentEvent, this)
                    }
                    return o(t, [{
                        key: "addEventListener",
                        value: function(t, e) {
                            var i = this.w;
                            i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e]
                        }
                    }, {
                        key: "removeEventListener",
                        value: function(t, e) {
                            var i = this.w;
                            if (i.globals.events.hasOwnProperty(t)) {
                                var n = i.globals.events[t].indexOf(e); - 1 !== n && i.globals.events[t].splice(n, 1)
                            }
                        }
                    }, {
                        key: "fireEvent",
                        value: function(t, e) {
                            var i = this.w;
                            if (i.globals.events.hasOwnProperty(t)) {
                                e && e.length || (e = []);
                                for (var n = i.globals.events[t], s = n.length, r = 0; r < s; r++) n[r].apply(null, e)
                            }
                        }
                    }, {
                        key: "setupEventHandlers",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = this.ctx,
                                n = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
                            this.ctx.eventList.forEach(function(t) {
                                n.addEventListener(t, function(t) {
                                    var n = Object.assign({}, e, {
                                        seriesIndex: e.globals.capturedSeriesIndex,
                                        dataPointIndex: e.globals.capturedDataPointIndex
                                    });
                                    "mousemove" === t.type || "touchmove" === t.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t, i, n) : ("mouseup" === t.type && 1 === t.which || "touchend" === t.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, i, n), i.ctx.events.fireEvent("click", [t, i, n]))
                                }, {
                                    capture: !1,
                                    passive: !0
                                })
                            }), this.ctx.eventList.forEach(function(i) {
                                e.globals.dom.baseEl.addEventListener(i, t.documentEvent, {
                                    passive: !0
                                })
                            }), this.ctx.core.setupBrushHandler()
                        }
                    }, {
                        key: "documentEvent",
                        value: function(t) {
                            var e = this.w,
                                i = t.target.className;
                            if ("click" === t.type) {
                                var n = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
                                n && n.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && n.classList.remove("apexcharts-menu-open")
                            }
                            e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY
                        }
                    }]), t
                }(),
                tt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "setCurrentLocaleValues",
                        value: function(t) {
                            var e = this.w.config.chart.locales;
                            window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                            var i = e.filter(function(e) {
                                return e.name === t
                            })[0];
                            if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                            var n = y.extend(O, i);
                            this.w.globals.locale = n.options
                        }
                    }]), t
                }(),
                et = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "drawAxis",
                        value: function(t, e) {
                            var i, n, s = this.w.globals,
                                r = this.w.config,
                                a = new q(this.ctx),
                                o = new K(this.ctx);
                            s.axisCharts && "radar" !== t && (s.isBarHorizontal ? (n = o.drawYaxisInversed(0), i = a.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(n)) : (i = a.drawXaxis(), s.dom.elGraphical.add(i), r.yaxis.map(function(t, e) {
                                -1 === s.ignoreYAxisIndexes.indexOf(e) && (n = o.drawYaxis(e), s.dom.Paper.add(n))
                            })))
                        }
                    }]), t
                }(),
                it = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "drawXCrosshairs",
                        value: function() {
                            var t = this.w,
                                e = new _(this.ctx),
                                i = new x(this.ctx),
                                n = t.config.xaxis.crosshairs.fill.gradient,
                                s = t.config.xaxis.crosshairs.dropShadow,
                                r = s.enabled,
                                a = s.left,
                                o = s.top,
                                l = s.blur,
                                c = s.color,
                                h = s.opacity,
                                u = t.config.xaxis.crosshairs.fill.color;
                            if (t.config.xaxis.crosshairs.show) {
                                "gradient" === t.config.xaxis.crosshairs.fill.type && (u = e.drawGradient("vertical", n.colorFrom, n.colorTo, n.opacityFrom, n.opacityTo, null, n.stops, null));
                                var d = e.drawRect();
                                1 === t.config.xaxis.crosshairs.width && (d = e.drawLine()), d.attr({
                                    class: "apexcharts-xcrosshairs",
                                    x: 0,
                                    y: 0,
                                    y2: t.globals.gridHeight,
                                    width: y.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0,
                                    height: t.globals.gridHeight,
                                    fill: u,
                                    filter: "none",
                                    "fill-opacity": t.config.xaxis.crosshairs.opacity,
                                    stroke: t.config.xaxis.crosshairs.stroke.color,
                                    "stroke-width": t.config.xaxis.crosshairs.stroke.width,
                                    "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
                                }), r && (d = i.dropShadow(d, {
                                    left: a,
                                    top: o,
                                    blur: l,
                                    color: c,
                                    opacity: h
                                })), t.globals.dom.elGraphical.add(d)
                            }
                        }
                    }, {
                        key: "drawYCrosshairs",
                        value: function() {
                            var t = this.w,
                                e = new _(this.ctx),
                                i = t.config.yaxis[0].crosshairs,
                                n = t.globals.barPadForNumericAxis;
                            if (t.config.yaxis[0].crosshairs.show) {
                                var s = e.drawLine(-n, 0, t.globals.gridWidth + n, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
                                s.attr({
                                    class: "apexcharts-ycrosshairs"
                                }), t.globals.dom.elGraphical.add(s)
                            }
                            var r = e.drawLine(-n, 0, t.globals.gridWidth + n, 0, i.stroke.color, 0, 0);
                            r.attr({
                                class: "apexcharts-ycrosshairs-hidden"
                            }), t.globals.dom.elGraphical.add(r)
                        }
                    }]), t
                }(),
                nt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "checkResponsiveConfig",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = i.config;
                            if (0 !== n.responsive.length) {
                                var s = n.responsive.slice();
                                s.sort(function(t, e) {
                                    return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0
                                }).reverse();
                                var r = new B({}),
                                    a = function() {
                                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                            n = s[0].breakpoint,
                                            a = window.innerWidth > 0 ? window.innerWidth : screen.width;
                                        if (a > n) {
                                            var o = k.extendArrayProps(r, i.globals.initialConfig, i);
                                            t = y.extend(o, t), t = y.extend(i.config, t), e.overrideResponsiveOptions(t)
                                        } else
                                            for (var l = 0; l < s.length; l++) a < s[l].breakpoint && (t = k.extendArrayProps(r, s[l].options, i), t = y.extend(i.config, t), e.overrideResponsiveOptions(t))
                                    };
                                if (t) {
                                    var o = k.extendArrayProps(r, t, i);
                                    o = y.extend(i.config, o), a(o = y.extend(o, t))
                                } else a({})
                            }
                        }
                    }, {
                        key: "overrideResponsiveOptions",
                        value: function(t) {
                            var e = new B(t).init({
                                responsiveOverride: !0
                            });
                            this.w.config = e
                        }
                    }]), t
                }(),
                st = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.colors = [], this.w = e.w;
                        var i = this.w;
                        this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === i.config.chart.type && i.config.plotOptions.treemap.distributed || "heatmap" === i.config.chart.type && i.config.plotOptions.heatmap.distributed, this.isBarDistributed = i.config.plotOptions.bar.distributed && ("bar" === i.config.chart.type || "rangeBar" === i.config.chart.type)
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            this.setDefaultColors()
                        }
                    }, {
                        key: "setDefaultColors",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = new y;
                            if (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && "function" == typeof e.config.colors[0] && (e.globals.colors = e.config.series.map(function(i, n) {
                                    var s = e.config.colors[n];
                                    return s || (s = e.config.colors[0]), "function" == typeof s ? (t.isColorFn = !0, s({
                                        value: e.globals.axisCharts ? e.globals.series[n][0] ? e.globals.series[n][0] : 0 : e.globals.series[n],
                                        seriesIndex: n,
                                        dataPointIndex: n,
                                        w: e
                                    })) : s
                                }))), e.globals.seriesColors.map(function(t, i) {
                                    t && (e.globals.colors[i] = t)
                                }), e.config.theme.monochrome.enabled) {
                                var n = [],
                                    s = e.globals.series.length;
                                (this.isBarDistributed || this.isHeatmapDistributed) && (s = e.globals.series[0].length * e.globals.series.length);
                                for (var r = e.config.theme.monochrome.color, a = 1 / (s / e.config.theme.monochrome.shadeIntensity), o = e.config.theme.monochrome.shadeTo, l = 0, c = 0; c < s; c++) {
                                    var h = void 0;
                                    "dark" === o ? (h = i.shadeColor(-1 * l, r), l += a) : (h = i.shadeColor(l, r), l += a), n.push(h)
                                }
                                e.globals.colors = n.slice()
                            }
                            var u = e.globals.colors.slice();
                            this.pushExtraColors(e.globals.colors), ["fill", "stroke"].forEach(function(i) {
                                e.globals[i].colors = void 0 === e.config[i].colors ? t.isColorFn ? e.config.colors : u : e.config[i].colors.slice(), t.pushExtraColors(e.globals[i].colors)
                            }), e.globals.dataLabels.style.colors = void 0 === e.config.dataLabels.style.colors ? u : e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), e.globals.radarPolygons.fill.colors = void 0 === e.config.plotOptions.radar.polygons.fill.colors ? ["dark" === e.config.theme.mode ? "#424242" : "none"] : e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), e.globals.markers.colors = void 0 === e.config.markers.colors ? u : e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors)
                        }
                    }, {
                        key: "pushExtraColors",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                n = this.w,
                                s = e || n.globals.series.length;
                            if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === n.config.chart.type && n.config.plotOptions.heatmap.colorScale.inverse), i && n.globals.series.length && (s = n.globals.series[n.globals.maxValsInArrayIndex].length * n.globals.series.length), t.length < s)
                                for (var r = s - t.length, a = 0; a < r; a++) t.push(t[a])
                        }
                    }, {
                        key: "updateThemeOptions",
                        value: function(t) {
                            t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
                            var e = t.theme.mode || "light",
                                i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
                                n = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
                            return t.tooltip.theme = e, t.chart.foreColor = n, t.theme.palette = i, t
                        }
                    }, {
                        key: "predefined",
                        value: function() {
                            switch (this.w.config.theme.palette) {
                                case "palette1":
                                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                                    break;
                                case "palette2":
                                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                                    break;
                                case "palette3":
                                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                                    break;
                                case "palette4":
                                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                                    break;
                                case "palette5":
                                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                                    break;
                                case "palette6":
                                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                                    break;
                                case "palette7":
                                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                                    break;
                                case "palette8":
                                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                                    break;
                                case "palette9":
                                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                                    break;
                                case "palette10":
                                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
                                    break;
                                default:
                                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"]
                            }
                            return this.colors
                        }
                    }]), t
                }(),
                rt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "draw",
                        value: function() {
                            this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
                        }
                    }, {
                        key: "drawTitleSubtitle",
                        value: function(t) {
                            var e = this.w,
                                i = "title" === t ? e.config.title : e.config.subtitle,
                                n = e.globals.svgWidth / 2,
                                s = i.offsetY,
                                r = "middle";
                            if ("left" === i.align ? (n = 10, r = "start") : "right" === i.align && (n = e.globals.svgWidth - 10, r = "end"), n += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
                                var a = new _(this.ctx).drawText({
                                    x: n,
                                    y: s,
                                    text: i.text,
                                    textAnchor: r,
                                    fontSize: i.style.fontSize,
                                    fontFamily: i.style.fontFamily,
                                    fontWeight: i.style.fontWeight,
                                    foreColor: i.style.color,
                                    opacity: 1
                                });
                                a.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(a)
                            }
                        }
                    }]), t
                }(),
                at = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.dCtx = e
                    }
                    return o(t, [{
                        key: "getTitleSubtitleCoords",
                        value: function(t) {
                            var e = this.w,
                                i = 0,
                                n = 0,
                                s = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
                                r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
                            if (null !== r && !s) {
                                var a = r.getBoundingClientRect();
                                i = a.width, n = e.globals.axisCharts ? a.height + 5 : a.height
                            }
                            return {
                                width: i,
                                height: n
                            }
                        }
                    }, {
                        key: "getLegendsRect",
                        value: function() {
                            var t = this.w,
                                e = t.globals.dom.baseEl.querySelector(".apexcharts-legend");
                            t.config.legend.height || "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
                            var i = Object.assign({}, y.getBoundingClientRect(e));
                            return this.dCtx.lgRect = null !== e && !t.config.legend.floating && t.config.legend.show ? {
                                x: i.x,
                                y: i.y,
                                height: i.height,
                                width: 0 === i.height ? 0 : i.width
                            } : {
                                x: 0,
                                y: 0,
                                height: 0,
                                width: 0
                            }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect
                        }
                    }, {
                        key: "getLargestStringFromMultiArr",
                        value: function(t, e) {
                            var i = t;
                            if (this.w.globals.isMultiLineX) {
                                var n = e.map(function(t, e) {
                                        return Array.isArray(t) ? t.length : 1
                                    }),
                                    s = Math.max.apply(Math, m(n));
                                i = e[n.indexOf(s)]
                            }
                            return i
                        }
                    }]), t
                }(),
                ot = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.dCtx = e
                    }
                    return o(t, [{
                        key: "getxAxisLabelsCoords",
                        value: function() {
                            var t, e = this.w,
                                i = e.globals.labels.slice();
                            if (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
                                var n = this.getxAxisTimeScaleLabelsCoords();
                                t = {
                                    width: n.width,
                                    height: n.height
                                }, e.globals.rotateXLabels = !1
                            } else {
                                this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                                var s = e.globals.xLabelFormatter,
                                    r = y.getLargestStringFromArr(i),
                                    a = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
                                e.globals.isBarHorizontal && (a = r = e.globals.yAxisScale[0].result.reduce(function(t, e) {
                                    return t.length > e.length ? t : e
                                }, 0));
                                var o = new W(this.dCtx.ctx),
                                    l = r;
                                r = o.xLabelFormat(s, r, l, {
                                    i: void 0,
                                    dateFormatter: new N(this.dCtx.ctx).formatDate,
                                    w: e
                                }), a = o.xLabelFormat(s, a, l, {
                                    i: void 0,
                                    dateFormatter: new N(this.dCtx.ctx).formatDate,
                                    w: e
                                }), (e.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (a = r = "1");
                                var c = new _(this.dCtx.ctx),
                                    h = c.getTextRects(r, e.config.xaxis.labels.style.fontSize),
                                    u = h;
                                if (r !== a && (u = c.getTextRects(a, e.config.xaxis.labels.style.fontSize)), (t = {
                                        width: h.width >= u.width ? h.width : u.width,
                                        height: h.height >= u.height ? h.height : u.height
                                    }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
                                    if (!e.globals.isBarHorizontal) {
                                        e.globals.rotateXLabels = !0;
                                        var d = function(t) {
                                            return c.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1)
                                        };
                                        h = d(r), r !== a && (u = d(a)), t.height = (h.height > u.height ? h.height : u.height) / 1.5, t.width = h.width > u.width ? h.width : u.width
                                    }
                                } else e.globals.rotateXLabels = !1
                            }
                            return e.config.xaxis.labels.show || (t = {
                                width: 0,
                                height: 0
                            }), {
                                width: t.width,
                                height: t.height
                            }
                        }
                    }, {
                        key: "getxAxisTitleCoords",
                        value: function() {
                            var t = this.w,
                                e = 0,
                                i = 0;
                            if (void 0 !== t.config.xaxis.title.text) {
                                var n = new _(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
                                e = n.width, i = n.height
                            }
                            return {
                                width: e,
                                height: i
                            }
                        }
                    }, {
                        key: "getxAxisTimeScaleLabelsCoords",
                        value: function() {
                            var t, e = this.w;
                            this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
                            var i = this.dCtx.timescaleLabels.map(function(t) {
                                    return t.value
                                }),
                                n = i.reduce(function(t, e) {
                                    return void 0 === t ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t.length > e.length ? t : e
                                }, 0);
                            return 1.05 * (t = new _(this.dCtx.ctx).getTextRects(n, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t
                        }
                    }, {
                        key: "additionalPaddingXLabels",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = i.globals,
                                s = i.config,
                                r = s.xaxis.type,
                                a = t.width;
                            n.skipLastTimelinelabel = !1, n.skipFirstTimelinelabel = !1;
                            var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal,
                                l = function(t, o) {
                                    (function(t) {
                                        return -1 !== n.collapsedSeriesIndices.indexOf(t)
                                    })(o) || function(t) {
                                        if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
                                            var o = e.dCtx.timescaleLabels[0].position - a / 1.75 + e.dCtx.yAxisWidthLeft;
                                            e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + a / 1.75 - e.dCtx.yAxisWidthRight > n.svgWidth - n.translateX - ("right" === i.config.legend.position && e.dCtx.lgRect.width > 0 ? e.dCtx.lgRect.width : 0) && (n.skipLastTimelinelabel = !0), o < -(t.show && !t.floating || "bar" !== s.chart.type && "candlestick" !== s.chart.type && "rangeBar" !== s.chart.type && "boxPlot" !== s.chart.type ? 10 : a / 1.75) && (n.skipFirstTimelinelabel = !0)
                                        } else "datetime" === r ? e.dCtx.gridPad.right < a && !n.rotateXLabels && (n.skipLastTimelinelabel = !0) : "datetime" !== r && e.dCtx.gridPad.right < a / 2 - e.dCtx.yAxisWidthRight && !n.rotateXLabels && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = a / 2 + 1)
                                    }(t)
                                };
                            s.yaxis.forEach(function(t, i) {
                                o ? (e.dCtx.gridPad.left < a && (e.dCtx.xPadLeft = a / 2 + 1), e.dCtx.xPadRight = a / 2 + 1) : l(t, i)
                            })
                        }
                    }]), t
                }(),
                lt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.dCtx = e
                    }
                    return o(t, [{
                        key: "getyAxisLabelsCoords",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = [],
                                n = 10,
                                s = new Y(this.dCtx.ctx);
                            return e.config.yaxis.map(function(r, a) {
                                var o = e.globals.yAxisScale[a];
                                if (!s.isYAxisHidden(a) && r.labels.show && o.result.length) {
                                    var l = e.globals.yLabelFormatters[a],
                                        c = o.niceMin === Number.MIN_VALUE ? 0 : o.niceMin,
                                        h = String(c).length > String(o.niceMax).length ? c : o.niceMax,
                                        u = l(h, {
                                            seriesIndex: a,
                                            dataPointIndex: -1,
                                            w: e
                                        }),
                                        d = u;
                                    if (void 0 !== u && 0 !== u.length || (u = h), e.globals.isBarHorizontal) {
                                        n = 0;
                                        var p = e.globals.labels.slice();
                                        u = l(u = y.getLargestStringFromArr(p), {
                                            seriesIndex: a,
                                            dataPointIndex: -1,
                                            w: e
                                        }), d = t.dCtx.dimHelpers.getLargestStringFromMultiArr(u, p)
                                    }
                                    var f = new _(t.dCtx.ctx),
                                        g = "rotate(".concat(r.labels.rotate, " 0 0)"),
                                        m = f.getTextRects(u, r.labels.style.fontSize, r.labels.style.fontFamily, g, !1),
                                        b = m;
                                    u !== d && (b = f.getTextRects(d, r.labels.style.fontSize, r.labels.style.fontFamily, g, !1)), i.push({
                                        width: (b.width > m.width ? b.width : m.width) + n,
                                        height: b.height > m.height ? b.height : m.height
                                    })
                                } else i.push({
                                    width: 0,
                                    height: 0
                                })
                            }), i
                        }
                    }, {
                        key: "getyAxisTitleCoords",
                        value: function() {
                            var t = this,
                                e = [];
                            return this.w.config.yaxis.map(function(i, n) {
                                if (i.show && void 0 !== i.title.text) {
                                    var s = new _(t.dCtx.ctx),
                                        r = "rotate(".concat(i.title.rotate, " 0 0)"),
                                        a = s.getTextRects(i.title.text, i.title.style.fontSize, i.title.style.fontFamily, r, !1);
                                    e.push({
                                        width: a.width,
                                        height: a.height
                                    })
                                } else e.push({
                                    width: 0,
                                    height: 0
                                })
                            }), e
                        }
                    }, {
                        key: "getTotalYAxisWidth",
                        value: function() {
                            var t = this.w,
                                e = 0,
                                i = 0,
                                n = 0,
                                s = t.globals.yAxisScale.length > 1 ? 10 : 0,
                                r = new Y(this.dCtx.ctx),
                                a = function(a, o) {
                                    var l = t.config.yaxis[o].floating,
                                        c = 0;
                                    a.width > 0 && !l ? (c = a.width + s, function(e) {
                                        return t.globals.ignoreYAxisIndexes.indexOf(e) > -1
                                    }(o) && (c = c - a.width - s)) : c = l || r.isYAxisHidden(o) ? 0 : 5, t.config.yaxis[o].opposite ? n += c : i += c, e += c
                                };
                            return t.globals.yLabelsCoords.map(function(t, e) {
                                a(t, e)
                            }), t.globals.yTitleCoords.map(function(t, e) {
                                a(t, e)
                            }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = n, e
                        }
                    }]), t
                }(),
                ct = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.dCtx = e
                    }
                    return o(t, [{
                        key: "gridPadForColumnsInNumericAxis",
                        value: function(t) {
                            var e = this.w;
                            if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
                            var i = function(t) {
                                    return "bar" === t || "rangeBar" === t || "candlestick" === t || "boxPlot" === t
                                },
                                n = e.config.chart.type,
                                s = 0,
                                r = i(n) ? e.config.series.length : 1;
                            if (e.globals.comboBarCount > 0 && (r = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(function(t) {
                                    i(t.type) && (r -= 1)
                                }), e.config.chart.stacked && (r = 1), (i(n) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && r > 0) {
                                var a, o, l = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
                                l <= 3 && (l = e.globals.dataPoints), a = l / t, e.globals.minXDiff && e.globals.minXDiff / a > 0 && (o = e.globals.minXDiff / a), o > t / 2 && (o /= 2), (s = o / r * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s = 1), e.globals.barPadForNumericAxis = s = s / (r > 1 ? 1 : 1.5) + 5
                            }
                            return s
                        }
                    }, {
                        key: "gridPadFortitleSubtitle",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.globals,
                                n = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
                            ["title", "subtitle"].forEach(function(i) {
                                n += void 0 !== e.config[i].text ? e.config[i].margin : t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5
                            }), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (n += 10);
                            var s = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
                                r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                            i.gridHeight = i.gridHeight - s.height - r.height - n, i.translateY = i.translateY + s.height + r.height + n
                        }
                    }, {
                        key: "setGridXPosForDualYAxis",
                        value: function(t, e) {
                            var i = this.w,
                                n = new Y(this.dCtx.ctx);
                            i.config.yaxis.map(function(s, r) {
                                -1 !== i.globals.ignoreYAxisIndexes.indexOf(r) || s.floating || n.isYAxisHidden(r) || (s.opposite && (i.globals.translateX = i.globals.translateX - (e[r].width + t[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2))
                            })
                        }
                    }]), t
                }(),
                ht = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new at(this), this.dimYAxis = new lt(this), this.dimXAxis = new ot(this), this.dimGrid = new ct(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
                    }
                    return o(t, [{
                        key: "plotCoords",
                        value: function() {
                            var t = this.w.globals;
                            this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                            var e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);
                            t.gridWidth = t.gridWidth - 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY = t.translateY + this.gridPad.top
                        }
                    }, {
                        key: "setDimensionsForAxisCharts",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.globals,
                                n = this.dimYAxis.getyAxisLabelsCoords(),
                                s = this.dimYAxis.getyAxisTitleCoords();
                            e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(function(t, i) {
                                e.globals.yLabelsCoords.push({
                                    width: n[i].width,
                                    index: i
                                }), e.globals.yTitleCoords.push({
                                    width: s[i].width,
                                    index: i
                                })
                            }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                            var r = this.dimXAxis.getxAxisLabelsCoords(),
                                a = this.dimXAxis.getxAxisTitleCoords();
                            this.conditionalChecksForAxisCoords(r, a), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
                            var o = this.yAxisWidth,
                                l = this.xAxisHeight;
                            i.xAxisLabelsHeight = this.xAxisHeight - a.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
                            var c = 10;
                            ("radar" === e.config.chart.type || this.isSparkline) && (o = 0, l = i.goldenPadding), this.isSparkline && (this.lgRect = {
                                height: 0,
                                width: 0
                            }), (this.isSparkline || "treemap" === e.config.chart.type) && (o = 0, l = 0, c = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
                            var h = function() {
                                i.translateX = o, i.gridHeight = i.svgHeight - t.lgRect.height - l - (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o
                            };
                            switch ("top" === e.config.xaxis.position && (c = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
                                case "bottom":
                                    i.translateY = c, h();
                                    break;
                                case "top":
                                    i.translateY = this.lgRect.height + c, h();
                                    break;
                                case "left":
                                    i.translateY = c, i.translateX = this.lgRect.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o;
                                    break;
                                case "right":
                                    i.translateY = c, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o - 5;
                                    break;
                                default:
                                    throw new Error("Legend position not supported")
                            }
                            this.dimGrid.setGridXPosForDualYAxis(s, n), new K(this.ctx).setYAxisXPosition(n, s)
                        }
                    }, {
                        key: "setDimensionsForNonAxisCharts",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = t.config,
                                n = 0;
                            t.config.legend.show && !t.config.legend.floating && (n = 20);
                            var s = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar",
                                r = i.plotOptions[s].offsetY,
                                a = i.plotOptions[s].offsetX;
                            if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = r, void(e.translateX = a + (e.svgWidth - e.gridWidth) / 2);
                            switch (i.legend.position) {
                                case "bottom":
                                    e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = r - 10, e.translateX = a + (e.svgWidth - e.gridWidth) / 2;
                                    break;
                                case "top":
                                    e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = this.lgRect.height + r + 10, e.translateX = a + (e.svgWidth - e.gridWidth) / 2;
                                    break;
                                case "left":
                                    e.gridWidth = e.svgWidth - this.lgRect.width - n, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = a + this.lgRect.width + n;
                                    break;
                                case "right":
                                    e.gridWidth = e.svgWidth - this.lgRect.width - n - 5, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = a + 10;
                                    break;
                                default:
                                    throw new Error("Legend position not supported")
                            }
                        }
                    }, {
                        key: "conditionalChecksForAxisCoords",
                        value: function(t, e) {
                            var i = this.w;
                            this.xAxisHeight = (t.height + e.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0);
                            var n = 0,
                                s = 0;
                            i.config.yaxis.forEach(function(t) {
                                n += t.labels.minWidth, s += t.labels.maxWidth
                            }), this.yAxisWidth < n && (this.yAxisWidth = n), this.yAxisWidth > s && (this.yAxisWidth = s)
                        }
                    }]), t
                }(),
                ut = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.lgCtx = e
                    }
                    return o(t, [{
                        key: "getLegendStyles",
                        value: function() {
                            var t = document.createElement("style");
                            t.setAttribute("type", "text/css");
                            var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                            return t.appendChild(e), t
                        }
                    }, {
                        key: "getLegendBBox",
                        value: function() {
                            var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect();
                            return {
                                clwh: t.height,
                                clww: t.width
                            }
                        }
                    }, {
                        key: "appendToForeignObject",
                        value: function() {
                            var t = this.w.globals;
                            t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
                            var e = t.dom.elLegendForeign;
                            e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t.svgWidth), e.setAttribute("height", t.svgHeight), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node)
                        }
                    }, {
                        key: "toggleDataSeries",
                        value: function(t, e) {
                            var i = this,
                                n = this.w;
                            if (n.globals.axisCharts || "radialBar" === n.config.chart.type) {
                                n.globals.resized = !0;
                                var s = null,
                                    r = null;
                                n.globals.risingSeries = [], n.globals.axisCharts ? (s = n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = n.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(s.getAttribute("rel"), 10) - 1), e ? [{
                                    cs: n.globals.collapsedSeries,
                                    csi: n.globals.collapsedSeriesIndices
                                }, {
                                    cs: n.globals.ancillaryCollapsedSeries,
                                    csi: n.globals.ancillaryCollapsedSeriesIndices
                                }].forEach(function(t) {
                                    i.riseCollapsedSeries(t.cs, t.csi, r)
                                }) : this.hideSeries({
                                    seriesEl: s,
                                    realIndex: r
                                })
                            } else {
                                var a = n.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
                                    o = n.config.chart.type;
                                if ("pie" === o || "polarArea" === o || "donut" === o) {
                                    var l = n.config.plotOptions.pie.donut.labels;
                                    new _(this.lgCtx.ctx).pathMouseDown(a.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(a.members[0].node, l)
                                }
                                a.fire("click")
                            }
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            var e = t.seriesEl,
                                i = t.realIndex,
                                n = this.w,
                                s = y.clone(n.config.series);
                            if (n.globals.axisCharts) {
                                var r = !1;
                                if (n.config.yaxis[i] && n.config.yaxis[i].show && n.config.yaxis[i].showAlways && (r = !0, n.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (n.globals.ancillaryCollapsedSeries.push({
                                        index: i,
                                        data: s[i].data.slice(),
                                        type: e.parentNode.className.baseVal.split("-")[1]
                                    }), n.globals.ancillaryCollapsedSeriesIndices.push(i))), !r) {
                                    n.globals.collapsedSeries.push({
                                        index: i,
                                        data: s[i].data.slice(),
                                        type: e.parentNode.className.baseVal.split("-")[1]
                                    }), n.globals.collapsedSeriesIndices.push(i);
                                    var a = n.globals.risingSeries.indexOf(i);
                                    n.globals.risingSeries.splice(a, 1)
                                }
                            } else n.globals.collapsedSeries.push({
                                index: i,
                                data: s[i]
                            }), n.globals.collapsedSeriesIndices.push(i);
                            for (var o = e.childNodes, l = 0; l < o.length; l++) o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
                            n.globals.allSeriesCollapsed = n.globals.collapsedSeries.length === n.config.series.length, s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, n.config.chart.animations.dynamicAnimation.enabled)
                        }
                    }, {
                        key: "riseCollapsedSeries",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = y.clone(n.config.series);
                            if (t.length > 0) {
                                for (var r = 0; r < t.length; r++) t[r].index === i && (n.globals.axisCharts ? (s[i].data = t[r].data.slice(), t.splice(r, 1), e.splice(r, 1), n.globals.risingSeries.push(i)) : (s[i] = t[r].data, t.splice(r, 1), e.splice(r, 1), n.globals.risingSeries.push(i)));
                                s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, n.config.chart.animations.dynamicAnimation.enabled)
                            }
                        }
                    }, {
                        key: "_getSeriesBasedOnCollapsedState",
                        value: function(t) {
                            var e = this.w;
                            return t.forEach(e.globals.axisCharts ? function(i, n) {
                                e.globals.collapsedSeriesIndices.indexOf(n) > -1 && (t[n].data = [])
                            } : function(i, n) {
                                e.globals.collapsedSeriesIndices.indexOf(n) > -1 && (t[n] = 0)
                            }), t
                        }
                    }]), t
                }(),
                dt = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ut(this)
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = t.config;
                            if ((i.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
                                for (; e.dom.elLegendWrap.firstChild;) e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
                                this.drawLegends(), y.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical()
                            }
                        }
                    }, {
                        key: "drawLegends",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.config.legend.fontFamily,
                                n = e.globals.seriesNames,
                                s = e.globals.colors.slice();
                            if ("heatmap" === e.config.chart.type) {
                                var r = e.config.plotOptions.heatmap.colorScale.ranges;
                                n = r.map(function(t) {
                                    return t.name ? t.name : t.from + " - " + t.to
                                }), s = r.map(function(t) {
                                    return t.color
                                })
                            } else this.isBarsDistributed && (n = e.globals.labels.slice());
                            for (var a = e.globals.legendFormatter, o = e.config.legend.inverseOrder, l = o ? n.length - 1 : 0; o ? l >= 0 : l <= n.length - 1; o ? l-- : l++) {
                                var c = a(n[l], {
                                        seriesIndex: l,
                                        w: e
                                    }),
                                    h = !1,
                                    u = !1;
                                if (e.globals.collapsedSeries.length > 0)
                                    for (var d = 0; d < e.globals.collapsedSeries.length; d++) e.globals.collapsedSeries[d].index === l && (h = !0);
                                if (e.globals.ancillaryCollapsedSeriesIndices.length > 0)
                                    for (var p = 0; p < e.globals.ancillaryCollapsedSeriesIndices.length; p++) e.globals.ancillaryCollapsedSeriesIndices[p] === l && (u = !0);
                                var f = document.createElement("span");
                                f.classList.add("apexcharts-legend-marker");
                                var g = e.config.legend.markers.offsetX,
                                    m = e.config.legend.markers.offsetY,
                                    b = e.config.legend.markers.height,
                                    v = e.config.legend.markers.width,
                                    x = e.config.legend.markers.strokeWidth,
                                    w = e.config.legend.markers.strokeColor,
                                    C = e.config.legend.markers.radius,
                                    S = f.style;
                                S.background = s[l], S.color = s[l], S.setProperty("background", s[l], "important"), e.config.legend.markers.fillColors && e.config.legend.markers.fillColors[l] && (S.background = e.config.legend.markers.fillColors[l]), void 0 !== e.globals.seriesColors[l] && (S.background = e.globals.seriesColors[l], S.color = e.globals.seriesColors[l]), S.height = Array.isArray(b) ? parseFloat(b[l]) + "px" : parseFloat(b) + "px", S.width = Array.isArray(v) ? parseFloat(v[l]) + "px" : parseFloat(v) + "px", S.left = Array.isArray(g) ? g[l] : g, S.top = Array.isArray(m) ? m[l] : m, S.borderWidth = Array.isArray(x) ? x[l] : x, S.borderColor = Array.isArray(w) ? w[l] : w, S.borderRadius = Array.isArray(C) ? parseFloat(C[l]) + "px" : parseFloat(C) + "px", e.config.legend.markers.customHTML && (Array.isArray(e.config.legend.markers.customHTML) ? e.config.legend.markers.customHTML[l] && (f.innerHTML = e.config.legend.markers.customHTML[l]()) : f.innerHTML = e.config.legend.markers.customHTML()), _.setAttrs(f, {
                                    rel: l + 1,
                                    "data:collapsed": h || u
                                }), (h || u) && f.classList.add("apexcharts-inactive-legend");
                                var A = document.createElement("div"),
                                    O = document.createElement("span");
                                O.classList.add("apexcharts-legend-text"), O.innerHTML = Array.isArray(c) ? c.join(" ") : c;
                                var E = e.config.legend.labels.useSeriesColors ? e.globals.colors[l] : e.config.legend.labels.colors;
                                E || (E = e.config.chart.foreColor), O.style.color = E, O.style.fontSize = parseFloat(e.config.legend.fontSize) + "px", O.style.fontWeight = e.config.legend.fontWeight, O.style.fontFamily = i || e.config.chart.fontFamily, _.setAttrs(O, {
                                    rel: l + 1,
                                    i: l,
                                    "data:default-text": encodeURIComponent(c),
                                    "data:collapsed": h || u
                                }), A.appendChild(f), A.appendChild(O);
                                var P = new k(this.ctx);
                                e.config.legend.showForZeroSeries || 0 === P.getSeriesTotalByIndex(l) && P.seriesHaveSameValues(l) && !P.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && A.classList.add("apexcharts-hidden-zero-series"), e.config.legend.showForNullSeries || P.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && A.classList.add("apexcharts-hidden-null-series"), e.globals.dom.elLegendWrap.appendChild(A), e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)), e.globals.dom.elLegendWrap.classList.add("position-" + e.config.legend.position), A.classList.add("apexcharts-legend-series"), A.style.margin = "".concat(e.config.legend.itemMargin.vertical, "px ").concat(e.config.legend.itemMargin.horizontal, "px"), e.globals.dom.elLegendWrap.style.width = e.config.legend.width ? e.config.legend.width + "px" : "", e.globals.dom.elLegendWrap.style.height = e.config.legend.height ? e.config.legend.height + "px" : "", _.setAttrs(A, {
                                    rel: l + 1,
                                    seriesName: y.escapeString(n[l]),
                                    "data:collapsed": h || u
                                }), (h || u) && A.classList.add("apexcharts-inactive-legend"), e.config.legend.onItemClick.toggleDataSeries || A.classList.add("apexcharts-no-click")
                            }
                            e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), e.config.legend.onItemHover.highlightDataSeries && (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0))
                        }
                    }, {
                        key: "setLegendWrapXY",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.globals.dom.baseEl.querySelector(".apexcharts-legend"),
                                s = n.getBoundingClientRect(),
                                r = 0,
                                a = 0;
                            if ("bottom" === i.config.legend.position) a += i.globals.svgHeight - s.height / 2;
                            else if ("top" === i.config.legend.position) {
                                var o = new ht(this.ctx),
                                    l = o.dimHelpers.getTitleSubtitleCoords("title").height,
                                    c = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                                a = a + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0)
                            }
                            n.style.position = "absolute", a = a + e + i.config.legend.offsetY, n.style.left = (r = r + t + i.config.legend.offsetX) + "px", n.style.top = a + "px", "bottom" === i.config.legend.position ? (n.style.top = "auto", n.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (n.style.left = "auto", n.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(t) {
                                n.style[t] && (n.style[t] = parseInt(i.config.legend[t], 10) + "px")
                            })
                        }
                    }, {
                        key: "legendAlignHorizontal",
                        value: function() {
                            var t = this.w;
                            t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                            var e = this.legendHelpers.getLegendBBox(),
                                i = new ht(this.ctx),
                                n = i.dimHelpers.getTitleSubtitleCoords("title"),
                                s = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
                                r = 0;
                            "bottom" === t.config.legend.position ? r = -e.clwh / 1.8 : "top" === t.config.legend.position && (r = n.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r)
                        }
                    }, {
                        key: "legendAlignVertical",
                        value: function() {
                            var t = this.w,
                                e = this.legendHelpers.getLegendBBox(),
                                i = 0;
                            "left" === t.config.legend.position && (i = 20), "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20)
                        }
                    }, {
                        key: "onLegendHovered",
                        value: function(t) {
                            var e = this.w,
                                i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
                            if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
                                if (i) {
                                    var n = parseInt(t.target.getAttribute("rel"), 10) - 1;
                                    this.ctx.events.fireEvent("legendHover", [this.ctx, n, this.w]), new R(this.ctx).highlightRangeInSeries(t, t.target)
                                }
                            } else !t.target.classList.contains("apexcharts-inactive-legend") && i && new R(this.ctx).toggleSeriesOnHover(t, t.target)
                        }
                    }, {
                        key: "onLegendClick",
                        value: function(t) {
                            var e = this.w;
                            if (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker")) {
                                var i = parseInt(t.target.getAttribute("rel"), 10) - 1,
                                    n = "true" === t.target.getAttribute("data:collapsed"),
                                    s = this.w.config.chart.events.legendClick;
                                "function" == typeof s && s(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                                var r = this.w.config.legend.markers.onClick;
                                "function" == typeof r && t.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), "treemap" !== e.config.chart.type && "heatmap" !== e.config.chart.type && !this.isBarsDistributed && e.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, n)
                            }
                        }
                    }]), t
                }(),
                pt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i.globals.minX, this.maxX = i.globals.maxX
                    }
                    return o(t, [{
                        key: "createToolbar",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = function() {
                                    return document.createElement("div")
                                },
                                n = i();
                            if (n.setAttribute("class", "apexcharts-toolbar"), n.style.top = e.config.chart.toolbar.offsetY + "px", n.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(n), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
                                for (var s = 0; s < this.t.customIcons.length; s++) this.elCustomIcons.push(i());
                            var r = [],
                                a = function(i, n, s) {
                                    var a = i.toLowerCase();
                                    t.t[a] && e.config.chart.zoom.enabled && r.push({
                                        el: n,
                                        icon: "string" == typeof t.t[a] ? t.t[a] : s,
                                        title: t.localeValues[i],
                                        class: "apexcharts-".concat(a, "-icon")
                                    })
                                };
                            a("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), a("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                            var o = function(i) {
                                t.t[i] && e.config.chart[i].enabled && r.push({
                                    el: "zoom" === i ? t.elZoom : t.elSelection,
                                    icon: "string" == typeof t.t[i] ? t.t[i] : "zoom" === i ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                                    title: t.localeValues["zoom" === i ? "selectionZoom" : "selection"],
                                    class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i, "-icon")
                                })
                            };
                            o("zoom"), o("selection"), this.t.pan && e.config.chart.zoom.enabled && r.push({
                                el: this.elPan,
                                icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                                title: this.localeValues.pan,
                                class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                            }), a("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r.push({
                                el: this.elMenuIcon,
                                icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                                title: this.localeValues.menu,
                                class: "apexcharts-menu-icon"
                            });
                            for (var l = 0; l < this.elCustomIcons.length; l++) r.push({
                                el: this.elCustomIcons[l],
                                icon: this.t.customIcons[l].icon,
                                title: this.t.customIcons[l].title,
                                index: this.t.customIcons[l].index,
                                class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
                            });
                            r.forEach(function(t, e) {
                                t.index && y.moveIndexInArray(r, e, t.index)
                            });
                            for (var c = 0; c < r.length; c++) _.setAttrs(r[c].el, {
                                class: r[c].class,
                                title: r[c].title
                            }), r[c].el.innerHTML = r[c].icon, n.appendChild(r[c].el);
                            this._createHamburgerMenu(n), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
                        }
                    }, {
                        key: "_createHamburgerMenu",
                        value: function(t) {
                            this.elMenuItems = [], t.appendChild(this.elMenu), _.setAttrs(this.elMenu, {
                                class: "apexcharts-menu"
                            });
                            var e = [{
                                name: "exportSVG",
                                title: this.localeValues.exportToSVG
                            }, {
                                name: "exportPNG",
                                title: this.localeValues.exportToPNG
                            }, {
                                name: "exportCSV",
                                title: this.localeValues.exportToCSV
                            }];
                            this.w.globals.allSeriesHasEqualX || e.splice(2, 1);
                            for (var i = 0; i < e.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e[i].title, _.setAttrs(this.elMenuItems[i], {
                                class: "apexcharts-menu-item ".concat(e[i].name),
                                title: e[i].title
                            }), this.elMenu.appendChild(this.elMenuItems[i])
                        }
                    }, {
                        key: "addToolbarEventListeners",
                        value: function() {
                            var t = this;
                            this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e) {
                                e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"))
                            });
                            for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w))
                        }
                    }, {
                        key: "toggleZoomSelection",
                        value: function(t) {
                            this.ctx.getSyncedCharts().forEach(function(e) {
                                e.ctx.toolbar.toggleOtherControls();
                                var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                                    n = "selection" === t ? "selectionEnabled" : "zoomEnabled";
                                e.w.globals[n] = !e.w.globals[n], i.classList.contains(e.ctx.toolbar.selectedClass) ? i.classList.remove(e.ctx.toolbar.selectedClass) : i.classList.add(e.ctx.toolbar.selectedClass)
                            })
                        }
                    }, {
                        key: "getToolbarIconsReference",
                        value: function() {
                            var t = this.w;
                            this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
                        }
                    }, {
                        key: "enableZoomPanFromToolbar",
                        value: function(t) {
                            this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                            var e = "pan" === t ? this.elPan : this.elZoom,
                                i = "pan" === t ? this.elZoom : this.elPan;
                            e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass)
                        }
                    }, {
                        key: "togglePanning",
                        value: function() {
                            this.ctx.getSyncedCharts().forEach(function(t) {
                                t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)
                            })
                        }
                    }, {
                        key: "toggleOtherControls",
                        value: function() {
                            var t = this,
                                e = this.w;
                            e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e) {
                                e && e.classList.remove(t.selectedClass)
                            })
                        }
                    }, {
                        key: "handleZoomIn",
                        value: function() {
                            var t = this.w;
                            t.globals.isTimelineBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
                            var e = (this.minX + this.maxX) / 2,
                                i = this._getNewMinXMaxX((this.minX + e) / 2, (this.maxX + e) / 2);
                            t.globals.disableZoomIn || this.zoomUpdateOptions(i.minX, i.maxX)
                        }
                    }, {
                        key: "handleZoomOut",
                        value: function() {
                            var t = this.w;
                            if (t.globals.isTimelineBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !("datetime" === t.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                                var e = (this.minX + this.maxX) / 2,
                                    i = this._getNewMinXMaxX(this.minX - (e - this.minX), this.maxX - (e - this.maxX));
                                t.globals.disableZoomOut || this.zoomUpdateOptions(i.minX, i.maxX)
                            }
                        }
                    }, {
                        key: "_getNewMinXMaxX",
                        value: function(t, e) {
                            var i = this.w.config.xaxis.convertedCatToNumeric;
                            return {
                                minX: i ? Math.floor(t) : t,
                                maxX: i ? Math.floor(e) : e
                            }
                        }
                    }, {
                        key: "zoomUpdateOptions",
                        value: function(t, e) {
                            var i = this.w;
                            if (void 0 !== t || void 0 !== e) {
                                if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) {
                                    var n = {
                                            min: t,
                                            max: e
                                        },
                                        s = this.getBeforeZoomRange(n);
                                    s && (n = s.xaxis);
                                    var r = {
                                            xaxis: n
                                        },
                                        a = y.clone(i.globals.initialConfig.yaxis);
                                    i.config.chart.zoom.autoScaleYaxis && (a = new $(this.ctx).autoScaleY(this.ctx, a, {
                                        xaxis: n
                                    })), i.config.chart.group || (r.yaxis = a), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(n, a)
                                }
                            } else this.handleZoomReset()
                        }
                    }, {
                        key: "zoomCallback",
                        value: function(t, e) {
                            "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                                xaxis: t,
                                yaxis: e
                            })
                        }
                    }, {
                        key: "getBeforeZoomRange",
                        value: function(t, e) {
                            var i = null;
                            return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
                                xaxis: t,
                                yaxis: e
                            })), i
                        }
                    }, {
                        key: "toggleMenu",
                        value: function() {
                            var t = this;
                            window.setTimeout(function() {
                                t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open")
                            }, 0)
                        }
                    }, {
                        key: "handleDownload",
                        value: function(t) {
                            var e = this.w,
                                i = new G(this.ctx);
                            switch (t) {
                                case "svg":
                                    i.exportToSVG(this.ctx);
                                    break;
                                case "png":
                                    i.exportToPng(this.ctx);
                                    break;
                                case "csv":
                                    i.exportToCSV({
                                        series: e.config.series,
                                        columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter
                                    })
                            }
                        }
                    }, {
                        key: "handleZoomReset",
                        value: function(t) {
                            this.ctx.getSyncedCharts().forEach(function(t) {
                                var e = t.w;
                                if (e.globals.lastXAxis.min = void 0, e.globals.lastXAxis.max = void 0, t.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e.config.chart.events.beforeResetZoom) {
                                    var i = e.config.chart.events.beforeResetZoom(t, e);
                                    i && t.updateHelpers.revertDefaultAxisMinMax(i)
                                }
                                "function" == typeof e.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
                                    min: e.config.xaxis.min,
                                    max: e.config.xaxis.max
                                }), e.globals.zoomed = !1;
                                var n = t.ctx.series.emptyCollapsedSeries(y.clone(e.globals.initialSeries));
                                t.updateHelpers._updateSeries(n, e.config.chart.animations.dynamicAnimation.enabled)
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
                        }
                    }]), t
                }(),
                ft = function(t) {
                    u(i, pt);
                    var e = g(i);

                    function i(t) {
                        var n;
                        return r(this, i), (n = e.call(this, t)).ctx = t, n.w = t.w, n.dragged = !1, n.graphics = new _(n.ctx), n.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], n.clientX = 0, n.clientY = 0, n.startX = 0, n.endX = 0, n.dragX = 0, n.startY = 0, n.endY = 0, n.dragY = 0, n.moveDirection = "none", n
                    }
                    return o(i, [{
                        key: "init",
                        value: function(t) {
                            var e = this,
                                i = t.xyRatios,
                                n = this.w,
                                s = this;
                            this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = n.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), n.globals.dom.elGraphical.add(this.zoomRect), n.globals.dom.elGraphical.add(this.selectionRect), this.slDraggableRect = "x" === n.config.chart.selection.type ? this.selectionRect.draggable({
                                minX: 0,
                                minY: 0,
                                maxX: n.globals.gridWidth,
                                maxY: n.globals.gridHeight
                            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === n.config.chart.selection.type ? this.selectionRect.draggable({
                                minX: 0,
                                maxX: n.globals.gridWidth
                            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = n.globals.dom.baseEl.querySelector("".concat(n.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t) {
                                e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), {
                                    capture: !1,
                                    passive: !0
                                })
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
                        }
                    }, {
                        key: "svgMouseEvents",
                        value: function(t, e) {
                            var i = this.w,
                                n = this,
                                s = this.ctx.toolbar,
                                r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type,
                                a = i.config.chart.toolbar.autoSelected;
                            e.shiftKey ? (this.shiftWasPressed = !0, s.enableZoomPanFromToolbar("pan" === a ? "zoom" : "pan")) : this.shiftWasPressed && (s.enableZoomPanFromToolbar(a), this.shiftWasPressed = !1);
                            var o = e.target.classList;
                            if (!(o.contains("apexcharts-selection-rect") || o.contains("apexcharts-legend-marker") || o.contains("apexcharts-legend-text") || e.target.parentNode.classList.contains("apexcharts-toolbar"))) {
                                if (n.clientX = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientX : "touchend" === e.type ? e.changedTouches[0].clientX : e.clientX, n.clientY = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientY : "touchend" === e.type ? e.changedTouches[0].clientY : e.clientY, "mousedown" === e.type && 1 === e.which) {
                                    var l = n.gridRect.getBoundingClientRect();
                                    n.startX = n.clientX - l.left, n.startY = n.clientY - l.top, n.dragged = !1, n.w.globals.mousedown = !0
                                }
                                if (("mousemove" === e.type && 1 === e.which || "touchmove" === e.type) && (n.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, n.w.globals.mousedown && n.panDragging({
                                        context: n,
                                        zoomtype: r,
                                        xyRatios: t
                                    })) : (n.w.globals.mousedown && i.globals.zoomEnabled || n.w.globals.mousedown && i.globals.selectionEnabled) && (n.selection = n.selectionDrawing({
                                        context: n,
                                        zoomtype: r
                                    }))), "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type) {
                                    var c = n.gridRect.getBoundingClientRect();
                                    n.w.globals.mousedown && (n.endX = n.clientX - c.left, n.endY = n.clientY - c.top, n.dragX = Math.abs(n.endX - n.startX), n.dragY = Math.abs(n.endY - n.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && n.selectionDrawn({
                                        context: n,
                                        zoomtype: r
                                    }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && n.delayedPanScrolled()), i.globals.zoomEnabled && n.hideSelectionRect(this.selectionRect), n.dragged = !1, n.w.globals.mousedown = !1
                                }
                                this.makeSelectionRectDraggable()
                            }
                        }
                    }, {
                        key: "makeSelectionRectDraggable",
                        value: function() {
                            var t = this.w;
                            if (this.selectionRect) {
                                var e = this.selectionRect.node.getBoundingClientRect();
                                e.width > 0 && e.height > 0 && this.slDraggableRect.selectize({
                                    points: "l, r",
                                    pointSize: 8,
                                    pointType: "rect"
                                }).resize({
                                    constraint: {
                                        minX: 0,
                                        minY: 0,
                                        maxX: t.globals.gridWidth,
                                        maxY: t.globals.gridHeight
                                    }
                                }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                            }
                        }
                    }, {
                        key: "preselectedSelection",
                        value: function() {
                            var t = this.w,
                                e = this.xyRatios;
                            if (!t.globals.zoomEnabled)
                                if (null != t.globals.selection) this.drawSelectionRect(t.globals.selection);
                                else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
                                var i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio;
                                this.drawSelectionRect({
                                    x: i,
                                    y: 0,
                                    width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i,
                                    height: t.globals.gridHeight,
                                    translateX: 0,
                                    translateY: 0,
                                    selectionEnabled: !0
                                }), this.makeSelectionRectDraggable(), "function" == typeof t.config.chart.events.selection && t.config.chart.events.selection(this.ctx, {
                                    xaxis: {
                                        min: t.config.chart.selection.xaxis.min,
                                        max: t.config.chart.selection.xaxis.max
                                    },
                                    yaxis: {}
                                })
                            }
                        }
                    }, {
                        key: "drawSelectionRect",
                        value: function(t) {
                            var e = t.x,
                                i = t.y,
                                n = t.width,
                                s = t.height,
                                r = t.translateX,
                                a = t.translateY,
                                o = this.w,
                                l = this.zoomRect,
                                c = this.selectionRect;
                            if (this.dragged || null !== o.globals.selection) {
                                var h = {
                                    transform: "translate(" + (void 0 === r ? 0 : r) + ", " + (void 0 === a ? 0 : a) + ")"
                                };
                                o.globals.zoomEnabled && this.dragged && (n < 0 && (n = 1), l.attr({
                                    x: e,
                                    y: i,
                                    width: n,
                                    height: s,
                                    fill: o.config.chart.zoom.zoomedArea.fill.color,
                                    "fill-opacity": o.config.chart.zoom.zoomedArea.fill.opacity,
                                    stroke: o.config.chart.zoom.zoomedArea.stroke.color,
                                    "stroke-width": o.config.chart.zoom.zoomedArea.stroke.width,
                                    "stroke-opacity": o.config.chart.zoom.zoomedArea.stroke.opacity
                                }), _.setAttrs(l.node, h)), o.globals.selectionEnabled && (c.attr({
                                    x: e,
                                    y: i,
                                    width: n > 0 ? n : 0,
                                    height: s > 0 ? s : 0,
                                    fill: o.config.chart.selection.fill.color,
                                    "fill-opacity": o.config.chart.selection.fill.opacity,
                                    stroke: o.config.chart.selection.stroke.color,
                                    "stroke-width": o.config.chart.selection.stroke.width,
                                    "stroke-dasharray": o.config.chart.selection.stroke.dashArray,
                                    "stroke-opacity": o.config.chart.selection.stroke.opacity
                                }), _.setAttrs(c.node, h))
                            }
                        }
                    }, {
                        key: "hideSelectionRect",
                        value: function(t) {
                            t && t.attr({
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            })
                        }
                    }, {
                        key: "selectionDrawing",
                        value: function(t) {
                            var e, i = t.zoomtype,
                                n = this.w,
                                s = t.context,
                                r = this.gridRect.getBoundingClientRect(),
                                a = s.startX - 1,
                                o = s.startY,
                                l = !1,
                                c = !1,
                                h = s.clientX - r.left - a,
                                u = s.clientY - r.top - o;
                            return Math.abs(h + a) > n.globals.gridWidth ? h = n.globals.gridWidth - a : s.clientX - r.left < 0 && (h = a), a > s.clientX - r.left && (l = !0, h = Math.abs(h)), o > s.clientY - r.top && (c = !0, u = Math.abs(u)), s.drawSelectionRect(e = "x" === i ? {
                                x: l ? a - h : a,
                                y: 0,
                                width: h,
                                height: n.globals.gridHeight
                            } : "y" === i ? {
                                x: 0,
                                y: c ? o - u : o,
                                width: n.globals.gridWidth,
                                height: u
                            } : {
                                x: l ? a - h : a,
                                y: c ? o - u : o,
                                width: h,
                                height: u
                            }), s.selectionDragging("resizing"), e
                        }
                    }, {
                        key: "selectionDragging",
                        value: function(t, e) {
                            var i = this,
                                n = this.w,
                                s = this.xyRatios,
                                r = this.selectionRect,
                                a = 0;
                            "resizing" === t && (a = 30);
                            var o = function(t) {
                                    return parseFloat(r.node.getAttribute(t))
                                },
                                l = {
                                    x: o("x"),
                                    y: o("y"),
                                    width: o("width"),
                                    height: o("height")
                                };
                            n.globals.selection = l, "function" == typeof n.config.chart.events.selection && n.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
                                var t = i.gridRect.getBoundingClientRect(),
                                    e = r.node.getBoundingClientRect(),
                                    a = {
                                        xaxis: {
                                            min: n.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio,
                                            max: n.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio
                                        },
                                        yaxis: {
                                            min: n.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0],
                                            max: n.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0]
                                        }
                                    };
                                n.config.chart.events.selection(i.ctx, a), n.config.chart.brush.enabled && void 0 !== n.config.chart.events.brushScrolled && n.config.chart.events.brushScrolled(i.ctx, a)
                            }, a))
                        }
                    }, {
                        key: "selectionDrawn",
                        value: function(t) {
                            var e = t.zoomtype,
                                i = this.w,
                                n = t.context,
                                s = this.xyRatios,
                                r = this.ctx.toolbar;
                            if (n.startX > n.endX) {
                                var a = n.startX;
                                n.startX = n.endX, n.endX = a
                            }
                            if (n.startY > n.endY) {
                                var o = n.startY;
                                n.startY = n.endY, n.endY = o
                            }
                            var l = void 0,
                                c = void 0;
                            i.globals.isTimelineBar ? (l = i.globals.yAxisScale[0].niceMin + n.startX * s.invertedYRatio, c = i.globals.yAxisScale[0].niceMin + n.endX * s.invertedYRatio) : (l = i.globals.xAxisScale.niceMin + n.startX * s.xRatio, c = i.globals.xAxisScale.niceMin + n.endX * s.xRatio);
                            var h = [],
                                u = [];
                            if (i.config.yaxis.forEach(function(t, e) {
                                    h.push(i.globals.yAxisScale[e].niceMax - s.yRatio[e] * n.startY), u.push(i.globals.yAxisScale[e].niceMax - s.yRatio[e] * n.endY)
                                }), n.dragged && (n.dragX > 10 || n.dragY > 10) && l !== c)
                                if (i.globals.zoomEnabled) {
                                    var d = y.clone(i.globals.initialConfig.yaxis),
                                        p = y.clone(i.globals.initialConfig.xaxis);
                                    if (i.globals.zoomed = !0, i.config.xaxis.convertedCatToNumeric && (l = Math.floor(l), c = Math.floor(c), l < 1 && (l = 1, c = i.globals.dataPoints), c - l < 2 && (c = l + 1)), "xy" !== e && "x" !== e || (p = {
                                            min: l,
                                            max: c
                                        }), "xy" !== e && "y" !== e || d.forEach(function(t, e) {
                                            d[e].min = u[e], d[e].max = h[e]
                                        }), i.config.chart.zoom.autoScaleYaxis) {
                                        var f = new $(n.ctx);
                                        d = f.autoScaleY(n.ctx, d, {
                                            xaxis: p
                                        })
                                    }
                                    if (r) {
                                        var g = r.getBeforeZoomRange(p, d);
                                        g && (p = g.xaxis ? g.xaxis : p, d = g.yaxis ? g.yaxis : d)
                                    }
                                    var m = {
                                        xaxis: p
                                    };
                                    i.config.chart.group || (m.yaxis = d), n.ctx.updateHelpers._updateOptions(m, !1, n.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof i.config.chart.events.zoomed && r.zoomCallback(p, d)
                                } else if (i.globals.selectionEnabled) {
                                var b, v = null;
                                b = {
                                    min: l,
                                    max: c
                                }, "xy" !== e && "y" !== e || (v = y.clone(i.config.yaxis)).forEach(function(t, e) {
                                    v[e].min = u[e], v[e].max = h[e]
                                }), i.globals.selection = n.selection, "function" == typeof i.config.chart.events.selection && i.config.chart.events.selection(n.ctx, {
                                    xaxis: b,
                                    yaxis: v
                                })
                            }
                        }
                    }, {
                        key: "panDragging",
                        value: function(t) {
                            var e = this.w,
                                i = t.context;
                            if (void 0 !== e.globals.lastClientPosition.x) {
                                var n = e.globals.lastClientPosition.x - i.clientX,
                                    s = e.globals.lastClientPosition.y - i.clientY;
                                Math.abs(n) > Math.abs(s) && n > 0 ? this.moveDirection = "left" : Math.abs(n) > Math.abs(s) && n < 0 ? this.moveDirection = "right" : Math.abs(s) > Math.abs(n) && s > 0 ? this.moveDirection = "up" : Math.abs(s) > Math.abs(n) && s < 0 && (this.moveDirection = "down")
                            }
                            e.globals.lastClientPosition = {
                                x: i.clientX,
                                y: i.clientY
                            }, e.config.xaxis.convertedCatToNumeric || i.panScrolled(e.globals.isTimelineBar ? e.globals.minY : e.globals.minX, e.globals.isTimelineBar ? e.globals.maxY : e.globals.maxX)
                        }
                    }, {
                        key: "delayedPanScrolled",
                        value: function() {
                            var t = this.w,
                                e = t.globals.minX,
                                i = t.globals.maxX,
                                n = (t.globals.maxX - t.globals.minX) / 2;
                            "left" === this.moveDirection ? (e = t.globals.minX + n, i = t.globals.maxX + n) : "right" === this.moveDirection && (e = t.globals.minX - n, i = t.globals.maxX - n), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({
                                xaxis: {
                                    min: e,
                                    max: i
                                }
                            }, e, i)
                        }
                    }, {
                        key: "panScrolled",
                        value: function(t, e) {
                            var i = this.w,
                                n = this.xyRatios,
                                s = y.clone(i.globals.initialConfig.yaxis),
                                r = n.xRatio,
                                a = i.globals.minX,
                                o = i.globals.maxX;
                            i.globals.isTimelineBar && (r = n.invertedYRatio, a = i.globals.minY, o = i.globals.maxY), "left" === this.moveDirection ? (t = a + i.globals.gridWidth / 15 * r, e = o + i.globals.gridWidth / 15 * r) : "right" === this.moveDirection && (t = a - i.globals.gridWidth / 15 * r, e = o - i.globals.gridWidth / 15 * r), i.globals.isTimelineBar || (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = a, e = o);
                            var l = {
                                min: t,
                                max: e
                            };
                            i.config.chart.zoom.autoScaleYaxis && (s = new $(this.ctx).autoScaleY(this.ctx, s, {
                                xaxis: l
                            }));
                            var c = {
                                xaxis: {
                                    min: t,
                                    max: e
                                }
                            };
                            i.config.chart.group || (c.yaxis = s), this.updateScrolledChart(c, t, e)
                        }
                    }, {
                        key: "updateScrolledChart",
                        value: function(t, e, i) {
                            var n = this.w;
                            this.ctx.updateHelpers._updateOptions(t, !1, !1), "function" == typeof n.config.chart.events.scrolled && n.config.chart.events.scrolled(this.ctx, {
                                xaxis: {
                                    min: e,
                                    max: i
                                }
                            })
                        }
                    }]), i
                }(),
                gt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx
                    }
                    return o(t, [{
                        key: "getNearestValues",
                        value: function(t) {
                            var e = t.hoverArea,
                                i = t.clientX,
                                n = t.clientY,
                                s = this.w,
                                r = s.globals.gridWidth,
                                a = r / (s.globals.dataPoints - 1),
                                o = s.globals.gridHeight / s.globals.dataPoints,
                                l = t.elGrid.getBoundingClientRect(),
                                c = this.hasBars();
                            !s.globals.comboCharts && !c || s.config.xaxis.convertedCatToNumeric || (a = r / s.globals.dataPoints);
                            var h = i - l.left - s.globals.barPadForNumericAxis,
                                u = n - l.top;
                            h < 0 || u < 0 || h > s.globals.gridWidth || u > s.globals.gridHeight ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : s.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : s.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
                            var d = Math.round(h / a),
                                p = Math.floor(u / o);
                            c && !s.config.xaxis.convertedCatToNumeric && (d = Math.ceil(h / a), d -= 1);
                            for (var f, g = null, m = null, b = [], v = 0; v < s.globals.seriesXvalues.length; v++) b.push([s.globals.seriesXvalues[v][0] - 1e-6].concat(s.globals.seriesXvalues[v]));
                            return b = b.map(function(t) {
                                return t.filter(function(t) {
                                    return t
                                })
                            }), f = s.globals.seriesYvalues.map(function(t) {
                                return t.filter(function(t) {
                                    return y.isNumber(t)
                                })
                            }), s.globals.isXNumeric && (g = (m = this.closestInMultiArray(h, u, b, f)).index, d = m.j, null !== g && (d = (m = this.closestInArray(h, b = s.globals.seriesXvalues[g])).index)), s.globals.capturedSeriesIndex = null === g ? -1 : g, (!d || d < 1) && (d = 0), s.globals.capturedDataPointIndex = d, {
                                capturedSeries: g,
                                j: s.globals.isBarHorizontal ? p : d,
                                hoverX: h,
                                hoverY: u
                            }
                        }
                    }, {
                        key: "closestInMultiArray",
                        value: function(t, e, i, n) {
                            var s = 0,
                                r = null,
                                a = -1;
                            this.w.globals.series.length > 1 ? s = this.getFirstActiveXArray(i) : r = 0;
                            var o = n[s][0],
                                l = Math.abs(t - i[s][0]),
                                c = Math.abs(e - o),
                                h = c + l;
                            return n.map(function(s, o) {
                                s.map(function(s, u) {
                                    var d = Math.abs(e - n[o][u]),
                                        p = Math.abs(t - i[o][u]),
                                        f = p + d;
                                    f < h && (h = f, l = p, c = d, r = o, a = u)
                                })
                            }), {
                                index: r,
                                j: a
                            }
                        }
                    }, {
                        key: "getFirstActiveXArray",
                        value: function(t) {
                            for (var e = 0, i = t.map(function(t, e) {
                                    return t.length > 0 ? e : -1
                                }), n = 0; n < i.length; n++)
                                if (-1 !== i[n]) {
                                    e = i[n];
                                    break
                                } return e
                        }
                    }, {
                        key: "closestInArray",
                        value: function(t, e) {
                            for (var i = null, n = Math.abs(t - e[0]), s = 0; s < e.length; s++) {
                                var r = Math.abs(t - e[s]);
                                r < n && (n = r, i = s)
                            }
                            return {
                                index: i
                            }
                        }
                    }, {
                        key: "isXoverlap",
                        value: function(t) {
                            var e = [],
                                i = this.w.globals.seriesX.filter(function(t) {
                                    return void 0 !== t[0]
                                });
                            if (i.length > 0)
                                for (var n = 0; n < i.length - 1; n++) void 0 !== i[n][t] && void 0 !== i[n + 1][t] && i[n][t] !== i[n + 1][t] && e.push("unEqual");
                            return 0 === e.length
                        }
                    }, {
                        key: "isInitialSeriesSameLen",
                        value: function() {
                            for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++)
                                if (e[i].data.length !== e[i + 1].data.length) {
                                    t = !1;
                                    break
                                } return t
                        }
                    }, {
                        key: "getBarsHeight",
                        value: function(t) {
                            return m(t).reduce(function(t, e) {
                                return t + e.getBBox().height
                            }, 0)
                        }
                    }, {
                        key: "getElMarkers",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers")
                        }
                    }, {
                        key: "getAllMarkers",
                        value: function() {
                            var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                            (t = m(t)).sort(function(t, e) {
                                return Number(e.getAttribute("data:realIndex")) < Number(t.getAttribute("data:realIndex")) ? 0 : -1
                            });
                            var e = [];
                            return t.forEach(function(t) {
                                e.push(t.querySelector(".apexcharts-marker"))
                            }), e
                        }
                    }, {
                        key: "hasMarkers",
                        value: function() {
                            return this.getElMarkers().length > 0
                        }
                    }, {
                        key: "getElBars",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
                        }
                    }, {
                        key: "hasBars",
                        value: function() {
                            return this.getElBars().length > 0
                        }
                    }, {
                        key: "getHoverMarkerSize",
                        value: function(t) {
                            var e = this.w,
                                i = e.config.markers.hover.size;
                            return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i
                        }
                    }, {
                        key: "toggleAllTooltipSeriesGroups",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                            for (var n = i.allTooltipSeriesGroups, s = 0; s < n.length; s++) "enable" === t ? (n[s].classList.add("apexcharts-active"), n[s].style.display = e.config.tooltip.items.display) : (n[s].classList.remove("apexcharts-active"), n[s].style.display = "none")
                        }
                    }]), t
                }(),
                mt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new gt(e)
                    }
                    return o(t, [{
                        key: "drawSeriesTexts",
                        value: function(t) {
                            var e = t.shared,
                                i = void 0 === e || e,
                                n = t.ttItems,
                                s = t.i,
                                r = void 0 === s ? 0 : s,
                                a = t.j,
                                o = void 0 === a ? null : a,
                                l = t.e,
                                c = this.w;
                            void 0 !== c.config.tooltip.custom ? this.handleCustomTooltip({
                                i: r,
                                j: o,
                                y1: t.y1,
                                y2: t.y2,
                                w: c
                            }) : this.toggleActiveInactiveSeries(i);
                            var h = this.getValuesToPrint({
                                i: r,
                                j: o
                            });
                            this.printLabels({
                                i: r,
                                j: o,
                                values: h,
                                ttItems: n,
                                shared: i,
                                e: l
                            });
                            var u = this.ttCtx.getElTooltip();
                            this.ttCtx.tooltipRect.ttWidth = u.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u.getBoundingClientRect().height
                        }
                    }, {
                        key: "printLabels",
                        value: function(t) {
                            var e, i = this,
                                n = t.i,
                                s = t.j,
                                r = t.values,
                                a = t.ttItems,
                                o = t.shared,
                                l = t.e,
                                c = this.w,
                                u = r.xVal,
                                d = r.zVal,
                                p = r.xAxisTTVal,
                                f = "",
                                g = c.globals.colors[n];
                            null !== s && c.config.plotOptions.bar.distributed && (g = c.globals.colors[s]);
                            for (var m = function(t, r) {
                                    var m = i.getFormatters(n);
                                    f = i.getSeriesName({
                                        fn: m.yLbTitleFormatter,
                                        index: n,
                                        seriesIndex: n,
                                        j: s
                                    }), "treemap" === c.config.chart.type && (f = m.yLbTitleFormatter(String(c.config.series[n].data[s].x), {
                                        series: c.globals.series,
                                        seriesIndex: n,
                                        dataPointIndex: s,
                                        w: c
                                    }));
                                    var b = c.config.tooltip.inverseOrder ? r : t;
                                    if (c.globals.axisCharts) {
                                        var y = function(t) {
                                            return m.yLbFormatter(c.globals.series[t][s], {
                                                series: c.globals.series,
                                                seriesIndex: t,
                                                dataPointIndex: s,
                                                w: c
                                            })
                                        };
                                        o ? (m = i.getFormatters(b), f = i.getSeriesName({
                                            fn: m.yLbTitleFormatter,
                                            index: b,
                                            seriesIndex: n,
                                            j: s
                                        }), g = c.globals.colors[b], e = y(b)) : (l && l.target && l.target.getAttribute("fill") && (g = l.target.getAttribute("fill")), e = y(n))
                                    }
                                    null === s && (e = m.yLbFormatter(c.globals.series[n], h(h({}, c), {}, {
                                        seriesIndex: n,
                                        dataPointIndex: n
                                    }))), i.DOMHandling({
                                        i: n,
                                        t: b,
                                        j: s,
                                        ttItems: a,
                                        values: {
                                            val: e,
                                            xVal: u,
                                            xAxisTTVal: p,
                                            zVal: d
                                        },
                                        seriesName: f,
                                        shared: o,
                                        pColor: g
                                    })
                                }, b = 0, y = c.globals.series.length - 1; b < c.globals.series.length; b++, y--) m(b, y)
                        }
                    }, {
                        key: "getFormatters",
                        value: function(t) {
                            var e, i = this.w,
                                n = i.globals.yLabelFormatters[t];
                            return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (n = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (n = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof n && (n = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(t) {
                                return t
                            }), "function" != typeof e && (e = function(t) {
                                return t
                            }), {
                                yLbFormatter: n,
                                yLbTitleFormatter: e
                            }
                        }
                    }, {
                        key: "getSeriesName",
                        value: function(t) {
                            var e = t.seriesIndex,
                                i = t.j,
                                n = this.w;
                            return (0, t.fn)(String(n.globals.seriesNames[t.index]), {
                                series: n.globals.series,
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: n
                            })
                        }
                    }, {
                        key: "DOMHandling",
                        value: function(t) {
                            var e = t.t,
                                i = t.ttItems,
                                n = t.values,
                                s = t.seriesName,
                                r = t.shared,
                                a = t.pColor,
                                o = this.w,
                                l = this.ttCtx,
                                c = n.val,
                                h = n.xVal,
                                u = n.xAxisTTVal,
                                d = n.zVal,
                                p = null;
                            p = i[e].children, o.config.tooltip.fillSeriesColor && (i[e].style.backgroundColor = a, p[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = o.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = h), l.blxaxisTooltip && (l.xaxisTooltipText.innerHTML = "" !== u ? u : h);
                            var f = i[e].querySelector(".apexcharts-tooltip-text-label");
                            f && (f.innerHTML = s || "");
                            var g = i[e].querySelector(".apexcharts-tooltip-text-value");
                            g && (g.innerHTML = void 0 !== c ? c : ""), p[0] && p[0].classList.contains("apexcharts-tooltip-marker") && (o.config.tooltip.marker.fillColors && Array.isArray(o.config.tooltip.marker.fillColors) && (a = o.config.tooltip.marker.fillColors[e]), p[0].style.backgroundColor = a), o.config.tooltip.marker.show || (p[0].style.display = "none"), null !== d && (i[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = o.config.tooltip.z.title, i[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== d ? d : ""), r && p[0] && (p[0].parentNode.style.display = null == c || o.globals.collapsedSeriesIndices.indexOf(e) > -1 ? "none" : o.config.tooltip.items.display)
                        }
                    }, {
                        key: "toggleActiveInactiveSeries",
                        value: function(t) {
                            var e = this.w;
                            if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                            else {
                                this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                                var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                                i && (i.classList.add("apexcharts-active"), i.style.display = e.config.tooltip.items.display)
                            }
                        }
                    }, {
                        key: "getValuesToPrint",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                n = this.w,
                                s = this.ctx.series.filteredSeriesX(),
                                r = "",
                                a = "",
                                o = null,
                                l = null,
                                c = {
                                    series: n.globals.series,
                                    seriesIndex: e,
                                    dataPointIndex: i,
                                    w: n
                                },
                                h = n.globals.ttZFormatter;
                            null === i ? l = n.globals.series[e] : n.globals.isXNumeric && "treemap" !== n.config.chart.type ? (r = s[e][i], 0 === s[e].length && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== n.globals.labels[i] ? n.globals.labels[i] : "";
                            var u = r;
                            return r = n.globals.isXNumeric && "datetime" === n.config.xaxis.type ? new W(this.ctx).xLabelFormat(n.globals.ttKeyFormatter, u, u, {
                                i: void 0,
                                dateFormatter: new N(this.ctx).formatDate,
                                w: this.w
                            }) : n.globals.isBarHorizontal ? n.globals.yLabelFormatters[0](u, c) : n.globals.xLabelFormatter(u, c), void 0 !== n.config.tooltip.x.formatter && (r = n.globals.ttKeyFormatter(u, c)), n.globals.seriesZ.length > 0 && n.globals.seriesZ[e].length > 0 && (o = h(n.globals.seriesZ[e][i], n)), a = "function" == typeof n.config.xaxis.tooltip.formatter ? n.globals.xaxisTooltipFormatter(u, c) : r, {
                                val: Array.isArray(l) ? l.join(" ") : l,
                                xVal: Array.isArray(r) ? r.join(" ") : r,
                                xAxisTTVal: Array.isArray(a) ? a.join(" ") : a,
                                zVal: o
                            }
                        }
                    }, {
                        key: "handleCustomTooltip",
                        value: function(t) {
                            var e = t.i,
                                i = t.j,
                                n = t.y1,
                                s = t.y2,
                                r = t.w,
                                a = this.ttCtx.getElTooltip(),
                                o = r.config.tooltip.custom;
                            Array.isArray(o) && o[e] && (o = o[e]), a.innerHTML = o({
                                ctx: this.ctx,
                                series: r.globals.series,
                                seriesIndex: e,
                                dataPointIndex: i,
                                y1: n,
                                y2: s,
                                w: r
                            })
                        }
                    }]), t
                }(),
                bt = function() {
                    function t(e) {
                        r(this, t), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w
                    }
                    return o(t, [{
                        key: "moveXCrosshairs",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                i = this.ttCtx,
                                n = this.w,
                                s = i.getElXCrosshairs(),
                                r = t - i.xcrosshairsWidth / 2,
                                a = n.globals.labels.slice().length;
                            if (null !== e && (r = n.globals.gridWidth / a * e), null !== s && (s.setAttribute("x", r), s.setAttribute("x1", r), s.setAttribute("x2", r), s.setAttribute("y2", n.globals.gridHeight), s.classList.add("apexcharts-active")), r < 0 && (r = 0), r > n.globals.gridWidth && (r = n.globals.gridWidth), i.blxaxisTooltip) {
                                var o = r;
                                "tickWidth" !== n.config.xaxis.crosshairs.width && "barWidth" !== n.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o)
                            }
                        }
                    }, {
                        key: "moveYCrosshairs",
                        value: function(t) {
                            var e = this.ttCtx;
                            null !== e.ycrosshairs && _.setAttrs(e.ycrosshairs, {
                                y1: t,
                                y2: t
                            }), null !== e.ycrosshairsHidden && _.setAttrs(e.ycrosshairsHidden, {
                                y1: t,
                                y2: t
                            })
                        }
                    }, {
                        key: "moveXAxisTooltip",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            if (null !== i.xaxisTooltip) {
                                i.xaxisTooltip.classList.add("apexcharts-active");
                                var n, s = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;
                                t -= i.xaxisTooltip.getBoundingClientRect().width / 2, isNaN(t) || (t += e.globals.translateX, n = new _(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = n.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = s + "px")
                            }
                        }
                    }, {
                        key: "moveYAxisTooltip",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx;
                            null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                            var n = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
                                s = e.globals.translateY + n,
                                r = i.yaxisTTEls[t].getBoundingClientRect().height,
                                a = e.globals.translateYAxisX[t] - 2;
                            e.config.yaxis[t].opposite && (a -= 26), s -= r / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = s + "px", i.yaxisTTEls[t].style.left = a + e.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active")
                        }
                    }, {
                        key: "moveTooltip",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                n = this.w,
                                s = this.ttCtx,
                                r = s.getElTooltip(),
                                a = s.tooltipRect,
                                o = null !== i ? parseFloat(i) : 1,
                                l = parseFloat(t) + o + 5,
                                c = parseFloat(e) + o / 2;
                            if (l > n.globals.gridWidth / 2 && (l = l - a.ttWidth - o - 15), l > n.globals.gridWidth - a.ttWidth - 10 && (l = n.globals.gridWidth - a.ttWidth), l < -20 && (l = -20), n.config.tooltip.followCursor) {
                                var h = s.getElGrid(),
                                    u = h.getBoundingClientRect();
                                c = s.e.clientY + n.globals.translateY - u.top - a.ttHeight / 2
                            } else n.globals.isBarHorizontal ? c -= a.ttHeight : (a.ttHeight / 2 + c > n.globals.gridHeight && (c = n.globals.gridHeight - a.ttHeight + n.globals.translateY), c < 0 && (c = 0));
                            isNaN(l) || (r.style.left = (l += n.globals.translateX) + "px", r.style.top = c + "px")
                        }
                    }, {
                        key: "moveMarkers",
                        value: function(t, e) {
                            var i = this.w,
                                n = this.ttCtx;
                            if (i.globals.markers.size[t] > 0)
                                for (var s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < s.length; r++) parseInt(s[r].getAttribute("rel"), 10) === e && (n.marker.resetPointsSize(), n.marker.enlargeCurrentPoint(e, s[r]));
                            else n.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t)
                        }
                    }, {
                        key: "moveDynamicPointOnHover",
                        value: function(t, e) {
                            var i, n, s = this.w,
                                r = this.ttCtx,
                                a = s.globals.pointsArray,
                                o = r.tooltipUtil.getHoverMarkerSize(e),
                                l = s.config.series[e].type;
                            if (!l || "column" !== l && "candlestick" !== l && "boxPlot" !== l) {
                                i = a[e][t][0], n = a[e][t][1] ? a[e][t][1] : 0;
                                var c = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
                                c && n < s.globals.gridHeight && n > 0 && (c.setAttribute("r", o), c.setAttribute("cx", i), c.setAttribute("cy", n)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, n, o)
                            }
                        }
                    }, {
                        key: "moveDynamicPointsOnHover",
                        value: function(t) {
                            var e, i = this.ttCtx,
                                n = i.w,
                                s = 0,
                                r = 0,
                                a = n.globals.pointsArray;
                            e = new R(this.ctx).getActiveConfigSeriesIndex(!0);
                            var o = i.tooltipUtil.getHoverMarkerSize(e);
                            a[e] && (s = a[e][t][0], r = a[e][t][1]);
                            var l = i.tooltipUtil.getAllMarkers();
                            if (null !== l)
                                for (var c = 0; c < n.globals.series.length; c++) {
                                    var h = a[c];
                                    if (n.globals.comboCharts && void 0 === h && l.splice(c, 0, null), h && h.length) {
                                        var u = a[c][t][1];
                                        l[c].setAttribute("cx", s), null !== u && !isNaN(u) && u < n.globals.gridHeight && u > 0 ? (l[c] && l[c].setAttribute("r", o), l[c] && l[c].setAttribute("cy", u)) : l[c] && l[c].setAttribute("r", 0)
                                    }
                                }
                            this.moveXCrosshairs(s), i.fixedTooltip || this.moveTooltip(s, r || n.globals.gridHeight, o)
                        }
                    }, {
                        key: "moveStickyTooltipOverBars",
                        value: function(t) {
                            var e = this.w,
                                i = this.ttCtx,
                                n = e.globals.columnSeries ? e.globals.columnSeries.length : e.globals.series.length,
                                s = n >= 2 && n % 2 == 0 ? Math.floor(n / 2) : Math.floor(n / 2) + 1;
                            e.globals.isBarHorizontal && (s = new R(this.ctx).getActiveConfigSeriesIndex(!1, "desc") + 1);
                            var r = e.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(s, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "']")),
                                a = r ? parseFloat(r.getAttribute("cx")) : 0,
                                o = r ? parseFloat(r.getAttribute("cy")) : 0,
                                l = r ? parseFloat(r.getAttribute("barWidth")) : 0,
                                c = r ? parseFloat(r.getAttribute("barHeight")) : 0,
                                h = i.getElGrid().getBoundingClientRect();
                            e.globals.isXNumeric ? (a -= n % 2 != 0 ? l / 2 : 0, r && (r.classList.contains("apexcharts-candlestick-area") || r.classList.contains("apexcharts-boxPlot-area")) && e.globals.comboCharts && (a -= l / 2)) : e.globals.isBarHorizontal || (a = i.xAxisTicksPositions[t - 1] + i.dataPointsDividedWidth / 2, isNaN(a) && (a = i.xAxisTicksPositions[t] - i.dataPointsDividedWidth / 2)), e.globals.isBarHorizontal ? o += c / 3 : o = i.e.clientY - h.top - i.tooltipRect.ttHeight / 2, e.globals.isBarHorizontal || this.moveXCrosshairs(a), i.fixedTooltip || this.moveTooltip(a, o || e.globals.gridHeight)
                        }
                    }]), t
                }(),
                yt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new bt(e)
                    }
                    return o(t, [{
                        key: "drawDynamicPoints",
                        value: function() {
                            var t = this.w,
                                e = new _(this.ctx),
                                i = new D(this.ctx),
                                n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                            n = m(n), t.config.chart.stacked && n.sort(function(t, e) {
                                return parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"))
                            });
                            for (var s = 0; s < n.length; s++) {
                                var r = n[s].querySelector(".apexcharts-series-markers-wrap");
                                if (null !== r) {
                                    var a = void 0,
                                        o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                                    "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (o += " no-pointer-events");
                                    var l = i.getMarkerConfig(o, s);
                                    (a = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                                    var c = document.createElementNS(t.globals.SVGNS, "g");
                                    c.classList.add("apexcharts-series-markers"), c.appendChild(a.node), r.appendChild(c)
                                }
                            }
                        }
                    }, {
                        key: "enlargeCurrentPoint",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                s = this.w;
                            "bubble" !== s.config.chart.type && this.newPointSize(t, e);
                            var r = e.getAttribute("cx"),
                                a = e.getAttribute("cy");
                            if (null !== i && null !== n && (r = i, a = n), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
                                if ("radar" === s.config.chart.type) {
                                    var o = this.ttCtx.getElGrid(),
                                        l = o.getBoundingClientRect();
                                    r = this.ttCtx.e.clientX - l.left
                                }
                                this.tooltipPosition.moveTooltip(r, a, s.config.markers.hover.size)
                            }
                        }
                    }, {
                        key: "enlargePoints",
                        value: function(t) {
                            for (var e = this.w, i = this, n = this.ttCtx, s = t, r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), a = e.config.markers.hover.size, o = 0; o < r.length; o++) {
                                var l = r[o].getAttribute("rel"),
                                    c = r[o].getAttribute("index");
                                if (void 0 === a && (a = e.globals.markers.size[c] + e.config.markers.hover.sizeOffset), s === parseInt(l, 10)) {
                                    i.newPointSize(s, r[o]);
                                    var h = r[o].getAttribute("cx"),
                                        u = r[o].getAttribute("cy");
                                    i.tooltipPosition.moveXCrosshairs(h), n.fixedTooltip || i.tooltipPosition.moveTooltip(h, u, a)
                                } else i.oldPointSize(r[o])
                            }
                        }
                    }, {
                        key: "newPointSize",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.config.markers.hover.size,
                                s = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;
                            if ("0" !== s.getAttribute("default-marker-size")) {
                                var r = parseInt(s.getAttribute("index"), 10);
                                void 0 === n && (n = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), n < 0 && (n = 0), s.setAttribute("r", n)
                            }
                        }
                    }, {
                        key: "oldPointSize",
                        value: function(t) {
                            var e = parseFloat(t.getAttribute("default-marker-size"));
                            t.setAttribute("r", e)
                        }
                    }, {
                        key: "resetPointsSize",
                        value: function() {
                            for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
                                var i = parseFloat(t[e].getAttribute("default-marker-size"));
                                y.isNumber(i) && i >= 0 ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0)
                            }
                        }
                    }]), t
                }(),
                vt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.ttCtx = e
                    }
                    return o(t, [{
                        key: "getAttr",
                        value: function(t, e) {
                            return parseFloat(t.target.getAttribute(e))
                        }
                    }, {
                        key: "handleHeatTreeTooltip",
                        value: function(t) {
                            var e = t.e,
                                i = t.opt,
                                n = t.x,
                                s = t.y,
                                r = this.ttCtx,
                                a = this.w;
                            if (e.target.classList.contains("apexcharts-".concat(t.type, "-rect"))) {
                                var o = this.getAttr(e, "i"),
                                    l = this.getAttr(e, "j"),
                                    c = this.getAttr(e, "cx"),
                                    h = this.getAttr(e, "cy"),
                                    u = this.getAttr(e, "width"),
                                    d = this.getAttr(e, "height");
                                if (r.tooltipLabels.drawSeriesTexts({
                                        ttItems: i.ttItems,
                                        i: o,
                                        j: l,
                                        shared: !1,
                                        e
                                    }), a.globals.capturedSeriesIndex = o, a.globals.capturedDataPointIndex = l, n = c + r.tooltipRect.ttWidth / 2 + u, s = h + r.tooltipRect.ttHeight / 2 - d / 2, r.tooltipPosition.moveXCrosshairs(c + u / 2), n > a.globals.gridWidth / 2 && (n = c - r.tooltipRect.ttWidth / 2 + u), r.w.config.tooltip.followCursor) {
                                    var p = a.globals.dom.elWrap.getBoundingClientRect();
                                    n = a.globals.clientX - p.left - r.tooltipRect.ttWidth / 2, s = a.globals.clientY - p.top - r.tooltipRect.ttHeight - 5
                                }
                            }
                            return {
                                x: n,
                                y: s
                            }
                        }
                    }, {
                        key: "handleMarkerTooltip",
                        value: function(t) {
                            var e, i, n = t.e,
                                s = t.opt,
                                r = t.x,
                                a = t.y,
                                o = this.w,
                                l = this.ttCtx;
                            if (n.target.classList.contains("apexcharts-marker")) {
                                var c = parseInt(s.paths.getAttribute("cx"), 10),
                                    h = parseInt(s.paths.getAttribute("cy"), 10),
                                    u = parseFloat(s.paths.getAttribute("val"));
                                if (i = parseInt(s.paths.getAttribute("rel"), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l.intersect) {
                                    var d = y.findAncestor(s.paths, "apexcharts-series");
                                    d && (e = parseInt(d.getAttribute("data:realIndex"), 10))
                                }
                                if (l.tooltipLabels.drawSeriesTexts({
                                        ttItems: s.ttItems,
                                        i: e,
                                        j: i,
                                        shared: !l.showOnIntersect && o.config.tooltip.shared,
                                        e: n
                                    }), "mouseup" === n.type && l.markerClick(n, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = c, a = h + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
                                    var p = l.getElGrid().getBoundingClientRect();
                                    a = l.e.clientY + o.globals.translateY - p.top
                                }
                                u < 0 && (a = h), l.marker.enlargeCurrentPoint(i, s.paths, r, a)
                            }
                            return {
                                x: r,
                                y: a
                            }
                        }
                    }, {
                        key: "handleBarTooltip",
                        value: function(t) {
                            var e, i, n = t.e,
                                s = t.opt,
                                r = this.w,
                                a = this.ttCtx,
                                o = a.getElTooltip(),
                                l = 0,
                                c = 0,
                                h = 0,
                                u = this.getBarTooltipXY({
                                    e: n,
                                    opt: s
                                }),
                                d = u.barHeight,
                                p = u.j;
                            r.globals.capturedSeriesIndex = e = u.i, r.globals.capturedDataPointIndex = p, r.globals.isBarHorizontal && a.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (c = u.x, h = u.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = c) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(h) ? h = r.globals.svgHeight - a.tooltipRect.ttHeight : h < 0 && (h = 0);
                            var f = parseInt(s.paths.parentNode.getAttribute("data:realIndex"), 10),
                                g = r.globals.isMultipleYAxis ? r.config.yaxis[f] && r.config.yaxis[f].reversed : r.config.yaxis[0].reversed;
                            if (c + a.tooltipRect.ttWidth > r.globals.gridWidth && !g ? c -= a.tooltipRect.ttWidth : c < 0 && (c = 0), a.w.config.tooltip.followCursor) {
                                var m = a.getElGrid().getBoundingClientRect();
                                h = a.e.clientY - m.top
                            }
                            null === a.tooltip && (a.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || a.tooltipPosition.moveXCrosshairs(r.globals.comboBarCount > 0 ? l + i / 2 : l), !a.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && a.tooltipUtil.hasBars()) && (g && (c -= a.tooltipRect.ttWidth) < 0 && (c = 0), o.style.left = c + r.globals.translateX + "px", !g || r.globals.isBarHorizontal && a.tooltipUtil.hasBars() || (h = h + d - 2 * (r.globals.series[e][p] < 0 ? d : 0)), o.style.top = a.tooltipRect.ttHeight + h > r.globals.gridHeight ? (h = r.globals.gridHeight - a.tooltipRect.ttHeight + r.globals.translateY) + "px" : h + r.globals.translateY - a.tooltipRect.ttHeight / 2 + "px")
                        }
                    }, {
                        key: "getBarTooltipXY",
                        value: function(t) {
                            var e = t.e,
                                i = t.opt,
                                n = this.w,
                                s = null,
                                r = this.ttCtx,
                                a = 0,
                                o = 0,
                                l = 0,
                                c = 0,
                                h = 0,
                                u = e.target.classList;
                            if (u.contains("apexcharts-bar-area") || u.contains("apexcharts-candlestick-area") || u.contains("apexcharts-boxPlot-area") || u.contains("apexcharts-rangebar-area")) {
                                var d = e.target,
                                    p = d.getBoundingClientRect(),
                                    f = i.elGrid.getBoundingClientRect(),
                                    g = p.height;
                                h = p.height;
                                var m = p.width,
                                    b = parseInt(d.getAttribute("cx"), 10),
                                    y = parseInt(d.getAttribute("cy"), 10);
                                c = parseFloat(d.getAttribute("barWidth"));
                                var v = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
                                s = parseInt(d.getAttribute("j"), 10), a = parseInt(d.parentNode.getAttribute("rel"), 10) - 1;
                                var x = d.getAttribute("data-range-y1"),
                                    _ = d.getAttribute("data-range-y2");
                                n.globals.comboCharts && (a = parseInt(d.parentNode.getAttribute("data:realIndex"), 10)), r.tooltipLabels.drawSeriesTexts({
                                    ttItems: i.ttItems,
                                    i: a,
                                    j: s,
                                    y1: x ? parseInt(x, 10) : null,
                                    y2: _ ? parseInt(_, 10) : null,
                                    shared: !r.showOnIntersect && n.config.tooltip.shared,
                                    e
                                }), n.config.tooltip.followCursor ? n.globals.isBarHorizontal ? (o = v - f.left + 15, l = y - r.dataPointsDividedHeight + g / 2 - r.tooltipRect.ttHeight / 2) : (o = n.globals.isXNumeric ? b - m / 2 : b - r.dataPointsDividedWidth + m / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : n.globals.isBarHorizontal ? ((o = b) < r.xyRatios.baseLineInvertedY && (o = b - r.tooltipRect.ttWidth), l = y - r.dataPointsDividedHeight + g / 2 - r.tooltipRect.ttHeight / 2) : (o = n.globals.isXNumeric ? b - m / 2 : b - r.dataPointsDividedWidth + m / 2, l = y)
                            }
                            return {
                                x: o,
                                y: l,
                                barHeight: h,
                                barWidth: c,
                                i: a,
                                j: s
                            }
                        }
                    }]), t
                }(),
                xt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.ttCtx = e
                    }
                    return o(t, [{
                        key: "drawXaxisTooltip",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx,
                                i = "bottom" === t.config.xaxis.position;
                            e.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
                            var n = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
                                s = t.globals.dom.elWrap;
                            e.blxaxisTooltip && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", n + " apexcharts-theme-" + t.config.tooltip.theme), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText))
                        }
                    }, {
                        key: "drawYaxisTooltip",
                        value: function() {
                            for (var t = this.w, e = this.ttCtx, i = function(i) {
                                    var n = t.config.yaxis[i].opposite || t.config.yaxis[i].crosshairs.opposite;
                                    e.yaxisOffX = n ? t.globals.gridWidth + 1 : 1;
                                    var s = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, n ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                                    t.globals.yAxisSameScaleIndices.map(function(e, n) {
                                        e.map(function(e, n) {
                                            n === i && (s += t.config.yaxis[n].show ? " " : " apexcharts-yaxistooltip-hidden")
                                        })
                                    });
                                    var r = t.globals.dom.elWrap;
                                    null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + t.config.tooltip.theme), r.appendChild(e.yaxisTooltip), 0 === i && (e.yaxisTooltipText = []), e.yaxisTooltipText[i] = document.createElement("div"), e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))
                                }, n = 0; n < t.config.yaxis.length; n++) i(n)
                        }
                    }, {
                        key: "setXCrosshairWidth",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx,
                                i = e.getElXCrosshairs();
                            if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
                                var n = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                if (null !== n && "barWidth" === t.config.xaxis.crosshairs.width) {
                                    var s = parseFloat(n.getAttribute("barWidth"));
                                    e.xcrosshairsWidth = s
                                } else "tickWidth" === t.config.xaxis.crosshairs.width && (e.xcrosshairsWidth = t.globals.gridWidth / t.globals.labels.length)
                            } else if ("tickWidth" === t.config.xaxis.crosshairs.width) e.xcrosshairsWidth = t.globals.gridWidth / t.globals.labels.length;
                            else if ("barWidth" === t.config.xaxis.crosshairs.width) {
                                var r = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                if (null !== r) {
                                    var a = parseFloat(r.getAttribute("barWidth"));
                                    e.xcrosshairsWidth = a
                                } else e.xcrosshairsWidth = 1
                            }
                            t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth)
                        }
                    }, {
                        key: "handleYCrosshair",
                        value: function() {
                            var t = this.w,
                                e = this.ttCtx;
                            e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
                        }
                    }, {
                        key: "drawYaxisTooltipText",
                        value: function(t, e, i) {
                            var n = this.ttCtx,
                                s = this.w,
                                r = s.globals.yLabelFormatters[t];
                            if (n.yaxisTooltips[t]) {
                                var a = n.getElGrid().getBoundingClientRect(),
                                    o = s.globals.minYArr[t] + (s.globals.maxYArr[t] - s.globals.minYArr[t] - (e - a.top) * i.yRatio[t]);
                                n.tooltipPosition.moveYCrosshairs(e - a.top), n.yaxisTooltipText[t].innerHTML = r(o), n.tooltipPosition.moveYAxisTooltip(t)
                            }
                        }
                    }]), t
                }(),
                _t = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.tConfig = i.config.tooltip, this.tooltipUtil = new gt(this), this.tooltipLabels = new mt(this), this.tooltipPosition = new bt(this), this.marker = new yt(this), this.intersect = new vt(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i.globals.isBarHorizontal && this.tConfig.shared
                    }
                    return o(t, [{
                        key: "getElTooltip",
                        value: function(t) {
                            return t || (t = this), t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip")
                        }
                    }, {
                        key: "getElXCrosshairs",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
                        }
                    }, {
                        key: "getElGrid",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
                        }
                    }, {
                        key: "drawTooltip",
                        value: function(t) {
                            var e = this.w;
                            this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map(function(t, i) {
                                return !!(t.show && t.tooltip.enabled && e.globals.axisCharts)
                            }), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
                            var i = document.createElement("div");
                            if (i.classList.add("apexcharts-tooltip"), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
                                this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
                                var n = new q(this.ctx);
                                this.xAxisTicksPositions = n.getXAxisTicksPositions()
                            }
                            if (!e.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
                                this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
                                var s = e.globals.series.length;
                                (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s), this.addSVGEvents()
                            }
                        }
                    }, {
                        key: "createTTElements",
                        value: function(t) {
                            for (var e = this.w, i = [], n = this.getElTooltip(), s = 0; s < t; s++) {
                                var r = document.createElement("div");
                                r.classList.add("apexcharts-tooltip-series-group"), r.style.order = e.config.tooltip.inverseOrder ? t - s : s + 1, this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(s) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
                                var a = document.createElement("span");
                                a.classList.add("apexcharts-tooltip-marker"), a.style.backgroundColor = e.globals.colors[s], r.appendChild(a);
                                var o = document.createElement("div");
                                o.classList.add("apexcharts-tooltip-text"), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize;
                                var l = document.createElement("div");
                                l.classList.add("apexcharts-tooltip-y-group");
                                var c = document.createElement("span");
                                c.classList.add("apexcharts-tooltip-text-label"), l.appendChild(c);
                                var h = document.createElement("span");
                                h.classList.add("apexcharts-tooltip-text-value"), l.appendChild(h);
                                var u = document.createElement("div");
                                u.classList.add("apexcharts-tooltip-z-group");
                                var d = document.createElement("span");
                                d.classList.add("apexcharts-tooltip-text-z-label"), u.appendChild(d);
                                var p = document.createElement("span");
                                p.classList.add("apexcharts-tooltip-text-z-value"), u.appendChild(p), o.appendChild(l), o.appendChild(u), r.appendChild(o), n.appendChild(r), i.push(r)
                            }
                            return i
                        }
                    }, {
                        key: "addSVGEvents",
                        value: function() {
                            var t = this.w,
                                e = t.config.chart.type,
                                i = this.getElTooltip(),
                                n = !("bar" !== e && "candlestick" !== e && "boxPlot" !== e && "rangeBar" !== e),
                                s = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
                                r = t.globals.dom.Paper.node,
                                a = this.getElGrid();
                            a && (this.seriesBound = a.getBoundingClientRect());
                            var o, l = [],
                                c = [],
                                h = {
                                    hoverArea: r,
                                    elGrid: a,
                                    tooltipEl: i,
                                    tooltipY: l,
                                    tooltipX: c,
                                    ttItems: this.ttItems
                                };
                            if (t.globals.axisCharts && (s ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : n ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e && "treemap" !== e || (o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o && o.length))
                                for (var u = 0; u < o.length; u++) l.push(o[u].getAttribute("cy")), c.push(o[u].getAttribute("cx"));
                            if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || n && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r], h);
                            else if (n && !t.globals.comboCharts || s && this.showOnIntersect) this.addDatapointEventsListeners(h);
                            else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
                                var d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                                this.addPathsEventListeners(d, h)
                            }
                            if (this.showOnIntersect) {
                                var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                                p.length > 0 && this.addPathsEventListeners(p, h), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(h)
                            }
                        }
                    }, {
                        key: "drawFixedTooltipRect",
                        value: function() {
                            var t = this.w,
                                e = this.getElTooltip(),
                                i = e.getBoundingClientRect(),
                                n = i.width + 10,
                                s = i.height + 10,
                                r = this.tConfig.fixed.offsetX,
                                a = this.tConfig.fixed.offsetY,
                                o = this.tConfig.fixed.position.toLowerCase();
                            return o.indexOf("right") > -1 && (r = r + t.globals.svgWidth - n + 10), o.indexOf("bottom") > -1 && (a = a + t.globals.svgHeight - s - 10), e.style.left = r + "px", e.style.top = a + "px", {
                                x: r,
                                y: a,
                                ttWidth: n,
                                ttHeight: s
                            }
                        }
                    }, {
                        key: "addDatapointEventsListeners",
                        value: function(t) {
                            var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                            this.addPathsEventListeners(e, t)
                        }
                    }, {
                        key: "addPathsEventListeners",
                        value: function(t, e) {
                            for (var i = this, n = function(n) {
                                    var s = {
                                        paths: t[n],
                                        tooltipEl: e.tooltipEl,
                                        tooltipY: e.tooltipY,
                                        tooltipX: e.tooltipX,
                                        elGrid: e.elGrid,
                                        hoverArea: e.hoverArea,
                                        ttItems: e.ttItems
                                    };
                                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e) {
                                        return t[n].addEventListener(e, i.seriesHover.bind(i, s), {
                                            capture: !1,
                                            passive: !0
                                        })
                                    })
                                }, s = 0; s < t.length; s++) n(s)
                        }
                    }, {
                        key: "seriesHover",
                        value: function(t, e) {
                            var i = this,
                                n = [],
                                s = this.w;
                            s.config.chart.group && (n = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || 0 === s.globals.dataPoints) || (n.length ? n.forEach(function(n) {
                                var s = i.getElTooltip(n);
                                n.w.globals.minX === i.w.globals.minX && n.w.globals.maxX === i.w.globals.maxX && n.w.globals.tooltip.seriesHoverByContext({
                                    chartCtx: n,
                                    ttCtx: n.w.globals.tooltip,
                                    opt: {
                                        paths: t.paths,
                                        tooltipEl: s,
                                        tooltipY: t.tooltipY,
                                        tooltipX: t.tooltipX,
                                        elGrid: t.elGrid,
                                        hoverArea: t.hoverArea,
                                        ttItems: n.w.globals.tooltip.ttItems
                                    },
                                    e
                                })
                            }) : this.seriesHoverByContext({
                                chartCtx: this.ctx,
                                ttCtx: this.w.globals.tooltip,
                                opt: t,
                                e
                            }))
                        }
                    }, {
                        key: "seriesHoverByContext",
                        value: function(t) {
                            var e = t.chartCtx,
                                i = t.ttCtx,
                                n = t.opt,
                                s = t.e,
                                r = e.w,
                                a = this.getElTooltip();
                            i.tooltipRect = {
                                x: 0,
                                y: 0,
                                ttWidth: a.getBoundingClientRect().width,
                                ttHeight: a.getBoundingClientRect().height
                            }, i.e = s, !i.tooltipUtil.hasBars() || r.globals.comboCharts || i.isBarShared || this.tConfig.onDatasetHover.highlightDataSeries && new R(e).toggleSeriesOnHover(s, s.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({
                                e: s,
                                opt: n,
                                tooltipRect: i.tooltipRect
                            }) : i.nonAxisChartsTooltips({
                                e: s,
                                opt: n,
                                tooltipRect: i.tooltipRect
                            })
                        }
                    }, {
                        key: "axisChartsTooltips",
                        value: function(t) {
                            var e, i, n = t.e,
                                s = t.opt,
                                r = this.w,
                                a = s.elGrid.getBoundingClientRect(),
                                o = "touchmove" === n.type ? n.touches[0].clientX : n.clientX,
                                l = "touchmove" === n.type ? n.touches[0].clientY : n.clientY;
                            if (this.clientY = l, this.clientX = o, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, l < a.top || l > a.top + a.height) this.handleMouseOut(s);
                            else {
                                if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
                                    var c = parseInt(s.paths.getAttribute("index"), 10);
                                    if (this.tConfig.enabledOnSeries.indexOf(c) < 0) return void this.handleMouseOut(s)
                                }
                                var h = this.getElTooltip(),
                                    u = this.getElXCrosshairs(),
                                    d = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
                                if ("mousemove" === n.type || "touchmove" === n.type || "mouseup" === n.type) {
                                    null !== u && u.classList.add("apexcharts-active");
                                    var p = this.yaxisTooltips.filter(function(t) {
                                        return !0 === t
                                    });
                                    if (null !== this.ycrosshairs && p.length && this.ycrosshairs.classList.add("apexcharts-active"), d && !this.showOnIntersect) this.handleStickyTooltip(n, o, l, s);
                                    else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
                                        var f = this.intersect.handleHeatTreeTooltip({
                                            e: n,
                                            opt: s,
                                            x: e,
                                            y: i,
                                            type: r.config.chart.type
                                        });
                                        i = f.y, h.style.left = (e = f.x) + "px", h.style.top = i + "px"
                                    } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                        e: n,
                                        opt: s
                                    }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                        e: n,
                                        opt: s,
                                        x: e,
                                        y: i
                                    });
                                    if (this.yaxisTooltips.length)
                                        for (var g = 0; g < r.config.yaxis.length; g++) this.axesTooltip.drawYaxisTooltipText(g, l, this.xyRatios);
                                    s.tooltipEl.classList.add("apexcharts-active")
                                } else "mouseout" !== n.type && "touchend" !== n.type || this.handleMouseOut(s)
                            }
                        }
                    }, {
                        key: "nonAxisChartsTooltips",
                        value: function(t) {
                            var e = t.e,
                                i = t.opt,
                                n = t.tooltipRect,
                                s = this.w,
                                r = i.paths.getAttribute("rel"),
                                a = this.getElTooltip(),
                                o = s.globals.dom.elWrap.getBoundingClientRect();
                            if ("mousemove" === e.type || "touchmove" === e.type) {
                                a.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                                    ttItems: i.ttItems,
                                    i: parseInt(r, 10) - 1,
                                    shared: !1
                                });
                                var l = s.globals.clientY - o.top - n.ttHeight - 10;
                                if (a.style.left = s.globals.clientX - o.left - n.ttWidth / 2 + "px", a.style.top = l + "px", s.config.legend.tooltipHoverFormatter) {
                                    var c = r - 1,
                                        h = (0, s.config.legend.tooltipHoverFormatter)(this.legendLabels[c].getAttribute("data:default-text"), {
                                            seriesIndex: c,
                                            dataPointIndex: c,
                                            w: s
                                        });
                                    this.legendLabels[c].innerHTML = h
                                }
                            } else "mouseout" !== e.type && "touchend" !== e.type || (a.classList.remove("apexcharts-active"), s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t) {
                                var e = t.getAttribute("data:default-text");
                                t.innerHTML = decodeURIComponent(e)
                            }))
                        }
                    }, {
                        key: "handleStickyTooltip",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = this.tooltipUtil.getNearestValues({
                                    context: this,
                                    hoverArea: n.hoverArea,
                                    elGrid: n.elGrid,
                                    clientX: e,
                                    clientY: i
                                }),
                                a = r.j,
                                o = r.capturedSeries;
                            r.hoverX < 0 || r.hoverX > s.globals.gridWidth ? this.handleMouseOut(n) : null !== o ? this.handleStickyCapturedSeries(t, o, n, a) : (this.tooltipUtil.isXoverlap(a) || s.globals.isBarHorizontal) && this.create(t, this, 0, a, n.ttItems)
                        }
                    }, {
                        key: "handleStickyCapturedSeries",
                        value: function(t, e, i, n) {
                            var s = this.w;
                            null === s.globals.series[e][n] ? this.handleMouseOut(i) : void 0 !== s.globals.series[e][n] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(n) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, n, i.ttItems) : this.create(t, this, e, n, i.ttItems, !1) : this.tooltipUtil.isXoverlap(n) && this.create(t, this, 0, n, i.ttItems)
                        }
                    }, {
                        key: "deactivateHoverFilter",
                        value: function() {
                            for (var t = this.w, e = new _(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), n = 0; n < i.length; n++) e.pathMouseLeave(i[n])
                        }
                    }, {
                        key: "handleMouseOut",
                        value: function(t) {
                            var e = this.w,
                                i = this.getElXCrosshairs();
                            if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.blxaxisTooltip && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                                null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                                for (var n = 0; n < this.yaxisTTEls.length; n++) this.yaxisTTEls[n].classList.remove("apexcharts-active")
                            }
                            e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t) {
                                var e = t.getAttribute("data:default-text");
                                t.innerHTML = decodeURIComponent(e)
                            })
                        }
                    }, {
                        key: "markerClick",
                        value: function(t, e, i) {
                            var n = this.w;
                            "function" == typeof n.config.chart.events.markerClick && n.config.chart.events.markerClick(t, this.ctx, {
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: n
                            }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {
                                seriesIndex: e,
                                dataPointIndex: i,
                                w: n
                            }])
                        }
                    }, {
                        key: "create",
                        value: function(t, e, i, n, s) {
                            var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                a = this.w,
                                o = e;
                            "mouseup" === t.type && this.markerClick(t, i, n), null === r && (r = this.tConfig.shared);
                            var l = this.tooltipUtil.hasMarkers(),
                                c = this.tooltipUtil.getElBars();
                            if (a.config.legend.tooltipHoverFormatter) {
                                var h = a.config.legend.tooltipHoverFormatter,
                                    u = Array.from(this.legendLabels);
                                u.forEach(function(t) {
                                    var e = t.getAttribute("data:default-text");
                                    t.innerHTML = decodeURIComponent(e)
                                });
                                for (var d = 0; d < u.length; d++) {
                                    var p = u[d],
                                        f = parseInt(p.getAttribute("i"), 10),
                                        g = decodeURIComponent(p.getAttribute("data:default-text")),
                                        m = h(g, {
                                            seriesIndex: r ? f : i,
                                            dataPointIndex: n,
                                            w: a
                                        });
                                    if (r) p.innerHTML = a.globals.collapsedSeriesIndices.indexOf(f) < 0 ? m : g;
                                    else if (p.innerHTML = f === i ? m : g, i === f) break
                                }
                            }
                            if (r) {
                                if (o.tooltipLabels.drawSeriesTexts({
                                        ttItems: s,
                                        i,
                                        j: n,
                                        shared: !this.showOnIntersect && this.tConfig.shared
                                    }), l && (a.globals.markers.largestSize > 0 ? o.marker.enlargePoints(n) : o.tooltipPosition.moveDynamicPointsOnHover(n)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(c), this.barSeriesHeight > 0)) {
                                    var b = new _(this.ctx),
                                        y = a.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(n, "']"));
                                    this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(n);
                                    for (var v = 0; v < y.length; v++) b.pathMouseEnter(y[v])
                                }
                            } else o.tooltipLabels.drawSeriesTexts({
                                shared: !1,
                                ttItems: s,
                                i,
                                j: n
                            }), this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(n), l && o.tooltipPosition.moveMarkers(i, n)
                        }
                    }]), t
                }(),
                wt = function(t) {
                    u(i, F);
                    var e = g(i);

                    function i() {
                        return r(this, i), e.apply(this, arguments)
                    }
                    return o(i, [{
                        key: "draw",
                        value: function(t, e) {
                            var i = this,
                                n = this.w;
                            this.graphics = new _(this.ctx), this.bar = new F(this.ctx, this.xyRatios);
                            var s = new k(this.ctx, n);
                            t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), "100%" === n.config.chart.stackType && (t = n.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
                            for (var r = 0; r < t.length; r++) t[r].length > 0 && (this.totalItems += t[r].length);
                            for (var a = this.graphics.group({
                                    class: "apexcharts-bar-series apexcharts-plot-series"
                                }), o = 0, l = 0, c = function(s, r) {
                                    var c = void 0,
                                        u = void 0,
                                        d = void 0,
                                        p = void 0,
                                        f = [],
                                        g = [],
                                        m = n.globals.comboCharts ? e[s] : s;
                                    i.yRatio.length > 1 && (i.yaxisIndex = m), i.isReversed = n.config.yaxis[i.yaxisIndex] && n.config.yaxis[i.yaxisIndex].reversed;
                                    var b = i.graphics.group({
                                        class: "apexcharts-series",
                                        seriesName: y.escapeString(n.globals.seriesNames[m]),
                                        rel: s + 1,
                                        "data:realIndex": m
                                    });
                                    i.ctx.series.addCollapsedClassToSeries(b, m);
                                    var v = i.graphics.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": m
                                        }),
                                        x = 0,
                                        _ = 0,
                                        w = i.initialPositions(o, l, c, u, d, p);
                                    l = w.y, x = w.barHeight, u = w.yDivision, p = w.zeroW, o = w.x, _ = w.barWidth, c = w.xDivision, d = w.zeroH, i.yArrj = [], i.yArrjF = [], i.yArrjVal = [], i.xArrj = [], i.xArrjF = [], i.xArrjVal = [], 1 === i.prevY.length && i.prevY[0].every(function(t) {
                                        return isNaN(t)
                                    }) && (i.prevY[0] = i.prevY[0].map(function(t) {
                                        return d
                                    }), i.prevYF[0] = i.prevYF[0].map(function(t) {
                                        return 0
                                    }));
                                    for (var C = 0; C < n.globals.dataPoints; C++) {
                                        var k = i.barHelpers.getStrokeWidth(s, C, m),
                                            S = {
                                                indexes: {
                                                    i: s,
                                                    j: C,
                                                    realIndex: m,
                                                    bc: r
                                                },
                                                strokeWidth: k,
                                                x: o,
                                                y: l,
                                                elSeries: b
                                            },
                                            A = null;
                                        i.isHorizontal ? (A = i.drawStackedBarPaths(h(h({}, S), {}, {
                                            zeroW: p,
                                            barHeight: x,
                                            yDivision: u
                                        })), _ = i.series[s][C] / i.invertedYRatio) : (A = i.drawStackedColumnPaths(h(h({}, S), {}, {
                                            xDivision: c,
                                            barWidth: _,
                                            zeroH: d
                                        })), x = i.series[s][C] / i.yRatio[i.yaxisIndex]), l = A.y, f.push(o = A.x), g.push(l);
                                        var O = i.barHelpers.getPathFillColor(t, s, C, m);
                                        b = i.renderSeries({
                                            realIndex: m,
                                            pathFill: O,
                                            j: C,
                                            i: s,
                                            pathFrom: A.pathFrom,
                                            pathTo: A.pathTo,
                                            strokeWidth: k,
                                            elSeries: b,
                                            x: o,
                                            y: l,
                                            series: t,
                                            barHeight: x,
                                            barWidth: _,
                                            elDataLabelsWrap: v,
                                            type: "bar",
                                            visibleSeries: 0
                                        })
                                    }
                                    n.globals.seriesXvalues[m] = f, n.globals.seriesYvalues[m] = g, i.prevY.push(i.yArrj), i.prevYF.push(i.yArrjF), i.prevYVal.push(i.yArrjVal), i.prevX.push(i.xArrj), i.prevXF.push(i.xArrjF), i.prevXVal.push(i.xArrjVal), a.add(b)
                                }, u = 0, d = 0; u < t.length; u++, d++) c(u, d);
                            return a
                        }
                    }, {
                        key: "initialPositions",
                        value: function(t, e, i, n, s, r) {
                            var a, o, l = this.w;
                            return this.isHorizontal ? (a = (a = n = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (n - a) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric && l.globals.dataPoints > 1 ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
                                x: t,
                                y: e,
                                yDivision: n,
                                xDivision: i,
                                barHeight: a,
                                barWidth: o,
                                zeroH: s,
                                zeroW: r
                            }
                        }
                    }, {
                        key: "drawStackedBarPaths",
                        value: function(t) {
                            for (var e, i, n = t.indexes, s = t.barHeight, r = t.strokeWidth, a = t.zeroW, o = t.y, l = t.yDivision, c = t.elSeries, h = this.w, u = o, d = n.i, p = n.j, f = 0, g = 0; g < this.prevXF.length; g++) f += this.prevXF[g][p];
                            if (d > 0) {
                                var m = a;
                                this.prevXVal[d - 1][p] < 0 ? m = this.series[d][p] >= 0 ? this.prevX[d - 1][p] + f - 2 * (this.isReversed ? f : 0) : this.prevX[d - 1][p] : this.prevXVal[d - 1][p] >= 0 && (m = this.series[d][p] >= 0 ? this.prevX[d - 1][p] : this.prevX[d - 1][p] - f + 2 * (this.isReversed ? f : 0)), e = m
                            } else e = a;
                            var b = this.barHelpers.getBarpaths({
                                barYPosition: u,
                                barHeight: s,
                                x1: e,
                                x2: i = null === this.series[d][p] ? e : e + this.series[d][p] / this.invertedYRatio - 2 * (this.isReversed ? this.series[d][p] / this.invertedYRatio : 0),
                                strokeWidth: r,
                                series: this.series,
                                realIndex: n.realIndex,
                                i: d,
                                j: p,
                                w: h
                            });
                            return this.barHelpers.barBackground({
                                j: p,
                                i: d,
                                y1: u,
                                y2: s,
                                elSeries: c
                            }), {
                                pathTo: b.pathTo,
                                pathFrom: b.pathFrom,
                                x: i,
                                y: o += l
                            }
                        }
                    }, {
                        key: "drawStackedColumnPaths",
                        value: function(t) {
                            var e, i = t.indexes,
                                n = t.x,
                                s = t.xDivision,
                                r = t.barWidth,
                                a = t.zeroH,
                                o = t.elSeries,
                                l = this.w,
                                c = i.i,
                                h = i.j,
                                u = i.bc;
                            if (l.globals.isXNumeric) {
                                var d = l.globals.seriesX[c][h];
                                d || (d = 0), n = (d - l.globals.minX) / this.xRatio - r / 2
                            }
                            for (var p, f = n, g = 0, m = 0; m < this.prevYF.length; m++) g += isNaN(this.prevYF[m][h]) ? 0 : this.prevYF[m][h];
                            if (c > 0 && !l.globals.isXNumeric || c > 0 && l.globals.isXNumeric && l.globals.seriesX[c - 1][h] === l.globals.seriesX[c][h]) {
                                var b, y, v = Math.min(this.yRatio.length + 1, c + 1);
                                if (void 0 !== this.prevY[c - 1])
                                    for (var x = 1; x < v; x++)
                                        if (!isNaN(this.prevY[c - x][h])) {
                                            y = this.prevY[c - x][h];
                                            break
                                        } for (var _ = 1; _ < v; _++) {
                                    if (this.prevYVal[c - _][h] < 0) {
                                        b = this.series[c][h] >= 0 ? y - g + 2 * (this.isReversed ? g : 0) : y;
                                        break
                                    }
                                    if (this.prevYVal[c - _][h] >= 0) {
                                        b = this.series[c][h] >= 0 ? y : y + g - 2 * (this.isReversed ? g : 0);
                                        break
                                    }
                                }
                                void 0 === b && (b = l.globals.gridHeight), p = this.prevYF[0].every(function(t) {
                                    return 0 === t
                                }) && this.prevYF.slice(1, c).every(function(t) {
                                    return t.every(function(t) {
                                        return isNaN(t)
                                    })
                                }) ? l.globals.gridHeight - a : b
                            } else p = l.globals.gridHeight - a;
                            var w = this.barHelpers.getColumnPaths({
                                barXPosition: f,
                                barWidth: r,
                                y1: p,
                                y2: e = p - this.series[c][h] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][h] / this.yRatio[this.yaxisIndex] : 0),
                                yRatio: this.yRatio[this.yaxisIndex],
                                strokeWidth: this.strokeWidth,
                                series: this.series,
                                realIndex: i.realIndex,
                                i: c,
                                j: h,
                                w: l
                            });
                            return this.barHelpers.barBackground({
                                bc: u,
                                j: h,
                                i: c,
                                x1: f,
                                x2: r,
                                elSeries: o
                            }), n += s, {
                                pathTo: w.pathTo,
                                pathFrom: w.pathFrom,
                                x: l.globals.isXNumeric ? n - s : n,
                                y: e
                            }
                        }
                    }]), i
                }(),
                Ct = function(t) {
                    u(i, F);
                    var e = g(i);

                    function i() {
                        return r(this, i), e.apply(this, arguments)
                    }
                    return o(i, [{
                        key: "draw",
                        value: function(t, e) {
                            var i = this,
                                n = this.w,
                                s = new _(this.ctx),
                                r = new T(this.ctx);
                            this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot;
                            var a = new k(this.ctx, n);
                            t = a.getLogSeries(t), this.series = t, this.yRatio = a.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                            for (var o = s.group({
                                    class: "apexcharts-".concat(n.config.chart.type, "-series apexcharts-plot-series")
                                }), l = function(a) {
                                    i.isBoxPlot = "boxPlot" === n.config.chart.type || "boxPlot" === n.config.series[a].type;
                                    var l, c, h, u, d = void 0,
                                        p = void 0,
                                        f = [],
                                        g = [],
                                        m = n.globals.comboCharts ? e[a] : a,
                                        b = s.group({
                                            class: "apexcharts-series",
                                            seriesName: y.escapeString(n.globals.seriesNames[m]),
                                            rel: a + 1,
                                            "data:realIndex": m
                                        });
                                    t[a].length > 0 && (i.visibleI = i.visibleI + 1), i.yRatio.length > 1 && (i.yaxisIndex = m);
                                    var v = i.barHelpers.initialPositions();
                                    p = v.y, h = v.barHeight, l = v.xDivision, c = v.zeroH, g.push((d = v.x) + (u = v.barWidth) / 2);
                                    for (var x = s.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": m
                                        }), _ = function(e) {
                                            var s = i.barHelpers.getStrokeWidth(a, e, m),
                                                o = i.drawBoxPaths({
                                                    indexes: {
                                                        i: a,
                                                        j: e,
                                                        realIndex: m
                                                    },
                                                    x: d,
                                                    y: p,
                                                    xDivision: l,
                                                    barWidth: u,
                                                    zeroH: c,
                                                    strokeWidth: s,
                                                    elSeries: b
                                                });
                                            p = o.y, d = o.x, e > 0 && g.push(d + u / 2), f.push(p), o.pathTo.forEach(function(l, c) {
                                                var f = !i.isBoxPlot && i.candlestickOptions.wick.useFillColor ? o.color[c] : n.globals.stroke.colors[a],
                                                    g = r.fillPath({
                                                        seriesNumber: m,
                                                        dataPointIndex: e,
                                                        color: o.color[c],
                                                        value: t[a][e]
                                                    });
                                                i.renderSeries({
                                                    realIndex: m,
                                                    pathFill: g,
                                                    lineFill: f,
                                                    j: e,
                                                    i: a,
                                                    pathFrom: o.pathFrom,
                                                    pathTo: l,
                                                    strokeWidth: s,
                                                    elSeries: b,
                                                    x: d,
                                                    y: p,
                                                    series: t,
                                                    barHeight: h,
                                                    barWidth: u,
                                                    elDataLabelsWrap: x,
                                                    visibleSeries: i.visibleI,
                                                    type: n.config.chart.type
                                                })
                                            })
                                        }, w = 0; w < n.globals.dataPoints; w++) _(w);
                                    n.globals.seriesXvalues[m] = g, n.globals.seriesYvalues[m] = f, o.add(b)
                                }, c = 0; c < t.length; c++) l(c);
                            return o
                        }
                    }, {
                        key: "drawBoxPaths",
                        value: function(t) {
                            var e = t.indexes,
                                i = t.x,
                                n = t.xDivision,
                                s = t.barWidth,
                                r = t.zeroH,
                                a = t.strokeWidth,
                                o = this.w,
                                l = new _(this.ctx),
                                c = e.i,
                                h = e.j,
                                u = !0,
                                d = o.config.plotOptions.candlestick.colors.upward,
                                p = o.config.plotOptions.candlestick.colors.downward,
                                f = "";
                            this.isBoxPlot && (f = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                            var g = this.yRatio[this.yaxisIndex],
                                m = e.realIndex,
                                b = this.getOHLCValue(m, h),
                                y = r,
                                v = r;
                            b.o > b.c && (u = !1);
                            var x = Math.min(b.o, b.c),
                                w = Math.max(b.o, b.c),
                                C = b.m;
                            o.globals.isXNumeric && (i = (o.globals.seriesX[m][h] - o.globals.minX) / this.xRatio - s / 2);
                            var k = i + s * this.visibleI;
                            null == this.series[c][h] ? (x = r, w = r) : (x = r - x / g, w = r - w / g, y = r - b.h / g, v = r - b.l / g, C = r - b.m / g);
                            var S = l.move(k, r),
                                A = l.move(k + s / 2, x);
                            return o.globals.previousPaths.length > 0 && (A = this.getPreviousPath(m, h, !0)), S = this.isBoxPlot ? [l.move(k, x) + l.line(k + s / 2, x) + l.line(k + s / 2, y) + l.line(k + s / 4, y) + l.line(k + s - s / 4, y) + l.line(k + s / 2, y) + l.line(k + s / 2, x) + l.line(k + s, x) + l.line(k + s, C) + l.line(k, C) + l.line(k, x + a / 2), l.move(k, C) + l.line(k + s, C) + l.line(k + s, w) + l.line(k + s / 2, w) + l.line(k + s / 2, v) + l.line(k + s - s / 4, v) + l.line(k + s / 4, v) + l.line(k + s / 2, v) + l.line(k + s / 2, w) + l.line(k, w) + l.line(k, C) + "z"] : [l.move(k, w) + l.line(k + s / 2, w) + l.line(k + s / 2, y) + l.line(k + s / 2, w) + l.line(k + s, w) + l.line(k + s, x) + l.line(k + s / 2, x) + l.line(k + s / 2, v) + l.line(k + s / 2, x) + l.line(k, x) + l.line(k, w - a / 2)], A += l.move(k, x), o.globals.isXNumeric || (i += n), {
                                pathTo: S,
                                pathFrom: A,
                                x: i,
                                y: w,
                                barXPosition: k,
                                color: this.isBoxPlot ? f : u ? [d] : [p]
                            }
                        }
                    }, {
                        key: "getOHLCValue",
                        value: function(t, e) {
                            var i = this.w;
                            return {
                                o: this.isBoxPlot ? i.globals.seriesCandleH[t][e] : i.globals.seriesCandleO[t][e],
                                h: this.isBoxPlot ? i.globals.seriesCandleO[t][e] : i.globals.seriesCandleH[t][e],
                                m: i.globals.seriesCandleM[t][e],
                                l: this.isBoxPlot ? i.globals.seriesCandleC[t][e] : i.globals.seriesCandleL[t][e],
                                c: this.isBoxPlot ? i.globals.seriesCandleL[t][e] : i.globals.seriesCandleC[t][e]
                            }
                        }
                    }]), i
                }(),
                kt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "checkColorRange",
                        value: function() {
                            var t = this.w,
                                e = !1,
                                i = t.config.plotOptions[t.config.chart.type];
                            return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(t, i) {
                                t.from <= 0 && (e = !0)
                            }), e
                        }
                    }, {
                        key: "getShadeColor",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = 1,
                                a = s.config.plotOptions[t].shadeIntensity,
                                o = this.determineColor(t, e, i);
                            s.globals.hasNegs || n ? r = s.config.plotOptions[t].reverseNegativeShade ? o.percent < 0 ? o.percent / 100 * (1.25 * a) : 1.25 * a * (1 - o.percent / 100) : o.percent <= 0 ? 1 - (1 + o.percent / 100) * a : (1 - o.percent / 100) * a : (r = 1 - o.percent / 100, "treemap" === t && (r = 1.25 * a * (1 - o.percent / 100)));
                            var l = o.color,
                                c = new y;
                            return s.config.plotOptions[t].enableShades && (l = y.hexToRgba(c.shadeColor("dark" === this.w.config.theme.mode ? -1 * r : r, o.color), s.config.fill.opacity)), {
                                color: l,
                                colorProps: o
                            }
                        }
                    }, {
                        key: "determineColor",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = n.globals.series[e][i],
                                r = n.config.plotOptions[t],
                                a = r.colorScale.inverse ? i : e;
                            n.config.plotOptions[t].distributed && (a = i);
                            var o = n.globals.colors[a],
                                l = null,
                                c = Math.min.apply(Math, m(n.globals.series[e])),
                                h = Math.max.apply(Math, m(n.globals.series[e]));
                            r.distributed || "heatmap" !== t || (c = n.globals.minY, h = n.globals.maxY), void 0 !== r.colorScale.min && (c = r.colorScale.min < n.globals.minY ? r.colorScale.min : n.globals.minY, h = r.colorScale.max > n.globals.maxY ? r.colorScale.max : n.globals.maxY);
                            var u = Math.abs(h) + Math.abs(c),
                                d = 100 * s / (0 === u ? u - 1e-6 : u);
                            return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map(function(t, e) {
                                if (s >= t.from && s <= t.to) {
                                    o = t.color, l = t.foreColor ? t.foreColor : null, c = t.from, h = t.to;
                                    var i = Math.abs(h) + Math.abs(c);
                                    d = 100 * s / (0 === i ? i - 1e-6 : i)
                                }
                            }), {
                                color: o,
                                foreColor: l,
                                percent: d
                            }
                        }
                    }, {
                        key: "calculateDataLabels",
                        value: function(t) {
                            var e = t.text,
                                i = t.x,
                                n = t.y,
                                s = t.i,
                                r = t.j,
                                a = t.colorProps,
                                o = t.fontSize,
                                l = this.w.config.dataLabels,
                                c = new _(this.ctx),
                                h = new M(this.ctx),
                                u = null;
                            if (l.enabled) {
                                u = c.group({
                                    class: "apexcharts-data-labels"
                                });
                                var d = l.offsetY,
                                    p = i + l.offsetX,
                                    f = n + parseFloat(l.style.fontSize) / 3 + d;
                                h.plotDataLabelsText({
                                    x: p,
                                    y: f,
                                    text: e,
                                    i: s,
                                    j: r,
                                    color: a.foreColor,
                                    parent: u,
                                    fontSize: o,
                                    dataLabelsConfig: l
                                })
                            }
                            return u
                        }
                    }, {
                        key: "addListeners",
                        value: function(t) {
                            var e = new _(this.ctx);
                            t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t))
                        }
                    }]), t
                }(),
                St = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = e, this.w = e.w, this.xRatio = i.xRatio, this.yRatio = i.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new kt(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = i.group({
                                    class: "apexcharts-heatmap"
                                });
                            n.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
                            var s = e.globals.gridWidth / e.globals.dataPoints,
                                r = e.globals.gridHeight / e.globals.series.length,
                                a = 0,
                                o = !1;
                            this.negRange = this.helpers.checkColorRange();
                            var l = t.slice();
                            e.config.yaxis[0].reversed && (o = !0, l.reverse());
                            for (var c = o ? 0 : l.length - 1; o ? c < l.length : c >= 0; o ? c++ : c--) {
                                var h = i.group({
                                    class: "apexcharts-series apexcharts-heatmap-series",
                                    seriesName: y.escapeString(e.globals.seriesNames[c]),
                                    rel: c + 1,
                                    "data:realIndex": c
                                });
                                if (this.ctx.series.addCollapsedClassToSeries(h, c), e.config.chart.dropShadow.enabled) {
                                    var u = e.config.chart.dropShadow;
                                    new x(this.ctx).dropShadow(h, u, c)
                                }
                                for (var d = 0, p = e.config.plotOptions.heatmap.shadeIntensity, f = 0; f < l[c].length; f++) {
                                    var g = this.helpers.getShadeColor(e.config.chart.type, c, f, this.negRange),
                                        m = g.color,
                                        b = g.colorProps;
                                    "image" === e.config.fill.type && (m = new T(this.ctx).fillPath({
                                        seriesNumber: c,
                                        dataPointIndex: f,
                                        opacity: e.globals.hasNegs ? b.percent < 0 ? 1 - (1 + b.percent / 100) : p + b.percent / 100 : b.percent / 100,
                                        patternID: y.randomId(),
                                        width: e.config.fill.image.width ? e.config.fill.image.width : s,
                                        height: e.config.fill.image.height ? e.config.fill.image.height : r
                                    }));
                                    var v = i.drawRect(d, a, s, r, this.rectRadius);
                                    if (v.attr({
                                            cx: d,
                                            cy: a
                                        }), v.node.classList.add("apexcharts-heatmap-rect"), h.add(v), v.attr({
                                            fill: m,
                                            i: c,
                                            index: c,
                                            j: f,
                                            val: l[c][f],
                                            "stroke-width": this.strokeWidth,
                                            stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? m : e.globals.stroke.colors[0],
                                            color: m
                                        }), this.helpers.addListeners(v), e.config.chart.animations.enabled && !e.globals.dataChanged) {
                                        var w = 1;
                                        e.globals.resized || (w = e.config.chart.animations.speed), this.animateHeatMap(v, d, a, s, r, w)
                                    }
                                    if (e.globals.dataChanged) {
                                        var C = 1;
                                        if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                                            C = this.dynamicAnim.speed;
                                            var k = e.globals.previousPaths[c] && e.globals.previousPaths[c][f] && e.globals.previousPaths[c][f].color;
                                            k || (k = "rgba(255, 255, 255, 0)"), this.animateHeatColor(v, y.isColorHex(k) ? k : y.rgb2hex(k), y.isColorHex(m) ? m : y.rgb2hex(m), C)
                                        }
                                    }
                                    var S = (0, e.config.dataLabels.formatter)(e.globals.series[c][f], {
                                            value: e.globals.series[c][f],
                                            seriesIndex: c,
                                            dataPointIndex: f,
                                            w: e
                                        }),
                                        A = this.helpers.calculateDataLabels({
                                            text: S,
                                            x: d + s / 2,
                                            y: a + r / 2,
                                            i: c,
                                            j: f,
                                            colorProps: b,
                                            series: l
                                        });
                                    null !== A && h.add(A), d += s
                                }
                                a += r, n.add(h)
                            }
                            var O = e.globals.yAxisScale[0].result.slice();
                            return e.config.yaxis[0].reversed ? O.unshift("") : O.push(""), e.globals.yAxisScale[0].result = O, e.config.yaxis[0].labels.offsetY = -e.globals.gridHeight / e.globals.series.length / 2, n
                        }
                    }, {
                        key: "animateHeatMap",
                        value: function(t, e, i, n, s, r) {
                            var a = new v(this.ctx);
                            a.animateRect(t, {
                                x: e + n / 2,
                                y: i + s / 2,
                                width: 0,
                                height: 0
                            }, {
                                x: e,
                                y: i,
                                width: n,
                                height: s
                            }, r, function() {
                                a.animationCompleted(t)
                            })
                        }
                    }, {
                        key: "animateHeatColor",
                        value: function(t, e, i, n) {
                            t.attr({
                                fill: e
                            }).animate(n).attr({
                                fill: i
                            })
                        }
                    }]), t
                }(),
                At = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "drawYAxisTexts",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = s.config.yaxis[0],
                                a = s.globals.yLabelFormatters[0];
                            return new _(this.ctx).drawText({
                                x: t + r.labels.offsetX,
                                y: e + r.labels.offsetY,
                                text: a(n, i),
                                textAnchor: "middle",
                                fontSize: r.labels.style.fontSize,
                                fontFamily: r.labels.style.fontFamily,
                                foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors
                            })
                        }
                    }]), t
                }(),
                Ot = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w;
                        var i = this.w;
                        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = Math.min(i.globals.gridWidth, i.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i.globals.gridWidth / 2, this.fullAngle = "radialBar" === i.config.chart.type ? 360 : Math.abs(i.config.plotOptions.pie.endAngle - i.config.plotOptions.pie.startAngle), this.initialAngle = i.config.plotOptions.pie.startAngle % this.fullAngle, i.globals.radialSize = this.defaultSize / 2.05 - i.config.stroke.width - (i.config.chart.sparkline.enabled ? 0 : i.config.chart.dropShadow.blur), this.donutSize = i.globals.radialSize * parseInt(i.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = new _(this.ctx);
                            if (this.ret = n.group({
                                    class: "apexcharts-pie"
                                }), i.globals.noData) return this.ret;
                            for (var s = 0, r = 0; r < t.length; r++) s += y.negToZero(t[r]);
                            var a = [],
                                o = n.group();
                            0 === s && (s = 1e-5), t.forEach(function(t) {
                                e.maxY = Math.max(e.maxY, t)
                            }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                            for (var l = 0; l < t.length; l++) {
                                var c = this.fullAngle * y.negToZero(t[l]) / s;
                                a.push(c), "polarArea" === this.chartType ? (a[l] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[l] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                            }
                            if (i.globals.dataChanged) {
                                for (var h, u = 0, d = 0; d < i.globals.previousPaths.length; d++) u += y.negToZero(i.globals.previousPaths[d]);
                                for (var p = 0; p < i.globals.previousPaths.length; p++) h = this.fullAngle * y.negToZero(i.globals.previousPaths[p]) / u, this.prevSectorAngleArr.push(h)
                            }
                            this.donutSize < 0 && (this.donutSize = 0);
                            var f = i.config.plotOptions.pie.customScale,
                                g = i.globals.gridWidth / 2 - i.globals.gridWidth / 2 * f,
                                m = i.globals.gridHeight / 2 - i.globals.gridHeight / 2 * f;
                            if ("donut" === this.chartType) {
                                var b = n.drawCircle(this.donutSize);
                                b.attr({
                                    cx: this.centerX,
                                    cy: this.centerY,
                                    fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
                                }), o.add(b)
                            }
                            var v = this.drawArcs(a, t);
                            if (this.sliceLabels.forEach(function(t) {
                                    v.add(t)
                                }), o.attr({
                                    transform: "translate(".concat(g, ", ").concat(m, ") scale(").concat(f, ")")
                                }), o.add(v), this.ret.add(o), this.donutDataLabels.show) {
                                var x = this.renderInnerDataLabels(this.donutDataLabels, {
                                    hollowSize: this.donutSize,
                                    centerX: this.centerX,
                                    centerY: this.centerY,
                                    opacity: this.donutDataLabels.show,
                                    translateX: g,
                                    translateY: m
                                });
                                this.ret.add(x)
                            }
                            return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret
                        }
                    }, {
                        key: "drawArcs",
                        value: function(t, e) {
                            var i = this.w,
                                n = new x(this.ctx),
                                s = new _(this.ctx),
                                r = new T(this.ctx),
                                a = s.group({
                                    class: "apexcharts-slices"
                                }),
                                o = this.initialAngle,
                                l = this.initialAngle,
                                c = this.initialAngle,
                                h = this.initialAngle;
                            this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                            for (var u = 0; u < t.length; u++) {
                                var d = s.group({
                                    class: "apexcharts-series apexcharts-pie-series",
                                    seriesName: y.escapeString(i.globals.seriesNames[u]),
                                    rel: u + 1,
                                    "data:realIndex": u
                                });
                                a.add(d), c = (o = c) + t[u], h = (l = h) + this.prevSectorAngleArr[u];
                                var p = c < o ? this.fullAngle + c - o : c - o,
                                    f = r.fillPath({
                                        seriesNumber: u,
                                        size: this.sliceSizes[u],
                                        value: e[u]
                                    }),
                                    g = this.getChangedPath(l, h),
                                    m = s.drawPath({
                                        d: g,
                                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[u] : this.lineColorArr,
                                        strokeWidth: 0,
                                        fill: f,
                                        fillOpacity: i.config.fill.opacity,
                                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(u)
                                    });
                                m.attr({
                                    index: 0,
                                    j: u
                                }), n.setSelectionFilter(m, 0, u), i.config.chart.dropShadow.enabled && n.dropShadow(m, i.config.chart.dropShadow, u), this.addListeners(m, this.donutDataLabels), _.setAttrs(m.node, {
                                    "data:angle": p,
                                    "data:startAngle": o,
                                    "data:strokeWidth": this.strokeWidth,
                                    "data:value": e[u]
                                });
                                var b = {
                                    x: 0,
                                    y: 0
                                };
                                "pie" === this.chartType || "polarArea" === this.chartType ? b = y.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o + p / 2) % this.fullAngle) : "donut" === this.chartType && (b = y.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o + p / 2) % this.fullAngle)), d.add(m);
                                var v = 0;
                                if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (v = p / this.fullAngle * i.config.chart.animations.speed) && (v = 1), this.animDur = v + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(m, this.dynamicAnim && i.globals.dataChanged ? {
                                        size: this.sliceSizes[u],
                                        endAngle: c,
                                        startAngle: o,
                                        prevStartAngle: l,
                                        prevEndAngle: h,
                                        animateStartingPos: !0,
                                        i: u,
                                        animBeginArr: this.animBeginArr,
                                        shouldSetPrevPaths: !0,
                                        dur: i.config.chart.animations.dynamicAnimation.speed
                                    } : {
                                        size: this.sliceSizes[u],
                                        endAngle: c,
                                        startAngle: o,
                                        i: u,
                                        totalItems: t.length - 1,
                                        animBeginArr: this.animBeginArr,
                                        dur: v
                                    }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && m.click(this.pieClicked.bind(this, u)), void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(u) > -1 && this.pieClicked(u), i.config.dataLabels.enabled) {
                                    var w = b.x,
                                        C = b.y,
                                        k = 100 * p / this.fullAngle + "%";
                                    if (0 !== p && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[u]) {
                                        var S = i.config.dataLabels.formatter;
                                        void 0 !== S && (k = S(i.globals.seriesPercent[u][0], {
                                            seriesIndex: u,
                                            w: i
                                        }));
                                        var A = i.globals.dataLabels.style.colors[u],
                                            O = s.group({
                                                class: "apexcharts-datalabels"
                                            }),
                                            E = s.drawText({
                                                x: w,
                                                y: C,
                                                text: k,
                                                textAnchor: "middle",
                                                fontSize: i.config.dataLabels.style.fontSize,
                                                fontFamily: i.config.dataLabels.style.fontFamily,
                                                fontWeight: i.config.dataLabels.style.fontWeight,
                                                foreColor: A
                                            });
                                        O.add(E), i.config.dataLabels.dropShadow.enabled && n.dropShadow(E, i.config.dataLabels.dropShadow), E.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (E.node.classList.add("apexcharts-pie-label-delay"), E.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(O)
                                    }
                                }
                            }
                            return a
                        }
                    }, {
                        key: "addListeners",
                        value: function(t, e) {
                            var i = new _(this.ctx);
                            t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)))
                        }
                    }, {
                        key: "animatePaths",
                        value: function(t, e) {
                            var i = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
                                n = i,
                                s = e.startAngle,
                                r = e.startAngle;
                            void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (s = e.prevEndAngle, n = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === this.w.config.series.length - 1 && (i + r > this.fullAngle ? e.endAngle = e.endAngle - (i + r) : i + r < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (i + r)))), i === this.fullAngle && (i = this.fullAngle - .01), this.animateArc(t, s, r, i, n, e)
                        }
                    }, {
                        key: "animateArc",
                        value: function(t, e, i, n, s, r) {
                            var a, o = this,
                                l = this.w,
                                c = new v(this.ctx),
                                h = r.size;
                            (isNaN(e) || isNaN(s)) && (e = i, s = n, r.dur = 0);
                            var u = n,
                                d = i,
                                p = e < i ? this.fullAngle + e - i : e - i;
                            l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (a = o.getPiePath({
                                me: o,
                                startAngle: r.prevStartAngle,
                                angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                                size: h
                            }), t.attr({
                                d: a
                            })), 0 !== r.dur ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll(function() {
                                "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
                                    "stroke-width": o.strokeWidth
                                }), r.i === l.config.series.length - 1 && c.animationCompleted(t)
                            }).during(function(l) {
                                u = p + (n - p) * l, r.animateStartingPos && (u = s + (n - s) * l, d = e - s + (i - (e - s)) * l), a = o.getPiePath({
                                    me: o,
                                    startAngle: d,
                                    angle: u,
                                    size: h
                                }), t.node.setAttribute("data:pathOrig", a), t.attr({
                                    d: a
                                })
                            }) : (a = o.getPiePath({
                                me: o,
                                startAngle: d,
                                angle: n,
                                size: h
                            }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", a), t.attr({
                                d: a,
                                "stroke-width": o.strokeWidth
                            }))
                        }
                    }, {
                        key: "pieClicked",
                        value: function(t) {
                            var e, i = this.w,
                                n = this,
                                s = n.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
                                r = i.globals.dom.Paper.select(".apexcharts-".concat(n.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
                            if ("true" !== r.attr("data:pieClicked")) {
                                var a = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                                Array.prototype.forEach.call(a, function(t) {
                                    t.setAttribute("data:pieClicked", "false");
                                    var e = t.getAttribute("data:pathOrig");
                                    t.setAttribute("d", e)
                                }), r.attr("data:pieClicked", "true");
                                var o = parseInt(r.attr("data:startAngle"), 10),
                                    l = parseInt(r.attr("data:angle"), 10);
                                e = n.getPiePath({
                                    me: n,
                                    startAngle: o,
                                    angle: l,
                                    size: s
                                }), 360 !== l && r.plot(e)
                            } else {
                                r.attr({
                                    "data:pieClicked": "false"
                                }), this.revertDataLabelsInner(r.node, this.donutDataLabels);
                                var c = r.attr("data:pathOrig");
                                r.attr({
                                    d: c
                                })
                            }
                        }
                    }, {
                        key: "getChangedPath",
                        value: function(t, e) {
                            var i = "";
                            return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
                                me: this,
                                startAngle: t,
                                angle: e - t,
                                size: this.size
                            })), i
                        }
                    }, {
                        key: "getPiePath",
                        value: function(t) {
                            var e = t.me,
                                i = t.startAngle,
                                n = t.angle,
                                s = t.size,
                                r = i,
                                a = Math.PI * (r - 90) / 180,
                                o = n + i;
                            Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
                            var l = Math.PI * (o - 90) / 180,
                                c = e.centerX + s * Math.cos(a),
                                h = e.centerY + s * Math.sin(a),
                                u = e.centerX + s * Math.cos(l),
                                d = e.centerY + s * Math.sin(l),
                                p = y.polarToCartesian(e.centerX, e.centerY, e.donutSize, o),
                                f = y.polarToCartesian(e.centerX, e.centerY, e.donutSize, r),
                                g = n > 180 ? 1 : 0,
                                m = ["M", c, h, "A", s, s, 0, g, 1, u, d];
                            return "donut" === e.chartType ? [].concat(m, ["L", p.x, p.y, "A", e.donutSize, e.donutSize, 0, g, 0, f.x, f.y, "L", c, h, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(m, ["L", e.centerX, e.centerY, "L", c, h]).join(" ") : [].concat(m).join(" ")
                        }
                    }, {
                        key: "drawPolarElements",
                        value: function(t) {
                            var e = this.w,
                                i = new $(this.ctx),
                                n = new _(this.ctx),
                                s = new At(this.ctx),
                                r = n.group(),
                                a = n.group(),
                                o = i.niceScale(0, Math.ceil(this.maxY), e.config.yaxis[0].tickAmount, 0, !0),
                                l = o.result.reverse(),
                                c = o.result.length;
                            this.maxY = o.niceMax;
                            for (var h = e.globals.radialSize, u = h / (c - 1), d = 0; d < c - 1; d++) {
                                var p = n.drawCircle(h);
                                if (p.attr({
                                        cx: this.centerX,
                                        cy: this.centerY,
                                        fill: "none",
                                        "stroke-width": e.config.plotOptions.polarArea.rings.strokeWidth,
                                        stroke: e.config.plotOptions.polarArea.rings.strokeColor
                                    }), e.config.yaxis[0].show) {
                                    var f = s.drawYAxisTexts(this.centerX, this.centerY - h + parseInt(e.config.yaxis[0].labels.style.fontSize, 10) / 2, d, l[d]);
                                    a.add(f)
                                }
                                r.add(p), h -= u
                            }
                            this.drawSpokes(t), t.add(r), t.add(a)
                        }
                    }, {
                        key: "renderInnerDataLabels",
                        value: function(t, e) {
                            var i = this.w,
                                n = new _(this.ctx),
                                s = n.group({
                                    class: "apexcharts-datalabels-group",
                                    transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
                                }),
                                r = t.total.show;
                            s.node.style.opacity = e.opacity;
                            var a, o, l = e.centerX,
                                c = e.centerY;
                            a = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
                            var h = t.name.fontSize,
                                u = t.name.fontFamily,
                                d = t.value.fontWeight;
                            o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
                            var p = t.value.formatter,
                                f = "",
                                g = "";
                            if (r ? (a = t.total.color, h = t.total.fontSize, u = t.total.fontFamily, d = t.total.fontWeight, g = t.total.label, f = t.total.formatter(i)) : 1 === i.globals.series.length && (f = p(i.globals.series[0], i), g = i.globals.seriesNames[0]), g && (g = t.name.formatter(g, t.total.show, i)), t.name.show) {
                                var m = n.drawText({
                                    x: l,
                                    y: c + parseFloat(t.name.offsetY),
                                    text: g,
                                    textAnchor: "middle",
                                    foreColor: a,
                                    fontSize: h,
                                    fontWeight: d,
                                    fontFamily: u
                                });
                                m.node.classList.add("apexcharts-datalabel-label"), s.add(m)
                            }
                            if (t.value.show) {
                                var b = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
                                    y = n.drawText({
                                        x: l,
                                        y: c + b,
                                        text: f,
                                        textAnchor: "middle",
                                        foreColor: o,
                                        fontWeight: t.value.fontWeight,
                                        fontSize: t.value.fontSize,
                                        fontFamily: t.value.fontFamily
                                    });
                                y.node.classList.add("apexcharts-datalabel-value"), s.add(y)
                            }
                            return s
                        }
                    }, {
                        key: "printInnerLabels",
                        value: function(t, e, i, n) {
                            var s, r = this.w;
                            n ? s = void 0 === t.name.color ? r.globals.colors[parseInt(n.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (s = t.total.color);
                            var a = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
                                o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                            i = (0, t.value.formatter)(i, r), n || "function" != typeof t.total.formatter || (i = t.total.formatter(r)), e = t.name.formatter(e, e === t.total.label, r), null !== a && (a.textContent = e), null !== o && (o.textContent = i), null !== a && (a.style.fill = s)
                        }
                    }, {
                        key: "printDataLabelsInner",
                        value: function(t, e) {
                            var i = this.w,
                                n = t.getAttribute("data:value"),
                                s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
                            i.globals.series.length > 1 && this.printInnerLabels(e, s, n, t);
                            var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                            null !== r && (r.style.opacity = 1)
                        }
                    }, {
                        key: "drawSpokes",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = new _(this.ctx),
                                s = i.config.plotOptions.polarArea.spokes;
                            if (0 !== s.strokeWidth) {
                                for (var r = [], a = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++) r.push(y.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + a * o));
                                r.forEach(function(i, r) {
                                    var a = n.drawLine(i.x, i.y, e.centerX, e.centerY, Array.isArray(s.connectorColors) ? s.connectorColors[r] : s.connectorColors);
                                    t.add(a)
                                })
                            }
                        }
                    }, {
                        key: "revertDataLabelsInner",
                        value: function(t, e, i) {
                            var n = this,
                                s = this.w,
                                r = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
                                a = !1,
                                o = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
                                l = function(t) {
                                    var i = t.makeSliceOut,
                                        s = t.printLabel;
                                    Array.prototype.forEach.call(o, function(t) {
                                        "true" === t.getAttribute("data:pieClicked") && (i && (a = !0), s && n.printDataLabelsInner(t, e))
                                    })
                                };
                            if (l({
                                    makeSliceOut: !0,
                                    printLabel: !1
                                }), e.total.show && s.globals.series.length > 1) a && !e.total.showAlways ? l({
                                makeSliceOut: !1,
                                printLabel: !0
                            }) : this.printInnerLabels(e, e.total.label, e.total.formatter(s));
                            else if (l({
                                    makeSliceOut: !1,
                                    printLabel: !0
                                }), !a)
                                if (s.globals.selectedDataPoints.length && s.globals.series.length > 1)
                                    if (s.globals.selectedDataPoints[0].length > 0) {
                                        var c = s.globals.selectedDataPoints[0],
                                            h = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c));
                                        this.printDataLabelsInner(h, e)
                                    } else r && s.globals.selectedDataPoints.length && 0 === s.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
                            else r && s.globals.series.length > 1 && (r.style.opacity = 0)
                        }
                    }]), t
                }(),
                Et = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
                        var i = this.w;
                        this.graphics = new _(this.ctx), this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.gridHeight + 1.5 * i.globals.goldenPadding : i.globals.gridWidth, this.isLog = i.config.yaxis[0].logarithmic, this.coreUtils = new k(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i.globals.maxY, 0) : i.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i.globals.minY, this.polygons = i.config.plotOptions.radar.polygons, this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i.config.chart.dropShadow.blur, i.config.xaxis.labels.show && (this.size = this.size - i.globals.xAxisLabelsWidth / 1.75), void 0 !== i.config.plotOptions.radar.size && (this.size = i.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = new T(this.ctx),
                                s = [],
                                r = new M(this.ctx);
                            t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
                            var a = i.globals.gridHeight / 2 + i.config.plotOptions.radar.offsetY,
                                o = this.graphics.group({
                                    class: "apexcharts-radar-series apexcharts-plot-series",
                                    transform: "translate(".concat(i.globals.gridWidth / 2 + i.config.plotOptions.radar.offsetX || 0, ", ").concat(a || 0, ")")
                                }),
                                l = [],
                                c = null,
                                u = null;
                            if (this.yaxisLabels = this.graphics.group({
                                    class: "apexcharts-yaxis"
                                }), t.forEach(function(t, a) {
                                    var o = t.length === i.globals.dataPoints,
                                        d = e.graphics.group().attr({
                                            class: "apexcharts-series",
                                            "data:longestSeries": o,
                                            seriesName: y.escapeString(i.globals.seriesNames[a]),
                                            rel: a + 1,
                                            "data:realIndex": a
                                        });
                                    e.dataRadiusOfPercent[a] = [], e.dataRadius[a] = [], e.angleArr[a] = [], t.forEach(function(t, i) {
                                        var n = Math.abs(e.maxValue - e.minValue);
                                        t += Math.abs(e.minValue), e.isLog && (t = e.coreUtils.getLogVal(t, 0)), e.dataRadiusOfPercent[a][i] = t / n, e.dataRadius[a][i] = e.dataRadiusOfPercent[a][i] * e.size, e.angleArr[a][i] = i * e.disAngle
                                    }), l = e.getDataPointsPos(e.dataRadius[a], e.angleArr[a]);
                                    var p = e.createPaths(l, {
                                        x: 0,
                                        y: 0
                                    });
                                    c = e.graphics.group({
                                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                                    }), u = e.graphics.group({
                                        class: "apexcharts-datalabels",
                                        "data:realIndex": a
                                    }), i.globals.delayedElements.push({
                                        el: c.node,
                                        index: a
                                    });
                                    var f = {
                                            i: a,
                                            realIndex: a,
                                            animationDelay: a,
                                            initialSpeed: i.config.chart.animations.speed,
                                            dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                                            className: "apexcharts-radar",
                                            shouldClipToGrid: !1,
                                            bindEventsOnPaths: !1,
                                            stroke: i.globals.stroke.colors[a],
                                            strokeLineCap: i.config.stroke.lineCap
                                        },
                                        g = null;
                                    i.globals.previousPaths.length > 0 && (g = e.getPreviousPath(a));
                                    for (var m = 0; m < p.linePathsTo.length; m++) {
                                        var b = e.graphics.renderPaths(h(h({}, f), {}, {
                                            pathFrom: null === g ? p.linePathsFrom[m] : g,
                                            pathTo: p.linePathsTo[m],
                                            strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[a] : e.strokeWidth,
                                            fill: "none",
                                            drawShadow: !1
                                        }));
                                        d.add(b);
                                        var v = n.fillPath({
                                                seriesNumber: a
                                            }),
                                            _ = e.graphics.renderPaths(h(h({}, f), {}, {
                                                pathFrom: null === g ? p.areaPathsFrom[m] : g,
                                                pathTo: p.areaPathsTo[m],
                                                strokeWidth: 0,
                                                fill: v,
                                                drawShadow: !1
                                            }));
                                        i.config.chart.dropShadow.enabled && new x(e.ctx).dropShadow(_, Object.assign({}, i.config.chart.dropShadow, {
                                            noUserSpaceOnUse: !0
                                        }), a), d.add(_)
                                    }
                                    t.forEach(function(t, n) {
                                        var s = new D(e.ctx).getMarkerConfig("apexcharts-marker", a, n),
                                            o = e.graphics.drawMarker(l[n].x, l[n].y, s);
                                        o.attr("rel", n), o.attr("j", n), o.attr("index", a), o.node.setAttribute("default-marker-size", s.pSize);
                                        var p = e.graphics.group({
                                            class: "apexcharts-series-markers"
                                        });
                                        p && p.add(o), c.add(p), d.add(c);
                                        var f = i.config.dataLabels;
                                        if (f.enabled) {
                                            var g = f.formatter(i.globals.series[a][n], {
                                                seriesIndex: a,
                                                dataPointIndex: n,
                                                w: i
                                            });
                                            r.plotDataLabelsText({
                                                x: l[n].x,
                                                y: l[n].y,
                                                text: g,
                                                textAnchor: "middle",
                                                i: a,
                                                j: a,
                                                parent: u,
                                                offsetCorrection: !1,
                                                dataLabelsConfig: h({}, f)
                                            })
                                        }
                                        d.add(u)
                                    }), s.push(d)
                                }), this.drawPolygons({
                                    parent: o
                                }), i.config.xaxis.labels.show) {
                                var d = this.drawXAxisTexts();
                                o.add(d)
                            }
                            return s.forEach(function(t) {
                                o.add(t)
                            }), o.add(this.yaxisLabels), o
                        }
                    }, {
                        key: "drawPolygons",
                        value: function(t) {
                            for (var e = this, i = this.w, n = t.parent, s = new At(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), a = r.length, o = [], l = this.size / (a - 1), c = 0; c < a; c++) o[c] = l * c;
                            o.reverse();
                            var h = [],
                                u = [];
                            o.forEach(function(t, i) {
                                var n = y.getPolygonPos(t, e.dataPointsLen),
                                    s = "";
                                n.forEach(function(t, n) {
                                    if (0 === i) {
                                        var r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[n] : e.polygons.connectorColors);
                                        u.push(r)
                                    }
                                    0 === n && e.yaxisLabelsTextsPos.push({
                                        x: t.x,
                                        y: t.y
                                    }), s += t.x + "," + t.y + " "
                                }), h.push(s)
                            }), h.forEach(function(t, s) {
                                var r = e.polygons.strokeColors,
                                    a = e.polygons.strokeWidth,
                                    o = e.graphics.drawPolygon(t, Array.isArray(r) ? r[s] : r, Array.isArray(a) ? a[s] : a, i.globals.radarPolygons.fill.colors[s]);
                                n.add(o)
                            }), u.forEach(function(t) {
                                n.add(t)
                            }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t, i) {
                                var n = s.drawYAxisTexts(t.x, t.y, i, r[i]);
                                e.yaxisLabels.add(n)
                            })
                        }
                    }, {
                        key: "drawXAxisTexts",
                        value: function() {
                            var t = this,
                                e = this.w,
                                i = e.config.xaxis.labels,
                                n = this.graphics.group({
                                    class: "apexcharts-xaxis"
                                }),
                                s = y.getPolygonPos(this.size, this.dataPointsLen);
                            return e.globals.labels.forEach(function(r, a) {
                                var o = e.config.xaxis.labels.formatter,
                                    l = new M(t.ctx);
                                if (s[a]) {
                                    var c = t.getTextPos(s[a], t.size),
                                        u = o(r, {
                                            seriesIndex: -1,
                                            dataPointIndex: a,
                                            w: e
                                        });
                                    l.plotDataLabelsText({
                                        x: c.newX,
                                        y: c.newY,
                                        text: u,
                                        textAnchor: c.textAnchor,
                                        i: a,
                                        j: a,
                                        parent: n,
                                        color: Array.isArray(i.style.colors) && i.style.colors[a] ? i.style.colors[a] : "#a8a8a8",
                                        dataLabelsConfig: h({
                                            textAnchor: c.textAnchor,
                                            dropShadow: {
                                                enabled: !1
                                            }
                                        }, i),
                                        offsetCorrection: !1
                                    })
                                }
                            }), n
                        }
                    }, {
                        key: "createPaths",
                        value: function(t, e) {
                            var i = this,
                                n = [],
                                s = [],
                                r = [],
                                a = [];
                            if (t.length) {
                                s = [this.graphics.move(e.x, e.y)], a = [this.graphics.move(e.x, e.y)];
                                var o = this.graphics.move(t[0].x, t[0].y),
                                    l = this.graphics.move(t[0].x, t[0].y);
                                t.forEach(function(e, n) {
                                    o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), n === t.length - 1 && (o += "Z", l += "Z")
                                }), n.push(o), r.push(l)
                            }
                            return {
                                linePathsFrom: s,
                                linePathsTo: n,
                                areaPathsFrom: a,
                                areaPathsTo: r
                            }
                        }
                    }, {
                        key: "getTextPos",
                        value: function(t, e) {
                            var i = "middle",
                                n = t.x,
                                s = t.y;
                            return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", n += 10) : t.x < 0 && (i = "end", n -= 10) : i = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), {
                                textAnchor: i,
                                newX: n,
                                newY: s
                            }
                        }
                    }, {
                        key: "getPreviousPath",
                        value: function(t) {
                            for (var e = this.w, i = null, n = 0; n < e.globals.previousPaths.length; n++) {
                                var s = e.globals.previousPaths[n];
                                s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[n].paths[0] && (i = e.globals.previousPaths[n].paths[0].d)
                            }
                            return i
                        }
                    }, {
                        key: "getDataPointsPos",
                        value: function(t, e) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                            t = t || [], e = e || [];
                            for (var n = [], s = 0; s < i; s++) {
                                var r = {};
                                r.x = t[s] * Math.sin(e[s]), r.y = -t[s] * Math.cos(e[s]), n.push(r)
                            }
                            return n
                        }
                    }]), t
                }(),
                Pt = function(t) {
                    u(i, Ot);
                    var e = g(i);

                    function i(t) {
                        var n;
                        r(this, i), (n = e.call(this, t)).ctx = t, n.w = t.w, n.animBeginArr = [0], n.animDur = 0;
                        var s = n.w;
                        return n.startAngle = s.config.plotOptions.radialBar.startAngle, n.endAngle = s.config.plotOptions.radialBar.endAngle, n.totalAngle = Math.abs(s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle), n.trackStartAngle = s.config.plotOptions.radialBar.track.startAngle, n.trackEndAngle = s.config.plotOptions.radialBar.track.endAngle, n.radialDataLabels = s.config.plotOptions.radialBar.dataLabels, n.trackStartAngle || (n.trackStartAngle = n.startAngle), n.trackEndAngle || (n.trackEndAngle = n.endAngle), 360 === n.endAngle && (n.endAngle = 359.99), n.margin = parseInt(s.config.plotOptions.radialBar.track.margin, 10), n
                    }
                    return o(i, [{
                        key: "draw",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = i.group({
                                    class: "apexcharts-radialbar"
                                });
                            if (e.globals.noData) return n;
                            var s = i.group(),
                                r = this.defaultSize / 2,
                                a = e.globals.gridWidth / 2,
                                o = this.defaultSize / 2.05;
                            e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur);
                            var l = e.globals.fill.colors;
                            if (e.config.plotOptions.radialBar.track.show) {
                                var c = this.drawTracks({
                                    size: o,
                                    centerX: a,
                                    centerY: r,
                                    colorArr: l,
                                    series: t
                                });
                                s.add(c)
                            }
                            var h = this.drawArcs({
                                    size: o,
                                    centerX: a,
                                    centerY: r,
                                    colorArr: l,
                                    series: t
                                }),
                                u = 360;
                            e.config.plotOptions.radialBar.startAngle < 0 && (u = this.totalAngle);
                            var d = (360 - u) / 360;
                            if (e.globals.radialSize = o - o * d, this.radialDataLabels.value.show) {
                                var p = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                                e.globals.radialSize += p * d
                            }
                            return s.add(h.g), "front" === e.config.plotOptions.radialBar.hollow.position && (h.g.add(h.elHollow), h.dataLabels && h.g.add(h.dataLabels)), n.add(s), n
                        }
                    }, {
                        key: "drawTracks",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = i.group({
                                    class: "apexcharts-tracks"
                                }),
                                s = new x(this.ctx),
                                r = new T(this.ctx),
                                a = this.getStrokeWidth(t);
                            t.size = t.size - a / 2;
                            for (var o = 0; o < t.series.length; o++) {
                                var l = i.group({
                                    class: "apexcharts-radialbar-track apexcharts-track"
                                });
                                n.add(l), l.attr({
                                    rel: o + 1
                                }), t.size = t.size - a - this.margin;
                                var c = e.config.plotOptions.radialBar.track,
                                    h = r.fillPath({
                                        seriesNumber: 0,
                                        size: t.size,
                                        fillColors: Array.isArray(c.background) ? c.background[o] : c.background,
                                        solid: !0
                                    }),
                                    u = this.trackStartAngle,
                                    d = this.trackEndAngle;
                                Math.abs(d) + Math.abs(u) >= 360 && (d = 360 - Math.abs(this.startAngle) - .1);
                                var p = i.drawPath({
                                    d: "",
                                    stroke: h,
                                    strokeWidth: a * parseInt(c.strokeWidth, 10) / 100,
                                    fill: "none",
                                    strokeOpacity: c.opacity,
                                    classes: "apexcharts-radialbar-area"
                                });
                                c.dropShadow.enabled && s.dropShadow(p, c.dropShadow), l.add(p), p.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(p, {
                                    centerX: t.centerX,
                                    centerY: t.centerY,
                                    endAngle: d,
                                    startAngle: u,
                                    size: t.size,
                                    i: o,
                                    totalItems: 2,
                                    animBeginArr: 0,
                                    dur: 0,
                                    isTrack: !0,
                                    easing: e.globals.easing
                                })
                            }
                            return n
                        }
                    }, {
                        key: "drawArcs",
                        value: function(t) {
                            var e = this.w,
                                i = new _(this.ctx),
                                n = new T(this.ctx),
                                s = new x(this.ctx),
                                r = i.group(),
                                a = this.getStrokeWidth(t);
                            t.size = t.size - a / 2;
                            var o = e.config.plotOptions.radialBar.hollow.background,
                                l = t.size - a * t.series.length - this.margin * t.series.length - a * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
                                c = l - e.config.plotOptions.radialBar.hollow.margin;
                            void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, r, l, o));
                            var h = this.drawHollow({
                                size: c,
                                centerX: t.centerX,
                                centerY: t.centerY,
                                fill: o || "transparent"
                            });
                            e.config.plotOptions.radialBar.hollow.dropShadow.enabled && s.dropShadow(h, e.config.plotOptions.radialBar.hollow.dropShadow);
                            var u = 1;
                            !this.radialDataLabels.total.show && e.globals.series.length > 1 && (u = 0);
                            var d = null;
                            this.radialDataLabels.show && (d = this.renderInnerDataLabels(this.radialDataLabels, {
                                hollowSize: l,
                                centerX: t.centerX,
                                centerY: t.centerY,
                                opacity: u
                            })), "back" === e.config.plotOptions.radialBar.hollow.position && (r.add(h), d && r.add(d));
                            var p = !1;
                            e.config.plotOptions.radialBar.inverseOrder && (p = !0);
                            for (var f = p ? t.series.length - 1 : 0; p ? f >= 0 : f < t.series.length; p ? f-- : f++) {
                                var g = i.group({
                                    class: "apexcharts-series apexcharts-radial-series",
                                    seriesName: y.escapeString(e.globals.seriesNames[f])
                                });
                                r.add(g), g.attr({
                                    rel: f + 1,
                                    "data:realIndex": f
                                }), this.ctx.series.addCollapsedClassToSeries(g, f), t.size = t.size - a - this.margin;
                                var m = n.fillPath({
                                        seriesNumber: f,
                                        size: t.size,
                                        value: t.series[f]
                                    }),
                                    b = this.startAngle,
                                    v = void 0,
                                    w = y.negToZero(t.series[f] > 100 ? 100 : t.series[f]) / 100,
                                    C = Math.round(this.totalAngle * w) + this.startAngle,
                                    k = void 0;
                                e.globals.dataChanged && (v = this.startAngle, k = Math.round(this.totalAngle * y.negToZero(e.globals.previousPaths[f]) / 100) + v), Math.abs(C) + Math.abs(b) >= 360 && (C -= .01), Math.abs(k) + Math.abs(v) >= 360 && (k -= .01);
                                var S = C - b,
                                    A = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[f] : e.config.stroke.dashArray,
                                    O = i.drawPath({
                                        d: "",
                                        stroke: m,
                                        strokeWidth: a,
                                        fill: "none",
                                        fillOpacity: e.config.fill.opacity,
                                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f,
                                        strokeDashArray: A
                                    });
                                _.setAttrs(O.node, {
                                    "data:angle": S,
                                    "data:value": t.series[f]
                                }), e.config.chart.dropShadow.enabled && s.dropShadow(O, e.config.chart.dropShadow, f), s.setSelectionFilter(O, 0, f), this.addListeners(O, this.radialDataLabels), g.add(O), O.attr({
                                    index: 0,
                                    j: f
                                });
                                var E = 0;
                                !this.initialAnim || e.globals.resized || e.globals.dataChanged || (this.animDur = (E = (C - b) / 360 * e.config.chart.animations.speed) / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (this.animDur = (E = (C - b) / 360 * e.config.chart.animations.dynamicAnimation.speed) / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(O, {
                                    centerX: t.centerX,
                                    centerY: t.centerY,
                                    endAngle: C,
                                    startAngle: b,
                                    prevEndAngle: k,
                                    prevStartAngle: v,
                                    size: t.size,
                                    i: f,
                                    totalItems: 2,
                                    animBeginArr: this.animBeginArr,
                                    dur: E,
                                    shouldSetPrevPaths: !0,
                                    easing: e.globals.easing
                                })
                            }
                            return {
                                g: r,
                                elHollow: h,
                                dataLabels: d
                            }
                        }
                    }, {
                        key: "drawHollow",
                        value: function(t) {
                            var e = new _(this.ctx).drawCircle(2 * t.size);
                            return e.attr({
                                class: "apexcharts-radialbar-hollow",
                                cx: t.centerX,
                                cy: t.centerY,
                                r: t.size,
                                fill: t.fill
                            }), e
                        }
                    }, {
                        key: "drawHollowImage",
                        value: function(t, e, i, n) {
                            var s = this.w,
                                r = new T(this.ctx),
                                a = y.randomId(),
                                o = s.config.plotOptions.radialBar.hollow.image;
                            if (s.config.plotOptions.radialBar.hollow.imageClipped) r.clippedImgArea({
                                width: i,
                                height: i,
                                image: o,
                                patternID: "pattern".concat(s.globals.cuid).concat(a)
                            }), n = "url(#pattern".concat(s.globals.cuid).concat(a, ")");
                            else {
                                var l = s.config.plotOptions.radialBar.hollow.imageWidth,
                                    c = s.config.plotOptions.radialBar.hollow.imageHeight;
                                if (void 0 === l && void 0 === c) {
                                    var h = s.globals.dom.Paper.image(o).loaded(function(e) {
                                        this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY)
                                    });
                                    e.add(h)
                                } else {
                                    var u = s.globals.dom.Paper.image(o).loaded(function(e) {
                                        this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - c / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, c)
                                    });
                                    e.add(u)
                                }
                            }
                            return n
                        }
                    }, {
                        key: "getStrokeWidth",
                        value: function(t) {
                            return t.size * (100 - parseInt(this.w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin
                        }
                    }]), i
                }(),
                Tt = function() {
                    function t(e) {
                        r(this, t), this.w = e.w, this.lineCtx = e
                    }
                    return o(t, [{
                        key: "sameValueSeriesFix",
                        value: function(t, e) {
                            var i = this.w;
                            if ("line" === i.config.chart.type && ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) && new k(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
                                var n = e[t].slice();
                                n[n.length - 1] = n[n.length - 1] + 1e-6, e[t] = n
                            }
                            return e
                        }
                    }, {
                        key: "calculatePoints",
                        value: function(t) {
                            var e = t.series,
                                i = t.x,
                                n = t.y,
                                s = t.i,
                                r = t.j,
                                a = t.prevY,
                                o = this.w,
                                l = [],
                                c = [];
                            if (0 === r) {
                                var h = this.lineCtx.categoryAxisCorrection + o.config.markers.offsetX;
                                o.globals.isXNumeric && (h = (o.globals.seriesX[t.realIndex][0] - o.globals.minX) / this.lineCtx.xRatio + o.config.markers.offsetX), l.push(h), c.push(y.isNumber(e[s][0]) ? a + o.config.markers.offsetY : null), l.push(i + o.config.markers.offsetX), c.push(y.isNumber(e[s][r + 1]) ? n + o.config.markers.offsetY : null)
                            } else l.push(i + o.config.markers.offsetX), c.push(y.isNumber(e[s][r + 1]) ? n + o.config.markers.offsetY : null);
                            return {
                                x: l,
                                y: c
                            }
                        }
                    }, {
                        key: "checkPreviousPaths",
                        value: function(t) {
                            for (var e = t.pathFromLine, i = t.pathFromArea, n = t.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) {
                                var a = s.globals.previousPaths[r];
                                ("line" === a.type || "area" === a.type) && a.paths.length > 0 && parseInt(a.realIndex, 10) === parseInt(n, 10) && ("line" === a.type ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[r].paths[0].d) : "area" === a.type && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[r].paths[0].d, s.config.stroke.show && s.globals.previousPaths[r].paths[1] && (e = s.globals.previousPaths[r].paths[1].d)))
                            }
                            return {
                                pathFromLine: e,
                                pathFromArea: i
                            }
                        }
                    }, {
                        key: "determineFirstPrevY",
                        value: function(t) {
                            var e = t.i,
                                i = t.series,
                                n = t.prevY,
                                s = t.lineYPosition,
                                r = this.w;
                            if (void 0 !== i[e][0]) n = (s = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                            else if (r.config.chart.stacked && e > 0 && void 0 === i[e][0])
                                for (var a = e - 1; a >= 0; a--)
                                    if (null != i[a][0]) {
                                        n = s = this.lineCtx.prevSeriesY[a][0];
                                        break
                                    } return {
                                prevY: n,
                                lineYPosition: s
                            }
                        }
                    }]), t
                }(),
                Dt = function() {
                    function t(e, i, n) {
                        r(this, t), this.ctx = e, this.w = e.w, this.xyRatios = i, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || n, this.scatter = new I(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Tt(this), this.markers = new D(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = new _(this.ctx),
                                r = n.globals.comboCharts ? e : n.config.chart.type,
                                a = s.group({
                                    class: "apexcharts-".concat(r, "-series apexcharts-plot-series")
                                }),
                                o = new k(this.ctx, n);
                            this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio);
                            for (var l = [], c = 0; c < t.length; c++) {
                                t = this.lineHelpers.sameValueSeriesFix(c, t);
                                var h = n.globals.comboCharts ? i[c] : c;
                                this._initSerieVariables(t, c, h);
                                var u = [],
                                    d = [],
                                    p = n.globals.padHorizontal + this.categoryAxisCorrection;
                                this.ctx.series.addCollapsedClassToSeries(this.elSeries, h), n.globals.isXNumeric && n.globals.seriesX.length > 0 && (p = (n.globals.seriesX[h][0] - n.globals.minX) / this.xRatio), d.push(p);
                                var f, g = p,
                                    m = g,
                                    b = this.zeroY;
                                b = this.lineHelpers.determineFirstPrevY({
                                    i: c,
                                    series: t,
                                    prevY: b,
                                    lineYPosition: 0
                                }).prevY, u.push(b), f = b;
                                var y = this._calculatePathsFrom({
                                        series: t,
                                        i: c,
                                        realIndex: h,
                                        prevX: m,
                                        prevY: b
                                    }),
                                    v = this._iterateOverDataPoints({
                                        series: t,
                                        realIndex: h,
                                        i: c,
                                        x: p,
                                        y: 1,
                                        pX: g,
                                        pY: f,
                                        pathsFrom: y,
                                        linePaths: [],
                                        areaPaths: [],
                                        seriesIndex: i,
                                        lineYPosition: 0,
                                        xArrj: d,
                                        yArrj: u
                                    });
                                this._handlePaths({
                                    type: r,
                                    realIndex: h,
                                    i: c,
                                    paths: v
                                }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries)
                            }
                            if (n.config.chart.stacked)
                                for (var x = l.length; x > 0; x--) a.add(l[x - 1]);
                            else
                                for (var w = 0; w < l.length; w++) a.add(l[w]);
                            return a
                        }
                    }, {
                        key: "_initSerieVariables",
                        value: function(t, e, i) {
                            var n = this.w,
                                s = new _(this.ctx);
                            this.xDivision = n.globals.gridWidth / (n.globals.dataPoints - ("on" === n.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[i] : n.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = n.config.yaxis[this.yaxisIndex] && n.config.yaxis[this.yaxisIndex].reversed, this.zeroY = n.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? n.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > n.globals.gridHeight || "end" === n.config.plotOptions.area.fillTo) && (this.areaBottomY = n.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({
                                class: "apexcharts-series",
                                seriesName: y.escapeString(n.globals.seriesNames[i])
                            }), this.elPointsMain = s.group({
                                class: "apexcharts-series-markers-wrap",
                                "data:realIndex": i
                            }), this.elDataLabelsWrap = s.group({
                                class: "apexcharts-datalabels",
                                "data:realIndex": i
                            }), this.elSeries.attr({
                                "data:longestSeries": t[e].length === n.globals.dataPoints,
                                rel: e + 1,
                                "data:realIndex": i
                            }), this.appendPathFrom = !0
                        }
                    }, {
                        key: "_calculatePathsFrom",
                        value: function(t) {
                            var e, i, n, s, r = t.series,
                                a = t.i,
                                o = t.realIndex,
                                l = t.prevX,
                                c = t.prevY,
                                h = this.w,
                                u = new _(this.ctx);
                            if (null === r[a][0]) {
                                for (var d = 0; d < r[a].length; d++)
                                    if (null !== r[a][d]) {
                                        e = u.move(l = this.xDivision * d, c = this.zeroY - r[a][d] / this.yRatio[this.yaxisIndex]), i = u.move(l, this.areaBottomY);
                                        break
                                    }
                            } else e = u.move(l, c), i = u.move(l, this.areaBottomY) + u.line(l, c);
                            if (n = u.move(-1, this.zeroY) + u.line(-1, this.zeroY), s = u.move(-1, this.zeroY) + u.line(-1, this.zeroY), h.globals.previousPaths.length > 0) {
                                var p = this.lineHelpers.checkPreviousPaths({
                                    pathFromLine: n,
                                    pathFromArea: s,
                                    realIndex: o
                                });
                                n = p.pathFromLine, s = p.pathFromArea
                            }
                            return {
                                prevX: l,
                                prevY: c,
                                linePath: e,
                                areaPath: i,
                                pathFromLine: n,
                                pathFromArea: s
                            }
                        }
                    }, {
                        key: "_handlePaths",
                        value: function(t) {
                            var e = t.type,
                                i = t.realIndex,
                                n = t.i,
                                s = t.paths,
                                r = this.w,
                                a = new _(this.ctx),
                                o = new T(this.ctx);
                            this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj, this.pointsChart || r.globals.delayedElements.push({
                                el: this.elPointsMain.node,
                                index: i
                            });
                            var l = {
                                i: n,
                                realIndex: i,
                                animationDelay: n,
                                initialSpeed: r.config.chart.animations.speed,
                                dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                                className: "apexcharts-".concat(e)
                            };
                            if ("area" === e)
                                for (var c = o.fillPath({
                                        seriesNumber: i
                                    }), u = 0; u < s.areaPaths.length; u++) {
                                    var d = a.renderPaths(h(h({}, l), {}, {
                                        pathFrom: s.pathFromArea,
                                        pathTo: s.areaPaths[u],
                                        stroke: "none",
                                        strokeWidth: 0,
                                        strokeLineCap: null,
                                        fill: c
                                    }));
                                    this.elSeries.add(d)
                                }
                            if (r.config.stroke.show && !this.pointsChart) {
                                var p;
                                p = "line" === e ? o.fillPath({
                                    seriesNumber: i,
                                    i: n
                                }) : r.globals.stroke.colors[i];
                                for (var f = 0; f < s.linePaths.length; f++) {
                                    var g = a.renderPaths(h(h({}, l), {}, {
                                        pathFrom: s.pathFromLine,
                                        pathTo: s.linePaths[f],
                                        stroke: p,
                                        strokeWidth: this.strokeWidth,
                                        strokeLineCap: r.config.stroke.lineCap,
                                        fill: "none"
                                    }));
                                    this.elSeries.add(g)
                                }
                            }
                        }
                    }, {
                        key: "_iterateOverDataPoints",
                        value: function(t) {
                            for (var e = t.series, i = t.realIndex, n = t.i, s = t.x, r = t.y, a = t.pX, o = t.pY, l = t.pathsFrom, c = t.linePaths, h = t.areaPaths, u = t.seriesIndex, d = t.lineYPosition, p = t.xArrj, f = t.yArrj, g = this.w, m = new _(this.ctx), b = this.yRatio, v = l.prevY, x = l.linePath, w = l.areaPath, C = l.pathFromLine, k = l.pathFromArea, S = y.isNumber(g.globals.minYArr[i]) ? g.globals.minYArr[i] : g.globals.minY, A = g.globals.dataPoints > 1 ? g.globals.dataPoints - 1 : g.globals.dataPoints, O = 0; O < A; O++) {
                                var E = null == e[n][O + 1];
                                if (g.globals.isXNumeric) {
                                    var P = g.globals.seriesX[i][O + 1];
                                    void 0 === g.globals.seriesX[i][O + 1] && (P = g.globals.seriesX[i][A - 1]), s = (P - g.globals.minX) / this.xRatio
                                } else s += this.xDivision;
                                d = g.config.chart.stacked && n > 0 && g.globals.collapsedSeries.length < g.config.series.length - 1 ? this.prevSeriesY[function(t) {
                                    for (var e = t, i = 0; i < g.globals.series.length; i++)
                                        if (g.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                                            e--;
                                            break
                                        } return e >= 0 ? e : 0
                                }(n - 1)][O + 1] : this.zeroY, r = E ? d - S / b[this.yaxisIndex] + 2 * (this.isReversed ? S / b[this.yaxisIndex] : 0) : d - e[n][O + 1] / b[this.yaxisIndex] + 2 * (this.isReversed ? e[n][O + 1] / b[this.yaxisIndex] : 0), p.push(s), f.push(r);
                                var T = this.lineHelpers.calculatePoints({
                                        series: e,
                                        x: s,
                                        y: r,
                                        realIndex: i,
                                        i: n,
                                        j: O,
                                        prevY: v
                                    }),
                                    D = this._createPaths({
                                        series: e,
                                        i: n,
                                        realIndex: i,
                                        j: O,
                                        x: s,
                                        y: r,
                                        pX: a,
                                        pY: o,
                                        linePath: x,
                                        areaPath: w,
                                        linePaths: c,
                                        areaPaths: h,
                                        seriesIndex: u
                                    });
                                h = D.areaPaths, c = D.linePaths, a = D.pX, o = D.pY, w = D.areaPath, x = D.linePath, this.appendPathFrom && (C += m.line(s, this.zeroY), k += m.line(s, this.zeroY)), this.handleNullDataPoints(e, T, n, O, i), this._handleMarkersAndLabels({
                                    pointsPos: T,
                                    series: e,
                                    x: s,
                                    y: r,
                                    prevY: v,
                                    i: n,
                                    j: O,
                                    realIndex: i
                                })
                            }
                            return {
                                yArrj: f,
                                xArrj: p,
                                pathFromArea: k,
                                areaPaths: h,
                                pathFromLine: C,
                                linePaths: c
                            }
                        }
                    }, {
                        key: "_handleMarkersAndLabels",
                        value: function(t) {
                            var e = t.pointsPos,
                                i = t.i,
                                n = t.j,
                                s = t.realIndex,
                                r = this.w,
                                a = new M(this.ctx);
                            if (this.pointsChart) this.scatter.draw(this.elSeries, n, {
                                realIndex: s,
                                pointsPos: e,
                                zRatio: this.zRatio,
                                elParent: this.elPointsMain
                            });
                            else {
                                r.globals.series[i].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                                var o = this.markers.plotChartMarkers(e, s, n + 1);
                                null !== o && this.elPointsMain.add(o)
                            }
                            var l = a.drawDataLabel(e, s, n + 1, null);
                            null !== l && this.elDataLabelsWrap.add(l)
                        }
                    }, {
                        key: "_createPaths",
                        value: function(t) {
                            var e = t.series,
                                i = t.i,
                                n = t.realIndex,
                                s = t.j,
                                r = t.x,
                                a = t.y,
                                o = t.pX,
                                l = t.pY,
                                c = t.linePath,
                                h = t.areaPath,
                                u = t.linePaths,
                                d = t.areaPaths,
                                p = t.seriesIndex,
                                f = this.w,
                                g = new _(this.ctx),
                                m = f.config.stroke.curve,
                                b = this.areaBottomY;
                            if (Array.isArray(f.config.stroke.curve) && (m = Array.isArray(p) ? f.config.stroke.curve[p[i]] : f.config.stroke.curve[i]), "smooth" === m) {
                                var y = .35 * (r - o);
                                f.globals.hasNullValues ? (null !== e[i][s] && (null !== e[i][s + 1] ? (c = g.move(o, l) + g.curve(o + y, l, r - y, a, r + 1, a), h = g.move(o + 1, l) + g.curve(o + y, l, r - y, a, r + 1, a) + g.line(r, b) + g.line(o, b) + "z") : (c = g.move(o, l), h = g.move(o, l) + "z")), u.push(c), d.push(h)) : (c += g.curve(o + y, l, r - y, a, r, a), h += g.curve(o + y, l, r - y, a, r, a)), o = r, l = a, s === e[i].length - 2 && (h = h + g.curve(o, l, r, a, r, b) + g.move(r, a) + "z", f.globals.hasNullValues || (u.push(c), d.push(h)))
                            } else null === e[i][s + 1] && (c += g.move(r, a), h = h + g.line(f.globals.isXNumeric ? (f.globals.seriesX[n][s] - f.globals.minX) / this.xRatio : r - this.xDivision, b) + g.move(r, a) + "z"), null === e[i][s] && (c += g.move(r, a), h += g.move(r, b)), "stepline" === m ? (c = c + g.line(r, null, "H") + g.line(null, a, "V"), h = h + g.line(r, null, "H") + g.line(null, a, "V")) : "straight" === m && (c += g.line(r, a), h += g.line(r, a)), s === e[i].length - 2 && (h = h + g.line(r, b) + g.move(r, a) + "z", u.push(c), d.push(h));
                            return {
                                linePaths: u,
                                areaPaths: d,
                                pX: o,
                                pY: l,
                                linePath: c,
                                areaPath: h
                            }
                        }
                    }, {
                        key: "handleNullDataPoints",
                        value: function(t, e, i, n, s) {
                            var r = this.w;
                            if (null === t[i][n] && r.config.markers.showNullDataPoints || 1 === t[i].length) {
                                var a = this.markers.plotChartMarkers(e, s, n + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
                                null !== a && this.elPointsMain.add(a)
                            }
                        }
                    }]), t
                }();
            window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
                function t(e, i, n, s) {
                    this.xoffset = e, this.yoffset = i, this.height = s, this.width = n, this.shortestEdge = function() {
                        return Math.min(this.height, this.width)
                    }, this.getCoordinates = function(t) {
                        var e, i = [],
                            n = this.xoffset,
                            s = this.yoffset,
                            a = r(t) / this.height,
                            o = r(t) / this.width;
                        if (this.width >= this.height)
                            for (e = 0; e < t.length; e++) i.push([n, s, n + a, s + t[e] / a]), s += t[e] / a;
                        else
                            for (e = 0; e < t.length; e++) i.push([n, s, n + t[e] / o, s + o]), n += t[e] / o;
                        return i
                    }, this.cutArea = function(e) {
                        var i;
                        if (this.width >= this.height) {
                            var n = e / this.height;
                            i = new t(this.xoffset + n, this.yoffset, this.width - n, this.height)
                        } else {
                            var s = e / this.width;
                            i = new t(this.xoffset, this.yoffset + s, this.width, this.height - s)
                        }
                        return i
                    }
                }

                function e(e, n, s, a, o) {
                    return a = void 0 === a ? 0 : a, o = void 0 === o ? 0 : o,
                        function(t) {
                            var e, i, n = [];
                            for (e = 0; e < t.length; e++)
                                for (i = 0; i < t[e].length; i++) n.push(t[e][i]);
                            return n
                        }(i(function(t, e) {
                            var i, n = [],
                                s = e / r(t);
                            for (i = 0; i < t.length; i++) n[i] = t[i] * s;
                            return n
                        }(e, n * s), [], new t(a, o, n, s), []))
                }

                function i(t, e, s, a) {
                    var o, l, c;
                    if (0 !== t.length) return o = s.shortestEdge(),
                        function(t, e, i) {
                            var s;
                            return 0 === t.length || ((s = t.slice()).push(e), n(t, i) >= n(s, i))
                        }(e, l = t[0], o) ? (e.push(l), i(t.slice(1), e, s, a)) : (c = s.cutArea(r(e), a), a.push(s.getCoordinates(e)), i(t, [], c, a)), a;
                    a.push(s.getCoordinates(e))
                }

                function n(t, e) {
                    var i = Math.min.apply(Math, t),
                        n = Math.max.apply(Math, t),
                        s = r(t);
                    return Math.max(Math.pow(e, 2) * n / Math.pow(s, 2), Math.pow(s, 2) / (Math.pow(e, 2) * i))
                }

                function s(t) {
                    return t && t.constructor === Array
                }

                function r(t) {
                    var e, i = 0;
                    for (e = 0; e < t.length; e++) i += t[e];
                    return i
                }

                function a(t) {
                    var e, i = 0;
                    if (s(t[0]))
                        for (e = 0; e < t.length; e++) i += a(t[e]);
                    else i = r(t);
                    return i
                }
                return function t(i, n, r, o, l) {
                    o = void 0 === o ? 0 : o, l = void 0 === l ? 0 : l;
                    var c, h, u = [],
                        d = [];
                    if (s(i[0])) {
                        for (h = 0; h < i.length; h++) u[h] = a(i[h]);
                        for (c = e(u, n, r, o, l), h = 0; h < i.length; h++) d.push(t(i[h], c[h][2] - c[h][0], c[h][3] - c[h][1], c[h][0], c[h][1]))
                    } else d = e(i, n, r, o, l);
                    return d
                }
            }();
            var It, Mt, Lt = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new kt(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
                    }
                    return o(t, [{
                        key: "draw",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = new _(this.ctx),
                                s = new T(this.ctx),
                                r = n.group({
                                    class: "apexcharts-treemap"
                                });
                            if (i.globals.noData) return r;
                            var a = [];
                            return t.forEach(function(t) {
                                var e = t.map(function(t) {
                                    return Math.abs(t)
                                });
                                a.push(e)
                            }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(t, i) {
                                t.data.forEach(function(t) {
                                    Array.isArray(e.labels[i]) || (e.labels[i] = []), e.labels[i].push(t.x)
                                })
                            }), window.TreemapSquared.generate(a, i.globals.gridWidth, i.globals.gridHeight).forEach(function(a, o) {
                                var l = n.group({
                                    class: "apexcharts-series apexcharts-treemap-series",
                                    seriesName: y.escapeString(i.globals.seriesNames[o]),
                                    rel: o + 1,
                                    "data:realIndex": o
                                });
                                if (i.config.chart.dropShadow.enabled) {
                                    var c = i.config.chart.dropShadow;
                                    new x(e.ctx).dropShadow(r, c, o)
                                }
                                var h = n.group({
                                    class: "apexcharts-data-labels"
                                });
                                a.forEach(function(r, a) {
                                    var c = r[0],
                                        h = r[1],
                                        u = r[2],
                                        d = r[3],
                                        p = n.drawRect(c, h, u - c, d - h, 0, "#fff", 1, e.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? g : i.globals.stroke.colors[o]);
                                    p.attr({
                                        cx: c,
                                        cy: h,
                                        index: o,
                                        i: o,
                                        j: a,
                                        width: u - c,
                                        height: d - h
                                    });
                                    var f = e.helpers.getShadeColor(i.config.chart.type, o, a, e.negRange),
                                        g = f.color;
                                    void 0 !== i.config.series[o].data[a] && i.config.series[o].data[a].fillColor && (g = i.config.series[o].data[a].fillColor);
                                    var m = s.fillPath({
                                        color: g,
                                        seriesNumber: o,
                                        dataPointIndex: a
                                    });
                                    p.node.classList.add("apexcharts-treemap-rect"), p.attr({
                                        fill: m
                                    }), e.helpers.addListeners(p);
                                    var b = {
                                            x: c + (u - c) / 2,
                                            y: h + (d - h) / 2,
                                            width: 0,
                                            height: 0
                                        },
                                        y = {
                                            x: c,
                                            y: h,
                                            width: u - c,
                                            height: d - h
                                        };
                                    if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                                        var v = 1;
                                        i.globals.resized || (v = i.config.chart.animations.speed), e.animateTreemap(p, b, y, v)
                                    }
                                    i.globals.dataChanged && e.dynamicAnim.enabled && i.globals.shouldAnimate && (i.globals.previousPaths[o] && i.globals.previousPaths[o][a] && i.globals.previousPaths[o][a].rect && (b = i.globals.previousPaths[o][a].rect), e.animateTreemap(p, b, y, e.dynamicAnim.speed));
                                    var x = e.getFontSize(r),
                                        _ = i.config.dataLabels.formatter(e.labels[o][a], {
                                            value: i.globals.series[o][a],
                                            seriesIndex: o,
                                            dataPointIndex: a,
                                            w: i
                                        }),
                                        w = e.helpers.calculateDataLabels({
                                            text: _,
                                            x: (c + u) / 2,
                                            y: (h + d) / 2 + e.strokeWidth / 2 + x / 3,
                                            i: o,
                                            j: a,
                                            colorProps: f,
                                            fontSize: x,
                                            series: t
                                        });
                                    i.config.dataLabels.enabled && w && e.rotateToFitLabel(w, _, c, h, u, d), l.add(p), null !== w && l.add(w)
                                }), l.add(h), r.add(l)
                            }), r
                        }
                    }, {
                        key: "getFontSize",
                        value: function(t) {
                            var e, i = this.w,
                                n = function t(e) {
                                    var i, n = 0;
                                    if (Array.isArray(e[0]))
                                        for (i = 0; i < e.length; i++) n += t(e[i]);
                                    else
                                        for (i = 0; i < e.length; i++) n += e[i].length;
                                    return n
                                }(this.labels) / function t(e) {
                                    var i, n = 0;
                                    if (Array.isArray(e[0]))
                                        for (i = 0; i < e.length; i++) n += t(e[i]);
                                    else
                                        for (i = 0; i < e.length; i++) n += 1;
                                    return n
                                }(this.labels);
                            return e = Math.pow((t[2] - t[0]) * (t[3] - t[1]), .5), Math.min(e / n, parseInt(i.config.dataLabels.style.fontSize, 10))
                        }
                    }, {
                        key: "rotateToFitLabel",
                        value: function(t, e, i, n, s, r) {
                            var a = new _(this.ctx),
                                o = a.getTextRects(e);
                            if (o.width + 5 > s - i && o.width <= r - n) {
                                var l = a.rotateAroundCenter(t.node);
                                t.node.setAttribute("transform", "rotate(-90 ".concat(l.x, " ").concat(l.y, ")"))
                            }
                        }
                    }, {
                        key: "animateTreemap",
                        value: function(t, e, i, n) {
                            var s = new v(this.ctx);
                            s.animateRect(t, {
                                x: e.x,
                                y: e.y,
                                width: e.width,
                                height: e.height
                            }, {
                                x: i.x,
                                y: i.y,
                                width: i.width,
                                height: i.height
                            }, n, function() {
                                s.animationCompleted(t)
                            })
                        }
                    }]), t
                }(),
                Rt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
                    }
                    return o(t, [{
                        key: "calculateTimeScaleTicks",
                        value: function(t, e) {
                            var i = this,
                                n = this.w;
                            if (n.globals.allSeriesCollapsed) return n.globals.labels = [], n.globals.timescaleLabels = [], [];
                            var s = new N(this.ctx),
                                r = (e - t) / 864e5;
                            this.determineInterval(r), n.globals.disableZoomIn = !1, n.globals.disableZoomOut = !1, r < .00011574074074074075 ? n.globals.disableZoomIn = !0 : r > 5e4 && (n.globals.disableZoomOut = !0);
                            var a = s.getTimeUnitsfromTimestamp(t, e, this.utc),
                                o = n.globals.gridWidth / r,
                                l = o / 24,
                                c = l / 60,
                                u = c / 60,
                                d = Math.floor(24 * r),
                                p = Math.floor(1440 * r),
                                f = Math.floor(86400 * r),
                                g = Math.floor(r),
                                m = Math.floor(r / 30),
                                b = Math.floor(r / 365),
                                y = {
                                    minMillisecond: a.minMillisecond,
                                    minSecond: a.minSecond,
                                    minMinute: a.minMinute,
                                    minHour: a.minHour,
                                    minDate: a.minDate,
                                    minMonth: a.minMonth,
                                    minYear: a.minYear
                                },
                                v = {
                                    firstVal: y,
                                    currentMillisecond: y.minMillisecond,
                                    currentSecond: y.minSecond,
                                    currentMinute: y.minMinute,
                                    currentHour: y.minHour,
                                    currentMonthDate: y.minDate,
                                    currentDate: y.minDate,
                                    currentMonth: y.minMonth,
                                    currentYear: y.minYear,
                                    daysWidthOnXAxis: o,
                                    hoursWidthOnXAxis: l,
                                    minutesWidthOnXAxis: c,
                                    secondsWidthOnXAxis: u,
                                    numberOfSeconds: f,
                                    numberOfMinutes: p,
                                    numberOfHours: d,
                                    numberOfDays: g,
                                    numberOfMonths: m,
                                    numberOfYears: b
                                };
                            switch (this.tickInterval) {
                                case "years":
                                    this.generateYearScale(v);
                                    break;
                                case "months":
                                case "half_year":
                                    this.generateMonthScale(v);
                                    break;
                                case "months_days":
                                case "months_fortnight":
                                case "days":
                                case "week_days":
                                    this.generateDayScale(v);
                                    break;
                                case "hours":
                                    this.generateHourScale(v);
                                    break;
                                case "minutes_fives":
                                case "minutes":
                                    this.generateMinuteScale(v);
                                    break;
                                case "seconds_tens":
                                case "seconds_fives":
                                case "seconds":
                                    this.generateSecondScale(v)
                            }
                            var x = this.timeScaleArray.map(function(t) {
                                var e = {
                                    position: t.position,
                                    unit: t.unit,
                                    year: t.year,
                                    day: t.day ? t.day : 1,
                                    hour: t.hour ? t.hour : 0,
                                    month: t.month + 1
                                };
                                return "month" === t.unit ? h(h({}, e), {}, {
                                    day: 1,
                                    value: t.value + 1
                                }) : "day" === t.unit || "hour" === t.unit ? h(h({}, e), {}, {
                                    value: t.value
                                }) : "minute" === t.unit ? h(h({}, e), {}, {
                                    value: t.value,
                                    minute: t.value
                                }) : "second" === t.unit ? h(h({}, e), {}, {
                                    value: t.value,
                                    minute: t.minute,
                                    second: t.second
                                }) : t
                            });
                            return x.filter(function(t) {
                                var e = 1,
                                    s = Math.ceil(n.globals.gridWidth / 120),
                                    r = t.value;
                                void 0 !== n.config.xaxis.tickAmount && (s = n.config.xaxis.tickAmount), x.length > s && (e = Math.floor(x.length / s));
                                var a = !1,
                                    o = !1;
                                switch (i.tickInterval) {
                                    case "years":
                                        "year" === t.unit && (a = !0);
                                        break;
                                    case "half_year":
                                        e = 7, "year" === t.unit && (a = !0);
                                        break;
                                    case "months":
                                        e = 1, "year" === t.unit && (a = !0);
                                        break;
                                    case "months_fortnight":
                                        e = 15, "year" !== t.unit && "month" !== t.unit || (a = !0), 30 === r && (o = !0);
                                        break;
                                    case "months_days":
                                        e = 10, "month" === t.unit && (a = !0), 30 === r && (o = !0);
                                        break;
                                    case "week_days":
                                        e = 8, "month" === t.unit && (a = !0);
                                        break;
                                    case "days":
                                        e = 1, "month" === t.unit && (a = !0);
                                        break;
                                    case "hours":
                                        "day" === t.unit && (a = !0);
                                        break;
                                    case "minutes_fives":
                                        r % 5 != 0 && (o = !0);
                                        break;
                                    case "seconds_tens":
                                        r % 10 != 0 && (o = !0);
                                        break;
                                    case "seconds_fives":
                                        r % 5 != 0 && (o = !0)
                                }
                                if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
                                    if (!o) return !0
                                } else if ((r % e == 0 || a) && !o) return !0
                            })
                        }
                    }, {
                        key: "recalcDimensionsBasedOnFormat",
                        value: function(t, e) {
                            var i = this.w,
                                n = this.formatDates(t),
                                s = this.removeOverlappingTS(n);
                            i.globals.timescaleLabels = s.slice(), new ht(this.ctx).plotCoords()
                        }
                    }, {
                        key: "determineInterval",
                        value: function(t) {
                            var e = 24 * t,
                                i = 60 * e;
                            switch (!0) {
                                case t / 365 > 5:
                                    this.tickInterval = "years";
                                    break;
                                case t > 800:
                                    this.tickInterval = "half_year";
                                    break;
                                case t > 180:
                                    this.tickInterval = "months";
                                    break;
                                case t > 90:
                                    this.tickInterval = "months_fortnight";
                                    break;
                                case t > 60:
                                    this.tickInterval = "months_days";
                                    break;
                                case t > 30:
                                    this.tickInterval = "week_days";
                                    break;
                                case t > 2:
                                    this.tickInterval = "days";
                                    break;
                                case e > 2.4:
                                    this.tickInterval = "hours";
                                    break;
                                case i > 15:
                                    this.tickInterval = "minutes_fives";
                                    break;
                                case i > 5:
                                    this.tickInterval = "minutes";
                                    break;
                                case i > 1:
                                    this.tickInterval = "seconds_tens";
                                    break;
                                case 60 * i > 20:
                                    this.tickInterval = "seconds_fives";
                                    break;
                                default:
                                    this.tickInterval = "seconds"
                            }
                        }
                    }, {
                        key: "generateYearScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonth,
                                n = t.currentYear,
                                s = t.daysWidthOnXAxis,
                                r = t.numberOfYears,
                                a = e.minYear,
                                o = 0,
                                l = new N(this.ctx),
                                c = "year";
                            if (e.minDate > 1 || e.minMonth > 0) {
                                var h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
                                o = (l.determineDaysOfYear(e.minYear) - h + 1) * s, this.timeScaleArray.push({
                                    position: o,
                                    value: a = e.minYear + 1,
                                    unit: c,
                                    year: a,
                                    month: y.monthMod(i + 1)
                                })
                            } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
                                position: o,
                                value: a,
                                unit: c,
                                year: n,
                                month: y.monthMod(i + 1)
                            });
                            for (var u = a, d = o, p = 0; p < r; p++) u++, d = l.determineDaysOfYear(u - 1) * s + d, this.timeScaleArray.push({
                                position: d,
                                value: u,
                                unit: c,
                                year: u,
                                month: 1
                            })
                        }
                    }, {
                        key: "generateMonthScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonthDate,
                                n = t.currentMonth,
                                s = t.currentYear,
                                r = t.daysWidthOnXAxis,
                                a = t.numberOfMonths,
                                o = n,
                                l = 0,
                                c = new N(this.ctx),
                                h = "month",
                                u = 0;
                            if (e.minDate > 1) {
                                l = (c.determineDaysOfMonths(n + 1, e.minYear) - i + 1) * r, o = y.monthMod(n + 1);
                                var d = s + u,
                                    p = y.monthMod(o),
                                    f = o;
                                0 === o && (h = "year", f = d, p = 1, d += u += 1), this.timeScaleArray.push({
                                    position: l,
                                    value: f,
                                    unit: h,
                                    year: d,
                                    month: p
                                })
                            } else this.timeScaleArray.push({
                                position: l,
                                value: o,
                                unit: h,
                                year: s,
                                month: y.monthMod(n)
                            });
                            for (var g = o + 1, m = l, b = 0, v = 1; b < a; b++, v++) {
                                0 === (g = y.monthMod(g)) ? (h = "year", u += 1) : h = "month";
                                var x = this._getYear(s, g, u);
                                m = c.determineDaysOfMonths(g, x) * r + m, this.timeScaleArray.push({
                                    position: m,
                                    value: 0 === g ? x : g,
                                    unit: h,
                                    year: x,
                                    month: 0 === g ? 1 : g
                                }), g++
                            }
                        }
                    }, {
                        key: "generateDayScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentMonth,
                                n = t.currentYear,
                                s = t.hoursWidthOnXAxis,
                                r = t.numberOfDays,
                                a = new N(this.ctx),
                                o = "day",
                                l = e.minDate + 1,
                                c = l,
                                h = function(t, e, i) {
                                    return t > a.determineDaysOfMonths(e + 1, i) ? (c = 1, o = "month", d = e += 1, e) : e
                                },
                                u = (24 - e.minHour) * s,
                                d = l,
                                p = h(c, i, n);
                            0 === e.minHour && 1 === e.minDate ? (u = 0, d = y.monthMod(e.minMonth), o = "month", c = e.minDate, r++) : 1 !== e.minDate && 0 === e.minHour && 0 === e.minMinute && (u = 0, d = l = e.minDate, p = h(c = l, i, n)), this.timeScaleArray.push({
                                position: u,
                                value: d,
                                unit: o,
                                year: this._getYear(n, p, 0),
                                month: y.monthMod(p),
                                day: c
                            });
                            for (var f = u, g = 0; g < r; g++) {
                                o = "day", p = h(c += 1, p, this._getYear(n, p, 0));
                                var m = this._getYear(n, p, 0);
                                f = 24 * s + f;
                                var b = 1 === c ? y.monthMod(p) : c;
                                this.timeScaleArray.push({
                                    position: f,
                                    value: b,
                                    unit: o,
                                    year: m,
                                    month: y.monthMod(p),
                                    day: b
                                })
                            }
                        }
                    }, {
                        key: "generateHourScale",
                        value: function(t) {
                            var e = t.firstVal,
                                i = t.currentDate,
                                n = t.currentMonth,
                                s = t.currentYear,
                                r = t.minutesWidthOnXAxis,
                                a = t.numberOfHours,
                                o = new N(this.ctx),
                                l = "hour",
                                c = function(t, e) {
                                    return t > o.determineDaysOfMonths(e + 1, s) && (g = 1, e += 1), {
                                        month: e,
                                        date: g
                                    }
                                },
                                h = function(t, e) {
                                    return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e
                                },
                                u = 60 - (e.minMinute + e.minSecond / 60),
                                d = u * r,
                                p = e.minHour + 1,
                                f = p + 1;
                            60 === u && (d = 0, f = (p = e.minHour) + 1);
                            var g = i,
                                m = h(g, n);
                            this.timeScaleArray.push({
                                position: d,
                                value: p,
                                unit: l,
                                day: g,
                                hour: f,
                                year: s,
                                month: y.monthMod(m)
                            });
                            for (var b = d, v = 0; v < a; v++) {
                                l = "hour", f >= 24 && (f = 0, l = "day", m = c(g += 1, m).month, m = h(g, m));
                                var x = this._getYear(s, m, 0);
                                this.timeScaleArray.push({
                                    position: b = 0 === f && 0 === v ? u * r : 60 * r + b,
                                    value: 0 === f ? g : f,
                                    unit: l,
                                    hour: f,
                                    day: g,
                                    year: x,
                                    month: y.monthMod(m)
                                }), f++
                            }
                        }
                    }, {
                        key: "generateMinuteScale",
                        value: function(t) {
                            for (var e = t.minutesWidthOnXAxis, i = t.numberOfMinutes, n = t.currentMinute + 1, s = t.currentDate, r = t.currentMonth, a = t.currentYear, o = t.currentHour, l = (60 - t.currentSecond - t.currentMillisecond / 1e3) * t.secondsWidthOnXAxis, c = 0; c < i; c++) n >= 60 && (n = 0, 24 === (o += 1) && (o = 0)), this.timeScaleArray.push({
                                position: l,
                                value: n,
                                unit: "minute",
                                hour: o,
                                minute: n,
                                day: s,
                                year: this._getYear(a, r, 0),
                                month: y.monthMod(r)
                            }), l += e, n++
                        }
                    }, {
                        key: "generateSecondScale",
                        value: function(t) {
                            for (var e = t.secondsWidthOnXAxis, i = t.numberOfSeconds, n = t.currentSecond + 1, s = t.currentMinute, r = t.currentDate, a = t.currentMonth, o = t.currentYear, l = t.currentHour, c = (1e3 - t.currentMillisecond) / 1e3 * e, h = 0; h < i; h++) n >= 60 && (n = 0, ++s >= 60 && (s = 0, 24 == ++l && (l = 0))), this.timeScaleArray.push({
                                position: c,
                                value: n,
                                unit: "second",
                                hour: l,
                                minute: s,
                                second: n,
                                day: r,
                                year: this._getYear(o, a, 0),
                                month: y.monthMod(a)
                            }), c += e, n++
                        }
                    }, {
                        key: "createRawDateString",
                        value: function(t, e) {
                            var i = t.year;
                            return 0 === t.month && (t.month = 1), i += "-" + ("0" + t.month.toString()).slice(-2), i += "day" === t.unit ? "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : "-" + ("0" + (t.day ? t.day : "1")).slice(-2), i += "hour" === t.unit ? "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), i += "minute" === t.unit ? ":" + ("0" + e).slice(-2) : ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), i += "second" === t.unit ? ":" + ("0" + e).slice(-2) : ":00", this.utc && (i += ".000Z"), i
                        }
                    }, {
                        key: "formatDates",
                        value: function(t) {
                            var e = this,
                                i = this.w;
                            return t.map(function(t) {
                                var n = t.value.toString(),
                                    s = new N(e.ctx),
                                    r = e.createRawDateString(t, n),
                                    a = s.getDate(s.parseDate(r));
                                if (e.utc || (a = s.getDate(s.parseDateWithTimezone(r))), void 0 === i.config.xaxis.labels.format) {
                                    var o = "dd MMM",
                                        l = i.config.xaxis.labels.datetimeFormatter;
                                    "year" === t.unit && (o = l.year), "month" === t.unit && (o = l.month), "day" === t.unit && (o = l.day), "hour" === t.unit && (o = l.hour), "minute" === t.unit && (o = l.minute), "second" === t.unit && (o = l.second), n = s.formatDate(a, o)
                                } else n = s.formatDate(a, i.config.xaxis.labels.format);
                                return {
                                    dateString: r,
                                    position: t.position,
                                    value: n,
                                    unit: t.unit,
                                    year: t.year,
                                    month: t.month
                                }
                            })
                        }
                    }, {
                        key: "removeOverlappingTS",
                        value: function(t) {
                            var e, i = this,
                                n = new _(this.ctx),
                                s = !1;
                            t.length > 0 && t[0].value && t.every(function(e) {
                                return e.value.length === t[0].value.length
                            }) && (s = !0, e = n.getTextRects(t[0].value).width);
                            var r = 0;
                            return t.map(function(a, o) {
                                if (o > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                                    var l = s ? e : n.getTextRects(t[r].value).width;
                                    return a.position > t[r].position + l + 10 ? (r = o, a) : null
                                }
                                return a
                            }).filter(function(t) {
                                return null !== t
                            })
                        }
                    }, {
                        key: "_getYear",
                        value: function(t, e, i) {
                            return t + Math.floor(e / 12) + i
                        }
                    }]), t
                }(),
                jt = function() {
                    function t(e, i) {
                        r(this, t), this.ctx = i, this.w = i.w, this.el = e
                    }
                    return o(t, [{
                        key: "setupElements",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config,
                                i = e.chart.type;
                            t.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), _.setAttrs(t.dom.elWrap, {
                                id: t.chartClass.substring(1),
                                class: "apexcharts-canvas " + t.chartClass.substring(1)
                            }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
                                class: "apexcharts-svg",
                                "xmlns:data": "ApexChartsNS",
                                transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
                            }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({
                                class: "apexcharts-inner apexcharts-graphical"
                            }), t.dom.elAnnotations = t.dom.Paper.group().attr({
                                class: "apexcharts-annotations"
                            }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs)
                        }
                    }, {
                        key: "plotChartType",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.config,
                                s = i.globals,
                                r = {
                                    series: [],
                                    i: []
                                },
                                a = {
                                    series: [],
                                    i: []
                                },
                                o = {
                                    series: [],
                                    i: []
                                },
                                l = {
                                    series: [],
                                    i: []
                                },
                                c = {
                                    series: [],
                                    i: []
                                },
                                h = {
                                    series: [],
                                    i: []
                                },
                                u = {
                                    series: [],
                                    i: []
                                };
                            s.series.map(function(e, d) {
                                var p = 0;
                                void 0 !== t[d].type ? ("column" === t[d].type || "bar" === t[d].type ? (s.series.length > 1 && n.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), c.series.push(e), c.i.push(d), p++, i.globals.columnSeries = c.series) : "area" === t[d].type ? (a.series.push(e), a.i.push(d), p++) : "line" === t[d].type ? (r.series.push(e), r.i.push(d), p++) : "scatter" === t[d].type ? (o.series.push(e), o.i.push(d)) : "bubble" === t[d].type ? (l.series.push(e), l.i.push(d), p++) : "candlestick" === t[d].type ? (h.series.push(e), h.i.push(d), p++) : "boxPlot" === t[d].type ? (u.series.push(e), u.i.push(d), p++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"), p > 1 && (s.comboCharts = !0)) : (r.series.push(e), r.i.push(d))
                            });
                            var d = new Dt(this.ctx, e),
                                p = new Ct(this.ctx, e);
                            this.ctx.pie = new Ot(this.ctx);
                            var f = new Pt(this.ctx);
                            this.ctx.rangeBar = new z(this.ctx, e);
                            var g = new Et(this.ctx),
                                m = [];
                            if (s.comboCharts) {
                                if (a.series.length > 0 && m.push(d.draw(a.series, "area", a.i)), c.series.length > 0)
                                    if (i.config.chart.stacked) {
                                        var b = new wt(this.ctx, e);
                                        m.push(b.draw(c.series, c.i))
                                    } else this.ctx.bar = new F(this.ctx, e), m.push(this.ctx.bar.draw(c.series, c.i));
                                if (r.series.length > 0 && m.push(d.draw(r.series, "line", r.i)), h.series.length > 0 && m.push(p.draw(h.series, h.i)), u.series.length > 0 && m.push(p.draw(u.series, u.i)), o.series.length > 0) {
                                    var y = new Dt(this.ctx, e, !0);
                                    m.push(y.draw(o.series, "scatter", o.i))
                                }
                                if (l.series.length > 0) {
                                    var v = new Dt(this.ctx, e, !0);
                                    m.push(v.draw(l.series, "bubble", l.i))
                                }
                            } else switch (n.chart.type) {
                                case "line":
                                    m = d.draw(s.series, "line");
                                    break;
                                case "area":
                                    m = d.draw(s.series, "area");
                                    break;
                                case "bar":
                                    n.chart.stacked ? m = new wt(this.ctx, e).draw(s.series) : (this.ctx.bar = new F(this.ctx, e), m = this.ctx.bar.draw(s.series));
                                    break;
                                case "candlestick":
                                case "boxPlot":
                                    m = new Ct(this.ctx, e).draw(s.series);
                                    break;
                                case "rangeBar":
                                    m = this.ctx.rangeBar.draw(s.series);
                                    break;
                                case "heatmap":
                                    m = new St(this.ctx, e).draw(s.series);
                                    break;
                                case "treemap":
                                    m = new Lt(this.ctx, e).draw(s.series);
                                    break;
                                case "pie":
                                case "donut":
                                case "polarArea":
                                    m = this.ctx.pie.draw(s.series);
                                    break;
                                case "radialBar":
                                    m = f.draw(s.series);
                                    break;
                                case "radar":
                                    m = g.draw(s.series);
                                    break;
                                default:
                                    m = d.draw(s.series)
                            }
                            return m
                        }
                    }, {
                        key: "setSVGDimensions",
                        value: function() {
                            var t = this.w.globals,
                                e = this.w.config;
                            t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
                            var i = y.getDimensions(this.el),
                                n = e.chart.width.toString().split(/[0-9]+/g).pop();
                            "%" === n ? y.isNumber(i[0]) && (0 === i[0].width && (i = y.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : "px" !== n && "" !== n || (t.svgWidth = parseInt(e.chart.width, 10));
                            var s = e.chart.height.toString().split(/[0-9]+/g).pop();
                            if ("auto" !== t.svgHeight && "" !== t.svgHeight)
                                if ("%" === s) {
                                    var r = y.getDimensions(this.el.parentNode);
                                    t.svgHeight = r[1] * parseInt(e.chart.height, 10) / 100
                                } else t.svgHeight = parseInt(e.chart.height, 10);
                            else t.svgHeight = t.axisCharts ? t.svgWidth / 1.61 : t.svgWidth / 1.2;
                            t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), _.setAttrs(t.dom.Paper.node, {
                                width: t.svgWidth,
                                height: t.svgHeight
                            }), "%" !== s && (t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + (e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0) + "px"), t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px"
                        }
                    }, {
                        key: "shiftGraphPosition",
                        value: function() {
                            var t = this.w.globals;
                            _.setAttrs(t.dom.elGraphical.node, {
                                transform: "translate(" + t.translateX + ", " + t.translateY + ")"
                            })
                        }
                    }, {
                        key: "resizeNonAxisCharts",
                        value: function() {
                            var t = this.w,
                                e = t.globals,
                                i = 0,
                                n = t.config.chart.sparkline.enabled ? 1 : 15;
                            n += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (i = new dt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                            var s = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
                                r = 2.05 * t.globals.radialSize;
                            if (s && !t.config.chart.sparkline.enabled) {
                                var a = y.getBoundingClientRect(s);
                                r = a.bottom, r = Math.max(2.05 * t.globals.radialSize, a.bottom - a.top)
                            }
                            var o = r + e.translateY + i + n;
                            e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", o), e.dom.elWrap.style.height = o + "px", _.setAttrs(e.dom.Paper.node, {
                                height: o
                            }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = o + "px"
                        }
                    }, {
                        key: "coreCalculations",
                        value: function() {
                            new Q(this.ctx).init()
                        }
                    }, {
                        key: "resetGlobals",
                        value: function() {
                            var t = this,
                                e = function() {
                                    return t.w.config.series.map(function(t) {
                                        return []
                                    })
                                },
                                i = new H,
                                n = this.w.globals;
                            i.initGlobalVars(n), n.seriesXvalues = e(), n.seriesYvalues = e()
                        }
                    }, {
                        key: "isMultipleY",
                        value: function() {
                            if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0
                        }
                    }, {
                        key: "xySettings",
                        value: function() {
                            var t = null,
                                e = this.w;
                            if (e.globals.axisCharts) {
                                if ("back" === e.config.xaxis.crosshairs.position && new it(this.ctx).drawXCrosshairs(), "back" === e.config.yaxis[0].crosshairs.position && new it(this.ctx).drawYCrosshairs(), "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
                                    this.ctx.timeScale = new Rt(this.ctx);
                                    var i = [];
                                    isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)
                                }
                                t = new k(this.ctx).getCalculatedRatios()
                            }
                            return t
                        }
                    }, {
                        key: "updateSourceChart",
                        value: function(t) {
                            this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                                chart: {
                                    selection: {
                                        xaxis: {
                                            min: t.w.globals.minX,
                                            max: t.w.globals.maxX
                                        }
                                    }
                                }
                            }, !1, !1)
                        }
                    }, {
                        key: "setupBrushHandler",
                        value: function() {
                            var t = this,
                                e = this.w;
                            if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
                                var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
                                i.forEach(function(e) {
                                    var i = ApexCharts.getChartByID(e);
                                    i.w.globals.brushSource = t.ctx, "function" != typeof i.w.config.chart.events.zoomed && (i.w.config.chart.events.zoomed = function() {
                                        t.updateSourceChart(i)
                                    }), "function" != typeof i.w.config.chart.events.scrolled && (i.w.config.chart.events.scrolled = function() {
                                        t.updateSourceChart(i)
                                    })
                                }), e.config.chart.events.selection = function(t, n) {
                                    i.forEach(function(t) {
                                        var i = ApexCharts.getChartByID(t),
                                            s = y.clone(e.config.yaxis);
                                        if (e.config.chart.brush.autoScaleYaxis && 1 === i.w.globals.series.length) {
                                            var r = new $(i);
                                            s = r.autoScaleY(i, s, n)
                                        }
                                        var a = i.w.config.yaxis.reduce(function(t, e, n) {
                                            return [].concat(m(t), [h(h({}, i.w.config.yaxis[n]), {}, {
                                                min: s[0].min,
                                                max: s[0].max
                                            })])
                                        }, []);
                                        i.ctx.updateHelpers._updateOptions({
                                            xaxis: {
                                                min: n.xaxis.min,
                                                max: n.xaxis.max
                                            },
                                            yaxis: a
                                        }, !1, !1, !1, !1)
                                    })
                                }
                            }
                        }
                    }]), t
                }(),
                Ft = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "_updateOptions",
                        value: function(t) {
                            var e = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                                o = [this.ctx];
                            r && (o = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (o = [this.ctx], this.ctx.w.globals.isExecCalled = !1), o.forEach(function(r) {
                                var o = r.w;
                                return o.globals.shouldAnimate = n, i || (o.globals.resized = !0, o.globals.dataChanged = !0, n && r.series.getPreviousPaths()), t && "object" === s(t) && (r.config = new B(t), t = k.extendArrayProps(r.config, t, o), r.w.globals.chartID !== e.ctx.w.globals.chartID && delete t.series, o.config = y.extend(o.config, t), a && (o.globals.lastXAxis = t.xaxis ? y.clone(t.xaxis) : [], o.globals.lastYAxis = t.yaxis ? y.clone(t.yaxis) : [], o.globals.initialConfig = y.extend({}, o.config), o.globals.initialSeries = y.clone(o.config.series))), r.update(t)
                            })
                        }
                    }, {
                        key: "_updateSeries",
                        value: function(t, e) {
                            var i, n = this,
                                s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                                r = this.w;
                            return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? (0 === (i = t.map(function(t, e) {
                                return n._extendSeries(t, e)
                            })).length && (i = [{
                                data: []
                            }]), r.config.series = i) : r.config.series = t.slice(), s && (r.globals.initialSeries = y.clone(r.config.series)), this.ctx.update()
                        }
                    }, {
                        key: "_extendSeries",
                        value: function(t, e) {
                            var i = this.w,
                                n = i.config.series[e];
                            return h(h({}, i.config.series[e]), {}, {
                                name: t.name ? t.name : n && n.name,
                                color: t.color ? t.color : n && n.color,
                                type: t.type ? t.type : n && n.type,
                                data: t.data ? t.data : n && n.data
                            })
                        }
                    }, {
                        key: "toggleDataPointSelection",
                        value: function(t, e) {
                            var i = this.w,
                                n = null,
                                s = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
                            return i.globals.axisCharts ? n = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ").concat(s, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (n = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(t, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t)), n ? (new _(this.ctx).pathMouseDown(n, null), n.node ? n.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null)
                        }
                    }, {
                        key: "forceXAxisUpdate",
                        value: function(t) {
                            var e = this.w;
                            if (["min", "max"].forEach(function(i) {
                                    void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i])
                                }), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
                                var i = new V(t);
                                t = i.convertCatToNumericXaxis(t, this.ctx)
                            }
                            return t
                        }
                    }, {
                        key: "forceYAxisUpdate",
                        value: function(t) {
                            var e = this.w;
                            return e.config.chart.stacked && "100%" === e.config.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function(e, i) {
                                t.yaxis[i].min = 0, t.yaxis[i].max = 100
                            }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t
                        }
                    }, {
                        key: "revertDefaultAxisMinMax",
                        value: function(t) {
                            var e = this,
                                i = this.w,
                                n = i.globals.lastXAxis,
                                s = i.globals.lastYAxis;
                            t && t.xaxis && (n = t.xaxis), t && t.yaxis && (s = t.yaxis), i.config.xaxis.min = n.min, i.config.xaxis.max = n.max, i.config.yaxis.map(function(t, n) {
                                i.globals.zoomed || void 0 !== s[n] ? function(t) {
                                    void 0 !== s[t] && (i.config.yaxis[t].min = s[t].min, i.config.yaxis[t].max = s[t].max)
                                }(n) : void 0 !== e.ctx.opts.yaxis[n] && (t.min = e.ctx.opts.yaxis[n].min, t.max = e.ctx.opts.yaxis[n].max)
                            })
                        }
                    }]), t
                }();
            It = "undefined" != typeof window ? window : void 0, Mt = function(t, e) {
                    var i = (void 0 !== this ? this : t).SVG = function(t) {
                        if (i.supported) return t = new i.Doc(t), i.parser.draw || i.prepare(), t
                    };
                    if (i.ns = "http://www.w3.org/2000/svg", i.xmlns = "http://www.w3.org/2000/xmlns/", i.xlink = "http://www.w3.org/1999/xlink", i.svgjs = "http://svgjs.com/svgjs", i.supported = !0, !i.supported) return !1;
                    i.did = 1e3, i.eid = function(t) {
                        return "Svgjs" + u(t) + i.did++
                    }, i.create = function(t) {
                        var i = e.createElementNS(this.ns, t);
                        return i.setAttribute("id", this.eid(t)), i
                    }, i.extend = function() {
                        var t, e;
                        e = (t = [].slice.call(arguments)).pop();
                        for (var n = t.length - 1; n >= 0; n--)
                            if (t[n])
                                for (var s in e) t[n].prototype[s] = e[s];
                        i.Set && i.Set.inherit && i.Set.inherit()
                    }, i.invent = function(t) {
                        var e = "function" == typeof t.create ? t.create : function() {
                            this.constructor.call(this, i.create(t.create))
                        };
                        return t.inherit && (e.prototype = new t.inherit), t.extend && i.extend(e, t.extend), t.construct && i.extend(t.parent || i.Container, t.construct), e
                    }, i.adopt = function(e) {
                        return e ? e.instance ? e.instance : ((n = "svg" == e.nodeName ? e.parentNode instanceof t.SVGElement ? new i.Nested : new i.Doc : "linearGradient" == e.nodeName ? new i.Gradient("linear") : "radialGradient" == e.nodeName ? new i.Gradient("radial") : i[u(e.nodeName)] ? new(i[u(e.nodeName)]) : new i.Element(e)).type = e.nodeName, n.node = e, e.instance = n, n instanceof i.Doc && n.namespace().defs(), n.setData(JSON.parse(e.getAttribute("svgjs:data")) || {}), n) : null;
                        var n
                    }, i.prepare = function() {
                        var t = e.getElementsByTagName("body")[0],
                            n = (t ? new i.Doc(t) : i.adopt(e.documentElement).nested()).size(2, 0);
                        i.parser = {
                            body: t || e.documentElement,
                            draw: n.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                            poly: n.polyline().node,
                            path: n.path().node,
                            native: i.create("svg")
                        }
                    }, i.parser = {
                        native: i.create("svg")
                    }, e.addEventListener("DOMContentLoaded", function() {
                        i.parser.draw || i.prepare()
                    }, !1), i.regex = {
                        numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
                        hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                        rgb: /rgb\((\d+),(\d+),(\d+)\)/,
                        reference: /#([a-z0-9\-_]+)/i,
                        transforms: /\)\s*,?\s*/,
                        whitespace: /\s/g,
                        isHex: /^#[a-f0-9]{3,6}$/i,
                        isRgb: /^rgb\(/,
                        isCss: /[^:]+:[^;]+;?/,
                        isBlank: /^(\s+)?$/,
                        isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
                        isPercent: /^-?[\d\.]+%$/,
                        isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
                        delimiter: /[\s,]+/,
                        hyphen: /([^e])\-/gi,
                        pathLetters: /[MLHVCSQTAZ]/gi,
                        isPathLetter: /[MLHVCSQTAZ]/i,
                        numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
                        dots: /\./g
                    }, i.utils = {
                        map: function(t, e) {
                            for (var i = t.length, n = [], s = 0; s < i; s++) n.push(e(t[s]));
                            return n
                        },
                        filter: function(t, e) {
                            for (var i = t.length, n = [], s = 0; s < i; s++) e(t[s]) && n.push(t[s]);
                            return n
                        },
                        filterSVGElements: function(e) {
                            return this.filter(e, function(e) {
                                return e instanceof t.SVGElement
                            })
                        }
                    }, i.defaults = {
                        attrs: {
                            "fill-opacity": 1,
                            "stroke-opacity": 1,
                            "stroke-width": 0,
                            "stroke-linejoin": "miter",
                            "stroke-linecap": "butt",
                            fill: "#000000",
                            stroke: "#000000",
                            opacity: 1,
                            x: 0,
                            y: 0,
                            cx: 0,
                            cy: 0,
                            width: 0,
                            height: 0,
                            r: 0,
                            rx: 0,
                            ry: 0,
                            offset: 0,
                            "stop-opacity": 1,
                            "stop-color": "#000000",
                            "font-size": 16,
                            "font-family": "Helvetica, Arial, sans-serif",
                            "text-anchor": "start"
                        }
                    }, i.Color = function(t) {
                        var e, n;
                        this.r = 0, this.g = 0, this.b = 0, t && ("string" == typeof t ? i.regex.isRgb.test(t) ? (e = i.regex.rgb.exec(t.replace(i.regex.whitespace, "")), this.r = parseInt(e[1]), this.g = parseInt(e[2]), this.b = parseInt(e[3])) : i.regex.isHex.test(t) && (e = i.regex.hex.exec(4 == (n = t).length ? ["#", n.substring(1, 2), n.substring(1, 2), n.substring(2, 3), n.substring(2, 3), n.substring(3, 4), n.substring(3, 4)].join("") : n), this.r = parseInt(e[1], 16), this.g = parseInt(e[2], 16), this.b = parseInt(e[3], 16)) : "object" === s(t) && (this.r = t.r, this.g = t.g, this.b = t.b))
                    }, i.extend(i.Color, {
                        toString: function() {
                            return this.toHex()
                        },
                        toHex: function() {
                            return "#" + d(this.r) + d(this.g) + d(this.b)
                        },
                        toRgb: function() {
                            return "rgb(" + [this.r, this.g, this.b].join() + ")"
                        },
                        brightness: function() {
                            return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
                        },
                        morph: function(t) {
                            return this.destination = new i.Color(t), this
                        },
                        at: function(t) {
                            return this.destination ? new i.Color({
                                r: ~~(this.r + (this.destination.r - this.r) * (t = t < 0 ? 0 : t > 1 ? 1 : t)),
                                g: ~~(this.g + (this.destination.g - this.g) * t),
                                b: ~~(this.b + (this.destination.b - this.b) * t)
                            }) : this
                        }
                    }), i.Color.test = function(t) {
                        return i.regex.isHex.test(t += "") || i.regex.isRgb.test(t)
                    }, i.Color.isRgb = function(t) {
                        return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b
                    }, i.Color.isColor = function(t) {
                        return i.Color.isRgb(t) || i.Color.test(t)
                    }, i.Array = function(t, e) {
                        0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), this.value = this.parse(t)
                    }, i.extend(i.Array, {
                        toString: function() {
                            return this.value.join(" ")
                        },
                        valueOf: function() {
                            return this.value
                        },
                        parse: function(t) {
                            return t = t.valueOf(), Array.isArray(t) ? t : this.split(t)
                        }
                    }), i.PointArray = function(t, e) {
                        i.Array.call(this, t, e || [
                            [0, 0]
                        ])
                    }, i.PointArray.prototype = new i.Array, i.PointArray.prototype.constructor = i.PointArray;
                    for (var n = {
                            M: function(t, e, i) {
                                return e.x = i.x = t[0], e.y = i.y = t[1], ["M", e.x, e.y]
                            },
                            L: function(t, e) {
                                return e.x = t[0], e.y = t[1], ["L", t[0], t[1]]
                            },
                            H: function(t, e) {
                                return e.x = t[0], ["H", t[0]]
                            },
                            V: function(t, e) {
                                return e.y = t[0], ["V", t[0]]
                            },
                            C: function(t, e) {
                                return e.x = t[4], e.y = t[5], ["C", t[0], t[1], t[2], t[3], t[4], t[5]]
                            },
                            Q: function(t, e) {
                                return e.x = t[2], e.y = t[3], ["Q", t[0], t[1], t[2], t[3]]
                            },
                            Z: function(t, e, i) {
                                return e.x = i.x, e.y = i.y, ["Z"]
                            }
                        }, r = "mlhvqtcsaz".split(""), a = 0, o = r.length; a < o; ++a) n[r[a]] = function(t) {
                        return function(e, i, s) {
                            if ("H" == t) e[0] = e[0] + i.x;
                            else if ("V" == t) e[0] = e[0] + i.y;
                            else if ("A" == t) e[5] = e[5] + i.x, e[6] = e[6] + i.y;
                            else
                                for (var r = 0, a = e.length; r < a; ++r) e[r] = e[r] + (r % 2 ? i.y : i.x);
                            return n[t](e, i, s)
                        }
                    }(r[a].toUpperCase());
                    i.PathArray = function(t, e) {
                        i.Array.call(this, t, e || [
                            ["M", 0, 0]
                        ])
                    }, i.PathArray.prototype = new i.Array, i.PathArray.prototype.constructor = i.PathArray, i.extend(i.PathArray, {
                        toString: function() {
                            return function(t) {
                                for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e][0], null != t[e][1] && (n += t[e][1], null != t[e][2] && (n += " ", n += t[e][2], null != t[e][3] && (n += " ", n += t[e][3], n += " ", n += t[e][4], null != t[e][5] && (n += " ", n += t[e][5], n += " ", n += t[e][6], null != t[e][7] && (n += " ", n += t[e][7])))));
                                return n + " "
                            }(this.value)
                        },
                        move: function(t, e) {
                            return this.bbox(), this
                        },
                        at: function(t) {
                            if (!this.destination) return this;
                            for (var e = this.value, n = this.destination.value, s = [], r = new i.PathArray, a = 0, o = e.length; a < o; a++) {
                                s[a] = [e[a][0]];
                                for (var l = 1, c = e[a].length; l < c; l++) s[a][l] = e[a][l] + (n[a][l] - e[a][l]) * t;
                                "A" === s[a][0] && (s[a][4] = +(0 != s[a][4]), s[a][5] = +(0 != s[a][5]))
                            }
                            return r.value = s, r
                        },
                        parse: function(t) {
                            if (t instanceof i.PathArray) return t.valueOf();
                            var e, s = {
                                M: 2,
                                L: 2,
                                H: 1,
                                V: 1,
                                C: 6,
                                S: 4,
                                Q: 4,
                                T: 2,
                                A: 7,
                                Z: 0
                            };
                            t = "string" == typeof t ? t.replace(i.regex.numbersWithDots, c).replace(i.regex.pathLetters, " $& ").replace(i.regex.hyphen, "$1 -").trim().split(i.regex.delimiter) : t.reduce(function(t, e) {
                                return [].concat.call(t, e)
                            }, []);
                            var r = [],
                                a = new i.Point,
                                o = new i.Point,
                                l = 0,
                                h = t.length;
                            do {
                                i.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : "M" == e ? e = "L" : "m" == e && (e = "l"), r.push(n[e].call(null, t.slice(l, l += s[e.toUpperCase()]).map(parseFloat), a, o))
                            } while (h > l);
                            return r
                        },
                        bbox: function() {
                            return i.parser.draw || i.prepare(), i.parser.path.setAttribute("d", this.toString()), i.parser.path.getBBox()
                        }
                    }), i.Number = i.invent({
                        create: function(t, e) {
                            this.value = 0, this.unit = e || "", "number" == typeof t ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : "string" == typeof t ? (e = t.match(i.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), "%" == e[5] ? this.value /= 100 : "s" == e[5] && (this.value *= 1e3), this.unit = e[5]) : t instanceof i.Number && (this.value = t.valueOf(), this.unit = t.unit)
                        },
                        extend: {
                            toString: function() {
                                return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                            },
                            toJSON: function() {
                                return this.toString()
                            },
                            valueOf: function() {
                                return this.value
                            },
                            plus: function(t) {
                                return t = new i.Number(t), new i.Number(this + t, this.unit || t.unit)
                            },
                            minus: function(t) {
                                return t = new i.Number(t), new i.Number(this - t, this.unit || t.unit)
                            },
                            times: function(t) {
                                return t = new i.Number(t), new i.Number(this * t, this.unit || t.unit)
                            },
                            divide: function(t) {
                                return t = new i.Number(t), new i.Number(this / t, this.unit || t.unit)
                            },
                            to: function(t) {
                                var e = new i.Number(this);
                                return "string" == typeof t && (e.unit = t), e
                            },
                            morph: function(t) {
                                return this.destination = new i.Number(t), t.relative && (this.destination.value += this.value), this
                            },
                            at: function(t) {
                                return this.destination ? new i.Number(this.destination).minus(this).times(t).plus(this) : this
                            }
                        }
                    }), i.Element = i.invent({
                        create: function(t) {
                            this._stroke = i.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute("stroke") || this._stroke)
                        },
                        extend: {
                            x: function(t) {
                                return this.attr("x", t)
                            },
                            y: function(t) {
                                return this.attr("y", t)
                            },
                            cx: function(t) {
                                return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2)
                            },
                            cy: function(t) {
                                return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2)
                            },
                            move: function(t, e) {
                                return this.x(t).y(e)
                            },
                            center: function(t, e) {
                                return this.cx(t).cy(e)
                            },
                            width: function(t) {
                                return this.attr("width", t)
                            },
                            height: function(t) {
                                return this.attr("height", t)
                            },
                            size: function(t, e) {
                                var n = p(this, t, e);
                                return this.width(new i.Number(n.width)).height(new i.Number(n.height))
                            },
                            clone: function(t) {
                                this.writeDataToDom();
                                var e = m(this.node.cloneNode(!0));
                                return t ? t.add(e) : this.after(e), e
                            },
                            remove: function() {
                                return this.parent() && this.parent().removeElement(this), this
                            },
                            replace: function(t) {
                                return this.after(t).remove(), t
                            },
                            addTo: function(t) {
                                return t.put(this)
                            },
                            putIn: function(t) {
                                return t.add(this)
                            },
                            id: function(t) {
                                return this.attr("id", t)
                            },
                            show: function() {
                                return this.style("display", "")
                            },
                            hide: function() {
                                return this.style("display", "none")
                            },
                            visible: function() {
                                return "none" != this.style("display")
                            },
                            toString: function() {
                                return this.attr("id")
                            },
                            classes: function() {
                                var t = this.attr("class");
                                return null == t ? [] : t.trim().split(i.regex.delimiter)
                            },
                            hasClass: function(t) {
                                return -1 != this.classes().indexOf(t)
                            },
                            addClass: function(t) {
                                if (!this.hasClass(t)) {
                                    var e = this.classes();
                                    e.push(t), this.attr("class", e.join(" "))
                                }
                                return this
                            },
                            removeClass: function(t) {
                                return this.hasClass(t) && this.attr("class", this.classes().filter(function(e) {
                                    return e != t
                                }).join(" ")), this
                            },
                            toggleClass: function(t) {
                                return this.hasClass(t) ? this.removeClass(t) : this.addClass(t)
                            },
                            reference: function(t) {
                                return i.get(this.attr(t))
                            },
                            parent: function(e) {
                                var n = this;
                                if (!n.node.parentNode) return null;
                                if (n = i.adopt(n.node.parentNode), !e) return n;
                                for (; n && n.node instanceof t.SVGElement;) {
                                    if ("string" == typeof e ? n.matches(e) : n instanceof e) return n;
                                    if (!n.node.parentNode || "#document" == n.node.parentNode.nodeName) return null;
                                    n = i.adopt(n.node.parentNode)
                                }
                            },
                            doc: function() {
                                return this instanceof i.Doc ? this : this.parent(i.Doc)
                            },
                            parents: function(t) {
                                var e = [],
                                    i = this;
                                do {
                                    if (!(i = i.parent(t)) || !i.node) break;
                                    e.push(i)
                                } while (i.parent);
                                return e
                            },
                            matches: function(t) {
                                return function(t, e) {
                                    return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e)
                                }(this.node, t)
                            },
                            native: function() {
                                return this.node
                            },
                            svg: function(t) {
                                var n = e.createElement("svg");
                                if (!(t && this instanceof i.Parent)) return n.appendChild(t = e.createElement("svg")), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), n.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                                n.innerHTML = "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                                for (var s = 0, r = n.firstChild.childNodes.length; s < r; s++) this.node.appendChild(n.firstChild.firstChild);
                                return this
                            },
                            writeDataToDom: function() {
                                return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
                                    this.writeDataToDom()
                                }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
                            },
                            setData: function(t) {
                                return this.dom = t, this
                            },
                            is: function(t) {
                                return function(t, e) {
                                    return t instanceof e
                                }(this, t)
                            }
                        }
                    }), i.easing = {
                        "-": function(t) {
                            return t
                        },
                        "<>": function(t) {
                            return -Math.cos(t * Math.PI) / 2 + .5
                        },
                        ">": function(t) {
                            return Math.sin(t * Math.PI / 2)
                        },
                        "<": function(t) {
                            return 1 - Math.cos(t * Math.PI / 2)
                        }
                    }, i.morph = function(t) {
                        return function(e, n) {
                            return new i.MorphObj(e, n).at(t)
                        }
                    }, i.Situation = i.invent({
                        create: function(t) {
                            this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new i.Number(t.duration).valueOf(), this.delay = new i.Number(t.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
                        }
                    }), i.FX = i.invent({
                        create: function(t) {
                            this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
                        },
                        extend: {
                            animate: function(t, e, n) {
                                "object" === s(t) && (e = t.ease, n = t.delay, t = t.duration);
                                var r = new i.Situation({
                                    duration: t || 1e3,
                                    delay: n || 0,
                                    ease: i.easing[e || "-"] || e
                                });
                                return this.queue(r), this
                            },
                            target: function(t) {
                                return t && t instanceof i.Element ? (this._target = t, this) : this._target
                            },
                            timeToAbsPos: function(t) {
                                return (t - this.situation.start) / (this.situation.duration / this._speed)
                            },
                            absPosToTime: function(t) {
                                return this.situation.duration / this._speed * t + this.situation.start
                            },
                            startAnimFrame: function() {
                                this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame((function() {
                                    this.step()
                                }).bind(this))
                            },
                            stopAnimFrame: function() {
                                t.cancelAnimationFrame(this.animationFrame)
                            },
                            start: function() {
                                return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
                            },
                            startCurrent: function() {
                                return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
                            },
                            queue: function(t) {
                                return ("function" == typeof t || t instanceof i.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this
                            },
                            dequeue: function() {
                                return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof i.Situation ? this.start() : this.situation.call(this)), this
                            },
                            initAnimations: function() {
                                var t, e = this.situation;
                                if (e.init) return this;
                                for (var n in e.animations) {
                                    t = this.target()[n](), Array.isArray(t) || (t = [t]), Array.isArray(e.animations[n]) || (e.animations[n] = [e.animations[n]]);
                                    for (var s = t.length; s--;) e.animations[n][s] instanceof i.Number && (t[s] = new i.Number(t[s])), e.animations[n][s] = t[s].morph(e.animations[n][s])
                                }
                                for (var n in e.attrs) e.attrs[n] = new i.MorphObj(this.target().attr(n), e.attrs[n]);
                                for (var n in e.styles) e.styles[n] = new i.MorphObj(this.target().style(n), e.styles[n]);
                                return e.initialTransformation = this.target().matrixify(), e.init = !0, this
                            },
                            clearQueue: function() {
                                return this.situations = [], this
                            },
                            clearCurrent: function() {
                                return this.situation = null, this
                            },
                            stop: function(t, e) {
                                var i = this.active;
                                return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
                            },
                            after: function(t) {
                                var e = this.last();
                                return this.target().on("finished.fx", function i(n) {
                                    n.detail.situation == e && (t.call(this, e), this.off("finished.fx", i))
                                }), this._callStart()
                            },
                            during: function(t) {
                                var e = this.last(),
                                    n = function(n) {
                                        n.detail.situation == e && t.call(this, n.detail.pos, i.morph(n.detail.pos), n.detail.eased, e)
                                    };
                                return this.target().off("during.fx", n).on("during.fx", n), this.after(function() {
                                    this.off("during.fx", n)
                                }), this._callStart()
                            },
                            afterAll: function(t) {
                                var e = function e(i) {
                                    t.call(this), this.off("allfinished.fx", e)
                                };
                                return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart()
                            },
                            last: function() {
                                return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                            },
                            add: function(t, e, i) {
                                return this.last()[i || "animations"][t] = e, this._callStart()
                            },
                            step: function(t) {
                                var e, i, n;
                                t || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, n = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, n = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - n) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                                var s = this.situation.ease(this.pos);
                                for (var r in this.situation.once) r > this.lastPos && r <= s && (this.situation.once[r].call(this.target(), this.pos, s), delete this.situation.once[r]);
                                return this.active && this.target().fire("during", {
                                    pos: this.pos,
                                    eased: s,
                                    fx: this,
                                    situation: this.situation
                                }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                                    fx: this,
                                    situation: this.situation
                                }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this
                            },
                            eachAt: function() {
                                var t, e = this,
                                    n = this.target(),
                                    s = this.situation;
                                for (var r in s.animations) t = [].concat(s.animations[r]).map(function(t) {
                                    return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                }), n[r].apply(n, t);
                                for (var r in s.attrs) t = [r].concat(s.attrs[r]).map(function(t) {
                                    return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                }), n.attr.apply(n, t);
                                for (var r in s.styles) t = [r].concat(s.styles[r]).map(function(t) {
                                    return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                }), n.style.apply(n, t);
                                if (s.transforms.length) {
                                    t = s.initialTransformation, r = 0;
                                    for (var a = s.transforms.length; r < a; r++) {
                                        var o = s.transforms[r];
                                        o instanceof i.Matrix ? t = o.relative ? t.multiply((new i.Matrix).morph(o).at(s.ease(this.pos))) : t.morph(o).at(s.ease(this.pos)) : (o.relative || o.undo(t.extract()), t = t.multiply(o.at(s.ease(this.pos))))
                                    }
                                    n.matrix(t)
                                }
                                return this
                            },
                            once: function(t, e, i) {
                                var n = this.last();
                                return i || (t = n.ease(t)), n.once[t] = e, this
                            },
                            _callStart: function() {
                                return setTimeout((function() {
                                    this.start()
                                }).bind(this), 0), this
                            }
                        },
                        parent: i.Element,
                        construct: {
                            animate: function(t, e, n) {
                                return (this.fx || (this.fx = new i.FX(this))).animate(t, e, n)
                            },
                            delay: function(t) {
                                return (this.fx || (this.fx = new i.FX(this))).delay(t)
                            },
                            stop: function(t, e) {
                                return this.fx && this.fx.stop(t, e), this
                            },
                            finish: function() {
                                return this.fx && this.fx.finish(), this
                            }
                        }
                    }), i.MorphObj = i.invent({
                        create: function(t, e) {
                            return i.Color.isColor(e) ? new i.Color(t).morph(e) : i.regex.delimiter.test(t) ? i.regex.pathLetters.test(t) ? new i.PathArray(t).morph(e) : new i.Array(t).morph(e) : i.regex.numberAndUnit.test(e) ? new i.Number(t).morph(e) : (this.value = t, void(this.destination = e))
                        },
                        extend: {
                            at: function(t, e) {
                                return e < 1 ? this.value : this.destination
                            },
                            valueOf: function() {
                                return this.value
                            }
                        }
                    }), i.extend(i.FX, {
                        attr: function(t, e, i) {
                            if ("object" === s(t))
                                for (var n in t) this.attr(n, t[n]);
                            else this.add(t, e, "attrs");
                            return this
                        },
                        plot: function(t, e, i, n) {
                            return 4 == arguments.length ? this.plot([t, e, i, n]) : this.add("plot", new(this.target().morphArray)(t))
                        }
                    }), i.Box = i.invent({
                        create: function(t, e, n, r) {
                            if (!("object" !== s(t) || t instanceof i.Element)) return i.Box.call(this, null != t.left ? t.left : t.x, null != t.top ? t.top : t.y, t.width, t.height);
                            4 == arguments.length && (this.x = t, this.y = e, this.width = n, this.height = r), b(this)
                        }
                    }), i.BBox = i.invent({
                        create: function(t) {
                            if (i.Box.apply(this, [].slice.call(arguments)), t instanceof i.Element) {
                                var n;
                                try {
                                    if (!e.documentElement.contains) {
                                        for (var s = t.node; s.parentNode;) s = s.parentNode;
                                        if (s != e) throw new Error("Element not in the dom")
                                    }
                                    n = t.node.getBBox()
                                } catch (e) {
                                    if (t instanceof i.Shape) {
                                        i.parser.draw || i.prepare();
                                        var r = t.clone(i.parser.draw.instance).show();
                                        n = r.node.getBBox(), r.remove()
                                    } else n = {
                                        x: t.node.clientLeft,
                                        y: t.node.clientTop,
                                        width: t.node.clientWidth,
                                        height: t.node.clientHeight
                                    }
                                }
                                i.Box.call(this, n)
                            }
                        },
                        inherit: i.Box,
                        parent: i.Element,
                        construct: {
                            bbox: function() {
                                return new i.BBox(this)
                            }
                        }
                    }), i.BBox.prototype.constructor = i.BBox, i.Matrix = i.invent({
                        create: function(t) {
                            var e = g([1, 0, 0, 1, 0, 0]);
                            t = t instanceof i.Element ? t.matrixify() : "string" == typeof t ? g(t.split(i.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? g([].slice.call(arguments)) : Array.isArray(t) ? g(t) : "object" === s(t) ? t : e;
                            for (var n = v.length - 1; n >= 0; --n) this[v[n]] = null != t[v[n]] ? t[v[n]] : e[v[n]]
                        },
                        extend: {
                            extract: function() {
                                var t = f(this, 0, 1),
                                    e = (f(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90);
                                return {
                                    x: this.e,
                                    y: this.f,
                                    transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                                    transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                                    rotation: e,
                                    a: this.a,
                                    b: this.b,
                                    c: this.c,
                                    d: this.d,
                                    e: this.e,
                                    f: this.f,
                                    matrix: new i.Matrix(this)
                                }
                            },
                            clone: function() {
                                return new i.Matrix(this)
                            },
                            morph: function(t) {
                                return this.destination = new i.Matrix(t), this
                            },
                            multiply: function(t) {
                                return new i.Matrix(this.native().multiply(function(t) {
                                    return t instanceof i.Matrix || (t = new i.Matrix(t)), t
                                }(t).native()))
                            },
                            inverse: function() {
                                return new i.Matrix(this.native().inverse())
                            },
                            translate: function(t, e) {
                                return new i.Matrix(this.native().translate(t || 0, e || 0))
                            },
                            native: function() {
                                for (var t = i.parser.native.createSVGMatrix(), e = v.length - 1; e >= 0; e--) t[v[e]] = this[v[e]];
                                return t
                            },
                            toString: function() {
                                return "matrix(" + y(this.a) + "," + y(this.b) + "," + y(this.c) + "," + y(this.d) + "," + y(this.e) + "," + y(this.f) + ")"
                            }
                        },
                        parent: i.Element,
                        construct: {
                            ctm: function() {
                                return new i.Matrix(this.node.getCTM())
                            },
                            screenCTM: function() {
                                if (this instanceof i.Nested) {
                                    var t = this.rect(1, 1),
                                        e = t.node.getScreenCTM();
                                    return t.remove(), new i.Matrix(e)
                                }
                                return new i.Matrix(this.node.getScreenCTM())
                            }
                        }
                    }), i.Point = i.invent({
                        create: function(t, e) {
                            var i;
                            i = Array.isArray(t) ? {
                                x: t[0],
                                y: t[1]
                            } : "object" === s(t) ? {
                                x: t.x,
                                y: t.y
                            } : null != t ? {
                                x: t,
                                y: null != e ? e : t
                            } : {
                                x: 0,
                                y: 0
                            }, this.x = i.x, this.y = i.y
                        },
                        extend: {
                            clone: function() {
                                return new i.Point(this)
                            },
                            morph: function(t, e) {
                                return this.destination = new i.Point(t, e), this
                            }
                        }
                    }), i.extend(i.Element, {
                        point: function(t, e) {
                            return new i.Point(t, e).transform(this.screenCTM().inverse())
                        }
                    }), i.extend(i.Element, {
                        attr: function(t, e, n) {
                            if (null == t) {
                                for (t = {}, n = (e = this.node.attributes).length - 1; n >= 0; n--) t[e[n].nodeName] = i.regex.isNumber.test(e[n].nodeValue) ? parseFloat(e[n].nodeValue) : e[n].nodeValue;
                                return t
                            }
                            if ("object" === s(t))
                                for (var r in t) this.attr(r, t[r]);
                            else if (null === e) this.node.removeAttribute(t);
                            else {
                                if (null == e) return null == (e = this.node.getAttribute(t)) ? i.defaults.attrs[t] : i.regex.isNumber.test(e) ? parseFloat(e) : e;
                                "stroke-width" == t ? this.attr("stroke", parseFloat(e) > 0 ? this._stroke : null) : "stroke" == t && (this._stroke = e), "fill" != t && "stroke" != t || (i.regex.isImage.test(e) && (e = this.doc().defs().image(e, 0, 0)), e instanceof i.Image && (e = this.doc().defs().pattern(0, 0, function() {
                                    this.add(e)
                                }))), "number" == typeof e ? e = new i.Number(e) : i.Color.isColor(e) ? e = new i.Color(e) : Array.isArray(e) && (e = new i.Array(e)), "leading" == t ? this.leading && this.leading(e) : "string" == typeof n ? this.node.setAttributeNS(n, t, e.toString()) : this.node.setAttribute(t, e.toString()), !this.rebuild || "font-size" != t && "x" != t || this.rebuild(t, e)
                            }
                            return this
                        }
                    }), i.extend(i.Element, {
                        transform: function(t, e) {
                            var n;
                            return "object" !== s(t) ? (n = new i.Matrix(this).extract(), "string" == typeof t ? n[t] : n) : (n = new i.Matrix(this), e = !!e || !!t.relative, null != t.a && (n = e ? n.multiply(new i.Matrix(t)) : new i.Matrix(t)), this.attr("transform", n))
                        }
                    }), i.extend(i.Element, {
                        untransform: function() {
                            return this.attr("transform", null)
                        },
                        matrixify: function() {
                            return (this.attr("transform") || "").split(i.regex.transforms).slice(0, -1).map(function(t) {
                                var e = t.trim().split("(");
                                return [e[0], e[1].split(i.regex.delimiter).map(function(t) {
                                    return parseFloat(t)
                                })]
                            }).reduce(function(t, e) {
                                return "matrix" == e[0] ? t.multiply(g(e[1])) : t[e[0]].apply(t, e[1])
                            }, new i.Matrix)
                        },
                        toParent: function(t) {
                            if (this == t) return this;
                            var e = this.screenCTM(),
                                i = t.screenCTM().inverse();
                            return this.addTo(t).untransform().transform(i.multiply(e)), this
                        },
                        toDoc: function() {
                            return this.toParent(this.doc())
                        }
                    }), i.Transformation = i.invent({
                        create: function(t, e) {
                            if (arguments.length > 1 && "boolean" != typeof e) return this.constructor.call(this, [].slice.call(arguments));
                            if (Array.isArray(t))
                                for (var i = 0, n = this.arguments.length; i < n; ++i) this[this.arguments[i]] = t[i];
                            else if ("object" === s(t))
                                for (i = 0, n = this.arguments.length; i < n; ++i) this[this.arguments[i]] = t[this.arguments[i]];
                            this.inversed = !1, !0 === e && (this.inversed = !0)
                        }
                    }), i.Translate = i.invent({
                        parent: i.Matrix,
                        inherit: i.Transformation,
                        create: function(t, e) {
                            this.constructor.apply(this, [].slice.call(arguments))
                        },
                        extend: {
                            arguments: ["transformedX", "transformedY"],
                            method: "translate"
                        }
                    }), i.extend(i.Element, {
                        style: function(t, e) {
                            if (0 == arguments.length) return this.node.style.cssText || "";
                            if (arguments.length < 2)
                                if ("object" === s(t))
                                    for (var n in t) this.style(n, t[n]);
                                else {
                                    if (!i.regex.isCss.test(t)) return this.node.style[h(t)];
                                    for (t = t.split(/\s*;\s*/).filter(function(t) {
                                            return !!t
                                        }).map(function(t) {
                                            return t.split(/\s*:\s*/)
                                        }); e = t.pop();) this.style(e[0], e[1])
                                }
                            else this.node.style[h(t)] = null === e || i.regex.isBlank.test(e) ? "" : e;
                            return this
                        }
                    }), i.Parent = i.invent({
                        create: function(t) {
                            this.constructor.call(this, t)
                        },
                        inherit: i.Element,
                        extend: {
                            children: function() {
                                return i.utils.map(i.utils.filterSVGElements(this.node.childNodes), function(t) {
                                    return i.adopt(t)
                                })
                            },
                            add: function(t, e) {
                                return null == e ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this
                            },
                            put: function(t, e) {
                                return this.add(t, e), t
                            },
                            has: function(t) {
                                return this.index(t) >= 0
                            },
                            index: function(t) {
                                return [].slice.call(this.node.childNodes).indexOf(t.node)
                            },
                            get: function(t) {
                                return i.adopt(this.node.childNodes[t])
                            },
                            first: function() {
                                return this.get(0)
                            },
                            last: function() {
                                return this.get(this.node.childNodes.length - 1)
                            },
                            each: function(t, e) {
                                for (var n = this.children(), s = 0, r = n.length; s < r; s++) n[s] instanceof i.Element && t.apply(n[s], [s, n]), e && n[s] instanceof i.Container && n[s].each(t, e);
                                return this
                            },
                            removeElement: function(t) {
                                return this.node.removeChild(t.node), this
                            },
                            clear: function() {
                                for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                return delete this._defs, this
                            },
                            defs: function() {
                                return this.doc().defs()
                            }
                        }
                    }), i.extend(i.Parent, {
                        ungroup: function(t, e) {
                            return 0 === e || this instanceof i.Defs || this.node == i.parser.draw || (t = t || (this instanceof i.Doc ? this : this.parent(i.Parent)), e = e || 1 / 0, this.each(function() {
                                return this instanceof i.Defs ? this : this instanceof i.Parent ? this.ungroup(t, e - 1) : this.toParent(t)
                            }), this.node.firstChild || this.remove()), this
                        },
                        flatten: function(t, e) {
                            return this.ungroup(t, e)
                        }
                    }), i.Container = i.invent({
                        create: function(t) {
                            this.constructor.call(this, t)
                        },
                        inherit: i.Parent
                    }), i.ViewBox = i.invent({
                        parent: i.Container,
                        construct: {}
                    }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t) {
                        i.Element.prototype[t] = function(e) {
                            return i.on(this.node, t, e), this
                        }
                    }), i.listeners = [], i.handlerMap = [], i.listenerId = 0, i.on = function(t, e, n, s, r) {
                        var a = n.bind(s || t.instance || t),
                            o = (i.handlerMap.indexOf(t) + 1 || i.handlerMap.push(t)) - 1,
                            l = e.split(".")[0],
                            c = e.split(".")[1] || "*";
                        i.listeners[o] = i.listeners[o] || {}, i.listeners[o][l] = i.listeners[o][l] || {}, i.listeners[o][l][c] = i.listeners[o][l][c] || {}, n._svgjsListenerId || (n._svgjsListenerId = ++i.listenerId), i.listeners[o][l][c][n._svgjsListenerId] = a, t.addEventListener(l, a, r || {
                            passive: !0
                        })
                    }, i.off = function(t, e, n) {
                        var s = i.handlerMap.indexOf(t),
                            r = e && e.split(".")[0],
                            a = e && e.split(".")[1],
                            o = "";
                        if (-1 != s)
                            if (n) {
                                if ("function" == typeof n && (n = n._svgjsListenerId), !n) return;
                                i.listeners[s][r] && i.listeners[s][r][a || "*"] && (t.removeEventListener(r, i.listeners[s][r][a || "*"][n], !1), delete i.listeners[s][r][a || "*"][n])
                            } else if (a && r) {
                            if (i.listeners[s][r] && i.listeners[s][r][a]) {
                                for (var l in i.listeners[s][r][a]) i.off(t, [r, a].join("."), l);
                                delete i.listeners[s][r][a]
                            }
                        } else if (a)
                            for (var c in i.listeners[s])
                                for (var o in i.listeners[s][c]) a === o && i.off(t, [c, a].join("."));
                        else if (r) {
                            if (i.listeners[s][r]) {
                                for (var o in i.listeners[s][r]) i.off(t, [r, o].join("."));
                                delete i.listeners[s][r]
                            }
                        } else {
                            for (var c in i.listeners[s]) i.off(t, c);
                            delete i.listeners[s], delete i.handlerMap[s]
                        }
                    }, i.extend(i.Element, {
                        on: function(t, e, n, s) {
                            return i.on(this.node, t, e, n, s), this
                        },
                        off: function(t, e) {
                            return i.off(this.node, t, e), this
                        },
                        fire: function(e, n) {
                            return this.node.dispatchEvent(e instanceof t.Event ? e : e = new i.CustomEvent(e, {
                                detail: n,
                                cancelable: !0
                            })), this._event = e, this
                        },
                        event: function() {
                            return this._event
                        }
                    }), i.Defs = i.invent({
                        create: "defs",
                        inherit: i.Container
                    }), i.G = i.invent({
                        create: "g",
                        inherit: i.Container,
                        extend: {
                            x: function(t) {
                                return null == t ? this.transform("x") : this.transform({
                                    x: t - this.x()
                                }, !0)
                            }
                        },
                        construct: {
                            group: function() {
                                return this.put(new i.G)
                            }
                        }
                    }), i.Doc = i.invent({
                        create: function(t) {
                            t && ("svg" == (t = "string" == typeof t ? e.getElementById(t) : t).nodeName ? this.constructor.call(this, t) : (this.constructor.call(this, i.create("svg")), t.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
                        },
                        inherit: i.Container,
                        extend: {
                            namespace: function() {
                                return this.attr({
                                    xmlns: i.ns,
                                    version: "1.1"
                                }).attr("xmlns:xlink", i.xlink, i.xmlns).attr("xmlns:svgjs", i.svgjs, i.xmlns)
                            },
                            defs: function() {
                                var t;
                                return this._defs || (this._defs = (t = this.node.getElementsByTagName("defs")[0]) ? i.adopt(t) : new i.Defs, this.node.appendChild(this._defs.node)), this._defs
                            },
                            parent: function() {
                                return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                            },
                            remove: function() {
                                return this.parent() && this.parent().removeChild(this.node), this
                            },
                            clear: function() {
                                for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                return delete this._defs, i.parser.draw && !i.parser.draw.parentNode && this.node.appendChild(i.parser.draw), this
                            },
                            clone: function(t) {
                                this.writeDataToDom();
                                var e = this.node,
                                    i = m(e.cloneNode(!0));
                                return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i
                            }
                        }
                    }), i.extend(i.Element, {}), i.Gradient = i.invent({
                        create: function(t) {
                            this.constructor.call(this, i.create(t + "Gradient")), this.type = t
                        },
                        inherit: i.Container,
                        extend: {
                            at: function(t, e, n) {
                                return this.put(new i.Stop).update(t, e, n)
                            },
                            update: function(t) {
                                return this.clear(), "function" == typeof t && t.call(this, this), this
                            },
                            fill: function() {
                                return "url(#" + this.id() + ")"
                            },
                            toString: function() {
                                return this.fill()
                            },
                            attr: function(t, e, n) {
                                return "transform" == t && (t = "gradientTransform"), i.Container.prototype.attr.call(this, t, e, n)
                            }
                        },
                        construct: {
                            gradient: function(t, e) {
                                return this.defs().gradient(t, e)
                            }
                        }
                    }), i.extend(i.Gradient, i.FX, {
                        from: function(t, e) {
                            return this.attr("radial" == (this._target || this).type ? {
                                fx: new i.Number(t),
                                fy: new i.Number(e)
                            } : {
                                x1: new i.Number(t),
                                y1: new i.Number(e)
                            })
                        },
                        to: function(t, e) {
                            return this.attr("radial" == (this._target || this).type ? {
                                cx: new i.Number(t),
                                cy: new i.Number(e)
                            } : {
                                x2: new i.Number(t),
                                y2: new i.Number(e)
                            })
                        }
                    }), i.extend(i.Defs, {
                        gradient: function(t, e) {
                            return this.put(new i.Gradient(t)).update(e)
                        }
                    }), i.Stop = i.invent({
                        create: "stop",
                        inherit: i.Element,
                        extend: {
                            update: function(t) {
                                return ("number" == typeof t || t instanceof i.Number) && (t = {
                                    offset: arguments[0],
                                    color: arguments[1],
                                    opacity: arguments[2]
                                }), null != t.opacity && this.attr("stop-opacity", t.opacity), null != t.color && this.attr("stop-color", t.color), null != t.offset && this.attr("offset", new i.Number(t.offset)), this
                            }
                        }
                    }), i.Pattern = i.invent({
                        create: "pattern",
                        inherit: i.Container,
                        extend: {
                            fill: function() {
                                return "url(#" + this.id() + ")"
                            },
                            update: function(t) {
                                return this.clear(), "function" == typeof t && t.call(this, this), this
                            },
                            toString: function() {
                                return this.fill()
                            },
                            attr: function(t, e, n) {
                                return "transform" == t && (t = "patternTransform"), i.Container.prototype.attr.call(this, t, e, n)
                            }
                        },
                        construct: {
                            pattern: function(t, e, i) {
                                return this.defs().pattern(t, e, i)
                            }
                        }
                    }), i.extend(i.Defs, {
                        pattern: function(t, e, n) {
                            return this.put(new i.Pattern).update(n).attr({
                                x: 0,
                                y: 0,
                                width: t,
                                height: e,
                                patternUnits: "userSpaceOnUse"
                            })
                        }
                    }), i.Shape = i.invent({
                        create: function(t) {
                            this.constructor.call(this, t)
                        },
                        inherit: i.Element
                    }), i.Symbol = i.invent({
                        create: "symbol",
                        inherit: i.Container,
                        construct: {
                            symbol: function() {
                                return this.put(new i.Symbol)
                            }
                        }
                    }), i.Use = i.invent({
                        create: "use",
                        inherit: i.Shape,
                        extend: {
                            element: function(t, e) {
                                return this.attr("href", (e || "") + "#" + t, i.xlink)
                            }
                        },
                        construct: {
                            use: function(t, e) {
                                return this.put(new i.Use).element(t, e)
                            }
                        }
                    }), i.Rect = i.invent({
                        create: "rect",
                        inherit: i.Shape,
                        construct: {
                            rect: function(t, e) {
                                return this.put(new i.Rect).size(t, e)
                            }
                        }
                    }), i.Circle = i.invent({
                        create: "circle",
                        inherit: i.Shape,
                        construct: {
                            circle: function(t) {
                                return this.put(new i.Circle).rx(new i.Number(t).divide(2)).move(0, 0)
                            }
                        }
                    }), i.extend(i.Circle, i.FX, {
                        rx: function(t) {
                            return this.attr("r", t)
                        },
                        ry: function(t) {
                            return this.rx(t)
                        }
                    }), i.Ellipse = i.invent({
                        create: "ellipse",
                        inherit: i.Shape,
                        construct: {
                            ellipse: function(t, e) {
                                return this.put(new i.Ellipse).size(t, e).move(0, 0)
                            }
                        }
                    }), i.extend(i.Ellipse, i.Rect, i.FX, {
                        rx: function(t) {
                            return this.attr("rx", t)
                        },
                        ry: function(t) {
                            return this.attr("ry", t)
                        }
                    }), i.extend(i.Circle, i.Ellipse, {
                        x: function(t) {
                            return null == t ? this.cx() - this.rx() : this.cx(t + this.rx())
                        },
                        y: function(t) {
                            return null == t ? this.cy() - this.ry() : this.cy(t + this.ry())
                        },
                        cx: function(t) {
                            return null == t ? this.attr("cx") : this.attr("cx", t)
                        },
                        cy: function(t) {
                            return null == t ? this.attr("cy") : this.attr("cy", t)
                        },
                        width: function(t) {
                            return null == t ? 2 * this.rx() : this.rx(new i.Number(t).divide(2))
                        },
                        height: function(t) {
                            return null == t ? 2 * this.ry() : this.ry(new i.Number(t).divide(2))
                        },
                        size: function(t, e) {
                            var n = p(this, t, e);
                            return this.rx(new i.Number(n.width).divide(2)).ry(new i.Number(n.height).divide(2))
                        }
                    }), i.Line = i.invent({
                        create: "line",
                        inherit: i.Shape,
                        extend: {
                            array: function() {
                                return new i.PointArray([
                                    [this.attr("x1"), this.attr("y1")],
                                    [this.attr("x2"), this.attr("y2")]
                                ])
                            },
                            plot: function(t, e, n, s) {
                                return null == t ? this.array() : (t = void 0 !== e ? {
                                    x1: t,
                                    y1: e,
                                    x2: n,
                                    y2: s
                                } : new i.PointArray(t).toLine(), this.attr(t))
                            },
                            move: function(t, e) {
                                return this.attr(this.array().move(t, e).toLine())
                            },
                            size: function(t, e) {
                                var i = p(this, t, e);
                                return this.attr(this.array().size(i.width, i.height).toLine())
                            }
                        },
                        construct: {
                            line: function(t, e, n, s) {
                                return i.Line.prototype.plot.apply(this.put(new i.Line), null != t ? [t, e, n, s] : [0, 0, 0, 0])
                            }
                        }
                    }), i.Polyline = i.invent({
                        create: "polyline",
                        inherit: i.Shape,
                        construct: {
                            polyline: function(t) {
                                return this.put(new i.Polyline).plot(t || new i.PointArray)
                            }
                        }
                    }), i.Polygon = i.invent({
                        create: "polygon",
                        inherit: i.Shape,
                        construct: {
                            polygon: function(t) {
                                return this.put(new i.Polygon).plot(t || new i.PointArray)
                            }
                        }
                    }), i.extend(i.Polyline, i.Polygon, {
                        array: function() {
                            return this._array || (this._array = new i.PointArray(this.attr("points")))
                        },
                        plot: function(t) {
                            return null == t ? this.array() : this.clear().attr("points", "string" == typeof t ? t : this._array = new i.PointArray(t))
                        },
                        clear: function() {
                            return delete this._array, this
                        },
                        move: function(t, e) {
                            return this.attr("points", this.array().move(t, e))
                        },
                        size: function(t, e) {
                            var i = p(this, t, e);
                            return this.attr("points", this.array().size(i.width, i.height))
                        }
                    }), i.extend(i.Line, i.Polyline, i.Polygon, {
                        morphArray: i.PointArray,
                        x: function(t) {
                            return null == t ? this.bbox().x : this.move(t, this.bbox().y)
                        },
                        y: function(t) {
                            return null == t ? this.bbox().y : this.move(this.bbox().x, t)
                        },
                        width: function(t) {
                            var e = this.bbox();
                            return null == t ? e.width : this.size(t, e.height)
                        },
                        height: function(t) {
                            var e = this.bbox();
                            return null == t ? e.height : this.size(e.width, t)
                        }
                    }), i.Path = i.invent({
                        create: "path",
                        inherit: i.Shape,
                        extend: {
                            morphArray: i.PathArray,
                            array: function() {
                                return this._array || (this._array = new i.PathArray(this.attr("d")))
                            },
                            plot: function(t) {
                                return null == t ? this.array() : this.clear().attr("d", "string" == typeof t ? t : this._array = new i.PathArray(t))
                            },
                            clear: function() {
                                return delete this._array, this
                            }
                        },
                        construct: {
                            path: function(t) {
                                return this.put(new i.Path).plot(t || new i.PathArray)
                            }
                        }
                    }), i.Image = i.invent({
                        create: "image",
                        inherit: i.Shape,
                        extend: {
                            load: function(e) {
                                if (!e) return this;
                                var n = this,
                                    s = new t.Image;
                                return i.on(s, "load", function() {
                                    i.off(s);
                                    var t = n.parent(i.Pattern);
                                    null !== t && (0 == n.width() && 0 == n.height() && n.size(s.width, s.height), t && 0 == t.width() && 0 == t.height() && t.size(n.width(), n.height()), "function" == typeof n._loaded && n._loaded.call(n, {
                                        width: s.width,
                                        height: s.height,
                                        ratio: s.width / s.height,
                                        url: e
                                    }))
                                }), i.on(s, "error", function(t) {
                                    i.off(s), "function" == typeof n._error && n._error.call(n, t)
                                }), this.attr("href", s.src = this.src = e, i.xlink)
                            },
                            loaded: function(t) {
                                return this._loaded = t, this
                            },
                            error: function(t) {
                                return this._error = t, this
                            }
                        },
                        construct: {
                            image: function(t, e, n) {
                                return this.put(new i.Image).load(t).size(e || 0, n || e || 0)
                            }
                        }
                    }), i.Text = i.invent({
                        create: function() {
                            this.constructor.call(this, i.create("text")), this.dom.leading = new i.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", i.defaults.attrs["font-family"])
                        },
                        inherit: i.Shape,
                        extend: {
                            x: function(t) {
                                return null == t ? this.attr("x") : this.attr("x", t)
                            },
                            text: function(t) {
                                if (void 0 === t) {
                                    t = "";
                                    for (var e = this.node.childNodes, n = 0, s = e.length; n < s; ++n) 0 != n && 3 != e[n].nodeType && 1 == i.adopt(e[n]).dom.newLined && (t += "\n"), t += e[n].textContent;
                                    return t
                                }
                                if (this.clear().build(!0), "function" == typeof t) t.call(this, this);
                                else {
                                    n = 0;
                                    for (var r = (t = t.split("\n")).length; n < r; n++) this.tspan(t[n]).newLine()
                                }
                                return this.build(!1).rebuild()
                            },
                            size: function(t) {
                                return this.attr("font-size", t).rebuild()
                            },
                            leading: function(t) {
                                return null == t ? this.dom.leading : (this.dom.leading = new i.Number(t), this.rebuild())
                            },
                            lines: function() {
                                var t = (this.textPath && this.textPath() || this).node,
                                    e = i.utils.map(i.utils.filterSVGElements(t.childNodes), function(t) {
                                        return i.adopt(t)
                                    });
                                return new i.Set(e)
                            },
                            rebuild: function(t) {
                                if ("boolean" == typeof t && (this._rebuild = t), this._rebuild) {
                                    var e = this,
                                        n = 0,
                                        s = this.dom.leading * new i.Number(this.attr("font-size"));
                                    this.lines().each(function() {
                                        this.dom.newLined && (e.textPath() || this.attr("x", e.attr("x")), "\n" == this.text() ? n += s : (this.attr("dy", s + n), n = 0))
                                    }), this.fire("rebuild")
                                }
                                return this
                            },
                            build: function(t) {
                                return this._build = !!t, this
                            },
                            setData: function(t) {
                                return this.dom = t, this.dom.leading = new i.Number(t.leading || 1.3), this
                            }
                        },
                        construct: {
                            text: function(t) {
                                return this.put(new i.Text).text(t)
                            },
                            plain: function(t) {
                                return this.put(new i.Text).plain(t)
                            }
                        }
                    }), i.Tspan = i.invent({
                        create: "tspan",
                        inherit: i.Shape,
                        extend: {
                            text: function(t) {
                                return null == t ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t ? t.call(this, this) : this.plain(t), this)
                            },
                            dx: function(t) {
                                return this.attr("dx", t)
                            },
                            dy: function(t) {
                                return this.attr("dy", t)
                            },
                            newLine: function() {
                                var t = this.parent(i.Text);
                                return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x())
                            }
                        }
                    }), i.extend(i.Text, i.Tspan, {
                        plain: function(t) {
                            return !1 === this._build && this.clear(), this.node.appendChild(e.createTextNode(t)), this
                        },
                        tspan: function(t) {
                            var e = (this.textPath && this.textPath() || this).node,
                                n = new i.Tspan;
                            return !1 === this._build && this.clear(), e.appendChild(n.node), n.text(t)
                        },
                        clear: function() {
                            for (var t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();) t.removeChild(t.lastChild);
                            return this
                        },
                        length: function() {
                            return this.node.getComputedTextLength()
                        }
                    }), i.TextPath = i.invent({
                        create: "textPath",
                        inherit: i.Parent,
                        parent: i.Text,
                        construct: {
                            morphArray: i.PathArray,
                            array: function() {
                                var t = this.track();
                                return t ? t.array() : null
                            },
                            plot: function(t) {
                                var e = this.track(),
                                    i = null;
                                return e && (i = e.plot(t)), null == t ? i : this
                            },
                            track: function() {
                                var t = this.textPath();
                                if (t) return t.reference("href")
                            },
                            textPath: function() {
                                if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return i.adopt(this.node.firstChild)
                            }
                        }
                    }), i.Nested = i.invent({
                        create: function() {
                            this.constructor.call(this, i.create("svg")), this.style("overflow", "visible")
                        },
                        inherit: i.Container,
                        construct: {
                            nested: function() {
                                return this.put(new i.Nested)
                            }
                        }
                    });
                    var l = {
                        stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
                        fill: ["color", "opacity", "rule"],
                        prefix: function(t, e) {
                            return "color" == e ? t : t + "-" + e
                        }
                    };

                    function c(t, e, n, s) {
                        return n + s.replace(i.regex.dots, " .")
                    }

                    function h(t) {
                        return t.toLowerCase().replace(/-(.)/g, function(t, e) {
                            return e.toUpperCase()
                        })
                    }

                    function u(t) {
                        return t.charAt(0).toUpperCase() + t.slice(1)
                    }

                    function d(t) {
                        var e = t.toString(16);
                        return 1 == e.length ? "0" + e : e
                    }

                    function p(t, e, i) {
                        if (null == e || null == i) {
                            var n = t.bbox();
                            null == e ? e = n.width / n.height * i : null == i && (i = n.height / n.width * e)
                        }
                        return {
                            width: e,
                            height: i
                        }
                    }

                    function f(t, e, i) {
                        return {
                            x: e * t.a + i * t.c + 0,
                            y: e * t.b + i * t.d + 0
                        }
                    }

                    function g(t) {
                        return {
                            a: t[0],
                            b: t[1],
                            c: t[2],
                            d: t[3],
                            e: t[4],
                            f: t[5]
                        }
                    }

                    function m(e) {
                        for (var n = e.childNodes.length - 1; n >= 0; n--) e.childNodes[n] instanceof t.SVGElement && m(e.childNodes[n]);
                        return i.adopt(e).id(i.eid(e.nodeName))
                    }

                    function b(t) {
                        return null == t.x && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t
                    }

                    function y(t) {
                        return Math.abs(t) > 1e-37 ? t : 0
                    } ["fill", "stroke"].forEach(function(t) {
                        var e = {};
                        e[t] = function(e) {
                            if (void 0 === e) return this;
                            if ("string" == typeof e || i.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(t, e);
                            else
                                for (var n = l[t].length - 1; n >= 0; n--) null != e[l[t][n]] && this.attr(l.prefix(t, l[t][n]), e[l[t][n]]);
                            return this
                        }, i.extend(i.Element, i.FX, e)
                    }), i.extend(i.Element, i.FX, {
                        translate: function(t, e) {
                            return this.transform({
                                x: t,
                                y: e
                            })
                        },
                        matrix: function(t) {
                            return this.attr("transform", new i.Matrix(6 == arguments.length ? [].slice.call(arguments) : t))
                        },
                        opacity: function(t) {
                            return this.attr("opacity", t)
                        },
                        dx: function(t) {
                            return this.x(new i.Number(t).plus(this instanceof i.FX ? 0 : this.x()), !0)
                        },
                        dy: function(t) {
                            return this.y(new i.Number(t).plus(this instanceof i.FX ? 0 : this.y()), !0)
                        }
                    }), i.extend(i.Path, {
                        length: function() {
                            return this.node.getTotalLength()
                        },
                        pointAt: function(t) {
                            return this.node.getPointAtLength(t)
                        }
                    }), i.Set = i.invent({
                        create: function(t) {
                            Array.isArray(t) ? this.members = t : this.clear()
                        },
                        extend: {
                            add: function() {
                                for (var t = [].slice.call(arguments), e = 0, i = t.length; e < i; e++) this.members.push(t[e]);
                                return this
                            },
                            remove: function(t) {
                                var e = this.index(t);
                                return e > -1 && this.members.splice(e, 1), this
                            },
                            each: function(t) {
                                for (var e = 0, i = this.members.length; e < i; e++) t.apply(this.members[e], [e, this.members]);
                                return this
                            },
                            clear: function() {
                                return this.members = [], this
                            },
                            length: function() {
                                return this.members.length
                            },
                            has: function(t) {
                                return this.index(t) >= 0
                            },
                            index: function(t) {
                                return this.members.indexOf(t)
                            },
                            get: function(t) {
                                return this.members[t]
                            },
                            first: function() {
                                return this.get(0)
                            },
                            last: function() {
                                return this.get(this.members.length - 1)
                            },
                            valueOf: function() {
                                return this.members
                            }
                        },
                        construct: {
                            set: function(t) {
                                return new i.Set(t)
                            }
                        }
                    }), i.FX.Set = i.invent({
                        create: function(t) {
                            this.set = t
                        }
                    }), i.Set.inherit = function() {
                        var t = [];
                        for (var e in i.Shape.prototype) "function" == typeof i.Shape.prototype[e] && "function" != typeof i.Set.prototype[e] && t.push(e);
                        for (var e in t.forEach(function(t) {
                                i.Set.prototype[t] = function() {
                                    for (var e = 0, n = this.members.length; e < n; e++) this.members[e] && "function" == typeof this.members[e][t] && this.members[e][t].apply(this.members[e], arguments);
                                    return "animate" == t ? this.fx || (this.fx = new i.FX.Set(this)) : this
                                }
                            }), t = [], i.FX.prototype) "function" == typeof i.FX.prototype[e] && "function" != typeof i.FX.Set.prototype[e] && t.push(e);
                        t.forEach(function(t) {
                            i.FX.Set.prototype[t] = function() {
                                for (var e = 0, i = this.set.members.length; e < i; e++) this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
                                return this
                            }
                        })
                    }, i.extend(i.Element, {}), i.extend(i.Element, {
                        remember: function(t, e) {
                            if ("object" === s(arguments[0]))
                                for (var i in t) this.remember(i, t[i]);
                            else {
                                if (1 == arguments.length) return this.memory()[t];
                                this.memory()[t] = e
                            }
                            return this
                        },
                        forget: function() {
                            if (0 == arguments.length) this._memory = {};
                            else
                                for (var t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]];
                            return this
                        },
                        memory: function() {
                            return this._memory || (this._memory = {})
                        }
                    }), i.get = function(t) {
                        var n = e.getElementById(function(t) {
                            var e = (t || "").toString().match(i.regex.reference);
                            if (e) return e[1]
                        }(t) || t);
                        return i.adopt(n)
                    }, i.select = function(t, n) {
                        return new i.Set(i.utils.map((n || e).querySelectorAll(t), function(t) {
                            return i.adopt(t)
                        }))
                    }, i.extend(i.Parent, {
                        select: function(t) {
                            return i.select(t, this.node)
                        }
                    });
                    var v = "abcdef".split("");
                    if ("function" != typeof t.CustomEvent) {
                        var x = function(t, i) {
                            i = i || {
                                bubbles: !1,
                                cancelable: !1,
                                detail: void 0
                            };
                            var n = e.createEvent("CustomEvent");
                            return n.initCustomEvent(t, i.bubbles, i.cancelable, i.detail), n
                        };
                        x.prototype = t.Event.prototype, i.CustomEvent = x
                    } else i.CustomEvent = t.CustomEvent;
                    return i
                }, void 0 !== (n = (function() {
                    return Mt(It, It.document)
                }).call(e, i, e, t)) && (t.exports = n), (function() {
                    SVG.Filter = SVG.invent({
                        create: "filter",
                        inherit: SVG.Parent,
                        extend: {
                            source: "SourceGraphic",
                            sourceAlpha: "SourceAlpha",
                            background: "BackgroundImage",
                            backgroundAlpha: "BackgroundAlpha",
                            fill: "FillPaint",
                            stroke: "StrokePaint",
                            autoSetIn: !0,
                            put: function(t, e) {
                                return this.add(t, e), !t.attr("in") && this.autoSetIn && t.attr("in", this.source), t.attr("result") || t.attr("result", t), t
                            },
                            blend: function(t, e, i) {
                                return this.put(new SVG.BlendEffect(t, e, i))
                            },
                            colorMatrix: function(t, e) {
                                return this.put(new SVG.ColorMatrixEffect(t, e))
                            },
                            convolveMatrix: function(t) {
                                return this.put(new SVG.ConvolveMatrixEffect(t))
                            },
                            componentTransfer: function(t) {
                                return this.put(new SVG.ComponentTransferEffect(t))
                            },
                            composite: function(t, e, i) {
                                return this.put(new SVG.CompositeEffect(t, e, i))
                            },
                            flood: function(t, e) {
                                return this.put(new SVG.FloodEffect(t, e))
                            },
                            offset: function(t, e) {
                                return this.put(new SVG.OffsetEffect(t, e))
                            },
                            image: function(t) {
                                return this.put(new SVG.ImageEffect(t))
                            },
                            merge: function() {
                                var t = [void 0];
                                for (var e in arguments) t.push(arguments[e]);
                                return this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect, t)))
                            },
                            gaussianBlur: function(t, e) {
                                return this.put(new SVG.GaussianBlurEffect(t, e))
                            },
                            morphology: function(t, e) {
                                return this.put(new SVG.MorphologyEffect(t, e))
                            },
                            diffuseLighting: function(t, e, i) {
                                return this.put(new SVG.DiffuseLightingEffect(t, e, i))
                            },
                            displacementMap: function(t, e, i, n, s) {
                                return this.put(new SVG.DisplacementMapEffect(t, e, i, n, s))
                            },
                            specularLighting: function(t, e, i, n) {
                                return this.put(new SVG.SpecularLightingEffect(t, e, i, n))
                            },
                            tile: function() {
                                return this.put(new SVG.TileEffect)
                            },
                            turbulence: function(t, e, i, n, s) {
                                return this.put(new SVG.TurbulenceEffect(t, e, i, n, s))
                            },
                            toString: function() {
                                return "url(#" + this.attr("id") + ")"
                            }
                        }
                    }), SVG.extend(SVG.Defs, {
                        filter: function(t) {
                            var e = this.put(new SVG.Filter);
                            return "function" == typeof t && t.call(e, e), e
                        }
                    }), SVG.extend(SVG.Container, {
                        filter: function(t) {
                            return this.defs().filter(t)
                        }
                    }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
                        filter: function(t) {
                            return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
                        },
                        unfilter: function(t) {
                            return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
                        }
                    }), SVG.Effect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Element,
                        extend: {
                            in: function(t) {
                                return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                            },
                            result: function(t) {
                                return null == t ? this.attr("result") : this.attr("result", t)
                            },
                            toString: function() {
                                return this.result()
                            }
                        }
                    }), SVG.ParentEffect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Parent,
                        extend: {
                            in: function(t) {
                                return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                            },
                            result: function(t) {
                                return null == t ? this.attr("result") : this.attr("result", t)
                            },
                            toString: function() {
                                return this.result()
                            }
                        }
                    });
                    var t = {
                        blend: function(t, e) {
                            return this.parent() && this.parent().blend(this, t, e)
                        },
                        colorMatrix: function(t, e) {
                            return this.parent() && this.parent().colorMatrix(t, e).in(this)
                        },
                        convolveMatrix: function(t) {
                            return this.parent() && this.parent().convolveMatrix(t).in(this)
                        },
                        componentTransfer: function(t) {
                            return this.parent() && this.parent().componentTransfer(t).in(this)
                        },
                        composite: function(t, e) {
                            return this.parent() && this.parent().composite(this, t, e)
                        },
                        flood: function(t, e) {
                            return this.parent() && this.parent().flood(t, e)
                        },
                        offset: function(t, e) {
                            return this.parent() && this.parent().offset(t, e).in(this)
                        },
                        image: function(t) {
                            return this.parent() && this.parent().image(t)
                        },
                        merge: function() {
                            return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
                        },
                        gaussianBlur: function(t, e) {
                            return this.parent() && this.parent().gaussianBlur(t, e).in(this)
                        },
                        morphology: function(t, e) {
                            return this.parent() && this.parent().morphology(t, e).in(this)
                        },
                        diffuseLighting: function(t, e, i) {
                            return this.parent() && this.parent().diffuseLighting(t, e, i).in(this)
                        },
                        displacementMap: function(t, e, i, n) {
                            return this.parent() && this.parent().displacementMap(this, t, e, i, n)
                        },
                        specularLighting: function(t, e, i, n) {
                            return this.parent() && this.parent().specularLighting(t, e, i, n).in(this)
                        },
                        tile: function() {
                            return this.parent() && this.parent().tile().in(this)
                        },
                        turbulence: function(t, e, i, n, s) {
                            return this.parent() && this.parent().turbulence(t, e, i, n, s).in(this)
                        }
                    };
                    SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({
                        create: function() {
                            this.constructor.call(this)
                        },
                        inherit: SVG.Element,
                        extend: {
                            in: function(t) {
                                this.attr("in", t)
                            }
                        }
                    });
                    var e = {
                            blend: function(t, e, i) {
                                this.attr({
                                    in: t,
                                    in2: e,
                                    mode: i || "normal"
                                })
                            },
                            colorMatrix: function(t, e) {
                                "matrix" == t && (e = s(e)), this.attr({
                                    type: t,
                                    values: void 0 === e ? null : e
                                })
                            },
                            convolveMatrix: function(t) {
                                t = s(t), this.attr({
                                    order: Math.sqrt(t.split(" ").length),
                                    kernelMatrix: t
                                })
                            },
                            composite: function(t, e, i) {
                                this.attr({
                                    in: t,
                                    in2: e,
                                    operator: i
                                })
                            },
                            flood: function(t, e) {
                                this.attr("flood-color", t), null != e && this.attr("flood-opacity", e)
                            },
                            offset: function(t, e) {
                                this.attr({
                                    dx: t,
                                    dy: e
                                })
                            },
                            image: function(t) {
                                this.attr("href", t, SVG.xlink)
                            },
                            displacementMap: function(t, e, i, n, s) {
                                this.attr({
                                    in: t,
                                    in2: e,
                                    scale: i,
                                    xChannelSelector: n,
                                    yChannelSelector: s
                                })
                            },
                            gaussianBlur: function(t, e) {
                                this.attr("stdDeviation", null != t || null != e ? r(Array.prototype.slice.call(arguments)) : "0 0")
                            },
                            morphology: function(t, e) {
                                this.attr({
                                    operator: t,
                                    radius: e
                                })
                            },
                            tile: function() {},
                            turbulence: function(t, e, i, n, s) {
                                this.attr({
                                    numOctaves: e,
                                    seed: i,
                                    stitchTiles: n,
                                    baseFrequency: t,
                                    type: s
                                })
                            }
                        },
                        i = {
                            merge: function() {
                                var t;
                                if (arguments[0] instanceof SVG.Set) {
                                    var e = this;
                                    arguments[0].each(function(t) {
                                        this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this))
                                    })
                                } else {
                                    t = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                                    for (var i = 0; i < t.length; i++) t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i]))
                                }
                            },
                            componentTransfer: function(t) {
                                if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach((function(t) {
                                        this[t] = new(SVG["Func" + t.toUpperCase()])("identity"), this.rgb.add(this[t]), this.node.appendChild(this[t].node)
                                    }).bind(this)), t)
                                    for (var e in t.rgb && (["r", "g", "b"].forEach((function(e) {
                                            this[e].attr(t.rgb)
                                        }).bind(this)), delete t.rgb), t) this[e].attr(t[e])
                            },
                            diffuseLighting: function(t, e, i) {
                                this.attr({
                                    surfaceScale: t,
                                    diffuseConstant: e,
                                    kernelUnitLength: i
                                })
                            },
                            specularLighting: function(t, e, i, n) {
                                this.attr({
                                    surfaceScale: t,
                                    diffuseConstant: e,
                                    specularExponent: i,
                                    kernelUnitLength: n
                                })
                            }
                        },
                        n = {
                            distantLight: function(t, e) {
                                this.attr({
                                    azimuth: t,
                                    elevation: e
                                })
                            },
                            pointLight: function(t, e, i) {
                                this.attr({
                                    x: t,
                                    y: e,
                                    z: i
                                })
                            },
                            spotLight: function(t, e, i, n, s, r) {
                                this.attr({
                                    x: t,
                                    y: e,
                                    z: i,
                                    pointsAtX: n,
                                    pointsAtY: s,
                                    pointsAtZ: r
                                })
                            },
                            mergeNode: function(t) {
                                this.attr("in", t)
                            }
                        };

                    function s(t) {
                        return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
                    }

                    function r(t) {
                        if (!Array.isArray(t)) return t;
                        for (var e = 0, i = t.length, n = []; e < i; e++) n.push(t[e]);
                        return n.join(" ")
                    }

                    function a() {
                        var t = function() {};
                        for (var e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
                            for (var i in arguments[e]) t(arguments[e][i], i, arguments[e])
                    } ["r", "g", "b", "a"].forEach(function(t) {
                        n["Func" + t.toUpperCase()] = function(t) {
                            switch (this.attr("type", t), t) {
                                case "table":
                                    this.attr("tableValues", arguments[1]);
                                    break;
                                case "linear":
                                    this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                                    break;
                                case "gamma":
                                    this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
                            }
                        }
                    }), a(e, function(t, e) {
                        var i = e.charAt(0).toUpperCase() + e.slice(1);
                        SVG[i + "Effect"] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                            },
                            inherit: SVG.Effect,
                            extend: {}
                        })
                    }), a(i, function(t, e) {
                        var i = e.charAt(0).toUpperCase() + e.slice(1);
                        SVG[i + "Effect"] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                            },
                            inherit: SVG.ParentEffect,
                            extend: {}
                        })
                    }), a(n, function(t, e) {
                        var i = e.charAt(0).toUpperCase() + e.slice(1);
                        SVG[i] = SVG.invent({
                            create: function() {
                                this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments)
                            },
                            inherit: SVG.ChildEffect,
                            extend: {}
                        })
                    }), SVG.extend(SVG.MergeEffect, {
                        in: function(t) {
                            return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this
                        }
                    }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
                        in2: function(t) {
                            return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t)
                        }
                    }), SVG.filter = {
                        sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
                    }
                }).call(void 0),
                function() {
                    function t(t, s, r, a, o, l, c) {
                        for (var h = t.slice(s, r || c), u = a.slice(o, l || c), d = 0, p = {
                                pos: [0, 0],
                                start: [0, 0]
                            }, f = {
                                pos: [0, 0],
                                start: [0, 0]
                            }; h[d] = e.call(p, h[d]), u[d] = e.call(f, u[d]), h[d][0] != u[d][0] || "M" == h[d][0] || "A" == h[d][0] && (h[d][4] != u[d][4] || h[d][5] != u[d][5]) ? (Array.prototype.splice.apply(h, [d, 1].concat(n.call(p, h[d]))), Array.prototype.splice.apply(u, [d, 1].concat(n.call(f, u[d])))) : (h[d] = i.call(p, h[d]), u[d] = i.call(f, u[d])), ++d != h.length || d != u.length;) d == h.length && h.push(["C", p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]), d == u.length && u.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]);
                        return {
                            start: h,
                            dest: u
                        }
                    }

                    function e(t) {
                        switch (t[0]) {
                            case "z":
                            case "Z":
                                t[0] = "L", t[1] = this.start[0], t[2] = this.start[1];
                                break;
                            case "H":
                                t[0] = "L", t[2] = this.pos[1];
                                break;
                            case "V":
                                t[0] = "L", t[2] = t[1], t[1] = this.pos[0];
                                break;
                            case "T":
                                t[0] = "Q", t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0];
                                break;
                            case "S":
                                t[0] = "C", t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0]
                        }
                        return t
                    }

                    function i(t) {
                        var e = t.length;
                        return this.pos = [t[e - 2], t[e - 1]], -1 != "SCQT".indexOf(t[0]) && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t
                    }

                    function n(t) {
                        var e = [t];
                        switch (t[0]) {
                            case "M":
                                return this.pos = this.start = [t[1], t[2]], e;
                            case "L":
                                t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1];
                                break;
                            case "Q":
                                t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3;
                                break;
                            case "A":
                                t = (e = function(t, e) {
                                    var i, n, s, r, a, o, l, c, h, u, d, p, f, g, m, b, y, v, x, _, w, C, k, S, A, O, E = Math.abs(e[1]),
                                        P = Math.abs(e[2]),
                                        T = e[3] % 360,
                                        D = e[4],
                                        I = e[5],
                                        M = e[6],
                                        L = e[7],
                                        R = new SVG.Point(t),
                                        j = new SVG.Point(M, L),
                                        F = [];
                                    if (0 === E || 0 === P || R.x === j.x && R.y === j.y) return [
                                        ["C", R.x, R.y, j.x, j.y, j.x, j.y]
                                    ];
                                    for ((n = (i = new SVG.Point((R.x - j.x) / 2, (R.y - j.y) / 2).transform((new SVG.Matrix).rotate(T))).x * i.x / (E * E) + i.y * i.y / (P * P)) > 1 && (E *= n = Math.sqrt(n), P *= n), s = (new SVG.Matrix).rotate(T).scale(1 / E, 1 / P).rotate(-T), R = R.transform(s), o = (r = [(j = j.transform(s)).x - R.x, j.y - R.y])[0] * r[0] + r[1] * r[1], a = Math.sqrt(o), r[0] /= a, r[1] /= a, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, D === I && (l *= -1), c = new SVG.Point((j.x + R.x) / 2 + l * -r[1], (j.y + R.y) / 2 + l * r[0]), h = new SVG.Point(R.x - c.x, R.y - c.y), u = new SVG.Point(j.x - c.x, j.y - c.y), d = Math.acos(h.x / Math.sqrt(h.x * h.x + h.y * h.y)), h.y < 0 && (d *= -1), p = Math.acos(u.x / Math.sqrt(u.x * u.x + u.y * u.y)), u.y < 0 && (p *= -1), I && d > p && (p += 2 * Math.PI), !I && d < p && (p -= 2 * Math.PI), b = [], y = d, f = (p - d) / (g = Math.ceil(2 * Math.abs(d - p) / Math.PI)), m = 4 * Math.tan(f / 4) / 3, w = 0; w <= g; w++) x = Math.cos(y), v = Math.sin(y), _ = new SVG.Point(c.x + x, c.y + v), b[w] = [new SVG.Point(_.x + m * v, _.y - m * x), _, new SVG.Point(_.x - m * v, _.y + m * x)], y += f;
                                    for (b[0][0] = b[0][1].clone(), b[b.length - 1][2] = b[b.length - 1][1].clone(), s = (new SVG.Matrix).rotate(T).scale(E, P).rotate(-T), w = 0, C = b.length; w < C; w++) b[w][0] = b[w][0].transform(s), b[w][1] = b[w][1].transform(s), b[w][2] = b[w][2].transform(s);
                                    for (w = 1, C = b.length; w < C; w++) k = (_ = b[w - 1][2]).x, S = _.y, A = (_ = b[w][0]).x, O = _.y, M = (_ = b[w][1]).x, F.push(["C", k, S, A, O, M, L = _.y]);
                                    return F
                                }(this.pos, t))[0]
                        }
                        return t[0] = "C", this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e
                    }

                    function s(t, e) {
                        if (!1 === e) return !1;
                        for (var i = e, n = t.length; i < n; ++i)
                            if ("M" == t[i][0]) return i;
                        return !1
                    }
                    SVG.extend(SVG.PathArray, {
                        morph: function(e) {
                            for (var i = this.value, n = this.parse(e), r = 0, a = 0, o = !1, l = !1; !1 !== r || !1 !== a;) {
                                var c;
                                o = s(i, !1 !== r && r + 1), l = s(n, !1 !== a && a + 1), !1 === r && (r = 0 == (c = new SVG.PathArray(h.start).bbox()).height || 0 == c.width ? i.push(i[0]) - 1 : i.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1), !1 === a && (a = 0 == (c = new SVG.PathArray(h.dest).bbox()).height || 0 == c.width ? n.push(n[0]) - 1 : n.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1);
                                var h = t(i, r, o, n, a, l);
                                i = i.slice(0, r).concat(h.start, !1 === o ? [] : i.slice(o)), n = n.slice(0, a).concat(h.dest, !1 === l ? [] : n.slice(l)), r = !1 !== o && r + h.start.length, a = !1 !== l && a + h.dest.length
                            }
                            return this.value = i, this.destination = new SVG.PathArray, this.destination.value = n, this
                        }
                    })
                }(), (function() {
                    function t(t) {
                        t.remember("_draggable", this), this.el = t
                    }
                    t.prototype.init = function(t, e) {
                        var i = this;
                        this.constraint = t, this.value = e, this.el.on("mousedown.drag", function(t) {
                            i.start(t)
                        }), this.el.on("touchstart.drag", function(t) {
                            i.start(t)
                        })
                    }, t.prototype.transformPoint = function(t, e) {
                        var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
                        return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m)
                    }, t.prototype.getBBox = function() {
                        var t = this.el.bbox();
                        return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t
                    }, t.prototype.start = function(t) {
                        if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
                            var e = this;
                            if (this.el.fire("beforedrag", {
                                    event: t,
                                    handler: this
                                }), !this.el.event().defaultPrevented) {
                                t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                                var i, n = this.getBBox();
                                if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                                    case "middle":
                                        i /= 2;
                                        break;
                                    case "start":
                                        i = 0
                                }
                                this.startPoints = {
                                    point: this.transformPoint(t, i),
                                    box: n,
                                    transform: this.el.transform()
                                }, SVG.on(window, "mousemove.drag", function(t) {
                                    e.drag(t)
                                }), SVG.on(window, "touchmove.drag", function(t) {
                                    e.drag(t)
                                }), SVG.on(window, "mouseup.drag", function(t) {
                                    e.end(t)
                                }), SVG.on(window, "touchend.drag", function(t) {
                                    e.end(t)
                                }), this.el.fire("dragstart", {
                                    event: t,
                                    p: this.startPoints.point,
                                    m: this.m,
                                    handler: this
                                })
                            }
                        }
                    }, t.prototype.drag = function(t) {
                        var e = this.getBBox(),
                            i = this.transformPoint(t),
                            n = this.startPoints.box.x + i.x - this.startPoints.point.x,
                            s = this.startPoints.box.y + i.y - this.startPoints.point.y,
                            r = this.constraint,
                            a = i.x - this.startPoints.point.x,
                            o = i.y - this.startPoints.point.y;
                        if (this.el.fire("dragmove", {
                                event: t,
                                p: i,
                                m: this.m,
                                handler: this
                            }), this.el.event().defaultPrevented) return i;
                        if ("function" == typeof r) {
                            var l = r.call(this.el, n, s, this.m);
                            "boolean" == typeof l && (l = {
                                x: l,
                                y: l
                            }), !0 === l.x ? this.el.x(n) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y)
                        } else "object" == typeof r && (null != r.minX && n < r.minX ? a = (n = r.minX) - this.startPoints.box.x : null != r.maxX && n > r.maxX - e.width && (a = (n = r.maxX - e.width) - this.startPoints.box.x), null != r.minY && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : null != r.maxY && s > r.maxY - e.height && (o = (s = r.maxY - e.height) - this.startPoints.box.y), null != r.snapToGrid && (n -= n % r.snapToGrid, s -= s % r.snapToGrid, a -= a % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                            x: a,
                            y: o
                        }, !0) : this.el.move(n, s));
                        return i
                    }, t.prototype.end = function(t) {
                        var e = this.drag(t);
                        this.el.fire("dragend", {
                            event: t,
                            p: e,
                            m: this.m,
                            handler: this
                        }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
                    }, SVG.extend(SVG.Element, {
                        draggable: function(e, i) {
                            "function" != typeof e && "object" != typeof e || (i = e, e = !0);
                            var n = this.remember("_draggable") || new t(this);
                            return (e = void 0 === e || e) ? n.init(i || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
                        }
                    })
                }).call(void 0),
                function() {
                    function t(t) {
                        this.el = t, t.remember("_selectHandler", this), this.pointSelection = {
                            isSelected: !1
                        }, this.rectSelection = {
                            isSelected: !1
                        }, this.pointsList = {
                            lt: [0, 0],
                            rt: ["width", 0],
                            rb: ["width", "height"],
                            lb: [0, "height"],
                            t: ["width", 0],
                            r: ["width", "height"],
                            b: ["width", "height"],
                            l: [0, "height"]
                        }, this.pointCoord = function(t, e, i) {
                            var n = "string" != typeof t ? t : e[t];
                            return i ? n / 2 : n
                        }, this.pointCoords = function(t, e) {
                            var i = this.pointsList[t];
                            return {
                                x: this.pointCoord(i[0], e, "t" === t || "b" === t),
                                y: this.pointCoord(i[1], e, "r" === t || "l" === t)
                            }
                        }
                    }
                    t.prototype.init = function(t, e) {
                        var i = this.el.bbox();
                        this.options = {};
                        var n = this.el.selectize.defaults.points;
                        for (var s in this.el.selectize.defaults) this.options[s] = this.el.selectize.defaults[s], void 0 !== e[s] && (this.options[s] = e[s]);
                        var r = ["points", "pointsExclude"];
                        for (var s in r) {
                            var a = this.options[r[s]];
                            "string" == typeof a ? a = a.length > 0 ? a.split(/\s*,\s*/i) : [] : "boolean" == typeof a && "points" === r[s] && (a = a ? n : []), this.options[r[s]] = a
                        }
                        this.options.points = [n, this.options.points].reduce(function(t, e) {
                            return t.filter(function(t) {
                                return e.indexOf(t) > -1
                            })
                        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t, e) {
                            return t.filter(function(t) {
                                return e.indexOf(t) < 0
                            })
                        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup()
                    }, t.prototype.selectPoints = function(t) {
                        return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
                    }, t.prototype.getPointArray = function() {
                        var t = this.el.bbox();
                        return this.el.array().valueOf().map(function(e) {
                            return [e[0] - t.x, e[1] - t.y]
                        })
                    }, t.prototype.drawPoints = function() {
                        for (var t = this, e = this.getPointArray(), i = 0, n = e.length; i < n; ++i) {
                            var s = function(e) {
                                    return function(i) {
                                        (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(), t.el.fire("point", {
                                            x: i.pageX || i.touches[0].pageX,
                                            y: i.pageY || i.touches[0].pageY,
                                            i: e,
                                            event: i
                                        })
                                    }
                                }(i),
                                r = this.drawPoint(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);
                            this.pointSelection.set.add(r)
                        }
                    }, t.prototype.drawPoint = function(t, e) {
                        var i = this.options.pointType;
                        switch (i) {
                            case "circle":
                                return this.drawCircle(t, e);
                            case "rect":
                                return this.drawRect(t, e);
                            default:
                                if ("function" == typeof i) return i.call(this, t, e);
                                throw new Error("Unknown " + i + " point type!")
                        }
                    }, t.prototype.drawCircle = function(t, e) {
                        return this.nested.circle(this.options.pointSize).center(t, e)
                    }, t.prototype.drawRect = function(t, e) {
                        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e)
                    }, t.prototype.updatePointSelection = function() {
                        var t = this.getPointArray();
                        this.pointSelection.set.each(function(e) {
                            this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1])
                        })
                    }, t.prototype.updateRectSelection = function() {
                        var t = this,
                            e = this.el.bbox();
                        if (this.rectSelection.set.get(0).attr({
                                width: e.width,
                                height: e.height
                            }), this.options.points.length && this.options.points.map(function(i, n) {
                                var s = t.pointCoords(i, e);
                                t.rectSelection.set.get(n + 1).center(s.x, s.y)
                            }), this.options.rotationPoint) {
                            var i = this.rectSelection.set.length();
                            this.rectSelection.set.get(i - 1).center(e.width / 2, 20)
                        }
                    }, t.prototype.selectRect = function(t) {
                        var e = this,
                            i = this.el.bbox();

                        function n(t) {
                            return function(i) {
                                (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation(), e.el.fire(t, {
                                    x: i.pageX || i.touches[0].pageX,
                                    y: i.pageY || i.touches[0].pageY,
                                    event: i
                                })
                            }
                        }
                        if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(t, s) {
                                var r = e.pointCoords(t, i),
                                    a = e.drawPoint(r.x, r.y).attr("class", e.options.classPoints + "_" + t).on("mousedown", n(t)).on("touchstart", n(t));
                                e.rectSelection.set.add(a)
                            }), this.rectSelection.set.each(function() {
                                this.addClass(e.options.classPoints)
                            })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                            var s = function(t) {
                                    (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation(), e.el.fire("rot", {
                                        x: t.pageX || t.touches[0].pageX,
                                        y: t.pageY || t.touches[0].pageY,
                                        event: t
                                    })
                                },
                                r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s).on("mousedown", s);
                            this.rectSelection.set.add(r)
                        }
                    }, t.prototype.handler = function() {
                        var t = this.el.bbox();
                        this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
                    }, t.prototype.observe = function() {
                        var t = this;
                        if (MutationObserver)
                            if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function() {
                                t.handler()
                            }), this.observerInst.observe(this.el.node, {
                                attributes: !0
                            });
                            else try {
                                this.observerInst.disconnect(), delete this.observerInst
                            } catch (t) {} else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
                                t.handler()
                            })
                    }, t.prototype.cleanup = function() {
                        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
                            this.remove()
                        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
                            this.remove()
                        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
                    }, SVG.extend(SVG.Element, {
                        selectize: function(e, i) {
                            return "object" == typeof e && (i = e, e = !0), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}), this
                        }
                    }), SVG.Element.prototype.selectize.defaults = {
                        points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
                        pointsExclude: [],
                        classRect: "svg_select_boundingRect",
                        classPoints: "svg_select_points",
                        pointSize: 7,
                        rotationPoint: !0,
                        deepSelect: !1,
                        pointType: "circle"
                    }
                }(),
                function() {
                    (function() {
                        function t(t) {
                            t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint()
                        }
                        t.prototype.transformPoint = function(t, e, i) {
                            return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m)
                        }, t.prototype._extractPosition = function(t) {
                            return {
                                x: null != t.clientX ? t.clientX : t.touches[0].clientX,
                                y: null != t.clientY ? t.clientY : t.touches[0].clientY
                            }
                        }, t.prototype.init = function(t) {
                            var e = this;
                            if (this.stop(), "stop" !== t) {
                                for (var i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]);
                                this.el.on("lt.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("rt.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("rb.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("lb.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("t.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("r.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("b.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("l.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("rot.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.el.on("point.resize", function(t) {
                                    e.resize(t || window.event)
                                }), this.update()
                            }
                        }, t.prototype.stop = function() {
                            return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
                        }, t.prototype.resize = function(t) {
                            var e = this;
                            this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                                x: window.pageXOffset,
                                y: window.pageYOffset
                            };
                            var i = this._extractPosition(t.detail.event);
                            if (this.parameters = {
                                    type: this.el.type,
                                    p: this.transformPoint(i.x, i.y),
                                    x: t.detail.x,
                                    y: t.detail.y,
                                    box: this.el.bbox(),
                                    rotation: this.el.transform().rotation
                                }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
                                var n = this.el.array().valueOf();
                                this.parameters.i = t.detail.i, this.parameters.pointCoords = [n[t.detail.i][0], n[t.detail.i][1]]
                            }
                            switch (t.type) {
                                case "lt":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e);
                                        if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                                            i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1])
                                        }
                                    };
                                    break;
                                case "rt":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 2);
                                        if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                                            i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1])
                                        }
                                    };
                                    break;
                                case "rb":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 0);
                                        if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                                            i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1])
                                        }
                                    };
                                    break;
                                case "lb":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 1);
                                        if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                                            if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                                            i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1])
                                        }
                                    };
                                    break;
                                case "t":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 2);
                                        if (this.parameters.box.height - i[1] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1])
                                        }
                                    };
                                    break;
                                case "r":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 0);
                                        if (this.parameters.box.width + i[0] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0])
                                        }
                                    };
                                    break;
                                case "b":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 0);
                                        if (this.parameters.box.height + i[1] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1])
                                        }
                                    };
                                    break;
                                case "l":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, 1);
                                        if (this.parameters.box.width - i[0] > 0) {
                                            if ("text" === this.parameters.type) return;
                                            this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0])
                                        }
                                    };
                                    break;
                                case "rot":
                                    this.calc = function(t, e) {
                                        var i = t + this.parameters.p.x,
                                            n = e + this.parameters.p.y,
                                            s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                                            r = Math.atan2(n - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2),
                                            a = this.parameters.rotation + 180 * (r - s) / Math.PI + this.options.snapToAngle / 2;
                                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(a - a % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                                    };
                                    break;
                                case "point":
                                    this.calc = function(t, e) {
                                        var i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                                            n = this.el.array().valueOf();
                                        n[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], n[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(n)
                                    }
                            }
                            this.el.fire("resizestart", {
                                dx: this.parameters.x,
                                dy: this.parameters.y,
                                event: t
                            }), SVG.on(window, "touchmove.resize", function(t) {
                                e.update(t || window.event)
                            }), SVG.on(window, "touchend.resize", function() {
                                e.done()
                            }), SVG.on(window, "mousemove.resize", function(t) {
                                e.update(t || window.event)
                            }), SVG.on(window, "mouseup.resize", function() {
                                e.done()
                            })
                        }, t.prototype.update = function(t) {
                            if (t) {
                                var e = this._extractPosition(t),
                                    i = this.transformPoint(e.x, e.y),
                                    n = i.x - this.parameters.p.x,
                                    s = i.y - this.parameters.p.y;
                                this.lastUpdateCall = [n, s], this.calc(n, s), this.el.fire("resizing", {
                                    dx: n,
                                    dy: s,
                                    event: t
                                })
                            } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
                        }, t.prototype.done = function() {
                            this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
                        }, t.prototype.snapToGrid = function(t, e, i, n) {
                            var s;
                            return s = void 0 !== n ? [(i + t) % this.options.snapToGrid, (n + e) % this.options.snapToGrid] : [(this.parameters.box.x + t + (1 & (i = null == i ? 3 : i) ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid], t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, n)
                        }, t.prototype.constraintToBox = function(t, e, i, n) {
                            var s, r, a = this.options.constraint || {};
                            return void 0 !== n ? (s = i, r = n) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== a.minX && s + t < a.minX && (t = a.minX - s), void 0 !== a.maxX && s + t > a.maxX && (t = a.maxX - s), void 0 !== a.minY && r + e < a.minY && (e = a.minY - r), void 0 !== a.maxY && r + e > a.maxY && (e = a.maxY - r), [t, e]
                        }, t.prototype.checkAspectRatio = function(t, e) {
                            if (!this.options.saveAspectRatio) return t;
                            var i = t.slice(),
                                n = this.parameters.box.width / this.parameters.box.height,
                                s = this.parameters.box.width + t[0],
                                r = this.parameters.box.height - t[1],
                                a = s / r;
                            return a < n ? (i[1] = s / n - this.parameters.box.height, e && (i[1] = -i[1])) : a > n && (i[0] = this.parameters.box.width - r * n, e && (i[0] = -i[0])), i
                        }, SVG.extend(SVG.Element, {
                            resize: function(e) {
                                return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this
                            }
                        }), SVG.Element.prototype.resize.defaults = {
                            snapToAngle: .1,
                            snapToGrid: 1,
                            constraint: {},
                            saveAspectRatio: !1
                        }
                    }).call(this)
                }(),
                function(t, e) {
                    void 0 === e && (e = {});
                    var i = e.insertAt;
                    if ("undefined" != typeof document) {
                        var n = document.head || document.getElementsByTagName("head")[0],
                            s = document.createElement("style");
                        s.type = "text/css", "top" === i && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t))
                    }
                }('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  min-width: 12px;\n  min-height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}'),
                function() {
                    function t(t) {
                        var e = t.__resizeTriggers__,
                            i = e.firstElementChild,
                            n = e.lastElementChild,
                            s = i ? i.firstElementChild : null;
                        n && (n.scrollLeft = n.scrollWidth, n.scrollTop = n.scrollHeight), s && (s.style.width = i.offsetWidth + 1 + "px", s.style.height = i.offsetHeight + 1 + "px"), i && (i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight)
                    }

                    function e(e) {
                        var i = this;
                        t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = s(function() {
                            (function(t) {
                                return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height
                            })(i) && (i.__resizeLast__.width = i.offsetWidth, i.__resizeLast__.height = i.offsetHeight, i.__resizeListeners__.forEach(function(t) {
                                t.call(e)
                            }))
                        })
                    }
                    var i, n, s = (i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(t) {
                            return window.setTimeout(t, 20)
                        }, function(t) {
                            return i(t)
                        }),
                        r = (n = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function(t) {
                            return n(t)
                        }),
                        a = !1,
                        o = "animationstart",
                        l = "Webkit Moz O ms".split(" "),
                        c = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),
                        h = document.createElement("fakeelement");
                    if (void 0 !== h.style.animationName && (a = !0), !1 === a)
                        for (var u = 0; u < l.length; u++)
                            if (void 0 !== h.style[l[u] + "AnimationName"]) {
                                o = c[u];
                                break
                            } window.addResizeListener = function(i, n) {
                        i.__resizeTriggers__ || ("static" == getComputedStyle(i).position && (i.style.position = "relative"), i.__resizeLast__ = {}, i.__resizeListeners__ = [], (i.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", i.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', i.appendChild(i.__resizeTriggers__), t(i), i.addEventListener("scroll", e, !0), o && i.__resizeTriggers__.addEventListener(o, function(e) {
                            "resizeanim" == e.animationName && t(i)
                        })), i.__resizeListeners__.push(n)
                    }, window.removeResizeListener = function(t, i) {
                        t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i), 1), t.__resizeListeners__.length || (t.removeEventListener("scroll", e), t.__resizeTriggers__.parentNode && (t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__))))
                    }
                }(), void 0 === window.Apex && (window.Apex = {});
            var Nt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "initModules",
                        value: function() {
                            this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], this.ctx.animations = new v(this.ctx), this.ctx.axes = new et(this.ctx), this.ctx.core = new jt(this.ctx.el, this.ctx), this.ctx.config = new B({}), this.ctx.data = new X(this.ctx), this.ctx.grid = new Z(this.ctx), this.ctx.graphics = new _(this.ctx), this.ctx.coreUtils = new k(this.ctx), this.ctx.crosshairs = new it(this.ctx), this.ctx.events = new J(this.ctx), this.ctx.exports = new G(this.ctx), this.ctx.localization = new tt(this.ctx), this.ctx.options = new E, this.ctx.responsive = new nt(this.ctx), this.ctx.series = new R(this.ctx), this.ctx.theme = new st(this.ctx), this.ctx.formatters = new W(this.ctx), this.ctx.titleSubtitle = new rt(this.ctx), this.ctx.legend = new dt(this.ctx), this.ctx.toolbar = new pt(this.ctx), this.ctx.dimensions = new ht(this.ctx), this.ctx.updateHelpers = new Ft(this.ctx), this.ctx.zoomPanSelection = new ft(this.ctx), this.ctx.w.globals.tooltip = new _t(this.ctx)
                        }
                    }]), t
                }(),
                zt = function() {
                    function t(e) {
                        r(this, t), this.ctx = e, this.w = e.w
                    }
                    return o(t, [{
                        key: "clear",
                        value: function(t) {
                            var e = t.isUpdating;
                            this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
                                isUpdating: e
                            })
                        }
                    }, {
                        key: "killSVG",
                        value: function(t) {
                            t.each(function(t, e) {
                                this.removeClass("*"), this.off(), this.stop()
                            }, !0), t.ungroup(), t.clear()
                        }
                    }, {
                        key: "clearDomElements",
                        value: function(t) {
                            var e = this,
                                i = this.w.globals.dom.Paper.node;
                            i.parentNode && i.parentNode.parentNode && !t.isUpdating && (i.parentNode.parentNode.style.minHeight = "unset");
                            var n = this.w.globals.dom.baseEl;
                            n && this.ctx.eventList.forEach(function(t) {
                                n.removeEventListener(t, e.ctx.events.documentEvent)
                            });
                            var s = this.w.globals.dom;
                            if (null !== this.ctx.el)
                                for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
                            this.killSVG(s.Paper), s.Paper.remove(), s.elWrap = null, s.elGraphical = null, s.elAnnotations = null, s.elLegendWrap = null, s.baseEl = null, s.elGridRect = null, s.elGridRectMask = null, s.elGridRectMarkerMask = null, s.elDefs = null
                        }
                    }]), t
                }(),
                Vt = function() {
                    function t(e, i) {
                        r(this, t), this.opts = i, this.ctx = this, this.w = new U(i).init(), this.el = e, this.w.globals.cuid = y.randomId(), this.w.globals.chartID = this.w.config.chart.id ? y.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Nt(this).initModules(), this.create = y.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this)
                    }
                    return o(t, [{
                        key: "render",
                        value: function() {
                            var t = this;
                            return new Promise(function(e, i) {
                                if (null !== t.el) {
                                    void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
                                        id: t.w.globals.chartID,
                                        group: t.w.config.chart.group,
                                        chart: t
                                    }), t.setLocale(t.w.config.chart.defaultLocale);
                                    var n = t.w.config.chart.events.beforeMount;
                                    "function" == typeof n && n(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t.parentResizeHandler);
                                    var s = t.create(t.w.config.series, {});
                                    if (!s) return e(t);
                                    t.mount(s).then(function() {
                                        "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(s)
                                    }).catch(function(t) {
                                        i(t)
                                    })
                                } else i(new Error("Element not found"))
                            })
                        }
                    }, {
                        key: "create",
                        value: function(t, e) {
                            var i = this.w;
                            new Nt(this).initModules();
                            var n = this.w.globals;
                            if (n.noData = !1, n.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric && new V(i.config).convertCatToNumericXaxis(i.config, this.ctx), null === this.el) return n.animationEnded = !0, null;
                            if (this.core.setupElements(), "treemap" === i.config.chart.type && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), 0 === n.svgWidth) return n.animationEnded = !0, null;
                            var s = k.checkComboSeries(t);
                            n.comboCharts = s.comboCharts, n.comboBarCount = s.comboBarCount;
                            var r = t.every(function(t) {
                                return t.data && 0 === t.data.length
                            });
                            (0 === t.length || r) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new D(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), n.noData && n.collapsedSeries.length !== n.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), n.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords();
                            var a = this.core.xySettings();
                            this.grid.createGridMask();
                            var o = this.core.plotChartType(t, a),
                                l = new M(this);
                            return l.bringForward(), i.config.dataLabels.background.enabled && l.dataLabelsBackground(), this.core.shiftGraphPosition(), {
                                elGraph: o,
                                xyRatios: a,
                                elInner: i.globals.dom.elGraphical,
                                dimensions: {
                                    plot: {
                                        left: i.globals.translateX,
                                        top: i.globals.translateY,
                                        width: i.globals.gridWidth,
                                        height: i.globals.gridHeight
                                    }
                                }
                            }
                        }
                    }, {
                        key: "mount",
                        value: function() {
                            var t = this,
                                e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                i = this,
                                n = i.w;
                            return new Promise(function(s, r) {
                                if (null === i.el) return r(new Error("Not enough data to display or target element not found"));
                                (null === e || n.globals.allSeriesCollapsed) && i.series.handleNoData(), "treemap" !== n.config.chart.type && i.axes.drawAxis(n.config.chart.type, e.xyRatios), i.grid = new Z(i);
                                var a = i.grid.drawGrid();
                                i.annotations = new P(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === n.config.grid.position && a && n.globals.dom.elGraphical.add(a.el);
                                var o = new q(t.ctx),
                                    l = new K(t.ctx);
                                if (null !== a && (o.xAxisLabelCorrections(a.xAxisTickWidth), l.setYAxisTextAlignments(), n.config.yaxis.map(function(t, e) {
                                        -1 === n.globals.ignoreYAxisIndexes.indexOf(e) && l.yAxisTitleRotate(e, t.opposite)
                                    })), "back" === n.config.annotations.position && (n.globals.dom.Paper.add(n.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), Array.isArray(e.elGraph))
                                    for (var c = 0; c < e.elGraph.length; c++) n.globals.dom.elGraphical.add(e.elGraph[c]);
                                else n.globals.dom.elGraphical.add(e.elGraph);
                                if ("front" === n.config.grid.position && a && n.globals.dom.elGraphical.add(a.el), "front" === n.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === n.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "front" === n.config.annotations.position && (n.globals.dom.Paper.add(n.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), !n.globals.noData) {
                                    if (n.config.tooltip.enabled && !n.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), n.globals.axisCharts && (n.globals.isXNumeric || n.config.xaxis.convertedCatToNumeric || n.globals.isTimelineBar))(n.config.chart.zoom.enabled || n.config.chart.selection && n.config.chart.selection.enabled || n.config.chart.pan && n.config.chart.pan.enabled) && i.zoomPanSelection.init({
                                        xyRatios: e.xyRatios
                                    });
                                    else {
                                        var h = n.config.chart.toolbar.tools;
                                        ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t) {
                                            h[t] = !1
                                        })
                                    }
                                    n.config.chart.toolbar.show && !n.globals.allSeriesCollapsed && i.toolbar.createToolbar()
                                }
                                n.globals.memory.methodsToExec.length > 0 && n.globals.memory.methodsToExec.forEach(function(t) {
                                    t.method(t.params, !1, t.context)
                                }), n.globals.axisCharts || n.globals.noData || i.core.resizeNonAxisCharts(), s(i)
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            window.removeEventListener("resize", this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this.parentResizeHandler);
                            var t = this.w.config.chart.id;
                            t && Apex._chartInstances.forEach(function(e, i) {
                                e.id === y.escapeString(t) && Apex._chartInstances.splice(i, 1)
                            }), new zt(this.ctx).clear({
                                isUpdating: !1
                            })
                        }
                    }, {
                        key: "updateOptions",
                        value: function(t) {
                            var e = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                a = this.w;
                            return a.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function(t, i) {
                                return e.updateHelpers._extendSeries(t, i)
                            })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), a.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, n, s, r)
                        }
                    }, {
                        key: "updateSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                            return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i)
                        }
                    }, {
                        key: "appendSeries",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                n = this.w.config.series.slice();
                            return n.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(n, e, i)
                        }
                    }, {
                        key: "appendData",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = this;
                            i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
                            for (var n = i.w.config.series.slice(), s = 0; s < n.length; s++)
                                if (null != t[s])
                                    for (var r = 0; r < t[s].data.length; r++) n[s].data.push(t[s].data[r]);
                            return i.w.config.series = n, e && (i.w.globals.initialSeries = y.clone(i.w.config.series)), this.update()
                        }
                    }, {
                        key: "update",
                        value: function(t) {
                            var e = this;
                            return new Promise(function(i, n) {
                                new zt(e.ctx).clear({
                                    isUpdating: !0
                                });
                                var s = e.create(e.w.config.series, t);
                                if (!s) return i(e);
                                e.mount(s).then(function() {
                                    "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, i(e)
                                }).catch(function(t) {
                                    n(t)
                                })
                            })
                        }
                    }, {
                        key: "getSyncedCharts",
                        value: function() {
                            var t = this.getGroupedCharts(),
                                e = [this];
                            return t.length && (e = [], t.forEach(function(t) {
                                e.push(t)
                            })), e
                        }
                    }, {
                        key: "getGroupedCharts",
                        value: function() {
                            var t = this;
                            return Apex._chartInstances.filter(function(t) {
                                if (t.group) return !0
                            }).map(function(e) {
                                return t.w.config.chart.group === e.group ? e.chart : t
                            })
                        }
                    }, {
                        key: "toggleSeries",
                        value: function(t) {
                            return this.series.toggleSeries(t)
                        }
                    }, {
                        key: "showSeries",
                        value: function(t) {
                            this.series.showSeries(t)
                        }
                    }, {
                        key: "hideSeries",
                        value: function(t) {
                            this.series.hideSeries(t)
                        }
                    }, {
                        key: "resetSeries",
                        value: function() {
                            var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                            this.series.resetSeries(t, e)
                        }
                    }, {
                        key: "addEventListener",
                        value: function(t, e) {
                            this.events.addEventListener(t, e)
                        }
                    }, {
                        key: "removeEventListener",
                        value: function(t, e) {
                            this.events.removeEventListener(t, e)
                        }
                    }, {
                        key: "addXaxisAnnotation",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                n = this;
                            i && (n = i), n.annotations.addXaxisAnnotationExternal(t, e, n)
                        }
                    }, {
                        key: "addYaxisAnnotation",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                n = this;
                            i && (n = i), n.annotations.addYaxisAnnotationExternal(t, e, n)
                        }
                    }, {
                        key: "addPointAnnotation",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                n = this;
                            i && (n = i), n.annotations.addPointAnnotationExternal(t, e, n)
                        }
                    }, {
                        key: "clearAnnotations",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
                                e = this;
                            t && (e = t), e.annotations.clearAnnotations(e)
                        }
                    }, {
                        key: "removeAnnotation",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
                                i = this;
                            e && (i = e), i.annotations.removeAnnotation(i, t)
                        }
                    }, {
                        key: "getChartArea",
                        value: function() {
                            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
                        }
                    }, {
                        key: "getSeriesTotalXRange",
                        value: function(t, e) {
                            return this.coreUtils.getSeriesTotalsXRange(t, e)
                        }
                    }, {
                        key: "getHighestValueInSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                e = new Q(this.ctx);
                            return e.getMinYMaxY(t).highestY
                        }
                    }, {
                        key: "getLowestValueInSeries",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                e = new Q(this.ctx);
                            return e.getMinYMaxY(t).lowestY
                        }
                    }, {
                        key: "getSeriesTotal",
                        value: function() {
                            return this.w.globals.seriesTotals
                        }
                    }, {
                        key: "toggleDataPointSelection",
                        value: function(t, e) {
                            return this.updateHelpers.toggleDataPointSelection(t, e)
                        }
                    }, {
                        key: "zoomX",
                        value: function(t, e) {
                            this.ctx.toolbar.zoomUpdateOptions(t, e)
                        }
                    }, {
                        key: "setLocale",
                        value: function(t) {
                            this.localization.setCurrentLocaleValues(t)
                        }
                    }, {
                        key: "dataURI",
                        value: function() {
                            return new G(this.ctx).dataURI()
                        }
                    }, {
                        key: "paper",
                        value: function() {
                            return this.w.globals.dom.Paper
                        }
                    }, {
                        key: "_parentResizeCallback",
                        value: function() {
                            this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
                        }
                    }, {
                        key: "_windowResize",
                        value: function() {
                            var t = this;
                            clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
                                t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update()
                            }, 150)
                        }
                    }, {
                        key: "_windowResizeHandler",
                        value: function() {
                            var t = this.w.config.chart.redrawOnWindowResize;
                            "function" == typeof t && (t = t()), t && this._windowResize()
                        }
                    }], [{
                        key: "getChartByID",
                        value: function(t) {
                            var e = y.escapeString(t),
                                i = Apex._chartInstances.filter(function(t) {
                                    return t.id === e
                                })[0];
                            return i && i.chart
                        }
                    }, {
                        key: "initOnLoad",
                        value: function() {
                            for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++) new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render()
                        }
                    }, {
                        key: "exec",
                        value: function(t, e) {
                            var i = this.getChartByID(t);
                            if (i) {
                                i.w.globals.isExecCalled = !0;
                                var n = null;
                                if (-1 !== i.publicMethods.indexOf(e)) {
                                    for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), a = 2; a < s; a++) r[a - 2] = arguments[a];
                                    n = i[e].apply(i, r)
                                }
                                return n
                            }
                        }
                    }, {
                        key: "merge",
                        value: function(t, e) {
                            return y.extend(t, e)
                        }
                    }]), t
                }();
            t.exports = Vt
        },
        "v/4h": function(t, e, i) {
            "use strict";
            i.d(e, "b", function() {
                return n.a
            }), i.d(e, "a", function() {
                return s
            });
            var n = i("UtzL"),
                s = function(t) {
                    return t.YELLOW = "#ffc260", t.BLUE = "#536DFE", t.LIGHT_BLUE = "#F8F9FF", t.PINK = "#ff4081", t.GREEN = "#3CD4A0", t.VIOLET = "#9013FE", t
                }({})
        },
        v1EJ: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("SIQg");

            function s(t, e) {
                return new n.a(i => {
                    let n = 0;
                    return e.schedule(function() {
                        n === t.length ? i.complete() : (i.next(t[n++]), i.closed || this.schedule())
                    })
                })
            }
        },
        vRMS: function(t, e, i) {
            "use strict";

            function n(t, e) {
                if (t) {
                    const i = t.indexOf(e);
                    0 <= i && t.splice(i, 1)
                }
            }
            i.d(e, "a", function() {
                return n
            })
        },
        vauT: function(t, e, i) {
            "use strict";

            function n() {
                var t = document.querySelectorAll("input, textarea, select");
                return Array.prototype.slice.call(t).map(function(t) {
                    var e = t.tagName.toLowerCase(),
                        i = t.type,
                        n = t.id && "string" == typeof t.id ? t.id : null,
                        s = t.name && "string" == typeof t.name ? t.name : null,
                        r = t.value && "string" == typeof t.value ? t.value : null,
                        a = t.childNodes,
                        o = Boolean(t.selected),
                        l = {
                            tag: e,
                            type: null,
                            id: n,
                            name: s,
                            value: "",
                            checked: !1,
                            options: []
                        };
                    if ("input" === e || "textarea" === e) {
                        if (l.type = i, "input" !== e) return l.value = r, l;
                        switch (i) {
                            case "checkbox":
                            case "radio":
                                return l.checked = o, l.value = r, l;
                            case "image":
                            case "button":
                            case "submit":
                            case "reset":
                            default:
                                return l
                        }
                    } else if ("select" === e) {
                        var c = Array.prototype.slice.call(a).map(function(t, e) {
                            return {
                                value: t.value,
                                selected: Boolean(t.selected)
                            }
                        });
                        return l.options = c, l
                    }
                    return l
                })
            }

            function s(t) {
                var e = document.querySelectorAll("input, textarea");
                t.forEach(function(t, i) {
                    if ("input" === t.tag || "textarea" === t.tag)
                        if ("input" !== t.tag || "checkbox" !== t.type && "radio" !== t.type)("input" !== t.tagName.toLowerCase() || "image" !== t.type && "button" !== t.type && "submit" !== t.type && "reset" !== t.type) && (null === t.id && null === t.name ? !t.value.length || !e[i] || e[i].tagName.toLowerCase() !== t.tag || "textarea" !== t.tag && e[i].getAttribute("type") !== t.type || "string" == typeof e[i].id && e[i].id.length || "string" == typeof e[i].getAttribute("name") && e[i].getAttribute("name").length || (e[i].value = t.value, e[i].dispatchEvent(new CustomEvent("input", {
                            detail: e[i].value
                        }))) : (n = "input" + (null !== t.id ? "#" + t.id : "") + ("input" === t.tag ? '[type="' + t.type + '"]' : "") + (null !== t.name ? '[name="' + t.name + '"]' : ""), (s = document.body.querySelector(n)) && t.value.length && (s.value = t.value, s.dispatchEvent(new CustomEvent("input", {
                            detail: s.value
                        })))));
                        else {
                            var n = "input" + (null !== t.id ? "#" + t.id : "") + '[type="' + t.type + '"]' + (null !== t.name ? '[name="' + t.name + '"]' : "") + '[value="' + t.value + '"]';
                            (s = document.body.querySelector(n)) && Boolean(t.checked) && (s.checked = "checked", s.dispatchEvent(new CustomEvent("input", {
                                detail: s.checked
                            })))
                        }
                    else if ("select" === t.tag) {
                        var s, r = null;
                        null === t.id && null === t.name ? !e[i] || e[i].tagName.toLowerCase() !== t.tag || "string" == typeof e[i].id && e[i].id.length || "string" == typeof e[i].getAttribute("name") && e[i].getAttribute("name").length || (r = e[i]) : (n = "select" + (null !== t.id ? "#" + t.id : "") + (null !== t.name ? '[name="' + t.name + '"]' : ""), (s = document.body.querySelector(n)) && (r = s)), r && t.options.forEach(function(t, e) {
                            var i = r.querySelector('option[value="' + t.value + '"]');
                            i || !r.childNodes[e] || "string" == typeof r.childNodes[e].value && r.childNodes[e].value.length || (i = r.childNodes[e]), i && t.selected && (i.selected = "selected", i.dispatchEvent(new CustomEvent("input", {
                                detail: i.selected
                            })))
                        })
                    }
                })
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.__getInputValues = n, e.__setInputValues = s, e.__createInputTransfer = function() {
                var t = n();
                return function() {
                    return s(t)
                }
            }
        },
        vfWG: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return r
            });
            var n = i("v1EJ"),
                s = i("g/MW");

            function r(t, e) {
                return e ? Object(n.a)(t, e) : Object(s.b)(t)
            }
        },
        vxfF: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return x
            }), i.d(e, "b", function() {
                return w
            }), i.d(e, "c", function() {
                return v
            }), i.d(e, "d", function() {
                return C
            }), i.d(e, "e", function() {
                return _
            });
            var n = i("8LU1"),
                s = i("fXoL"),
                r = i("oXA7"),
                a = i("4krO"),
                o = i("SIQg"),
                l = i("KOvq"),
                c = i("Tk8M"),
                h = i("jqqC");
            const u = {
                schedule(t) {
                    let e = requestAnimationFrame,
                        i = cancelAnimationFrame;
                    const {
                        delegate: n
                    } = u;
                    n && (e = n.requestAnimationFrame, i = n.cancelAnimationFrame);
                    const s = e(e => {
                        i = void 0, t(e)
                    });
                    return new h.b(() => null == i ? void 0 : i(s))
                },
                requestAnimationFrame(...t) {
                    const {
                        delegate: e
                    } = u;
                    return ((null == e ? void 0 : e.requestAnimationFrame) || requestAnimationFrame)(...t)
                },
                cancelAnimationFrame(...t) {
                    const {
                        delegate: e
                    } = u;
                    return ((null == e ? void 0 : e.cancelAnimationFrame) || cancelAnimationFrame)(...t)
                },
                delegate: void 0
            };
            var d = i("3x7h");
            new class extends d.a {
                flush(t) {
                    this._active = !0, this._scheduled = void 0;
                    const {
                        actions: e
                    } = this;
                    let i, n = -1;
                    t = t || e.shift();
                    const s = e.length;
                    do {
                        if (i = t.execute(t.state, t.delay)) break
                    } while (++n < s && (t = e.shift()));
                    if (this._active = !1, i) {
                        for (; ++n < s && (t = e.shift());) t.unsubscribe();
                        throw i
                    }
                }
            }(class extends c.a {
                constructor(t, e) {
                    super(t, e), this.scheduler = t, this.work = e
                }
                requestAsyncId(t, e, i = 0) {
                    return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = u.requestAnimationFrame(() => t.flush(void 0))))
                }
                recycleAsyncId(t, e, i = 0) {
                    if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i);
                    0 === t.actions.length && (u.cancelAnimationFrame(e), t._scheduled = void 0)
                }
            }), i("2nZi");
            var p = (i("BBcS"), i("XJvv"), i("8iEs")),
                f = i("dLTe"),
                g = i("bk9D");
            i("zzs5"), i("EPzc"), i("xt23"), i("1q39"), i("ffME");
            var m = i("nLfN"),
                b = i("ofXK"),
                y = i("cH1L");
            i("0EQZ");
            let v = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._ngZone = t, this._platform = e, this._scrolled = new r.a, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = i
                        }
                        register(t) {
                            this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t)))
                        }
                        deregister(t) {
                            const e = this.scrollContainers.get(t);
                            e && (e.unsubscribe(), this.scrollContainers.delete(t))
                        }
                        scrolled(t = 20) {
                            return this._platform.isBrowser ? new o.a(e => {
                                this._globalSubscription || this._addGlobalListener();
                                const i = t > 0 ? this._scrolled.pipe(Object(p.a)(t)).subscribe(e) : this._scrolled.subscribe(e);
                                return this._scrolledCount++, () => {
                                    i.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener()
                                }
                            }) : Object(a.a)()
                        }
                        ngOnDestroy() {
                            this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete()
                        }
                        ancestorScrolled(t, e) {
                            const i = this.getAncestorScrollContainers(t);
                            return this.scrolled(e).pipe(Object(f.a)(t => !t || i.indexOf(t) > -1))
                        }
                        getAncestorScrollContainers(t) {
                            const e = [];
                            return this.scrollContainers.forEach((i, n) => {
                                this._scrollableContainsElement(n, t) && e.push(n)
                            }), e
                        }
                        _getWindow() {
                            return this._document.defaultView || window
                        }
                        _scrollableContainsElement(t, e) {
                            let i = Object(n.e)(e),
                                s = t.getElementRef().nativeElement;
                            do {
                                if (i == s) return !0
                            } while (i = i.parentElement);
                            return !1
                        }
                        _addGlobalListener() {
                            this._globalSubscription = this._ngZone.runOutsideAngular(() => {
                                const t = this._getWindow();
                                return Object(l.a)(t.document, "scroll").subscribe(() => this._scrolled.next())
                            })
                        }
                        _removeGlobalListener() {
                            this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(s.B), s.Zb(m.a), s.Zb(b.d, 8))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(s.B), Object(s.Zb)(m.a), Object(s.Zb)(b.d, 8))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                x = (() => {
                    class t {
                        constructor(t, e, i, n) {
                            this.elementRef = t, this.scrollDispatcher = e, this.ngZone = i, this.dir = n, this._destroyed = new r.a, this._elementScrolled = new o.a(t => this.ngZone.runOutsideAngular(() => Object(l.a)(this.elementRef.nativeElement, "scroll").pipe(Object(g.a)(this._destroyed)).subscribe(t)))
                        }
                        ngOnInit() {
                            this.scrollDispatcher.register(this)
                        }
                        ngOnDestroy() {
                            this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete()
                        }
                        elementScrolled() {
                            return this._elementScrolled
                        }
                        getElementRef() {
                            return this.elementRef
                        }
                        scrollTo(t) {
                            const e = this.elementRef.nativeElement,
                                i = this.dir && "rtl" == this.dir.value;
                            null == t.left && (t.left = i ? t.end : t.start), null == t.right && (t.right = i ? t.start : t.end), null != t.bottom && (t.top = e.scrollHeight - e.clientHeight - t.bottom), i && 0 != Object(m.d)() ? (null != t.left && (t.right = e.scrollWidth - e.clientWidth - t.left), 2 == Object(m.d)() ? t.left = t.right : 1 == Object(m.d)() && (t.left = t.right ? -t.right : t.right)) : null != t.right && (t.left = e.scrollWidth - e.clientWidth - t.right), this._applyScrollToOptions(t)
                        }
                        _applyScrollToOptions(t) {
                            const e = this.elementRef.nativeElement;
                            Object(m.g)() ? e.scrollTo(t) : (null != t.top && (e.scrollTop = t.top), null != t.left && (e.scrollLeft = t.left))
                        }
                        measureScrollOffset(t) {
                            const e = this.elementRef.nativeElement;
                            if ("top" == t) return e.scrollTop;
                            if ("bottom" == t) return e.scrollHeight - e.clientHeight - e.scrollTop;
                            const i = this.dir && "rtl" == this.dir.value;
                            return "start" == t ? t = i ? "right" : "left" : "end" == t && (t = i ? "left" : "right"), i && 2 == Object(m.d)() ? "left" == t ? e.scrollWidth - e.clientWidth - e.scrollLeft : e.scrollLeft : i && 1 == Object(m.d)() ? "left" == t ? e.scrollLeft + e.scrollWidth - e.clientWidth : -e.scrollLeft : "left" == t ? e.scrollLeft : e.scrollWidth - e.clientWidth - e.scrollLeft
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(s.l), s.Pb(v), s.Pb(s.B), s.Pb(y.b, 8))
                    }, t.\u0275dir = s.Kb({
                        type: t,
                        selectors: [
                            ["", "cdk-scrollable", ""],
                            ["", "cdkScrollable", ""]
                        ]
                    }), t
                })(),
                _ = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._platform = t, this._change = new r.a, this._changeListener = t => {
                                this._change.next(t)
                            }, this._document = i, e.runOutsideAngular(() => {
                                if (t.isBrowser) {
                                    const t = this._getWindow();
                                    t.addEventListener("resize", this._changeListener), t.addEventListener("orientationchange", this._changeListener)
                                }
                                this.change().subscribe(() => this._updateViewportSize())
                            })
                        }
                        ngOnDestroy() {
                            if (this._platform.isBrowser) {
                                const t = this._getWindow();
                                t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener)
                            }
                            this._change.complete()
                        }
                        getViewportSize() {
                            this._viewportSize || this._updateViewportSize();
                            const t = {
                                width: this._viewportSize.width,
                                height: this._viewportSize.height
                            };
                            return this._platform.isBrowser || (this._viewportSize = null), t
                        }
                        getViewportRect() {
                            const t = this.getViewportScrollPosition(),
                                {
                                    width: e,
                                    height: i
                                } = this.getViewportSize();
                            return {
                                top: t.top,
                                left: t.left,
                                bottom: t.top + i,
                                right: t.left + e,
                                height: i,
                                width: e
                            }
                        }
                        getViewportScrollPosition() {
                            if (!this._platform.isBrowser) return {
                                top: 0,
                                left: 0
                            };
                            const t = this._document,
                                e = this._getWindow(),
                                i = t.documentElement,
                                n = i.getBoundingClientRect();
                            return {
                                top: -n.top || t.body.scrollTop || e.scrollY || i.scrollTop || 0,
                                left: -n.left || t.body.scrollLeft || e.scrollX || i.scrollLeft || 0
                            }
                        }
                        change(t = 20) {
                            return t > 0 ? this._change.pipe(Object(p.a)(t)) : this._change
                        }
                        _getWindow() {
                            return this._document.defaultView || window
                        }
                        _updateViewportSize() {
                            const t = this._getWindow();
                            this._viewportSize = this._platform.isBrowser ? {
                                width: t.innerWidth,
                                height: t.innerHeight
                            } : {
                                width: 0,
                                height: 0
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Zb(m.a), s.Zb(s.B), s.Zb(b.d, 8))
                    }, t.\u0275prov = Object(s.Lb)({
                        factory: function() {
                            return new t(Object(s.Zb)(m.a), Object(s.Zb)(s.B), Object(s.Zb)(b.d, 8))
                        },
                        token: t,
                        providedIn: "root"
                    }), t
                })(),
                w = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({}), t
                })(),
                C = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = s.Nb({
                        type: t
                    }), t.\u0275inj = s.Mb({
                        imports: [
                            [y.a, m.b, w], y.a, w
                        ]
                    }), t
                })()
        },
        wZkO: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return q
            }), i.d(e, "b", function() {
                return rt
            }), i.d(e, "c", function() {
                return pt
            });
            var n = i("u47x"),
                s = i("GU7r"),
                r = i("+rOU"),
                a = i("ofXK"),
                o = i("fXoL"),
                l = i("FKr1"),
                c = i("R1ws"),
                h = i("oXA7"),
                u = i("jqqC"),
                d = i("2btn"),
                p = i("KOvq"),
                f = i("4krO"),
                g = i("QoT1"),
                m = i("R0Ic"),
                b = i("zzs5"),
                y = i("XJvv"),
                v = i("bk9D"),
                x = i("8LU1"),
                _ = i("nLfN"),
                w = i("FtGj"),
                C = i("cH1L"),
                k = i("vxfF");

            function S(t, e) {
                1 & t && o.jc(0)
            }
            const A = ["*"];

            function O(t, e) {}
            const E = function(t) {
                    return {
                        animationDuration: t
                    }
                },
                P = function(t, e) {
                    return {
                        value: t,
                        params: e
                    }
                },
                T = ["tabBodyWrapper"],
                D = ["tabHeader"];

            function I(t, e) {}

            function M(t, e) {
                if (1 & t && o.Bc(0, I, 0, 0, "ng-template", 9), 2 & t) {
                    const t = o.gc().$implicit;
                    o.lc("cdkPortalOutlet", t.templateLabel)
                }
            }

            function L(t, e) {
                if (1 & t && o.Cc(0), 2 & t) {
                    const t = o.gc().$implicit;
                    o.Dc(t.textLabel)
                }
            }

            function R(t, e) {
                if (1 & t) {
                    const t = o.Wb();
                    o.Vb(0, "div", 6), o.cc("click", function() {
                        o.uc(t);
                        const i = e.$implicit,
                            n = e.index,
                            s = o.gc(),
                            r = o.sc(1);
                        return s._handleClick(i, r, n)
                    })("cdkFocusChange", function(i) {
                        o.uc(t);
                        const n = e.index;
                        return o.gc()._tabFocusChanged(i, n)
                    }), o.Vb(1, "div", 7), o.Bc(2, M, 1, 1, "ng-template", 8), o.Bc(3, L, 1, 1, "ng-template", 8), o.Ub(), o.Ub()
                }
                if (2 & t) {
                    const t = e.$implicit,
                        i = e.index,
                        n = o.gc();
                    o.Hb("mat-tab-label-active", n.selectedIndex == i), o.lc("id", n._getTabLabelId(i))("disabled", t.disabled)("matRippleDisabled", t.disabled || n.disableRipple), o.Eb("tabIndex", n._getTabIndex(t, i))("aria-posinset", i + 1)("aria-setsize", n._tabs.length)("aria-controls", n._getTabContentId(i))("aria-selected", n.selectedIndex == i)("aria-label", t.ariaLabel || null)("aria-labelledby", !t.ariaLabel && t.ariaLabelledby ? t.ariaLabelledby : null), o.Db(2), o.lc("ngIf", t.templateLabel), o.Db(1), o.lc("ngIf", !t.templateLabel)
                }
            }

            function j(t, e) {
                if (1 & t) {
                    const t = o.Wb();
                    o.Vb(0, "mat-tab-body", 10), o.cc("_onCentered", function() {
                        return o.uc(t), o.gc()._removeTabBodyWrapperHeight()
                    })("_onCentering", function(e) {
                        return o.uc(t), o.gc()._setTabBodyWrapperHeight(e)
                    }), o.Ub()
                }
                if (2 & t) {
                    const t = e.$implicit,
                        i = e.index,
                        n = o.gc();
                    o.Hb("mat-tab-body-active", n.selectedIndex == i), o.lc("id", n._getTabContentId(i))("content", t.content)("position", t.position)("origin", t.origin)("animationDuration", n.animationDuration), o.Eb("aria-labelledby", n._getTabLabelId(i))
                }
            }
            const F = ["tabListContainer"],
                N = ["tabList"],
                z = ["nextPaginator"],
                V = ["previousPaginator"],
                B = new o.s("MatInkBarPositioner", {
                    providedIn: "root",
                    factory: function() {
                        return t => ({
                            left: t ? (t.offsetLeft || 0) + "px" : "0",
                            width: t ? (t.offsetWidth || 0) + "px" : "0"
                        })
                    }
                });
            let H = (() => {
                class t {
                    constructor(t, e, i, n) {
                        this._elementRef = t, this._ngZone = e, this._inkBarPositioner = i, this._animationMode = n
                    }
                    alignToElement(t) {
                        this.show(), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => {
                            requestAnimationFrame(() => this._setStyles(t))
                        }) : this._setStyles(t)
                    }
                    show() {
                        this._elementRef.nativeElement.style.visibility = "visible"
                    }
                    hide() {
                        this._elementRef.nativeElement.style.visibility = "hidden"
                    }
                    _setStyles(t) {
                        const e = this._inkBarPositioner(t),
                            i = this._elementRef.nativeElement;
                        i.style.left = e.left, i.style.width = e.width
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(o.Pb(o.l), o.Pb(o.B), o.Pb(B), o.Pb(c.a, 8))
                }, t.\u0275dir = o.Kb({
                    type: t,
                    selectors: [
                        ["mat-ink-bar"]
                    ],
                    hostAttrs: [1, "mat-ink-bar"],
                    hostVars: 2,
                    hostBindings: function(t, e) {
                        2 & t && o.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode)
                    }
                }), t
            })();
            const U = new o.s("MatTabContent"),
                X = new o.s("MatTabLabel");
            class W {}
            const Y = Object(l.s)(W),
                G = new o.s("MAT_TAB_GROUP");
            let q = (() => {
                class t extends Y {
                    constructor(t, e) {
                        super(), this._viewContainerRef = t, this._closestTabGroup = e, this.textLabel = "", this._contentPortal = null, this._stateChanges = new h.a, this.position = null, this.origin = null, this.isActive = !1
                    }
                    get templateLabel() {
                        return this._templateLabel
                    }
                    set templateLabel(t) {
                        this._setTemplateLabelInput(t)
                    }
                    get content() {
                        return this._contentPortal
                    }
                    ngOnChanges(t) {
                        (t.hasOwnProperty("textLabel") || t.hasOwnProperty("disabled")) && this._stateChanges.next()
                    }
                    ngOnDestroy() {
                        this._stateChanges.complete()
                    }
                    ngOnInit() {
                        this._contentPortal = new r.f(this._explicitContent || this._implicitContent, this._viewContainerRef)
                    }
                    _setTemplateLabelInput(t) {
                        t && (this._templateLabel = t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(o.Pb(o.S), o.Pb(G))
                }, t.\u0275cmp = o.Jb({
                    type: t,
                    selectors: [
                        ["mat-tab"]
                    ],
                    contentQueries: function(t, e, i) {
                        if (1 & t && (o.Ib(i, X, 1), o.Ib(i, U, 3, o.O)), 2 & t) {
                            let t;
                            o.rc(t = o.dc()) && (e.templateLabel = t.first), o.rc(t = o.dc()) && (e._explicitContent = t.first)
                        }
                    },
                    viewQuery: function(t, e) {
                        if (1 & t && o.Hc(o.O, 3), 2 & t) {
                            let t;
                            o.rc(t = o.dc()) && (e._implicitContent = t.first)
                        }
                    },
                    inputs: {
                        disabled: "disabled",
                        textLabel: ["label", "textLabel"],
                        ariaLabel: ["aria-label", "ariaLabel"],
                        ariaLabelledby: ["aria-labelledby", "ariaLabelledby"]
                    },
                    exportAs: ["matTab"],
                    features: [o.Ab, o.Bb],
                    ngContentSelectors: A,
                    decls: 1,
                    vars: 0,
                    template: function(t, e) {
                        1 & t && (o.kc(), o.Bc(0, S, 1, 0, "ng-template"))
                    },
                    encapsulation: 2
                }), t
            })();
            const Z = {
                translateTab: Object(m.m)("translateTab", [Object(m.j)("center, void, left-origin-center, right-origin-center", Object(m.k)({
                    transform: "none"
                })), Object(m.j)("left", Object(m.k)({
                    transform: "translate3d(-100%, 0, 0)",
                    minHeight: "1px"
                })), Object(m.j)("right", Object(m.k)({
                    transform: "translate3d(100%, 0, 0)",
                    minHeight: "1px"
                })), Object(m.l)("* => left, * => right, left => center, right => center", Object(m.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")), Object(m.l)("void => left-origin-center", [Object(m.k)({
                    transform: "translate3d(-100%, 0, 0)"
                }), Object(m.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]), Object(m.l)("void => right-origin-center", [Object(m.k)({
                    transform: "translate3d(100%, 0, 0)"
                }), Object(m.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])])
            };
            let $ = (() => {
                    class t extends r.b {
                        constructor(t, e, i, n) {
                            super(t, e, n), this._host = i, this._centeringSub = u.b.EMPTY, this._leavingSub = u.b.EMPTY
                        }
                        ngOnInit() {
                            super.ngOnInit(), this._centeringSub = this._host._beforeCentering.pipe(Object(b.a)(this._host._isCenterPosition(this._host._position))).subscribe(t => {
                                t && !this.hasAttached() && this.attach(this._host._content)
                            }), this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {
                                this.detach()
                            })
                        }
                        ngOnDestroy() {
                            super.ngOnDestroy(), this._centeringSub.unsubscribe(), this._leavingSub.unsubscribe()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.j), o.Pb(o.S), o.Pb(Object(o.W)(() => K)), o.Pb(a.d))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        selectors: [
                            ["", "matTabBodyHost", ""]
                        ],
                        features: [o.Ab]
                    }), t
                })(),
                Q = (() => {
                    class t {
                        constructor(t, e, i) {
                            this._elementRef = t, this._dir = e, this._dirChangeSubscription = u.b.EMPTY, this._translateTabComplete = new h.a, this._onCentering = new o.o, this._beforeCentering = new o.o, this._afterLeavingCenter = new o.o, this._onCentered = new o.o(!0), this.animationDuration = "500ms", e && (this._dirChangeSubscription = e.change.subscribe(t => {
                                this._computePositionAnimationState(t), i.markForCheck()
                            })), this._translateTabComplete.pipe(Object(y.a)((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => {
                                this._isCenterPosition(t.toState) && this._isCenterPosition(this._position) && this._onCentered.emit(), this._isCenterPosition(t.fromState) && !this._isCenterPosition(this._position) && this._afterLeavingCenter.emit()
                            })
                        }
                        set position(t) {
                            this._positionIndex = t, this._computePositionAnimationState()
                        }
                        ngOnInit() {
                            "center" == this._position && null != this.origin && (this._position = this._computePositionFromOrigin(this.origin))
                        }
                        ngOnDestroy() {
                            this._dirChangeSubscription.unsubscribe(), this._translateTabComplete.complete()
                        }
                        _onTranslateTabStarted(t) {
                            const e = this._isCenterPosition(t.toState);
                            this._beforeCentering.emit(e), e && this._onCentering.emit(this._elementRef.nativeElement.clientHeight)
                        }
                        _getLayoutDirection() {
                            return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr"
                        }
                        _isCenterPosition(t) {
                            return "center" == t || "left-origin-center" == t || "right-origin-center" == t
                        }
                        _computePositionAnimationState(t = this._getLayoutDirection()) {
                            this._position = this._positionIndex < 0 ? "ltr" == t ? "left" : "right" : this._positionIndex > 0 ? "ltr" == t ? "right" : "left" : "center"
                        }
                        _computePositionFromOrigin(t) {
                            const e = this._getLayoutDirection();
                            return "ltr" == e && t <= 0 || "rtl" == e && t > 0 ? "left-origin-center" : "right-origin-center"
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(C.b, 8), o.Pb(o.h))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        inputs: {
                            animationDuration: "animationDuration",
                            position: "position",
                            _content: ["content", "_content"],
                            origin: "origin"
                        },
                        outputs: {
                            _onCentering: "_onCentering",
                            _beforeCentering: "_beforeCentering",
                            _afterLeavingCenter: "_afterLeavingCenter",
                            _onCentered: "_onCentered"
                        }
                    }), t
                })(),
                K = (() => {
                    class t extends Q {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(C.b, 8), o.Pb(o.h))
                    }, t.\u0275cmp = o.Jb({
                        type: t,
                        selectors: [
                            ["mat-tab-body"]
                        ],
                        viewQuery: function(t, e) {
                            if (1 & t && o.Hc(r.b, 1), 2 & t) {
                                let t;
                                o.rc(t = o.dc()) && (e._portalHost = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-tab-body"],
                        features: [o.Ab],
                        decls: 3,
                        vars: 6,
                        consts: [
                            ["cdkScrollable", "", 1, "mat-tab-body-content"],
                            ["content", ""],
                            ["matTabBodyHost", ""]
                        ],
                        template: function(t, e) {
                            1 & t && (o.Vb(0, "div", 0, 1), o.cc("@translateTab.start", function(t) {
                                return e._onTranslateTabStarted(t)
                            })("@translateTab.done", function(t) {
                                return e._translateTabComplete.next(t)
                            }), o.Bc(2, O, 0, 0, "ng-template", 2), o.Ub()), 2 & t && o.lc("@translateTab", o.pc(3, P, e._position, o.oc(1, E, e.animationDuration)))
                        },
                        directives: [$],
                        styles: [".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\n"],
                        encapsulation: 2,
                        data: {
                            animation: [Z.translateTab]
                        }
                    }), t
                })();
            const J = new o.s("MAT_TABS_CONFIG");
            let tt = 0;
            class et {}
            class it {
                constructor(t) {
                    this._elementRef = t
                }
            }
            const nt = Object(l.q)(Object(l.r)(it), "primary");
            let st = (() => {
                    class t extends nt {
                        constructor(t, e, i, n) {
                            super(t), this._changeDetectorRef = e, this._animationMode = n, this._tabs = new o.F, this._indexToSelect = 0, this._tabBodyWrapperHeight = 0, this._tabsSubscription = u.b.EMPTY, this._tabLabelSubscription = u.b.EMPTY, this._selectedIndex = null, this.headerPosition = "above", this.selectedIndexChange = new o.o, this.focusChange = new o.o, this.animationDone = new o.o, this.selectedTabChange = new o.o(!0), this._groupId = tt++, this.animationDuration = i && i.animationDuration ? i.animationDuration : "500ms", this.disablePagination = !(!i || null == i.disablePagination) && i.disablePagination, this.dynamicHeight = !(!i || null == i.dynamicHeight) && i.dynamicHeight
                        }
                        get dynamicHeight() {
                            return this._dynamicHeight
                        }
                        set dynamicHeight(t) {
                            this._dynamicHeight = Object(x.c)(t)
                        }
                        get selectedIndex() {
                            return this._selectedIndex
                        }
                        set selectedIndex(t) {
                            this._indexToSelect = Object(x.f)(t, null)
                        }
                        get animationDuration() {
                            return this._animationDuration
                        }
                        set animationDuration(t) {
                            this._animationDuration = /^\d+$/.test(t) ? t + "ms" : t
                        }
                        get backgroundColor() {
                            return this._backgroundColor
                        }
                        set backgroundColor(t) {
                            const e = this._elementRef.nativeElement;
                            e.classList.remove(`mat-background-${this.backgroundColor}`), t && e.classList.add(`mat-background-${t}`), this._backgroundColor = t
                        }
                        ngAfterContentChecked() {
                            const t = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                            if (this._selectedIndex != t) {
                                const e = null == this._selectedIndex;
                                if (!e) {
                                    this.selectedTabChange.emit(this._createChangeEvent(t));
                                    const e = this._tabBodyWrapper.nativeElement;
                                    e.style.minHeight = e.clientHeight + "px"
                                }
                                Promise.resolve().then(() => {
                                    this._tabs.forEach((e, i) => e.isActive = i === t), e || (this.selectedIndexChange.emit(t), this._tabBodyWrapper.nativeElement.style.minHeight = "")
                                })
                            }
                            this._tabs.forEach((e, i) => {
                                e.position = i - t, null == this._selectedIndex || 0 != e.position || e.origin || (e.origin = t - this._selectedIndex)
                            }), this._selectedIndex !== t && (this._selectedIndex = t, this._changeDetectorRef.markForCheck())
                        }
                        ngAfterContentInit() {
                            this._subscribeToAllTabChanges(), this._subscribeToTabLabels(), this._tabsSubscription = this._tabs.changes.subscribe(() => {
                                if (this._clampTabIndex(this._indexToSelect) === this._selectedIndex) {
                                    const t = this._tabs.toArray();
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].isActive) {
                                            this._indexToSelect = this._selectedIndex = e;
                                            break
                                        }
                                }
                                this._changeDetectorRef.markForCheck()
                            })
                        }
                        _subscribeToAllTabChanges() {
                            this._allTabs.changes.pipe(Object(b.a)(this._allTabs)).subscribe(t => {
                                this._tabs.reset(t.filter(t => t._closestTabGroup === this)), this._tabs.notifyOnChanges()
                            })
                        }
                        ngOnDestroy() {
                            this._tabs.destroy(), this._tabsSubscription.unsubscribe(), this._tabLabelSubscription.unsubscribe()
                        }
                        realignInkBar() {
                            this._tabHeader && this._tabHeader._alignInkBarToSelectedTab()
                        }
                        _focusChanged(t) {
                            this.focusChange.emit(this._createChangeEvent(t))
                        }
                        _createChangeEvent(t) {
                            const e = new et;
                            return e.index = t, this._tabs && this._tabs.length && (e.tab = this._tabs.toArray()[t]), e
                        }
                        _subscribeToTabLabels() {
                            this._tabLabelSubscription && this._tabLabelSubscription.unsubscribe(), this._tabLabelSubscription = Object(d.a)(...this._tabs.map(t => t._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck())
                        }
                        _clampTabIndex(t) {
                            return Math.min(this._tabs.length - 1, Math.max(t || 0, 0))
                        }
                        _getTabLabelId(t) {
                            return `mat-tab-label-${this._groupId}-${t}`
                        }
                        _getTabContentId(t) {
                            return `mat-tab-content-${this._groupId}-${t}`
                        }
                        _setTabBodyWrapperHeight(t) {
                            if (!this._dynamicHeight || !this._tabBodyWrapperHeight) return;
                            const e = this._tabBodyWrapper.nativeElement;
                            e.style.height = this._tabBodyWrapperHeight + "px", this._tabBodyWrapper.nativeElement.offsetHeight && (e.style.height = t + "px")
                        }
                        _removeTabBodyWrapperHeight() {
                            const t = this._tabBodyWrapper.nativeElement;
                            this._tabBodyWrapperHeight = t.clientHeight, t.style.height = "", this.animationDone.emit()
                        }
                        _handleClick(t, e, i) {
                            t.disabled || (this.selectedIndex = e.focusIndex = i)
                        }
                        _getTabIndex(t, e) {
                            return t.disabled ? null : this.selectedIndex === e ? 0 : -1
                        }
                        _tabFocusChanged(t, e) {
                            t && (this._tabHeader.focusIndex = e)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(o.h), o.Pb(J, 8), o.Pb(c.a, 8))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        inputs: {
                            headerPosition: "headerPosition",
                            animationDuration: "animationDuration",
                            disablePagination: "disablePagination",
                            dynamicHeight: "dynamicHeight",
                            selectedIndex: "selectedIndex",
                            backgroundColor: "backgroundColor"
                        },
                        outputs: {
                            selectedIndexChange: "selectedIndexChange",
                            focusChange: "focusChange",
                            animationDone: "animationDone",
                            selectedTabChange: "selectedTabChange"
                        },
                        features: [o.Ab]
                    }), t
                })(),
                rt = (() => {
                    class t extends st {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(o.h), o.Pb(J, 8), o.Pb(c.a, 8))
                    }, t.\u0275cmp = o.Jb({
                        type: t,
                        selectors: [
                            ["mat-tab-group"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && o.Ib(i, q, 1), 2 & t) {
                                let t;
                                o.rc(t = o.dc()) && (e._allTabs = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && (o.Hc(T, 1), o.Hc(D, 1)), 2 & t) {
                                let t;
                                o.rc(t = o.dc()) && (e._tabBodyWrapper = t.first), o.rc(t = o.dc()) && (e._tabHeader = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-tab-group"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && o.Hb("mat-tab-group-dynamic-height", e.dynamicHeight)("mat-tab-group-inverted-header", "below" === e.headerPosition)
                        },
                        inputs: {
                            color: "color",
                            disableRipple: "disableRipple"
                        },
                        exportAs: ["matTabGroup"],
                        features: [o.Cb([{
                            provide: G,
                            useExisting: t
                        }]), o.Ab],
                        decls: 6,
                        vars: 7,
                        consts: [
                            [3, "selectedIndex", "disableRipple", "disablePagination", "indexFocused", "selectFocusedIndex"],
                            ["tabHeader", ""],
                            ["class", "mat-tab-label mat-focus-indicator", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "disabled", "matRippleDisabled", "click", "cdkFocusChange", 4, "ngFor", "ngForOf"],
                            [1, "mat-tab-body-wrapper"],
                            ["tabBodyWrapper", ""],
                            ["role", "tabpanel", 3, "id", "mat-tab-body-active", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf"],
                            ["role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", "mat-focus-indicator", 3, "id", "disabled", "matRippleDisabled", "click", "cdkFocusChange"],
                            [1, "mat-tab-label-content"],
                            [3, "ngIf"],
                            [3, "cdkPortalOutlet"],
                            ["role", "tabpanel", 3, "id", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering"]
                        ],
                        template: function(t, e) {
                            1 & t && (o.Vb(0, "mat-tab-header", 0, 1), o.cc("indexFocused", function(t) {
                                return e._focusChanged(t)
                            })("selectFocusedIndex", function(t) {
                                return e.selectedIndex = t
                            }), o.Bc(2, R, 4, 14, "div", 2), o.Ub(), o.Vb(3, "div", 3, 4), o.Bc(5, j, 1, 8, "mat-tab-body", 5), o.Ub()), 2 & t && (o.lc("selectedIndex", e.selectedIndex || 0)("disableRipple", e.disableRipple)("disablePagination", e.disablePagination), o.Db(2), o.lc("ngForOf", e._tabs), o.Db(1), o.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode), o.Db(2), o.lc("ngForOf", e._tabs))
                        },
                        directives: function() {
                            return [dt, a.k, lt, l.l, n.d, a.l, r.b, K]
                        },
                        styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"],
                        encapsulation: 2
                    }), t
                })();
            class at {}
            const ot = Object(l.s)(at);
            let lt = (() => {
                class t extends ot {
                    constructor(t) {
                        super(), this.elementRef = t
                    }
                    focus() {
                        this.elementRef.nativeElement.focus()
                    }
                    getOffsetLeft() {
                        return this.elementRef.nativeElement.offsetLeft
                    }
                    getOffsetWidth() {
                        return this.elementRef.nativeElement.offsetWidth
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)(o.Pb(o.l))
                }, t.\u0275dir = o.Kb({
                    type: t,
                    selectors: [
                        ["", "matTabLabelWrapper", ""]
                    ],
                    hostVars: 3,
                    hostBindings: function(t, e) {
                        2 & t && (o.Eb("aria-disabled", !!e.disabled), o.Hb("mat-tab-disabled", e.disabled))
                    },
                    inputs: {
                        disabled: "disabled"
                    },
                    features: [o.Ab]
                }), t
            })();
            const ct = Object(_.f)({
                passive: !0
            });
            let ht = (() => {
                    class t {
                        constructor(t, e, i, n, s, r, a) {
                            this._elementRef = t, this._changeDetectorRef = e, this._viewportRuler = i, this._dir = n, this._ngZone = s, this._platform = r, this._animationMode = a, this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new h.a, this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, this._stopScrolling = new h.a, this.disablePagination = !1, this._selectedIndex = 0, this.selectFocusedIndex = new o.o, this.indexFocused = new o.o, s.runOutsideAngular(() => {
                                Object(p.a)(t.nativeElement, "mouseleave").pipe(Object(v.a)(this._destroyed)).subscribe(() => {
                                    this._stopInterval()
                                })
                            })
                        }
                        get selectedIndex() {
                            return this._selectedIndex
                        }
                        set selectedIndex(t) {
                            t = Object(x.f)(t), this._selectedIndex != t && (this._selectedIndexChanged = !0, this._selectedIndex = t, this._keyManager && this._keyManager.updateActiveItem(t))
                        }
                        ngAfterViewInit() {
                            Object(p.a)(this._previousPaginator.nativeElement, "touchstart", ct).pipe(Object(v.a)(this._destroyed)).subscribe(() => {
                                this._handlePaginatorPress("before")
                            }), Object(p.a)(this._nextPaginator.nativeElement, "touchstart", ct).pipe(Object(v.a)(this._destroyed)).subscribe(() => {
                                this._handlePaginatorPress("after")
                            })
                        }
                        ngAfterContentInit() {
                            const t = this._dir ? this._dir.change : Object(f.a)(null),
                                e = this._viewportRuler.change(150),
                                i = () => {
                                    this.updatePagination(), this._alignInkBarToSelectedTab()
                                };
                            this._keyManager = new n.e(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(), this._keyManager.updateActiveItem(this._selectedIndex), "undefined" != typeof requestAnimationFrame ? requestAnimationFrame(i) : i(), Object(d.a)(t, e, this._items.changes).pipe(Object(v.a)(this._destroyed)).subscribe(() => {
                                this._ngZone.run(() => Promise.resolve().then(i)), this._keyManager.withHorizontalOrientation(this._getLayoutDirection())
                            }), this._keyManager.change.pipe(Object(v.a)(this._destroyed)).subscribe(t => {
                                this.indexFocused.emit(t), this._setTabFocus(t)
                            })
                        }
                        ngAfterContentChecked() {
                            this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck())
                        }
                        ngOnDestroy() {
                            this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete()
                        }
                        _handleKeydown(t) {
                            if (!Object(w.o)(t)) switch (t.keyCode) {
                                case w.d:
                                case w.j:
                                    this.focusIndex !== this.selectedIndex && (this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(t));
                                    break;
                                default:
                                    this._keyManager.onKeydown(t)
                            }
                        }
                        _onContentChanges() {
                            const t = this._elementRef.nativeElement.textContent;
                            t !== this._currentTextContent && (this._currentTextContent = t || "", this._ngZone.run(() => {
                                this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck()
                            }))
                        }
                        updatePagination() {
                            this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition()
                        }
                        get focusIndex() {
                            return this._keyManager ? this._keyManager.activeItemIndex : 0
                        }
                        set focusIndex(t) {
                            this._isValidIndex(t) && this.focusIndex !== t && this._keyManager && this._keyManager.setActiveItem(t)
                        }
                        _isValidIndex(t) {
                            if (!this._items) return !0;
                            const e = this._items ? this._items.toArray()[t] : null;
                            return !!e && !e.disabled
                        }
                        _setTabFocus(t) {
                            if (this._showPaginationControls && this._scrollToLabel(t), this._items && this._items.length) {
                                this._items.toArray()[t].focus();
                                const e = this._tabListContainer.nativeElement,
                                    i = this._getLayoutDirection();
                                e.scrollLeft = "ltr" == i ? 0 : e.scrollWidth - e.offsetWidth
                            }
                        }
                        _getLayoutDirection() {
                            return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr"
                        }
                        _updateTabScrollPosition() {
                            if (this.disablePagination) return;
                            const t = this.scrollDistance,
                                e = "ltr" === this._getLayoutDirection() ? -t : t;
                            this._tabList.nativeElement.style.transform = `translateX(${Math.round(e)}px)`, (this._platform.TRIDENT || this._platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0)
                        }
                        get scrollDistance() {
                            return this._scrollDistance
                        }
                        set scrollDistance(t) {
                            this._scrollTo(t)
                        }
                        _scrollHeader(t) {
                            return this._scrollTo(this._scrollDistance + ("before" == t ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3)
                        }
                        _handlePaginatorClick(t) {
                            this._stopInterval(), this._scrollHeader(t)
                        }
                        _scrollToLabel(t) {
                            if (this.disablePagination) return;
                            const e = this._items ? this._items.toArray()[t] : null;
                            if (!e) return;
                            const i = this._tabListContainer.nativeElement.offsetWidth,
                                {
                                    offsetLeft: n,
                                    offsetWidth: s
                                } = e.elementRef.nativeElement;
                            let r, a;
                            "ltr" == this._getLayoutDirection() ? (r = n, a = r + s) : (a = this._tabList.nativeElement.offsetWidth - n, r = a - s);
                            const o = this.scrollDistance,
                                l = this.scrollDistance + i;
                            r < o ? this.scrollDistance -= o - r + 60 : a > l && (this.scrollDistance += a - l + 60)
                        }
                        _checkPaginationEnabled() {
                            if (this.disablePagination) this._showPaginationControls = !1;
                            else {
                                const t = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
                                t || (this.scrollDistance = 0), t !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), this._showPaginationControls = t
                            }
                        }
                        _checkScrollingControls() {
                            this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck())
                        }
                        _getMaxScrollDistance() {
                            return this._tabList.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0
                        }
                        _alignInkBarToSelectedTab() {
                            const t = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null,
                                e = t ? t.elementRef.nativeElement : null;
                            e ? this._inkBar.alignToElement(e) : this._inkBar.hide()
                        }
                        _stopInterval() {
                            this._stopScrolling.next()
                        }
                        _handlePaginatorPress(t, e) {
                            e && null != e.button && 0 !== e.button || (this._stopInterval(), Object(g.a)(650, 100).pipe(Object(v.a)(Object(d.a)(this._stopScrolling, this._destroyed))).subscribe(() => {
                                const {
                                    maxScrollDistance: e,
                                    distance: i
                                } = this._scrollHeader(t);
                                (0 === i || i >= e) && this._stopInterval()
                            }))
                        }
                        _scrollTo(t) {
                            if (this.disablePagination) return {
                                maxScrollDistance: 0,
                                distance: 0
                            };
                            const e = this._getMaxScrollDistance();
                            return this._scrollDistance = Math.max(0, Math.min(e, t)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), {
                                maxScrollDistance: e,
                                distance: this._scrollDistance
                            }
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(o.h), o.Pb(k.e), o.Pb(C.b, 8), o.Pb(o.B), o.Pb(_.a), o.Pb(c.a, 8))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        inputs: {
                            disablePagination: "disablePagination"
                        }
                    }), t
                })(),
                ut = (() => {
                    class t extends ht {
                        constructor(t, e, i, n, s, r, a) {
                            super(t, e, i, n, s, r, a), this._disableRipple = !1
                        }
                        get disableRipple() {
                            return this._disableRipple
                        }
                        set disableRipple(t) {
                            this._disableRipple = Object(x.c)(t)
                        }
                        _itemSelected(t) {
                            t.preventDefault()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(o.h), o.Pb(k.e), o.Pb(C.b, 8), o.Pb(o.B), o.Pb(_.a), o.Pb(c.a, 8))
                    }, t.\u0275dir = o.Kb({
                        type: t,
                        inputs: {
                            disableRipple: "disableRipple"
                        },
                        features: [o.Ab]
                    }), t
                })(),
                dt = (() => {
                    class t extends ut {
                        constructor(t, e, i, n, s, r, a) {
                            super(t, e, i, n, s, r, a)
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(o.Pb(o.l), o.Pb(o.h), o.Pb(k.e), o.Pb(C.b, 8), o.Pb(o.B), o.Pb(_.a), o.Pb(c.a, 8))
                    }, t.\u0275cmp = o.Jb({
                        type: t,
                        selectors: [
                            ["mat-tab-header"]
                        ],
                        contentQueries: function(t, e, i) {
                            if (1 & t && o.Ib(i, lt, 0), 2 & t) {
                                let t;
                                o.rc(t = o.dc()) && (e._items = t)
                            }
                        },
                        viewQuery: function(t, e) {
                            if (1 & t && (o.Hc(H, 3), o.Hc(F, 3), o.Hc(N, 3), o.Hc(z, 1), o.Hc(V, 1)), 2 & t) {
                                let t;
                                o.rc(t = o.dc()) && (e._inkBar = t.first), o.rc(t = o.dc()) && (e._tabListContainer = t.first), o.rc(t = o.dc()) && (e._tabList = t.first), o.rc(t = o.dc()) && (e._nextPaginator = t.first), o.rc(t = o.dc()) && (e._previousPaginator = t.first)
                            }
                        },
                        hostAttrs: [1, "mat-tab-header"],
                        hostVars: 4,
                        hostBindings: function(t, e) {
                            2 & t && o.Hb("mat-tab-header-pagination-controls-enabled", e._showPaginationControls)("mat-tab-header-rtl", "rtl" == e._getLayoutDirection())
                        },
                        inputs: {
                            selectedIndex: "selectedIndex"
                        },
                        outputs: {
                            selectFocusedIndex: "selectFocusedIndex",
                            indexFocused: "indexFocused"
                        },
                        features: [o.Ab],
                        ngContentSelectors: A,
                        decls: 13,
                        vars: 8,
                        consts: [
                            ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend"],
                            ["previousPaginator", ""],
                            [1, "mat-tab-header-pagination-chevron"],
                            [1, "mat-tab-label-container", 3, "keydown"],
                            ["tabListContainer", ""],
                            ["role", "tablist", 1, "mat-tab-list", 3, "cdkObserveContent"],
                            ["tabList", ""],
                            [1, "mat-tab-labels"],
                            ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend"],
                            ["nextPaginator", ""]
                        ],
                        template: function(t, e) {
                            1 & t && (o.kc(), o.Vb(0, "div", 0, 1), o.cc("click", function() {
                                return e._handlePaginatorClick("before")
                            })("mousedown", function(t) {
                                return e._handlePaginatorPress("before", t)
                            })("touchend", function() {
                                return e._stopInterval()
                            }), o.Qb(2, "div", 2), o.Ub(), o.Vb(3, "div", 3, 4), o.cc("keydown", function(t) {
                                return e._handleKeydown(t)
                            }), o.Vb(5, "div", 5, 6), o.cc("cdkObserveContent", function() {
                                return e._onContentChanges()
                            }), o.Vb(7, "div", 7), o.jc(8), o.Ub(), o.Qb(9, "mat-ink-bar"), o.Ub(), o.Ub(), o.Vb(10, "div", 8, 9), o.cc("mousedown", function(t) {
                                return e._handlePaginatorPress("after", t)
                            })("click", function() {
                                return e._handlePaginatorClick("after")
                            })("touchend", function() {
                                return e._stopInterval()
                            }), o.Qb(12, "div", 2), o.Ub()), 2 & t && (o.Hb("mat-tab-header-pagination-disabled", e._disableScrollBefore), o.lc("matRippleDisabled", e._disableScrollBefore || e.disableRipple), o.Db(5), o.Hb("_mat-animation-noopable", "NoopAnimations" === e._animationMode), o.Db(5), o.Hb("mat-tab-header-pagination-disabled", e._disableScrollAfter), o.lc("matRippleDisabled", e._disableScrollAfter || e.disableRipple))
                        },
                        directives: [l.l, s.a, H],
                        styles: ['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n'],
                        encapsulation: 2
                    }), t
                })(),
                pt = (() => {
                    class t {}
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275mod = o.Nb({
                        type: t
                    }), t.\u0275inj = o.Mb({
                        imports: [
                            [a.c, l.e, r.e, l.m, s.c, n.a], l.e
                        ]
                    }), t
                })()
        },
        wb3g: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return o
            });
            const {
                isArray: n
            } = Array, {
                getPrototypeOf: s,
                prototype: r,
                keys: a
            } = Object;

            function o(t) {
                if (1 === t.length) {
                    const i = t[0];
                    if (n(i)) return {
                        args: i,
                        keys: null
                    };
                    if ((e = i) && "object" == typeof e && s(e) === r) {
                        const t = a(i);
                        return {
                            args: t.map(t => i[t]),
                            keys: t
                        }
                    }
                }
                var e;
                return {
                    args: t,
                    keys: null
                }
            }
        },
        xt23: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return s
            });
            var n = i("bx2D");
            class s extends n.b {
                constructor(t, e, i, n, s) {
                    super(t), this.onFinalize = s, this._next = e ? function(i) {
                        try {
                            e(i)
                        } catch (n) {
                            t.error(n)
                        }
                    } : super._next, this._error = n ? function(e) {
                        try {
                            n(e)
                        } catch (e) {
                            t.error(e)
                        } finally {
                            this.unsubscribe()
                        }
                    } : super._error, this._complete = i ? function() {
                        try {
                            i()
                        } catch (e) {
                            t.error(e)
                        } finally {
                            this.unsubscribe()
                        }
                    } : super._complete
                }
                unsubscribe() {
                    var t;
                    const {
                        closed: e
                    } = this;
                    super.unsubscribe(), !e && (null === (t = this.onFinalize) || void 0 === t || t.call(this))
                }
            }
        },
        zPkR: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return h
            });
            var n = i("SIQg"),
                s = i("wb3g"),
                r = i("g/MW"),
                a = i("1lu8"),
                o = i("xt23"),
                l = i("CLjF"),
                c = i("rFin");

            function h(...t) {
                const e = Object(a.b)(t),
                    {
                        args: i,
                        keys: h
                    } = Object(s.a)(t),
                    u = new n.a(t => {
                        const {
                            length: e
                        } = i;
                        if (!e) return void t.complete();
                        const n = new Array(e);
                        let s = e,
                            a = e;
                        for (let l = 0; l < e; l++) {
                            let e = !1;
                            Object(r.c)(i[l]).subscribe(new o.a(t, t => {
                                e || (e = !0, a--), n[l] = t
                            }, () => {
                                --s && e || (a || t.next(h ? Object(c.a)(h, n) : n), t.complete())
                            }))
                        }
                    });
                return e ? u.pipe(Object(l.a)(e)) : u
            }
        },
        zUnb: function(t, e, i) {
            "use strict";
            i.r(e);
            var n = i("jhN1"),
                s = i("fXoL");
            i("rB/T");
            var r = i("R1ws"),
                a = i("tyNb"),
                o = i("5eHb"),
                l = i("Wp6s"),
                c = i("bTqV");
            let h = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-root"]
                    ],
                    decls: 1,
                    vars: 0,
                    template: function(t, e) {
                        1 & t && s.Qb(0, "router-outlet")
                    },
                    directives: [a.f],
                    styles: [""]
                }), t
            })();
            var u = i("PCNd"),
                d = i("AGcZ"),
                p = i("0MCZ"),
                f = i("/t3+"),
                g = i("v/4h"),
                m = i("WwWl"),
                b = i("LNGT");
            const y = function(t) {
                return [t]
            };
            let v = (() => {
                class t {
                    constructor() {
                        this.colors = g.a
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-visits-chart"]
                    ],
                    inputs: {
                        visitsChartData: "visitsChartData"
                    },
                    decls: 26,
                    vars: 11,
                    consts: [
                        [1, "visits-chart"],
                        [1, "visits-chart__header"],
                        [1, "visits-chart__title"],
                        [1, "visits-chart__content"],
                        [1, "visits-chart__content-info"],
                        [1, "visits-chart__content-info-title"],
                        [1, "visits-chart__content-info-chart", 3, "data", "gradient", "height", "smooth", "strokeWidth"],
                        [1, "visits-chart__content-stats"],
                        [1, "visits-chart__content-stats-title"],
                        [1, "visits-chart__content-stats-data"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "h5", 2), s.Cc(3, "Visits Today"), s.Ub(), s.Qb(4, "app-settings-menu"), s.Ub(), s.Vb(5, "mat-card-content", 3), s.Vb(6, "div", 4), s.Vb(7, "h6", 5), s.Cc(8), s.Ub(), s.Qb(9, "ngx-trend", 6), s.Ub(), s.Vb(10, "div", 7), s.Vb(11, "div"), s.Vb(12, "p", 8), s.Cc(13, "Registration"), s.Ub(), s.Vb(14, "p", 9), s.Cc(15), s.Ub(), s.Ub(), s.Vb(16, "div"), s.Vb(17, "p", 8), s.Cc(18, "Sign Out"), s.Ub(), s.Vb(19, "p", 9), s.Cc(20), s.Ub(), s.Ub(), s.Vb(21, "div"), s.Vb(22, "p", 8), s.Cc(23, "Rate"), s.Ub(), s.Vb(24, "p", 9), s.Cc(25), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub()), 2 & t && (s.Db(8), s.Dc(e.visitsChartData.all), s.Db(1), s.lc("data", e.visitsChartData.data)("gradient", s.oc(9, y, e.colors.GREEN))("height", 44)("smooth", !0)("strokeWidth", 5), s.Db(6), s.Dc(e.visitsChartData.registration), s.Db(5), s.Dc(e.visitsChartData.signOut), s.Db(5), s.Ec("", e.visitsChartData.rate, "%"))
                    },
                    directives: [l.a, l.e, m.a, l.b, b.a],
                    styles: [".visits-chart[_ngcontent-%COMP%]{box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549);height:192px;flex-direction:column}.visits-chart[_ngcontent-%COMP%], .visits-chart__header[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.visits-chart__header[_ngcontent-%COMP%]{align-items:center;color:#6e6e6e}.visits-chart__title[_ngcontent-%COMP%]{font-size:20px;font-weight:400;margin:0;line-height:40px}.visits-chart__content[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;height:75%}.visits-chart__content-info[_ngcontent-%COMP%]{align-items:center;display:flex;height:96px;justify-content:space-between}.visits-chart__content-info-title[_ngcontent-%COMP%]{margin:0;font-weight:400;font-size:24px;line-height:1.5;letter-spacing:.15px;color:#4a4a4a}.visits-chart__content-info-chart[_ngcontent-%COMP%]{margin-left:16px}.visits-chart__content-stats[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.visits-chart__content-stats-title[_ngcontent-%COMP%]{margin:0;color:#6e6e6e;font-weight:400;font-size:14px}.visits-chart__content-stats-data[_ngcontent-%COMP%]{margin:0;line-height:1.5;font-weight:400;font-size:21px;color:#4a4a4a}"]
                }), t
            })();
            var x = i("bv9b");
            let _ = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-performance-chart"]
                    ],
                    inputs: {
                        performanceChartData: "performanceChartData"
                    },
                    decls: 22,
                    vars: 2,
                    consts: [
                        [1, "performance-chart"],
                        [1, "performance-chart__header"],
                        [1, "performance-chart__header-title"],
                        [1, "performance-chart__content"],
                        [1, "performance-chart__content-header"],
                        [1, "performance-chart__content-header-item"],
                        [1, "performance-chart__content-header-item-icon_blue"],
                        [1, "performance-chart__content-header-item-text"],
                        [1, "performance-chart__content-header-item-icon_yellow"],
                        [1, "performance-chart__progress-wrapper"],
                        [1, "performance-chart__progress-title"],
                        ["mode", "determinate", 1, "performance-chart__progress-bar", 3, "value"],
                        ["mode", "determinate", "color", "accent", 1, "performance-chart__progress-bar", 3, "value"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "h5", 2), s.Cc(3, "App Performance"), s.Ub(), s.Qb(4, "app-settings-menu"), s.Ub(), s.Vb(5, "mat-card-content", 3), s.Vb(6, "div", 4), s.Vb(7, "div", 5), s.Qb(8, "div", 6), s.Vb(9, "span", 7), s.Cc(10, "Integration"), s.Ub(), s.Ub(), s.Vb(11, "div", 5), s.Qb(12, "div", 8), s.Vb(13, "span", 7), s.Cc(14, "SDK"), s.Ub(), s.Ub(), s.Ub(), s.Vb(15, "div", 9), s.Vb(16, "h6", 10), s.Cc(17, "Integration"), s.Ub(), s.Qb(18, "mat-progress-bar", 11), s.Vb(19, "h6", 10), s.Cc(20, "SDK"), s.Ub(), s.Qb(21, "mat-progress-bar", 12), s.Ub(), s.Ub(), s.Ub()), 2 & t && (s.Db(18), s.lc("value", e.performanceChartData.integration), s.Db(3), s.lc("value", e.performanceChartData.sdk))
                    },
                    directives: [l.a, l.e, m.a, l.b, x.a],
                    styles: [".performance-chart[_ngcontent-%COMP%]{box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549);display:flex;flex-direction:column;height:192px;justify-content:space-between}.performance-chart__header[_ngcontent-%COMP%]{align-items:center;color:#6e6e6e;display:flex;justify-content:space-between}.performance-chart__header-title[_ngcontent-%COMP%]{font-size:20px;font-weight:400;margin:0;line-height:40px}.performance-chart__content[_ngcontent-%COMP%]{display:flex;height:70%;flex-direction:column;justify-content:space-between}.performance-chart__content-header[_ngcontent-%COMP%]{display:flex}.performance-chart__content-header-item[_ngcontent-%COMP%]{align-items:center;display:flex;margin-right:16px}.performance-chart__content-header-item-icon_blue[_ngcontent-%COMP%]{background-color:#536dfe;border-radius:50%;width:5px;height:5px}.performance-chart__content-header-item-icon_yellow[_ngcontent-%COMP%]{background-color:#ffc260;border-radius:50%;width:5px;height:5px}.performance-chart__content-header-item-text[_ngcontent-%COMP%]{margin-left:8px;color:#6e6e6e}.performance-chart__progress-title[_ngcontent-%COMP%]{margin:20px 0 5px;font-weight:400;font-size:21px;color:#6e6e6e}.performance-chart__progress-bar[_ngcontent-%COMP%]{margin-bottom:8px}@media (576px){.performance-chart__progress-bar[_ngcontent-%COMP%]{margin-bottom:10px}}"]
                }), t
            })();
            var w = i("ofXK"),
                C = i("CV0D");

            function k(t, e) {
                if (1 & t && (s.Vb(0, "div", 5), s.Vb(1, "p", 6), s.Cc(2), s.Ub(), s.Qb(3, "apx-chart", 7), s.Ub()), 2 & t) {
                    const t = e.$implicit,
                        i = e.index,
                        n = s.gc();
                    s.Db(2), s.Dc(n.serverDataTitles[i]), s.Db(1), s.lc("series", t.series)("chart", t.chart)("xaxis", t.xaxis)("stroke", t.stroke)("dataLabels", t.dataLabels)("yaxis", t.yaxis)("labels", t.labels)("legend", t.legend)("grid", t.grid)("tooltip", t.tooltip)("colors", t.colors)("fill", t.fill)
                }
            }
            let S = (() => {
                class t {
                    constructor() {
                        this.colors = g.a
                    }
                    ngOnInit() {
                        this.charts = [this.initChart(this.serverChartData.firstServerChartData, g.a.PINK), this.initChart(this.serverChartData.secondServerChartData, g.a.BLUE), this.initChart(this.serverChartData.thirdServerChartData, g.a.YELLOW)], this.serverDataTitles = [this.serverChartData.firstDataTitle, this.serverChartData.secondDataTitle, this.serverChartData.thirdDataTitle]
                    }
                    initChart(t, e) {
                        return {
                            chart: {
                                type: "area",
                                height: 80,
                                zoom: {
                                    enabled: !1
                                },
                                toolbar: {
                                    show: !1
                                }
                            },
                            series: [{
                                name: "STOCK ABC",
                                data: t
                            }],
                            colors: [e],
                            fill: {
                                type: "solid",
                                opacity: .3
                            },
                            dataLabels: {
                                enabled: !1
                            },
                            stroke: {
                                curve: "smooth",
                                width: 2
                            },
                            labels: this.serverChartData.dates,
                            xaxis: {
                                type: "datetime",
                                labels: {
                                    show: !1
                                },
                                axisBorder: {
                                    show: !1
                                },
                                axisTicks: {
                                    show: !1
                                }
                            },
                            yaxis: {
                                max: 5e4,
                                show: !1
                            },
                            legend: {
                                show: !1
                            },
                            grid: {
                                show: !1,
                                padding: {
                                    bottom: 0,
                                    left: 0,
                                    right: 0,
                                    top: 0
                                }
                            },
                            tooltip: {
                                enabled: !1
                            }
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-server-chart"]
                    ],
                    inputs: {
                        serverChartData: "serverChartData"
                    },
                    decls: 7,
                    vars: 1,
                    consts: [
                        [1, "server-chart"],
                        [1, "server-chart__header"],
                        [1, "server-chart__header-title"],
                        [1, "server-chart__content"],
                        ["class", "server-chart__content-item", 4, "ngFor", "ngForOf"],
                        [1, "server-chart__content-item"],
                        [1, "server-chart__content-item-text"],
                        [3, "series", "chart", "xaxis", "stroke", "dataLabels", "yaxis", "labels", "legend", "grid", "tooltip", "colors", "fill"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "h5", 2), s.Cc(3, "Server Overview"), s.Ub(), s.Qb(4, "app-settings-menu"), s.Ub(), s.Vb(5, "mat-card-content", 3), s.Bc(6, k, 4, 13, "div", 4), s.Ub(), s.Ub()), 2 & t && (s.Db(6), s.lc("ngForOf", e.charts))
                    },
                    directives: [l.a, l.e, m.a, l.b, w.k, C.a],
                    styles: [".server-chart[_ngcontent-%COMP%]{box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549);display:flex;flex-direction:column;height:192px}.server-chart__header[_ngcontent-%COMP%]{align-items:center;color:#6e6e6e;display:flex;justify-content:space-between}.server-chart__header-title[_ngcontent-%COMP%]{font-size:21px;font-weight:400;margin:0;line-height:40px}.server-chart__content[_ngcontent-%COMP%]{display:flex;flex-direction:column;height:100%;justify-content:space-between}.server-chart__content-item[_ngcontent-%COMP%]{align-items:center;display:flex;height:50px;justify-content:space-between}.server-chart__content-item-text[_ngcontent-%COMP%]{width:100%;color:#6e6e6e;font-weight:400;font-size:14px;padding-right:16px;margin:0}"]
                }), t
            })();
            var A = i("DKVz");
            let O = (() => {
                class t {
                    constructor() {
                        this.colors = g.a
                    }
                    ngOnInit() {
                        this.initChart()
                    }
                    initChart() {
                        this.revenueChart = {
                            color: [g.a.GREEN, g.a.PINK, g.a.YELLOW, g.a.BLUE],
                            tooltip: {
                                trigger: "item"
                            },
                            legend: {
                                top: "center",
                                right: "right",
                                data: ["Group A", "Group B", "Group C", "Group D"],
                                textStyle: {
                                    color: "#6E6E6E"
                                }
                            },
                            series: [{
                                type: "pie",
                                radius: ["50%", "70%"],
                                center: ["24%", "50%"],
                                label: {
                                    show: !1
                                },
                                labelLine: {
                                    normal: {
                                        show: !1
                                    }
                                },
                                hoverAnimation: !1,
                                avoidLabelOverlap: !1,
                                data: [{
                                    name: "Group A",
                                    value: this.revenueCharData.groupA
                                }, {
                                    name: "Group B",
                                    value: this.revenueCharData.groupB
                                }, {
                                    name: "Group C",
                                    value: this.revenueCharData.groupC
                                }, {
                                    name: "Group D",
                                    value: this.revenueCharData.groupD
                                }]
                            }]
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-revenue-chart"]
                    ],
                    inputs: {
                        revenueCharData: "revenueCharData"
                    },
                    decls: 7,
                    vars: 1,
                    consts: [
                        [1, "revenue-chart"],
                        [1, "revenue-chart__header"],
                        [1, "revenue-chart__header-title"],
                        [1, "revenue-chart__content"],
                        ["echarts", "", 1, "revenue-chart__content-chart", 3, "options"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "h5", 2), s.Cc(3, "Revenue Breakdown"), s.Ub(), s.Qb(4, "app-settings-menu"), s.Ub(), s.Vb(5, "mat-card-content", 3), s.Qb(6, "div", 4), s.Ub(), s.Ub()), 2 & t && (s.Db(6), s.lc("options", e.revenueChart))
                    },
                    directives: [l.a, l.e, m.a, l.b, A.a],
                    styles: [".revenue-chart[_ngcontent-%COMP%]{height:192px;box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549)}.revenue-chart__header[_ngcontent-%COMP%]{color:#6e6e6e;display:flex;justify-content:space-between}.revenue-chart__header-title[_ngcontent-%COMP%]{font-size:20px;font-weight:400;margin:0;line-height:40px}.revenue-chart__content[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.revenue-chart__content-chart[_ngcontent-%COMP%]{height:140px;width:100%;max-width:218px}"]
                }), t
            })();
            var E = i("d3UM"),
                P = i("3Pt+"),
                T = i("FKr1");
            const D = ["chart"];
            var I = function(t) {
                return t.daily = "Daily", t.weekly = "Weekly", t.monthly = "Monthly", t
            }({});
            let M = (() => {
                class t {
                    constructor() {
                        this.matSelectFields = I, this.selectedMatSelectValue = I.monthly, this.colors = g.a
                    }
                    ngOnInit() {
                        this.initChart(this.dailyLineChartData.monthlyData, this.dailyLineChartData.labels)
                    }
                    ngAfterViewInit() {
                        this.chartObj = new ApexCharts(this.chart.nativeElement, this.chartOptions), this.chartObj.render()
                    }
                    initChart(t, e) {
                        this.chartOptions = {
                            legend: {
                                show: !1
                            },
                            markers: {
                                size: [0, 0, 5]
                            },
                            series: [{
                                name: "Mobile",
                                type: "line",
                                data: t.mobile
                            }, {
                                name: "Desktop",
                                type: "area",
                                data: t.desktop
                            }, {
                                name: "Tablet",
                                type: "line",
                                data: t.tablet
                            }],
                            colors: [g.a.BLUE, g.a.LIGHT_BLUE, g.a.YELLOW],
                            chart: {
                                toolbar: {
                                    show: !1
                                },
                                height: 350,
                                width: "100%",
                                type: "line",
                                stacked: !0
                            },
                            stroke: {
                                width: [2, 0, 2],
                                curve: ["smooth", "smooth", "straight"]
                            },
                            plotOptions: {
                                bar: {
                                    columnWidth: "50%"
                                }
                            },
                            grid: {
                                yaxis: {
                                    lines: {
                                        show: !1
                                    }
                                }
                            },
                            fill: {
                                opacity: 1,
                                gradient: {
                                    inverseColors: !1,
                                    shade: "light",
                                    type: "vertical",
                                    opacityFrom: .85,
                                    opacityTo: .55,
                                    stops: [0, 100, 100, 100]
                                }
                            },
                            labels: e,
                            xaxis: {
                                type: "datetime",
                                labels: {
                                    style: {
                                        colors: "#4A4A4A",
                                        fontSize: "0.875rem",
                                        fontFamily: "Roboto, Helvetica, Arial, sans-serif",
                                        fontWeight: 400
                                    }
                                }
                            },
                            yaxis: {
                                show: !0,
                                labels: {
                                    style: {
                                        colors: "#4A4A4A",
                                        fontSize: "0.875rem",
                                        fontFamily: "Roboto, Helvetica, Arial, sans-serif",
                                        fontWeight: 400
                                    }
                                }
                            },
                            tooltip: {
                                custom: ({}) => '<div><div style="padding: 16px; 16px; display: flex; align-items: center;"> <div style="width: 8px; height: 8px; border-radius: 50%; background-color: #FFC260"></div><span style="color: #4A4A4A; margin-left: 8px">mobile</span></div><div style="padding: 16px; 16px; display: flex; align-items: center;"> <div style="width: 8px; height: 8px; border-radius: 50%; background-color: #536DFE"></div><span style="color: #4A4A4A; margin-left: 8px">desktop</span></div><div style="padding: 16px; 16px; display: flex; align-items: center;"> <div style="width: 8px; height: 8px; border-radius: 50%; background-color: #B1BCFF"></div><span style="color: #4A4A4A; margin-left: 8px">tablet</span></div></div>'
                            }
                        }
                    }
                    changedMatSelectionValue() {
                        switch (this.selectedMatSelectValue) {
                            case I.daily:
                                this.chartOptions = Object.assign(Object.assign({}, this.chartOptions), {
                                    series: [{
                                        name: "Mobile",
                                        type: "line",
                                        data: this.dailyLineChartData.dailyData.mobile
                                    }, {
                                        name: "Desktop",
                                        type: "area",
                                        data: this.dailyLineChartData.dailyData.desktop
                                    }, {
                                        name: "Tablet",
                                        type: "line",
                                        data: this.dailyLineChartData.dailyData.tablet
                                    }]
                                });
                                break;
                            case I.weekly:
                                this.chartOptions = Object.assign(Object.assign({}, this.chartOptions), {
                                    series: [{
                                        name: "Mobile",
                                        type: "line",
                                        data: this.dailyLineChartData.weeklyData.mobile
                                    }, {
                                        name: "Desktop",
                                        type: "area",
                                        data: this.dailyLineChartData.weeklyData.desktop
                                    }, {
                                        name: "Tablet",
                                        type: "line",
                                        data: this.dailyLineChartData.weeklyData.tablet
                                    }]
                                });
                                break;
                            default:
                                this.chartOptions = Object.assign(Object.assign({}, this.chartOptions), {
                                    series: [{
                                        name: "Mobile",
                                        type: "line",
                                        data: this.dailyLineChartData.monthlyData.mobile
                                    }, {
                                        name: "Desktop",
                                        type: "area",
                                        data: this.dailyLineChartData.monthlyData.desktop
                                    }, {
                                        name: "Tablet",
                                        type: "line",
                                        data: this.dailyLineChartData.monthlyData.tablet
                                    }]
                                })
                        }
                        this.chartObj.updateSeries(this.chartOptions.series)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-daily-line-chart"]
                    ],
                    viewQuery: function(t, e) {
                        if (1 & t && s.Hc(D, 1), 2 & t) {
                            let t;
                            s.rc(t = s.dc()) && (e.chart = t.first)
                        }
                    },
                    inputs: {
                        dailyLineChartData: "dailyLineChartData"
                    },
                    decls: 27,
                    vars: 4,
                    consts: [
                        [1, "chart"],
                        [1, "chart__header"],
                        [1, "chart__title"],
                        [1, "chart-legend"],
                        [1, "chart-legend__item"],
                        [1, "chart-legend__icon", "yellow"],
                        [1, "chart-legend__title"],
                        [1, "chart-legend__icon", "blue"],
                        [1, "chart-legend__icon", "light-blue"],
                        [1, "chart-select", 3, "ngModel", "ngModelChange", "selectionChange"],
                        [3, "value"],
                        [1, "chart__content"],
                        [1, "chart__content-item"],
                        ["chart", ""]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "p", 2), s.Cc(3, "Daily Line Chart"), s.Ub(), s.Vb(4, "div", 3), s.Vb(5, "div", 4), s.Qb(6, "div", 5), s.Vb(7, "span", 6), s.Cc(8, "Tablet"), s.Ub(), s.Ub(), s.Vb(9, "div", 4), s.Qb(10, "div", 7), s.Vb(11, "span", 6), s.Cc(12, "Mobile"), s.Ub(), s.Ub(), s.Vb(13, "div", 4), s.Qb(14, "div", 8), s.Vb(15, "span", 6), s.Cc(16, "Desktop"), s.Ub(), s.Ub(), s.Ub(), s.Vb(17, "mat-select", 9), s.cc("ngModelChange", function(t) {
                            return e.selectedMatSelectValue = t
                        })("selectionChange", function() {
                            return e.changedMatSelectionValue()
                        }), s.Vb(18, "mat-option", 10), s.Cc(19, "Daily"), s.Ub(), s.Vb(20, "mat-option", 10), s.Cc(21, "Weekly"), s.Ub(), s.Vb(22, "mat-option", 10), s.Cc(23, "Monthly"), s.Ub(), s.Ub(), s.Ub(), s.Vb(24, "mat-card-content", 11), s.Qb(25, "div", 12, 13), s.Ub(), s.Ub()), 2 & t && (s.Db(17), s.lc("ngModel", e.selectedMatSelectValue), s.Db(1), s.lc("value", e.matSelectFields.daily), s.Db(2), s.lc("value", e.matSelectFields.weekly), s.Db(2), s.lc("value", e.matSelectFields.monthly))
                    },
                    directives: [l.a, l.e, E.a, P.k, P.n, T.h, l.b],
                    styles: [".chart[_ngcontent-%COMP%]{box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549);margin:16px 24px}.chart__header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;padding:8px}@media (max-width:576px){.chart__header[_ngcontent-%COMP%]{flex-wrap:wrap}}.chart__title[_ngcontent-%COMP%]{margin:0;display:flex;align-items:center;color:#6e6e6e;font-weight:500;font-size:18px;text-transform:none;line-height:1.6;letter-spacing:.12px;order:1}.chart__content[_ngcontent-%COMP%]{height:380px;width:100%}@media (max-width:576px){.chart__content[_ngcontent-%COMP%]{overflow-x:scroll}.chart__content-item[_ngcontent-%COMP%]{width:600px}}.chart-legend[_ngcontent-%COMP%]{display:flex;order:2}.chart-legend__item[_ngcontent-%COMP%]{display:flex;align-items:center;margin-top:2.24px;margin-right:24px}.chart-legend__icon[_ngcontent-%COMP%]{width:5px;height:5px;border-radius:50%}.chart-legend__title[_ngcontent-%COMP%]{text-transform:none;font-weight:500;font-size:18px;color:#6e6e6e;margin-left:8px}@media (max-width:576px){.chart-legend[_ngcontent-%COMP%]{margin-top:20px;order:3}}.chart-select[_ngcontent-%COMP%]{order:3}@media (max-width:576px){.chart-select[_ngcontent-%COMP%]{order:2}}.yellow[_ngcontent-%COMP%]{background-color:#ffc260}.blue[_ngcontent-%COMP%]{background-color:#536dfe}.light-blue[_ngcontent-%COMP%]{background-color:#b1bcff}"]
                }), t
            })();
            var L = function(t) {
                return t.daily = "Daily", t.weekly = "Weekly", t.monthly = "Monthly", t
            }({});
            let R = (() => {
                class t {
                    constructor() {
                        this.changeDateType = new s.o, this.matSelectFields = L, this.selectedMatSelectValue = L.daily
                    }
                    changedMatSelectionValue(t) {
                        this.changeDateType.emit(t)
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-date-menu"]
                    ],
                    outputs: {
                        changeDateType: "changeDateType"
                    },
                    decls: 7,
                    vars: 4,
                    consts: [
                        [1, "date-menu", 3, "ngModel", "ngModelChange", "selectionChange"],
                        [3, "value"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-select", 0), s.cc("ngModelChange", function(t) {
                            return e.selectedMatSelectValue = t
                        })("selectionChange", function(t) {
                            return e.changedMatSelectionValue(t.value)
                        }), s.Vb(1, "mat-option", 1), s.Cc(2, "Daily"), s.Ub(), s.Vb(3, "mat-option", 1), s.Cc(4, "Weekly"), s.Ub(), s.Vb(5, "mat-option", 1), s.Cc(6, "Monthly"), s.Ub(), s.Ub()), 2 & t && (s.lc("ngModel", e.selectedMatSelectValue), s.Db(1), s.lc("value", e.matSelectFields.daily), s.Db(2), s.lc("value", e.matSelectFields.weekly), s.Db(2), s.lc("value", e.matSelectFields.monthly))
                    },
                    directives: [E.a, P.k, P.n, T.h],
                    styles: [".date-menu[_ngcontent-%COMP%]{border:none;width:55px;padding:8px 0 8px 4px}"]
                }), t
            })();
            var j = i("NFeN");

            function F(t, e) {
                if (1 & t && (s.Vb(0, "p", 20), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("+", t.selectedStatsLightBlueData.percent, "%")
                }
            }

            function N(t, e) {
                if (1 & t && (s.Vb(0, "p", 21), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("", t.selectedStatsLightBlueData.percent, "%")
                }
            }

            function z(t, e) {
                if (1 & t && (s.Vb(0, "p", 20), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("+", t.selectedStatsSingAppData.percent, "%")
                }
            }

            function V(t, e) {
                if (1 & t && (s.Vb(0, "p", 21), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("", t.selectedStatsSingAppData.percent, "%")
                }
            }

            function B(t, e) {
                if (1 & t && (s.Vb(0, "p", 20), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("+", t.selectedStatsRNSData.percent, "%")
                }
            }

            function H(t, e) {
                if (1 & t && (s.Vb(0, "p", 21), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc();
                    s.Db(1), s.Ec("", t.selectedStatsRNSData.percent, "%")
                }
            }
            var U = function(t) {
                return t.lightBlue = "lightBlue", t.SingApp = "SingApp", t.RNS = "RNS", t
            }({});
            let X = (() => {
                class t {
                    constructor() {
                        this.projectsType = U, this.colors = g.a
                    }
                    ngOnInit() {
                        this.selectedStatsLightBlueData = this.projectsStatsData.lightBlue.daily, this.selectedStatsSingAppData = this.projectsStatsData.singApp.daily, this.selectedStatsRNSData = this.projectsStatsData.rns.daily, this.initChart()
                    }
                    initChart() {
                        this.chartOptions = {
                            chart: {
                                type: "bar",
                                height: 100,
                                width: 130,
                                toolbar: {
                                    show: !1
                                }
                            },
                            legend: {
                                show: !1
                            },
                            grid: {
                                show: !1
                            },
                            plotOptions: {
                                bar: {
                                    horizontal: !1,
                                    columnWidth: "70%"
                                }
                            },
                            dataLabels: {
                                enabled: !1
                            },
                            stroke: {
                                show: !0,
                                width: 2,
                                colors: ["transparent"]
                            },
                            xaxis: {
                                categories: ["Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug"],
                                labels: {
                                    show: !1
                                },
                                axisTicks: {
                                    show: !1
                                },
                                axisBorder: {
                                    show: !1
                                }
                            },
                            yaxis: {
                                show: !1
                            },
                            tooltip: {
                                y: {
                                    formatter: t => "$ " + t + " thousands"
                                }
                            }
                        }
                    }
                    changeDateType(t, e) {
                        switch (e) {
                            case this.projectsType.lightBlue:
                                switch (t) {
                                    case "Weekly":
                                        this.selectedStatsLightBlueData = this.projectsStatsData.lightBlue.week;
                                        break;
                                    case "Monthly":
                                        this.selectedStatsLightBlueData = this.projectsStatsData.lightBlue.monthly;
                                        break;
                                    default:
                                        this.selectedStatsLightBlueData = this.projectsStatsData.lightBlue.daily
                                }
                                break;
                            case this.projectsType.SingApp:
                                switch (t) {
                                    case "Weekly":
                                        this.selectedStatsSingAppData = this.projectsStatsData.singApp.week;
                                        break;
                                    case "Monthly":
                                        this.selectedStatsSingAppData = this.projectsStatsData.singApp.monthly;
                                        break;
                                    default:
                                        this.selectedStatsSingAppData = this.projectsStatsData.singApp.daily
                                }
                                break;
                            case this.projectsType.RNS:
                                switch (t) {
                                    case "Weekly":
                                        this.selectedStatsRNSData = this.projectsStatsData.rns.week;
                                        break;
                                    case "Monthly":
                                        this.selectedStatsRNSData = this.projectsStatsData.rns.monthly;
                                        break;
                                    default:
                                        this.selectedStatsRNSData = this.projectsStatsData.rns.daily
                                }
                        }
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-project-stat-chart"]
                    ],
                    inputs: {
                        projectsStatsData: "projectsStatsData"
                    },
                    decls: 118,
                    vars: 57,
                    consts: [
                        [1, "project-stat"],
                        [1, "project-stat__item"],
                        [1, "project-stat__title"],
                        [1, "project-stat__title-text"],
                        [3, "changeDateType"],
                        [1, "project-stat-content"],
                        [1, "project-stat-content__total-info-wrapper"],
                        [1, "project-stat-content__total-info"],
                        [1, "project-stat-content__total-info-users"],
                        ["class", "project-stat-content__total-info-percent", 4, "ngIf"],
                        ["class", "project-stat-content__total-info-percent-warn", 4, "ngIf"],
                        [1, "project-stat-content__total-info-chart"],
                        [3, "series", "chart", "dataLabels", "plotOptions", "yaxis", "legend", "fill", "stroke", "tooltip", "xaxis", "grid", "colors"],
                        [1, "project-stat-content__stat-wrapper"],
                        [1, "project-stat-content__stat-item"],
                        [1, "project-stat-content__stat-value-wrapper"],
                        [1, "project-stat-content__stat-value"],
                        [1, "project-stat-content__stat-icon"],
                        [1, "project-stat-content__stat-item-title"],
                        [1, "project-stat-content__stat-icon-warn"],
                        [1, "project-stat-content__total-info-percent"],
                        [1, "project-stat-content__total-info-percent-warn"]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "div", 0), s.Vb(1, "mat-card", 1), s.Vb(2, "mat-card-title", 2), s.Vb(3, "h5", 3), s.Cc(4), s.Ub(), s.Vb(5, "app-date-menu", 4), s.cc("changeDateType", function(t) {
                            return e.changeDateType(t, e.projectsType.lightBlue)
                        }), s.Ub(), s.Ub(), s.Vb(6, "mat-card-content", 5), s.Vb(7, "div", 6), s.Vb(8, "div", 7), s.Vb(9, "p", 8), s.Cc(10), s.Ub(), s.Bc(11, F, 2, 1, "p", 9), s.Bc(12, N, 2, 1, "p", 10), s.Ub(), s.Vb(13, "div", 11), s.Qb(14, "apx-chart", 12), s.Ub(), s.Ub(), s.Vb(15, "div", 13), s.Vb(16, "div", 14), s.Vb(17, "div", 15), s.Vb(18, "h6", 16), s.Cc(19), s.Ub(), s.Vb(20, "mat-icon", 17), s.Cc(21, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(22, "p", 18), s.Cc(23, "Registrations"), s.Ub(), s.Ub(), s.Vb(24, "div", 14), s.Vb(25, "div", 15), s.Vb(26, "h6", 16), s.Cc(27), s.Ub(), s.Vb(28, "mat-icon", 17), s.Cc(29, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(30, "p", 18), s.Cc(31, "Bounce Rate"), s.Ub(), s.Ub(), s.Vb(32, "div", 14), s.Vb(33, "div", 15), s.Vb(34, "h6", 16), s.Cc(35), s.Ub(), s.Vb(36, "mat-icon", 19), s.Cc(37, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(38, "p", 18), s.Cc(39, "Views"), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Vb(40, "mat-card", 1), s.Vb(41, "mat-card-title", 2), s.Vb(42, "h5", 3), s.Cc(43), s.Ub(), s.Vb(44, "app-date-menu", 4), s.cc("changeDateType", function(t) {
                            return e.changeDateType(t, e.projectsType.SingApp)
                        }), s.Ub(), s.Ub(), s.Vb(45, "mat-card-content", 5), s.Vb(46, "div", 6), s.Vb(47, "div", 7), s.Vb(48, "p", 8), s.Cc(49), s.Ub(), s.Bc(50, z, 2, 1, "p", 9), s.Bc(51, V, 2, 1, "p", 10), s.Ub(), s.Vb(52, "div", 11), s.Qb(53, "apx-chart", 12), s.Ub(), s.Ub(), s.Vb(54, "div", 13), s.Vb(55, "div", 14), s.Vb(56, "div", 15), s.Vb(57, "h6", 16), s.Cc(58), s.Ub(), s.Vb(59, "mat-icon", 17), s.Cc(60, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(61, "p", 18), s.Cc(62, "Registrations"), s.Ub(), s.Ub(), s.Vb(63, "div", 14), s.Vb(64, "div", 15), s.Vb(65, "h6", 16), s.Cc(66), s.Ub(), s.Vb(67, "mat-icon", 17), s.Cc(68, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(69, "p", 18), s.Cc(70, "Bounce Rate"), s.Ub(), s.Ub(), s.Vb(71, "div", 14), s.Vb(72, "div", 15), s.Vb(73, "h6", 16), s.Cc(74), s.Ub(), s.Vb(75, "mat-icon", 17), s.Cc(76, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(77, "p", 18), s.Cc(78, "Views"), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Vb(79, "mat-card", 1), s.Vb(80, "mat-card-title", 2), s.Vb(81, "h5", 3), s.Cc(82), s.Ub(), s.Vb(83, "app-date-menu", 4), s.cc("changeDateType", function(t) {
                            return e.changeDateType(t, e.projectsType.RNS)
                        }), s.Ub(), s.Ub(), s.Vb(84, "mat-card-content", 5), s.Vb(85, "div", 6), s.Vb(86, "div", 7), s.Vb(87, "p", 8), s.Cc(88), s.Ub(), s.Bc(89, B, 2, 1, "p", 9), s.Bc(90, H, 2, 1, "p", 10), s.Ub(), s.Vb(91, "div", 11), s.Qb(92, "apx-chart", 12), s.Ub(), s.Ub(), s.Vb(93, "div", 13), s.Vb(94, "div", 14), s.Vb(95, "div", 15), s.Vb(96, "h6", 16), s.Cc(97), s.Ub(), s.Vb(98, "mat-icon", 19), s.Cc(99, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(100, "p", 18), s.Cc(101, "Registrations"), s.Ub(), s.Ub(), s.Vb(102, "div", 14), s.Vb(103, "div", 15), s.Vb(104, "h6", 16), s.Cc(105), s.Ub(), s.Vb(106, "mat-icon", 17), s.Cc(107, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(108, "p", 18), s.Cc(109, "Bounce Rate"), s.Ub(), s.Ub(), s.Vb(110, "div", 14), s.Vb(111, "div", 15), s.Vb(112, "h6", 16), s.Cc(113), s.Ub(), s.Vb(114, "mat-icon", 17), s.Cc(115, "arrow_upward"), s.Ub(), s.Ub(), s.Vb(116, "p", 18), s.Cc(117, "Views"), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub()), 2 & t && (s.Db(4), s.Dc(e.selectedStatsLightBlueData.name), s.Db(6), s.Dc(e.selectedStatsLightBlueData.users), s.Db(1), s.lc("ngIf", e.selectedStatsLightBlueData.percent > 0), s.Db(1), s.lc("ngIf", e.selectedStatsLightBlueData.percent < 0), s.Db(2), s.lc("series", e.selectedStatsLightBlueData.series)("chart", e.chartOptions.chart)("dataLabels", e.chartOptions.dataLabels)("plotOptions", e.chartOptions.plotOptions)("yaxis", e.chartOptions.yaxis)("legend", e.chartOptions.legend)("fill", e.chartOptions.fill)("stroke", e.chartOptions.stroke)("tooltip", e.chartOptions.tooltip)("xaxis", e.chartOptions.xaxis)("grid", e.chartOptions.grid)("colors", e.colors.BLUE), s.Db(5), s.Dc(e.selectedStatsLightBlueData.registrations), s.Db(8), s.Dc(e.selectedStatsLightBlueData.bounce), s.Db(8), s.Dc(e.selectedStatsLightBlueData.views), s.Db(8), s.Dc(e.selectedStatsSingAppData.name), s.Db(6), s.Dc(e.selectedStatsSingAppData.users), s.Db(1), s.lc("ngIf", e.selectedStatsSingAppData.percent > 0), s.Db(1), s.lc("ngIf", e.selectedStatsSingAppData.percent < 0), s.Db(2), s.lc("series", e.selectedStatsSingAppData.series)("chart", e.chartOptions.chart)("dataLabels", e.chartOptions.dataLabels)("plotOptions", e.chartOptions.plotOptions)("yaxis", e.chartOptions.yaxis)("legend", e.chartOptions.legend)("fill", e.chartOptions.fill)("stroke", e.chartOptions.stroke)("tooltip", e.chartOptions.tooltip)("xaxis", e.chartOptions.xaxis)("grid", e.chartOptions.grid)("colors", e.colors.YELLOW), s.Db(5), s.Dc(e.selectedStatsSingAppData.registrations), s.Db(8), s.Dc(e.selectedStatsSingAppData.bounce), s.Db(8), s.Dc(e.selectedStatsSingAppData.views), s.Db(8), s.Dc(e.selectedStatsRNSData.name), s.Db(6), s.Dc(e.selectedStatsRNSData.users), s.Db(1), s.lc("ngIf", e.selectedStatsRNSData.percent > 0), s.Db(1), s.lc("ngIf", e.selectedStatsRNSData.percent < 0), s.Db(2), s.lc("series", e.selectedStatsRNSData.series)("chart", e.chartOptions.chart)("dataLabels", e.chartOptions.dataLabels)("plotOptions", e.chartOptions.plotOptions)("yaxis", e.chartOptions.yaxis)("legend", e.chartOptions.legend)("fill", e.chartOptions.fill)("stroke", e.chartOptions.stroke)("tooltip", e.chartOptions.tooltip)("xaxis", e.chartOptions.xaxis)("grid", e.chartOptions.grid)("colors", e.colors.PINK), s.Db(5), s.Dc(e.selectedStatsRNSData.registrations), s.Db(8), s.Dc(e.selectedStatsRNSData.bounce), s.Db(8), s.Dc(e.selectedStatsRNSData.views))
                    },
                    directives: [l.a, l.e, R, l.b, w.l, C.a, j.a],
                    styles: [".project-stat[_ngcontent-%COMP%]{display:flex;justify-content:space-around;width:calc(100% - 16px);margin:16px 8px}.project-stat__item[_ngcontent-%COMP%]{height:208px;margin:16px;width:100%;box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549)}@media (min-width:576px) and (max-width:992px){.project-stat__item[_ngcontent-%COMP%]{width:41.4%}}@media (min-width:992px) and (max-width:1024px){.project-stat__item[_ngcontent-%COMP%]{width:43.6%}}.project-stat__title[_ngcontent-%COMP%]{padding:8px;display:flex;justify-content:space-between;align-items:center}.project-stat__title-text[_ngcontent-%COMP%]{font-weight:400;font-size:21px;color:#4a4a4a;margin:0}@media (min-width:576px) and (max-width:1024px){.project-stat[_ngcontent-%COMP%]{justify-content:start}}@media (max-width:1024px){.project-stat[_ngcontent-%COMP%]{flex-wrap:wrap}}.project-stat-content[_ngcontent-%COMP%]{padding:8px}.project-stat-content__total-info-wrapper[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;height:70px}.project-stat-content__total-info[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-end}.project-stat-content__total-info-users[_ngcontent-%COMP%]{color:#6e6e6e;font-weight:400;font-size:42px;margin:0;height:45px;letter-spacing:.15px}.project-stat-content__total-info-percent[_ngcontent-%COMP%]{color:#3cd4a0;font-weight:400;font-size:14px;margin:0 0 0 5px}.project-stat-content__total-info-percent-warn[_ngcontent-%COMP%]{color:#ff4081;font-weight:400;font-size:14px;margin:0 0 0 5px}.project-stat-content__total-info-chart[_ngcontent-%COMP%]{position:relative;right:-9px;top:-2px}.project-stat-content__stat-wrapper[_ngcontent-%COMP%]{display:flex;justify-content:space-between;margin-top:24px}.project-stat-content__stat-value-wrapper[_ngcontent-%COMP%]{display:flex;align-items:center}.project-stat-content__stat-value[_ngcontent-%COMP%]{font-weight:400;font-size:18px;color:#4a4a4a;margin:0}.project-stat-content__stat-icon[_ngcontent-%COMP%]{transform:rotate(45deg);color:#3cd4a0}.project-stat-content__stat-icon-warn[_ngcontent-%COMP%]{transform:rotate(135deg);color:#ff4081}.project-stat-content__stat-item-title[_ngcontent-%COMP%]{color:#6e6e6e;font-weight:400;font-size:11.2px;margin:0}"]
                }), t
            })();
            var W = i("+0xr");

            function Y(t, e) {
                if (1 & t && (s.Vb(0, "th", 11), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc().$implicit;
                    s.Db(1), s.Dc(t)
                }
            }

            function G(t, e) {
                if (1 & t && (s.Vb(0, "span"), s.Cc(1), s.Ub()), 2 & t) {
                    const t = s.gc().$implicit,
                        e = s.gc().$implicit;
                    s.Db(1), s.Dc(t[e])
                }
            }

            function q(t, e) {
                if (1 & t && (s.Vb(0, "div", 15), s.Vb(1, "span"), s.Cc(2), s.Ub(), s.Ub()), 2 & t) {
                    const t = s.gc().$implicit,
                        e = s.gc().$implicit;
                    s.lc("ngClass", t[e]), s.Db(2), s.Dc(t[e])
                }
            }

            function Z(t, e) {
                if (1 & t && (s.Vb(0, "td", 12), s.Bc(1, G, 2, 1, "span", 13), s.Bc(2, q, 3, 2, "div", 14), s.Ub()), 2 & t) {
                    const t = s.gc().$implicit;
                    s.Db(1), s.lc("ngIf", "status" !== t), s.Db(1), s.lc("ngIf", "status" === t)
                }
            }

            function $(t, e) {
                1 & t && (s.Tb(0, 8), s.Bc(1, Y, 2, 1, "th", 9), s.Bc(2, Z, 3, 2, "td", 10), s.Sb()), 2 & t && s.mc("matColumnDef", e.$implicit)
            }

            function Q(t, e) {
                1 & t && s.Qb(0, "tr", 16)
            }

            function K(t, e) {
                1 & t && s.Qb(0, "tr", 17)
            }
            let J = (() => {
                class t {
                    constructor() {
                        this.displayedColumns = ["name", "email", "product", "price", "date", "city", "status"]
                    }
                }
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275cmp = s.Jb({
                    type: t,
                    selectors: [
                        ["app-support-requests"]
                    ],
                    inputs: {
                        supportRequestData: "supportRequestData"
                    },
                    decls: 10,
                    vars: 4,
                    consts: [
                        [1, "support-requests"],
                        [1, "support-requests__header"],
                        [1, "support-requests__title"],
                        [1, "support-requests__content"],
                        ["mat-table", "", 1, "support-requests__table", 3, "dataSource"],
                        ["class", "support-requests__table-row", 3, "matColumnDef", 4, "ngFor", "ngForOf"],
                        ["mat-header-row", "", 4, "matHeaderRowDef"],
                        ["mat-row", "", 4, "matRowDef", "matRowDefColumns"],
                        [1, "support-requests__table-row", 3, "matColumnDef"],
                        ["mat-header-cell", "", "class", "support-requests__table-row-title", 4, "matHeaderCellDef"],
                        ["mat-cell", "", "class", "support-requests__table-content", 4, "matCellDef"],
                        ["mat-header-cell", "", 1, "support-requests__table-row-title"],
                        ["mat-cell", "", 1, "support-requests__table-content"],
                        [4, "ngIf"],
                        ["class", "support-requests__content-badge", 3, "ngClass", 4, "ngIf"],
                        [1, "support-requests__content-badge", 3, "ngClass"],
                        ["mat-header-row", ""],
                        ["mat-row", ""]
                    ],
                    template: function(t, e) {
                        1 & t && (s.Vb(0, "mat-card", 0), s.Vb(1, "mat-card-title", 1), s.Vb(2, "h5", 2), s.Cc(3, "Support Requests"), s.Ub(), s.Qb(4, "app-settings-menu"), s.Ub(), s.Vb(5, "mat-card-content", 3), s.Vb(6, "table", 4), s.Bc(7, $, 3, 1, "ng-container", 5), s.Bc(8, Q, 1, 0, "tr", 6), s.Bc(9, K, 1, 0, "tr", 7), s.Ub(), s.Ub(), s.Ub()), 2 & t && (s.Db(6), s.lc("dataSource", e.supportRequestData), s.Db(1), s.lc("ngForOf", e.displayedColumns), s.Db(1), s.lc("matHeaderRowDef", e.displayedColumns), s.Db(1), s.lc("matRowDefColumns", e.displayedColumns))
                    },
                    directives: [l.a, l.e, m.a, l.b, W.j, w.k, W.g, W.i, W.c, W.e, W.b, W.d, W.a, w.l, w.j, W.f, W.h],
                    styles: [".support-requests[_ngcontent-%COMP%]{margin:0 24px;padding:0;box-shadow:0 3px 11px 0 #e8eafc,0 3px 3px -2px hsla(0,0%,69.8%,.10196078431372549),0 1px 8px 0 hsla(0,0%,60.4%,.10196078431372549)}.support-requests__header[_ngcontent-%COMP%]{color:#6e6e6e;display:flex;justify-content:space-between;padding:24px 24px 8px;margin-bottom:0}.support-requests__title[_ngcontent-%COMP%]{font-size:21px;font-weight:400;margin:0;line-height:40px}.support-requests__content[_ngcontent-%COMP%]{height:427px;overflow-y:hidden;overflow-x:scroll}@media (max-width:576px){.support-requests__content[_ngcontent-%COMP%]{height:auto}}.support-requests__table[_ngcontent-%COMP%]{width:100%}.support-requests__table-row[_ngcontent-%COMP%]{height:64px}.support-requests__table-row-title[_ngcontent-%COMP%]{color:#4a4a4a;font-size:14px;font-weight:400;line-height:24px;text-transform:uppercase;padding:18.4px}.support-requests__table-content[_ngcontent-%COMP%]{color:#4a4a4a;font-size:14px;padding:20px}.support-requests__content-badge[_ngcontent-%COMP%]{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;border-radius:32px;color:#fff;text-align:center;padding:5px 10px;font-size:13px;box-sizing:border-box;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.75;letter-spacing:.45px}.support-requests__content-badge[_ngcontent-%COMP%]:first-letter{text-transform:uppercase}mat-menu[_ngcontent-%COMP%]{position:absolute}.send[_ngcontent-%COMP%]{background-color:#3cd4a0}.pending[_ngcontent-%COMP%]{background-color:#ffc260}.declined[_ngcontent-%COMP%]{background-color:#ff4081}"]
                }), t
            })();
            var tt = i("jQpT");
            let et = (() => {
                    class t {
                        constructor(t) {
                            this.service = t, this.dailyLineChartData$ = this.service.loadDailyLineChartData(), this.performanceChartData$ = this.service.loadPerformanceChartData(), this.revenueChartData$ = this.service.loadRevenueChartData(), this.serverChartData$ = this.service.loadServerChartData(), this.supportRequestData$ = this.service.loadSupportRequestData(), this.visitsChartData$ = this.service.loadVisitsChartData(), this.projectsStatsData$ = this.service.loadProjectsStatsData()
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)(s.Pb(d.a))
                    }, t.\u0275cmp = s.Jb({
                        type: t,
                        selectors: [
                            ["app-dashboard-page"]
                        ],
                        decls: 26,
                        vars: 21,
                        consts: [
                            ["role", "heading", 1, "page-header"],
                            ["mat-flat-button", "", "color", "warn"],
                            [1, "charts-wrapper"],
                            [1, "chart"],
                            [3, "visitsChartData"],
                            [3, "performanceChartData"],
                            [3, "serverChartData"],
                            [3, "revenueCharData"],
                            [3, "dailyLineChartData"],
                            [3, "projectsStatsData"],
                            [3, "supportRequestData"]
                        ],
                        template: function(t, e) {
                            1 & t && (s.Vb(0, "app-layout"), s.Vb(1, "mat-toolbar", 0), s.Vb(2, "h1"), s.Cc(3, "Dashboard"), s.Ub(), s.Vb(4, "button", 1), s.Cc(5, "Latest Reports"), s.Ub(), s.Ub(), s.Vb(6, "div", 2), s.Vb(7, "div", 3), s.Qb(8, "app-visits-chart", 4), s.hc(9, "async"), s.Ub(), s.Vb(10, "div", 3), s.Qb(11, "app-performance-chart", 5), s.hc(12, "async"), s.Ub(), s.Vb(13, "div", 3), s.Qb(14, "app-server-chart", 6), s.hc(15, "async"), s.Ub(), s.Vb(16, "div", 3), s.Qb(17, "app-revenue-chart", 7), s.hc(18, "async"), s.Ub(), s.Ub(), s.Qb(19, "app-daily-line-chart", 8), s.hc(20, "async"), s.Qb(21, "app-project-stat-chart", 9), s.hc(22, "async"), s.Qb(23, "app-support-requests", 10), s.hc(24, "async"), s.Qb(25, "app-footer"), s.Ub()), 2 & t && (s.Db(8), s.lc("visitsChartData", s.ic(9, 7, e.visitsChartData$)), s.Db(3), s.lc("performanceChartData", s.ic(12, 9, e.performanceChartData$)), s.Db(3), s.lc("serverChartData", s.ic(15, 11, e.serverChartData$)), s.Db(3), s.lc("revenueCharData", s.ic(18, 13, e.revenueChartData$)), s.Db(2), s.lc("dailyLineChartData", s.ic(20, 15, e.dailyLineChartData$)), s.Db(2), s.lc("projectsStatsData", s.ic(22, 17, e.projectsStatsData$)), s.Db(2), s.lc("supportRequestData", s.ic(24, 19, e.supportRequestData$)))
                        },
                        directives: [p.a, f.a, c.b, v, _, S, O, M, X, J, tt.a],
                        pipes: [w.b],
                        styles: [".charts-wrapper[_ngcontent-%COMP%]{display:flex;margin:0 8px}@media (max-width:1024px){.charts-wrapper[_ngcontent-%COMP%]{flex-wrap:wrap}}.chart[_ngcontent-%COMP%]{width:100%}@media (max-width:1024px){.chart[_ngcontent-%COMP%]{width:50%}}@media (max-width:576px){.chart[_ngcontent-%COMP%]{width:100%}}"]
                    }), t
                })(),
                it = (() => {
                    class t {
                        constructor() {
                            this.routes = g.b
                        }
                    }
                    return t.\u0275fac = function(e) {
                        return new(e || t)
                    }, t.\u0275cmp = s.Jb({
                        type: t,
                        selectors: [
                            ["app-not-found"]
                        ],
                        decls: 16,
                        vars: 1,
                        consts: [
                            [1, "not-found-page"],
                            [1, "not-found-page__content"],
                            [1, "not-found-page__title"],
                            ["src", "/flat/static/tte/assets/hot-found/logo.svg", "alt", "logo", 1, "not-found-page__title-img"],
                            [1, "not-found-page__title-text"],
                            [1, "not-found-page__card"],
                            [1, "not-found-page__card-title"],
                            [1, "not-found-page__card-sub-title"],
                            [1, "not-found-page__card-sub-title-second"],
                            ["mat-raised-button", "", "color", "primary", 1, "not-found-page__card-button", 3, "routerLink"]
                        ],
                        template: function(t, e) {
                            1 & t && (s.Vb(0, "div", 0), s.Vb(1, "div", 1), s.Vb(2, "div", 2), s.Qb(3, "img", 3), s.Vb(4, "h3", 4), s.Cc(5, "Material Admin"), s.Ub(), s.Ub(), s.Vb(6, "mat-card", 5), s.Vb(7, "mat-card-content", 1), s.Vb(8, "h1", 6), s.Cc(9, "404"), s.Ub(), s.Vb(10, "p", 7), s.Cc(11, "Oops. Looks like the page you're looking for no longer exists"), s.Ub(), s.Vb(12, "p", 8), s.Cc(13, "But we're here to bring you back to safety"), s.Ub(), s.Vb(14, "button", 9), s.Cc(15, "Back to Home"), s.Ub(), s.Ub(), s.Ub(), s.Ub(), s.Ub()), 2 & t && (s.Db(14), s.lc("routerLink", e.routes.DASHBOARD))
                        },
                        directives: [l.a, l.b, c.b, a.c],
                        styles: [".not-found-page[_ngcontent-%COMP%]{background-color:#536dfe;display:flex;justify-content:center;height:100vh}.not-found-page__content[_ngcontent-%COMP%]{width:355px}.not-found-page__title[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;margin-top:42px;margin-bottom:67px}.not-found-page__title-img[_ngcontent-%COMP%]{width:48px;margin-left:20px;margin-top:-6px}.not-found-page__title-text[_ngcontent-%COMP%]{color:#fff;margin:1px 30px 0 0;font-weight:500;font-size:32px;letter-spacing:.6px}.not-found-page__card[_ngcontent-%COMP%]{box-sizing:border-box;width:100%;height:70vh;padding:56px 0 36px;margin:0}.not-found-page__card-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center}.not-found-page__card-title[_ngcontent-%COMP%]{font-size:107px;font-weight:500;color:#536dfe;line-height:108px;text-align:center}.not-found-page__card-sub-title[_ngcontent-%COMP%]{margin-top:30px;font-size:16px;font-weight:400;letter-spacing:-.05px;color:#536dfe;text-align:center}.not-found-page__card-sub-title-second[_ngcontent-%COMP%]{margin-top:30px;font-size:16px;font-weight:400;letter-spacing:-.2px;color:#6e6e6e;text-align:center}.not-found-page__card-button[_ngcontent-%COMP%]{margin-top:40px;margin-left:36px;width:150px;line-height:40px;letter-spacing:1px}"]
                    }), t
                })();
            var nt = i("0fNd");
            const st = [{
                path: "dashboard",
                pathMatch: "full",
                canActivate: [nt.a],
                component: et
            }, {
                path: "typography",
                pathMatch: "full",
                canActivate: [nt.a],
                loadChildren: () => i.e(7).then(i.bind(null, "R+Zu")).then(t => t.TypographyModule)
            }, {
                path: "tables",
                pathMatch: "full",
                canActivate: [nt.a],
                loadChildren: () => i.e(6).then(i.bind(null, "w2km")).then(t => t.TablesModule)
            }, {
                path: "notification",
                pathMatch: "full",
                canActivate: [nt.a],
                loadChildren: () => i.e(5).then(i.bind(null, "UUPU")).then(t => t.NotificationModule)
            }, {
                path: "ui",
                canActivate: [nt.a],
                loadChildren: () => i.e(8).then(i.bind(null, "xIyE")).then(t => t.UiElementsModule)
            }, {
                path: "404",
                component: it
            }, {
                path: "login",
                loadChildren: () => Promise.resolve().then(i.bind(null, "lBUW")).then(t => t.AuthModule)
            }, {
                path: "**",
                redirectTo: "404"
            }];
            let rt = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = s.Nb({
                    type: t
                }), t.\u0275inj = s.Mb({
                    imports: [
                        [a.e.forRoot(st, {
                            useHash: !0,
                            preloadingStrategy: a.a,
                            relativeLinkResolution: "legacy"
                        })], a.e
                    ]
                }), t
            })();
            var at = i("/2RN"),
                ot = i("lBUW");
            let lt = (() => {
                class t {}
                return t.\u0275fac = function(e) {
                    return new(e || t)
                }, t.\u0275mod = s.Nb({
                    type: t,
                    bootstrap: [h]
                }), t.\u0275inj = s.Mb({
                    providers: [],
                    imports: [
                        [n.a, u.a, ot.AuthModule, at.a, r.b, a.e, rt, o.c.forRoot(), l.c, c.c, A.b.forRoot({
                            echarts: () => i.e(9).then(i.bind(null, "MT78"))
                        })]
                    ]
                }), t
            })();
            Object(s.V)(), n.c().bootstrapModule(lt).catch(t => console.log(t)), n.c().bootstrapModule(lt).catch(t => console.error(t))
        },
        zn8P: function(t, e) {
            function i(t) {
                return Promise.resolve().then(function() {
                    var e = new Error("Cannot find module '" + t + "'");
                    throw e.code = "MODULE_NOT_FOUND", e
                })
            }
            i.keys = function() {
                return []
            }, i.resolve = i, t.exports = i, i.id = "zn8P"
        },
        zzs5: function(t, e, i) {
            "use strict";
            i.d(e, "a", function() {
                return a
            });
            var n = i("g+Sw"),
                s = i("1lu8"),
                r = i("EPzc");

            function a(...t) {
                const e = Object(s.c)(t);
                return Object(r.b)((i, s) => {
                    (e ? Object(n.a)(t, i, e) : Object(n.a)(t, i)).subscribe(s)
                })
            }
        }
    },
    [
        [0, 0]
    ]
]);